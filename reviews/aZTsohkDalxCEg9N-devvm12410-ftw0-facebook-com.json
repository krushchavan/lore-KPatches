{
  "thread_id": "aZTsohkDalxCEg9N@devvm12410.ftw0.facebook.com",
  "subject": "Re: [PATCH] btrfs: reserve transaction space for qgroup ioctls",
  "url": "https://lore.kernel.org/all/aZTsohkDalxCEg9N@devvm12410.ftw0.facebook.com/",
  "dates": {
    "2026-02-17": {
      "report_file": "2026-02-17_ollama_llama3.1-8b.html",
      "developer": "Boris Burkov",
      "reviews": [
        {
          "author": "Boris Burkov",
          "summary": "Reviewer Boris Burkov approved the patch and gave a Reviewed-by tag.",
          "sentiment": "positive",
          "sentiment_signals": [
            "LGTM"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Tue, Feb 17, 2026 at 06:35:54PM +0000, fdmanana@kernel.org wrote:\n> From: Filipe Manana <fdmanana@suse.com>\n> \n> Currently our qgroup ioctls don't reserve any space, they just do a\n> transaction join, which does not reserve any space, neither for the quota\n> tree updates nor for the delayed refs generated when updating the quota\n> tree. The quota root uses the global block reserve, which is fine most of\n> the time since we don't expect a lot of updates to the quota root, or to\n> be too close to -ENOSPC such that other critical metadata updates need to\n> resort to the global reserve.\n> \n> However this is not optimal, as not reserving proper space may result in a\n> transaction abort due to not reserving space for delayed refs and then\n> abusing the use of the global block reserve.\n> \n> For example, the following reproducer (which is unlikely to model any\n> real world use case, but just to illustrate the problem), triggers such a\n> transaction abort due to -ENOSPC when running delayed refs:\n> \n>   $ cat test.sh\n>   #!/bin/bash\n> \n>   DEV=/dev/nullb0\n>   MNT=/mnt/nullb0\n> \n>   umount $DEV &> /dev/null\n>   # Limit device to 1G so that it's much faster to reproduce the issue.\n>   mkfs.btrfs -f -b 1G $DEV\n>   mount -o commit=600 $DEV $MNT\n> \n>   fallocate -l 800M $MNT/filler\n>   btrfs quota enable $MNT\n> \n>   for ((i = 1; i <= 400000; i++)); do\n>       btrfs qgroup create 1/$i $MNT\n>   done\n> \n>   umount $MNT\n> \n> When running this, we can see in dmesg/syslog that a transaction abort\n> happened:\n> \n>   [160436.490890] BTRFS error (device nullb0): failed to run delayed ref for logical 30408704 num_bytes 16384 type 176 action 1 ref_mod 1: -28\n>   [160436.493276] ------------[ cut here ]------------\n>   [160436.494166] BTRFS: Transaction aborted (error -28)\n>   [160436.495088] WARNING: fs/btrfs/extent-tree.c:2247 at btrfs_run_delayed_refs+0xd9/0x110 [btrfs], CPU#4: umount/2495372\n>   [160436.497219] Modules linked in: btrfs loop (...)\n>   [160436.508357] CPU: 4 UID: 0 PID: 2495372 Comm: umount Tainted: G        W           6.19.0-rc8-btrfs-next-225+ #1 PREEMPT(full)\n>   [160436.510497] Tainted: [W]=WARN\n>   [160436.511085] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014\n>   [160436.513260] RIP: 0010:btrfs_run_delayed_refs+0xdf/0x110 [btrfs]\n>   [160436.514515] Code: 0f 82 ea (...)\n>   [160436.518476] RSP: 0018:ffffd511850b7d78 EFLAGS: 00010292\n>   [160436.519544] RAX: 00000000ffffffe4 RBX: ffff8f120dad37e0 RCX: 0000000002040001\n>   [160436.520893] RDX: 0000000000000002 RSI: 00000000ffffffe4 RDI: ffffffffc090fd80\n>   [160436.522245] RBP: 0000000000000000 R08: 0000000000000001 R09: ffffffffc04d1867\n>   [160436.523612] R10: ffff8f18dc1fffa8 R11: 0000000000000003 R12: ffff8f173aa89400\n>   [160436.524960] R13: 0000000000000000 R14: ffff8f173aa89400 R15: 0000000000000000\n>   [160436.526289] FS:  00007fe59045d840(0000) GS:ffff8f192e22e000(0000) knlGS:0000000000000000\n>   [160436.527812] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n>   [160436.528868] CR2: 00007fe5905ff2b0 CR3: 000000060710a002 CR4: 0000000000370ef0\n>   [160436.530096] Call Trace:\n>   [160436.530527]  <TASK>\n>   [160436.530916]  btrfs_commit_transaction+0x73/0xc00 [btrfs]\n>   [160436.531753]  ? btrfs_attach_transaction_barrier+0x1e/0x70 [btrfs]\n>   [160436.532557]  sync_filesystem+0x7a/0x90\n>   [160436.533025]  generic_shutdown_super+0x28/0x180\n>   [160436.533584]  kill_anon_super+0x12/0x40\n>   [160436.534083]  btrfs_kill_super+0x12/0x20 [btrfs]\n>   [160436.534560]  deactivate_locked_super+0x2f/0xb0\n>   [160436.534983]  cleanup_mnt+0xea/0x180\n>   [160436.535388]  task_work_run+0x58/0xa0\n>   [160436.535804]  exit_to_user_mode_loop+0xed/0x480\n>   [160436.536308]  ? __x64_sys_umount+0x68/0x80\n>   [160436.536764]  do_syscall_64+0x2a5/0xf20\n>   [160436.537196]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n>   [160436.537780] RIP: 0033:0x7fe5906b6217\n>   [160436.538192] Code: 0d 00 f7 (...)\n>   [160436.540303] RSP: 002b:00007ffcd87a61f8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6\n>   [160436.541133] RAX: 0000000000000000 RBX: 00005618b9ecadc8 RCX: 00007fe5906b6217\n>   [160436.541886] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00005618b9ecb100\n>   [160436.542704] RBP: 0000000000000000 R08: 00007ffcd87a4fe0 R09: 00000000ffffffff\n>   [160436.544022] R10: 0000000000000103 R11: 0000000000000246 R12: 00007fe59081626c\n>   [160436.544950] R13: 00005618b9ecb100 R14: 0000000000000000 R15: 00005618b9ecacc0\n>   [160436.545729]  </TASK>\n>   [160436.545988] ---[ end trace 0000000000000000 ]---\n> \n> Fix this by changing the qgroup ioctls to use start transaction instead of\n> joining so that proper space is reserved for the delayed refs generated\n> for the updates to the quota root. This way we don't get any transaction\n> abort.\n> \n\nLGTM, thanks!\nReviewed-by: Boris Burkov <boris@bur.io>\n\n> Signed-off-by: Filipe Manana <fdmanana@suse.com>\n> ---\n>  fs/btrfs/ioctl.c | 12 +++++++++---\n>  1 file changed, 9 insertions(+), 3 deletions(-)\n> \n> diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c\n> index 38d93dae71ca..9fa4eca4c788 100644\n> --- a/fs/btrfs/ioctl.c\n> +++ b/fs/btrfs/ioctl.c\n> @@ -3680,7 +3680,8 @@ static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n>  \t\t}\n>  \t}\n>  \n> -\ttrans = btrfs_join_transaction(root);\n> +\t/* 2 BTRFS_QGROUP_RELATION_KEY items. */\n> +\ttrans = btrfs_start_transaction(root, 2);\n>  \tif (IS_ERR(trans)) {\n>  \t\tret = PTR_ERR(trans);\n>  \t\tgoto out;\n> @@ -3752,7 +3753,11 @@ static long btrfs_ioctl_qgroup_create(struct file *file, void __user *arg)\n>  \t\tgoto out;\n>  \t}\n>  \n> -\ttrans = btrfs_join_transaction(root);\n> +\t/*\n> +\t * 1 BTRFS_QGROUP_INFO_KEY item.\n> +\t * 1 BTRFS_QGROUP_LIMIT_KEY item.\n> +\t */\n> +\ttrans = btrfs_start_transaction(root, 2);\n>  \tif (IS_ERR(trans)) {\n>  \t\tret = PTR_ERR(trans);\n>  \t\tgoto out;\n> @@ -3801,7 +3806,8 @@ static long btrfs_ioctl_qgroup_limit(struct file *file, void __user *arg)\n>  \t\tgoto drop_write;\n>  \t}\n>  \n> -\ttrans = btrfs_join_transaction(root);\n> +\t/* 1 BTRFS_QGROUP_LIMIT_KEY item. */\n> +\ttrans = btrfs_start_transaction(root, 1);\n>  \tif (IS_ERR(trans)) {\n>  \t\tret = PTR_ERR(trans);\n>  \t\tgoto out;\n> -- \n> 2.47.2\n> \n"
        },
        {
          "author": "Qu Wenruo",
          "summary": "The reviewer approved the patch and gave a 'Reviewed-by' tag, but no specific technical concerns were raised.",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "\n\n在 2026/2/18 05:05, fdmanana@kernel.org 写道:\n> From: Filipe Manana <fdmanana@suse.com>\n> \n> Currently our qgroup ioctls don't reserve any space, they just do a\n> transaction join, which does not reserve any space, neither for the quota\n> tree updates nor for the delayed refs generated when updating the quota\n> tree. The quota root uses the global block reserve, which is fine most of\n> the time since we don't expect a lot of updates to the quota root, or to\n> be too close to -ENOSPC such that other critical metadata updates need to\n> resort to the global reserve.\n> \n> However this is not optimal, as not reserving proper space may result in a\n> transaction abort due to not reserving space for delayed refs and then\n> abusing the use of the global block reserve.\n> \n> For example, the following reproducer (which is unlikely to model any\n> real world use case, but just to illustrate the problem), triggers such a\n> transaction abort due to -ENOSPC when running delayed refs:\n> \n>    $ cat test.sh\n>    #!/bin/bash\n> \n>    DEV=/dev/nullb0\n>    MNT=/mnt/nullb0\n> \n>    umount $DEV &> /dev/null\n>    # Limit device to 1G so that it's much faster to reproduce the issue.\n>    mkfs.btrfs -f -b 1G $DEV\n>    mount -o commit=600 $DEV $MNT\n> \n>    fallocate -l 800M $MNT/filler\n>    btrfs quota enable $MNT\n> \n>    for ((i = 1; i <= 400000; i++)); do\n>        btrfs qgroup create 1/$i $MNT\n>    done\n> \n>    umount $MNT\n> \n> When running this, we can see in dmesg/syslog that a transaction abort\n> happened:\n> \n>    [160436.490890] BTRFS error (device nullb0): failed to run delayed ref for logical 30408704 num_bytes 16384 type 176 action 1 ref_mod 1: -28\n>    [160436.493276] ------------[ cut here ]------------\n>    [160436.494166] BTRFS: Transaction aborted (error -28)\n>    [160436.495088] WARNING: fs/btrfs/extent-tree.c:2247 at btrfs_run_delayed_refs+0xd9/0x110 [btrfs], CPU#4: umount/2495372\n>    [160436.497219] Modules linked in: btrfs loop (...)\n>    [160436.508357] CPU: 4 UID: 0 PID: 2495372 Comm: umount Tainted: G        W           6.19.0-rc8-btrfs-next-225+ #1 PREEMPT(full)\n>    [160436.510497] Tainted: [W]=WARN\n>    [160436.511085] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014\n>    [160436.513260] RIP: 0010:btrfs_run_delayed_refs+0xdf/0x110 [btrfs]\n>    [160436.514515] Code: 0f 82 ea (...)\n>    [160436.518476] RSP: 0018:ffffd511850b7d78 EFLAGS: 00010292\n>    [160436.519544] RAX: 00000000ffffffe4 RBX: ffff8f120dad37e0 RCX: 0000000002040001\n>    [160436.520893] RDX: 0000000000000002 RSI: 00000000ffffffe4 RDI: ffffffffc090fd80\n>    [160436.522245] RBP: 0000000000000000 R08: 0000000000000001 R09: ffffffffc04d1867\n>    [160436.523612] R10: ffff8f18dc1fffa8 R11: 0000000000000003 R12: ffff8f173aa89400\n>    [160436.524960] R13: 0000000000000000 R14: ffff8f173aa89400 R15: 0000000000000000\n>    [160436.526289] FS:  00007fe59045d840(0000) GS:ffff8f192e22e000(0000) knlGS:0000000000000000\n>    [160436.527812] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n>    [160436.528868] CR2: 00007fe5905ff2b0 CR3: 000000060710a002 CR4: 0000000000370ef0\n>    [160436.530096] Call Trace:\n>    [160436.530527]  <TASK>\n>    [160436.530916]  btrfs_commit_transaction+0x73/0xc00 [btrfs]\n>    [160436.531753]  ? btrfs_attach_transaction_barrier+0x1e/0x70 [btrfs]\n>    [160436.532557]  sync_filesystem+0x7a/0x90\n>    [160436.533025]  generic_shutdown_super+0x28/0x180\n>    [160436.533584]  kill_anon_super+0x12/0x40\n>    [160436.534083]  btrfs_kill_super+0x12/0x20 [btrfs]\n>    [160436.534560]  deactivate_locked_super+0x2f/0xb0\n>    [160436.534983]  cleanup_mnt+0xea/0x180\n>    [160436.535388]  task_work_run+0x58/0xa0\n>    [160436.535804]  exit_to_user_mode_loop+0xed/0x480\n>    [160436.536308]  ? __x64_sys_umount+0x68/0x80\n>    [160436.536764]  do_syscall_64+0x2a5/0xf20\n>    [160436.537196]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n>    [160436.537780] RIP: 0033:0x7fe5906b6217\n>    [160436.538192] Code: 0d 00 f7 (...)\n>    [160436.540303] RSP: 002b:00007ffcd87a61f8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6\n>    [160436.541133] RAX: 0000000000000000 RBX: 00005618b9ecadc8 RCX: 00007fe5906b6217\n>    [160436.541886] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00005618b9ecb100\n>    [160436.542704] RBP: 0000000000000000 R08: 00007ffcd87a4fe0 R09: 00000000ffffffff\n>    [160436.544022] R10: 0000000000000103 R11: 0000000000000246 R12: 00007fe59081626c\n>    [160436.544950] R13: 00005618b9ecb100 R14: 0000000000000000 R15: 00005618b9ecacc0\n>    [160436.545729]  </TASK>\n>    [160436.545988] ---[ end trace 0000000000000000 ]---\n> \n> Fix this by changing the qgroup ioctls to use start transaction instead of\n> joining so that proper space is reserved for the delayed refs generated\n> for the updates to the quota root. This way we don't get any transaction\n> abort.\n> \n> Signed-off-by: Filipe Manana <fdmanana@suse.com>\n\nReviewed-by: Qu Wenruo <wqu@suse.com>\n\nThanks,\nQu\n> ---\n>   fs/btrfs/ioctl.c | 12 +++++++++---\n>   1 file changed, 9 insertions(+), 3 deletions(-)\n> \n> diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c\n> index 38d93dae71ca..9fa4eca4c788 100644\n> --- a/fs/btrfs/ioctl.c\n> +++ b/fs/btrfs/ioctl.c\n> @@ -3680,7 +3680,8 @@ static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n>   \t\t}\n>   \t}\n>   \n> -\ttrans = btrfs_join_transaction(root);\n> +\t/* 2 BTRFS_QGROUP_RELATION_KEY items. */\n> +\ttrans = btrfs_start_transaction(root, 2);\n>   \tif (IS_ERR(trans)) {\n>   \t\tret = PTR_ERR(trans);\n>   \t\tgoto out;\n> @@ -3752,7 +3753,11 @@ static long btrfs_ioctl_qgroup_create(struct file *file, void __user *arg)\n>   \t\tgoto out;\n>   \t}\n>   \n> -\ttrans = btrfs_join_transaction(root);\n> +\t/*\n> +\t * 1 BTRFS_QGROUP_INFO_KEY item.\n> +\t * 1 BTRFS_QGROUP_LIMIT_KEY item.\n> +\t */\n> +\ttrans = btrfs_start_transaction(root, 2);\n>   \tif (IS_ERR(trans)) {\n>   \t\tret = PTR_ERR(trans);\n>   \t\tgoto out;\n> @@ -3801,7 +3806,8 @@ static long btrfs_ioctl_qgroup_limit(struct file *file, void __user *arg)\n>   \t\tgoto drop_write;\n>   \t}\n>   \n> -\ttrans = btrfs_join_transaction(root);\n> +\t/* 1 BTRFS_QGROUP_LIMIT_KEY item. */\n> +\ttrans = btrfs_start_transaction(root, 1);\n>   \tif (IS_ERR(trans)) {\n>   \t\tret = PTR_ERR(trans);\n>   \t\tgoto out;\n\n\n"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    }
  }
}