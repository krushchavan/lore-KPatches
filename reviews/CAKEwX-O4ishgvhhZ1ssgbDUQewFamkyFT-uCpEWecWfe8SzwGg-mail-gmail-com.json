{
  "thread_id": "CAKEwX=O4ishgvhhZ1ssgbDUQewFamkyFT-uCpEWecWfe8SzwGg@mail.gmail.com",
  "subject": "[LSF/MM/BPF TOPIC] Swap status and roadmap discussion",
  "url": "https://lore.kernel.org/all/CAKEwX=O4ishgvhhZ1ssgbDUQewFamkyFT-uCpEWecWfe8SzwGg@mail.gmail.com/",
  "dates": {
    "2026-02-23": {
      "report_file": "2026-02-23.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Yosry Ahmed",
          "summary": "I think we should actually revisit the need for a reverse mapping to begin with. For swapoff, we can probably scan the virtual swap space looking for entries that belong to the backend being swapped off. Not as efficient as a reverse map, but still better than the status quo of scanning page tables.",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "> > - Is 64 bits really needed for reverse mapping? For the context, reverse\n> >   mapping here is a swap entry recorded in a lower / physical device\n> >   pointing to the ghost / virtual device.\n>\n> I think you can compact this a bit. Swap space itself is not fully 64\n> bits right?\n>\n> Just not sure if the juice is worth the squeeze to save a couple of\n> bits here and there, especially if the reverse mapping is already\n> dynamic :)\n\nI think we should actually revisit the need for a reverse mapping to\nbegin with. For swapoff, we can probably scan the virtual swap space\nlooking for entries that belong to the backend being swapped off. Not\nas efficient as a reverse map, but still better than the status quo of\nscanning page tables. I don't think optimizing for swapoff is worth\nthe consistent overhead.\n\nThe other use cases are probably cluster readahead and swapcache-only\nreclaim, and I think both of these can also be revisited.\n\n",
          "reply_to": "",
          "message_date": "2026-02-23",
          "message_id": ""
        },
        {
          "author": "Yosry Ahmed",
          "summary": "Yeah I am not against having a reverse map in general (regardless of what design we end up having), I just think it has to be justified. With the current code, the use cases are not that important imo, so we can potentially drop it. If new features like migration and compaction require a reverse map, it can be tied to them, and depending on the use cases, we could even make the reverse mapping optional depending on whether these features are enabled or not -- at least in theory. Yeah it's not necessarily related, I was just mentioning that these are the obvious current users of the reverse map, but I don't think we should keep the reverse map for them. It kinda makes sense in theory, but ultimately it should be whatever makes the numbers look good for the largest amount of workloads.",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Mon, Feb 23, 2026 at 7:45 PM Kairui Song <ryncsn@gmail.com> wrote:\n>\n> On Tue, Feb 24, 2026 at 2:55 AM Yosry Ahmed <yosry@kernel.org> wrote:\n> >\n> > > > - Is 64 bits really needed for reverse mapping? For the context, reverse\n> > > >   mapping here is a swap entry recorded in a lower / physical device\n> > > >   pointing to the ghost / virtual device.\n> > >\n> > > I think you can compact this a bit. Swap space itself is not fully 64\n> > > bits right?\n> > >\n> > > Just not sure if the juice is worth the squeeze to save a couple of\n> > > bits here and there, especially if the reverse mapping is already\n> > > dynamic :)\n> >\n>\n> Hi, thanks for the comment.\n>\n> > I think we should actually revisit the need for a reverse mapping to\n> > begin with. For swapoff, we can probably scan the virtual swap space\n> > looking for entries that belong to the backend being swapped off. Not\n> > as efficient as a reverse map, but still better than the status quo of\n> > scanning page tables. I don't think optimizing for swapoff is worth\n> > the consistent overhead.\n>\n> Right, I don't really think swapoff is worth that much effort too. But\n> there are still ideas like migration and compaction, which could\n> really make use of a proper reverse map.\n\nYeah I am not against having a reverse map in general (regardless of\nwhat design we end up having), I just think it has to be justified.\nWith the current code, the use cases are not that important imo, so we\ncan potentially drop it.\n\nIf new features like migration and compaction require a reverse map,\nit can be tied to them, and depending on the use cases, we could even\nmake the reverse mapping optional depending on whether these features\nare enabled or not -- at least in theory.\n\n>\n> >\n> > The other use cases are probably cluster readahead and swapcache-only\n> > reclaim, and I think both of these can also be revisited.\n>\n> Agree, readahead and swap cache reclaim do need some revisit... Not\n> related to the revert map idea though.\n\nYeah it's not necessarily related, I was just mentioning that these\nare the obvious current users of the reverse map, but I don't think we\nshould keep the reverse map for them.\n\n>\n> I'm thinking if we can make the swap cache completely lazy and never\n> reclaim it proactively for non-RAM swap. And for RAM based swap\n> (zswap / ZRAM), do the opposite, always ensure swap cache is\n> reclaimed after use.\n\nIt kinda makes sense in theory, but ultimately it should be whatever\nmakes the numbers look good for the largest amount of workloads.\n\n\n",
          "reply_to": "",
          "message_date": "2026-02-23",
          "message_id": ""
        }
      ],
      "analysis_source": "heuristic"
    },
    "2026-02-24": {
      "report_file": "2026-02-23_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Kairui Song",
          "summary": "Right, I don't really think swapoff is worth that much effort too. But there are still ideas like migration and compaction, which could really make use of a proper reverse map. Agree, readahead and swap cache reclaim do need some revisit... Not related to the revert map idea though. I'm thinking if we can make the swap cache completely lazy and never reclaim it proactively for non-RAM swap. And for RAM based swap (zswap / ZRAM), do the opposite, always ensure swap cache is reclaimed after use.",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Tue, Feb 24, 2026 at 2:55 AM Yosry Ahmed <yosry@kernel.org> wrote:\n>\n> > > - Is 64 bits really needed for reverse mapping? For the context, reverse\n> > >   mapping here is a swap entry recorded in a lower / physical device\n> > >   pointing to the ghost / virtual device.\n> >\n> > I think you can compact this a bit. Swap space itself is not fully 64\n> > bits right?\n> >\n> > Just not sure if the juice is worth the squeeze to save a couple of\n> > bits here and there, especially if the reverse mapping is already\n> > dynamic :)\n>\n\nHi, thanks for the comment.\n\n> I think we should actually revisit the need for a reverse mapping to\n> begin with. For swapoff, we can probably scan the virtual swap space\n> looking for entries that belong to the backend being swapped off. Not\n> as efficient as a reverse map, but still better than the status quo of\n> scanning page tables. I don't think optimizing for swapoff is worth\n> the consistent overhead.\n\nRight, I don't really think swapoff is worth that much effort too. But\nthere are still ideas like migration and compaction, which could\nreally make use of a proper reverse map.\n\n>\n> The other use cases are probably cluster readahead and swapcache-only\n> reclaim, and I think both of these can also be revisited.\n\nAgree, readahead and swap cache reclaim do need some revisit... Not\nrelated to the revert map idea though.\n\nI'm thinking if we can make the swap cache completely lazy and never\nreclaim it proactively for non-RAM swap. And for RAM based swap\n(zswap / ZRAM), do the opposite, always ensure swap cache is\nreclaimed after use.\n\n",
          "reply_to": "",
          "message_date": "2026-02-24",
          "message_id": ""
        }
      ],
      "analysis_source": "heuristic"
    }
  }
}