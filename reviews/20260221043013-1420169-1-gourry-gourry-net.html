<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: [PATCH 1/2] cxl/region: fix region leak when attach_target fails in cxl_add_to_region</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }
        .reply-to-label {
            font-size: 0.8em;
            color: #999;
            font-style: italic;
            margin-top: 3px;
        }
        .lore-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 0.82em;
            color: #0366d6;
            text-decoration: none;
            font-weight: 500;
            white-space: nowrap;
        }
        .lore-link:hover { text-decoration: underline; color: #0056b3; }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../index.html">&larr; Back to reports</a></div>
    <h1>[PATCH 1/2] cxl/region: fix region leak when attach_target fails in cxl_add_to_region</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/20260221043013.1420169-1-gourry@gourry.net/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-24">2026-02-24</a> &bull; <a href="#2026-02-23">2026-02-23</a> &bull; <a href="#2026-02-21">2026-02-21</a> &bull; <a href="#2026-02-20">2026-02-20</a></div>
    <div class="patch-summary-block"><div class="patch-summary-label">Patch summary</div><div class="patch-summary-text">This patch fixes a region leak in the CXL driver when attaching a target fails. When `attach_target` returns an error, the auto-discovered region remains registered and consumes HPA resources without ever reaching a committed state. The patch tracks whether the region was created by checking the return value of `cxl_add_to_region`, and if it was not created successfully, it calls `drop_region` to unregister the region and release the HPA resource. This prevents subsequent region creation attempts from failing due to reserved HPA ranges.</div></div>
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-20">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-21_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-20">2026-02-20</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about device_attach() being called on auto-discovered regions when a custom attach callback is present. They explained that this can lead to dax memory being left online due to dax_kmem refusing to offline during its remove path. The author agreed to skip device_attach() in such cases, with the custom attach callback responsible for setting up the region afterwards.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">When a CXL memdev has a custom attach callback, cxl_add_to_region()
should not call device_attach() on the auto-discovered region.

The default device_attach() binds the dax driver, which may online
memory via dax_kmem.  The custom attach callback then has to tear down
the dax stack to convert the region to sysram, but dax_kmem refuses to
offline memory during its remove path, leaving regions stuck online.

Skip device_attach() when cxlmd-&gt;attach is set.  The attach callback
is responsible for setting up the region after auto-discovery completes
(e.g. adding it as sysram directly).

Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;
---
 drivers/cxl/core/region.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 276046d49f88..e5edeabd9262 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -3971,6 +3971,12 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)
 	}
 
 	if (attach) {
+		struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
+
+		/* Skip device_attach if memdev has is own attach callback */
+		if (cxlmd-&gt;attach)
+			return 0;
+
 		/*
 		 * If device_attach() fails the range may still be active via
 		 * the platform-firmware memory map, otherwise the driver for
-- 
2.47.3</pre>
</details>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-21">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-21_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-21">2026-02-21</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">BAH - disregard this patch, it uses drop_region which is introduced by Alejandro here: https://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:
&gt; cxl_add_to_region() ignores the return value of attach_target().  When
&gt; attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),
&gt; the auto-discovered region remains registered with its HPA resource
&gt; consumed but never reaches COMMIT state.  Subsequent region creation
&gt; attempts fail with -ENOSPC because the HPA range is already reserved.
&gt; 
&gt; Track whether this call to cxl_add_to_region() created the region, and
&gt; call drop_region() on attach_target() failure to unregister it and
&gt; release the HPA resource.  Pre-existing regions are left alone since
&gt; other endpoints may already be attached.
&gt; 
&gt; Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;

BAH - disregard this patch, it uses drop_region which is introduced by
Alejandro here:

https://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/

</pre>
</details>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-23">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Alison Schofield</span>
<a class="date-chip" href="../2026-02-23.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">I see you dropping this, perhaps just for the moment, because the drop_region() you wanted to use is not available yet. This looks a lot like https://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/ cxl/region: Unregister auto-created region when assembly fails When auto-created region assembly fails the region remains registered but disabled. The region continues to reserve its memory resource, preventing DAX from registering the memory. Unregister the region on assembly failure to release the resource. And the review comments on that one, or at least on that thread in general, was to leave all the broken things in place. I didn&#x27;t agree with that, and hope to see this version move ahead when you have the drop_region you need.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:
&gt; cxl_add_to_region() ignores the return value of attach_target().  When
&gt; attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),
&gt; the auto-discovered region remains registered with its HPA resource
&gt; consumed but never reaches COMMIT state.  Subsequent region creation
&gt; attempts fail with -ENOSPC because the HPA range is already reserved.
&gt; 
&gt; Track whether this call to cxl_add_to_region() created the region, and
&gt; call drop_region() on attach_target() failure to unregister it and
&gt; release the HPA resource.  Pre-existing regions are left alone since
&gt; other endpoints may already be attached.

I see you dropping this, perhaps just for the moment, because
the drop_region() you wanted to use is not available yet.

This looks a lot like 
	https://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/
	cxl/region: Unregister auto-created region when assembly fails
	When auto-created region assembly fails the region remains registered
	but disabled. The region continues to reserve its memory resource,
	preventing DAX from registering the memory.
	Unregister the region on assembly failure to release the resource.

And the review comments on that one, or at least on that thread in
general, was to leave all the broken things in place.
I didn&#x27;t agree with that, and hope to see this version move ahead
when you have the drop_region you need.

-- Alison






&gt; 
&gt; Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;
&gt; ---
&gt;  drivers/cxl/core/region.c | 15 ++++++++++++---
&gt;  1 file changed, 12 insertions(+), 3 deletions(-)
&gt; 
&gt; diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
&gt; index 385be9cb44cd..276046d49f88 100644
&gt; --- a/drivers/cxl/core/region.c
&gt; +++ b/drivers/cxl/core/region.c
&gt; @@ -3923,6 +3923,7 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)
&gt;  	struct cxl_region_context ctx;
&gt;  	struct cxl_region_params *p;
&gt;  	bool attach = false;
&gt; +	bool newly_created = false;
&gt;  	int rc;
&gt;  
&gt;  	ctx = (struct cxl_region_context) {
&gt; @@ -3946,15 +3947,23 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)
&gt;  	mutex_lock(&amp;cxlrd-&gt;range_lock);
&gt;  	struct cxl_region *cxlr __free(put_cxl_region) =
&gt;  		cxl_find_region_by_range(cxlrd, &amp;ctx.hpa_range);
&gt; -	if (!cxlr)
&gt; +	if (!cxlr) {
&gt;  		cxlr = construct_region(cxlrd, &amp;ctx);
&gt; +		newly_created = !IS_ERR(cxlr);
&gt; +	}
&gt;  	mutex_unlock(&amp;cxlrd-&gt;range_lock);
&gt;  
&gt;  	rc = PTR_ERR_OR_ZERO(cxlr);
&gt;  	if (rc)
&gt;  		return rc;
&gt;  
&gt; -	attach_target(cxlr, cxled, -1, TASK_UNINTERRUPTIBLE);
&gt; +	rc = attach_target(cxlr, cxled, -1, TASK_UNINTERRUPTIBLE);
&gt; +	if (rc) {
&gt; +		/* If endpoint was just created, tear it down to release HPA */
&gt; +		if (newly_created)
&gt; +			drop_region(cxlrd, cxlr);
&gt; +		return rc;
&gt; +	}
&gt;  
&gt;  	scoped_guard(rwsem_read, &amp;cxl_rwsem.region) {
&gt;  		p = &amp;cxlr-&gt;params;
&gt; @@ -3972,7 +3981,7 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)
&gt;  				p-&gt;res);
&gt;  	}
&gt;  
&gt; -	return rc;
&gt; +	return 0;
&gt;  }
&gt;  EXPORT_SYMBOL_NS_GPL(cxl_add_to_region, &quot;CXL&quot;);
&gt;  
&gt; -- 
&gt; 2.47.3
&gt; 
</pre>
</details>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-23.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Yeah it&#x27;s not a particularly useful cleanup in the current infrastructure because nothing actually uses this pattern (yet). The important note here is the difference between auto-regions and manually created regions.  For auto-regions, you might have another endpoint show up looking for the partially created region - and then just go off and create it anyway because it thinks it was first. But in my driver, i&#x27;m explicitly converting these auto-regions into other things, and if that fails it causes *all other* region creation to fail - even if it wasn&#x27;t actually dependent on that original region. This is only an issue if you have two devices unbind/bind cycling at the same time - i.e. echo 0000:d0:00.00 &gt; cxl_pci/unbind echo 0000:e0:00.00 &gt; cxl_pci/unbind echo 0000:d0:00.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, Feb 23, 2026 at 11:48:42AM -0800, Alison Schofield wrote:
&gt; On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:
&gt; &gt; cxl_add_to_region() ignores the return value of attach_target().  When
&gt; &gt; attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),
&gt; &gt; the auto-discovered region remains registered with its HPA resource
&gt; &gt; consumed but never reaches COMMIT state.  Subsequent region creation
&gt; &gt; attempts fail with -ENOSPC because the HPA range is already reserved.
&gt; &gt; 
&gt; &gt; Track whether this call to cxl_add_to_region() created the region, and
&gt; &gt; call drop_region() on attach_target() failure to unregister it and
&gt; &gt; release the HPA resource.  Pre-existing regions are left alone since
&gt; &gt; other endpoints may already be attached.
&gt; 
&gt; I see you dropping this, perhaps just for the moment, because
&gt; the drop_region() you wanted to use is not available yet.
&gt; 

Yeah it&#x27;s not a particularly useful cleanup in the current
infrastructure because nothing actually uses this pattern (yet).

&gt; This looks a lot like 
&gt; 	https://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/
&gt; 	cxl/region: Unregister auto-created region when assembly fails
&gt; 	When auto-created region assembly fails the region remains registered
&gt; 	but disabled. The region continues to reserve its memory resource,
&gt; 	preventing DAX from registering the memory.
&gt; 	Unregister the region on assembly failure to release the resource.
&gt; 
&gt; And the review comments on that one, or at least on that thread in
&gt; general, was to leave all the broken things in place.
&gt; I didn&#x27;t agree with that, and hope to see this version move ahead
&gt; when you have the drop_region you need.
&gt; 
&gt; 

The important note here is the difference between auto-regions and
manually created regions.  For auto-regions, you might have another
endpoint show up looking for the partially created region - and then
just go off and create it anyway because it thinks it was first.

But in my driver, i&#x27;m explicitly converting these auto-regions into
other things, and if that fails it causes *all other* region creation to
fail - even if it wasn&#x27;t actually dependent on that original region.

This is only an issue if you have two devices unbind/bind cycling at
the same time - i.e.

   echo 0000:d0:00.00 &gt; cxl_pci/unbind
   echo 0000:e0:00.00 &gt; cxl_pci/unbind
   echo 0000:d0:00.00 &gt; mydriver/bind
   echo 0000:e0:00.00 &gt; mydriver/bind

If the platform has pre-programmed and locked the decoders, and one of
the two devices fails to probe and leaves a hanging partially
created region, the other device will fail too.

It&#x27;s a pretty narrow failure scenario.

~Gregory
</pre>
</details>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Alison Schofield</span>
<a class="date-chip" href="../2026-02-23.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">That&#x27;s by design, and that&#x27;ll eventually fail too. But - is see how your case is different. Thanks for the explanation.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, Feb 23, 2026 at 03:15:16PM -0500, Gregory Price wrote:
&gt; On Mon, Feb 23, 2026 at 11:48:42AM -0800, Alison Schofield wrote:
&gt; &gt; On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:
&gt; &gt; &gt; cxl_add_to_region() ignores the return value of attach_target().  When
&gt; &gt; &gt; attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),
&gt; &gt; &gt; the auto-discovered region remains registered with its HPA resource
&gt; &gt; &gt; consumed but never reaches COMMIT state.  Subsequent region creation
&gt; &gt; &gt; attempts fail with -ENOSPC because the HPA range is already reserved.
&gt; &gt; &gt; 
&gt; &gt; &gt; Track whether this call to cxl_add_to_region() created the region, and
&gt; &gt; &gt; call drop_region() on attach_target() failure to unregister it and
&gt; &gt; &gt; release the HPA resource.  Pre-existing regions are left alone since
&gt; &gt; &gt; other endpoints may already be attached.
&gt; &gt; 
&gt; &gt; I see you dropping this, perhaps just for the moment, because
&gt; &gt; the drop_region() you wanted to use is not available yet.
&gt; &gt; 
&gt; 
&gt; Yeah it&#x27;s not a particularly useful cleanup in the current
&gt; infrastructure because nothing actually uses this pattern (yet).
&gt; 
&gt; &gt; This looks a lot like 
&gt; &gt; 	https://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/
&gt; &gt; 	cxl/region: Unregister auto-created region when assembly fails
&gt; &gt; 	When auto-created region assembly fails the region remains registered
&gt; &gt; 	but disabled. The region continues to reserve its memory resource,
&gt; &gt; 	preventing DAX from registering the memory.
&gt; &gt; 	Unregister the region on assembly failure to release the resource.
&gt; &gt; 
&gt; &gt; And the review comments on that one, or at least on that thread in
&gt; &gt; general, was to leave all the broken things in place.
&gt; &gt; I didn&#x27;t agree with that, and hope to see this version move ahead
&gt; &gt; when you have the drop_region you need.
&gt; &gt; 
&gt; &gt; 
&gt; 
&gt; The important note here is the difference between auto-regions and
&gt; manually created regions.  For auto-regions, you might have another
&gt; endpoint show up looking for the partially created region - and then
&gt; just go off and create it anyway because it thinks it was first.

That&#x27;s by design, and that&#x27;ll eventually fail too.

But - is see how your case is different. Thanks for the explanation.

&gt; 
&gt; But in my driver, i&#x27;m explicitly converting these auto-regions into
&gt; other things, and if that fails it causes *all other* region creation to
&gt; fail - even if it wasn&#x27;t actually dependent on that original region.
&gt; 
&gt; This is only an issue if you have two devices unbind/bind cycling at
&gt; the same time - i.e.
&gt; 
&gt;    echo 0000:d0:00.00 &gt; cxl_pci/unbind
&gt;    echo 0000:e0:00.00 &gt; cxl_pci/unbind
&gt;    echo 0000:d0:00.00 &gt; mydriver/bind
&gt;    echo 0000:e0:00.00 &gt; mydriver/bind
&gt; 
&gt; If the platform has pre-programmed and locked the decoders, and one of
&gt; the two devices fails to probe and leaves a hanging partially
&gt; created region, the other device will fail too.
&gt; 
&gt; It&#x27;s a pretty narrow failure scenario.
&gt; 
&gt; ~Gregory
&gt; 
</pre>
</details>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-24">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Alejandro Palau</span>
<a class="date-chip" href="../2026-02-24.html" title="First appeared in report for 2026-02-24">2026-02-24</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Feel free to add it to this series. I have started to send individual series as you know but the part changing the region creation will require more work than the already sent. About this fix, it looks good to me, although I have to admit I&#x27;m a bit lost after following the discussion Allison points to. If we want to keep the state of failure for forensics, not sure if the debugging/tracing or default error info in this case will be enough. In any case:</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">
On 2/21/26 05:17, Gregory Price wrote:
&gt; On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:
&gt;&gt; cxl_add_to_region() ignores the return value of attach_target().  When
&gt;&gt; attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),
&gt;&gt; the auto-discovered region remains registered with its HPA resource
&gt;&gt; consumed but never reaches COMMIT state.  Subsequent region creation
&gt;&gt; attempts fail with -ENOSPC because the HPA range is already reserved.
&gt;&gt;
&gt;&gt; Track whether this call to cxl_add_to_region() created the region, and
&gt;&gt; call drop_region() on attach_target() failure to unregister it and
&gt;&gt; release the HPA resource.  Pre-existing regions are left alone since
&gt;&gt; other endpoints may already be attached.
&gt;&gt;
&gt;&gt; Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;
&gt; BAH - disregard this patch, it uses drop_region which is introduced by
&gt; Alejandro here:
&gt;
&gt; https://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/
&gt;
Feel free to add it to this series. I have started to send individual 
series as you know but the part changing the region creation will 
require more work than the already sent.

About this fix, it looks good to me, although I have to admit I&#x27;m a bit 
lost after following the discussion Allison points to. If we want to 
keep the state of failure for forensics, not sure if the 
debugging/tracing or default error info in this case will be enough.

In any case:

Reviewed-by: Alejandro Lucero &lt;alucerop@amd.com&gt;

</pre>
</details>
<div class="review-comment-signals">Signals: LGTM</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-24.html" title="First appeared in report for 2026-02-24">2026-02-24</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Yeah i don&#x27;t quite follow the want to keep the objects around, it seems to cause more issues than it solves - but then i also don&#x27;t think this is going to be a particularly common problem</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, Feb 24, 2026 at 04:15:33PM +0000, Alejandro Lucero Palau wrote:
&gt; 
&gt; On 2/21/26 05:17, Gregory Price wrote:
&gt; &gt; On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:
&gt; &gt; &gt; cxl_add_to_region() ignores the return value of attach_target().  When
&gt; &gt; &gt; attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),
&gt; &gt; &gt; the auto-discovered region remains registered with its HPA resource
&gt; &gt; &gt; consumed but never reaches COMMIT state.  Subsequent region creation
&gt; &gt; &gt; attempts fail with -ENOSPC because the HPA range is already reserved.
&gt; &gt; &gt; 
&gt; &gt; &gt; Track whether this call to cxl_add_to_region() created the region, and
&gt; &gt; &gt; call drop_region() on attach_target() failure to unregister it and
&gt; &gt; &gt; release the HPA resource.  Pre-existing regions are left alone since
&gt; &gt; &gt; other endpoints may already be attached.
&gt; &gt; &gt; 
&gt; &gt; &gt; Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;
&gt; &gt; BAH - disregard this patch, it uses drop_region which is introduced by
&gt; &gt; Alejandro here:
&gt; &gt; 
&gt; &gt; https://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/
&gt; &gt; 
&gt; Feel free to add it to this series. I have started to send individual series
&gt; as you know but the part changing the region creation will require more work
&gt; than the already sent.
&gt; 
&gt; About this fix, it looks good to me, although I have to admit I&#x27;m a bit lost
&gt; after following the discussion Allison points to. If we want to keep the
&gt; state of failure for forensics, not sure if the debugging/tracing or default
&gt; error info in this case will be enough.
&gt; 
&gt; In any case:
&gt; 
&gt; Reviewed-by: Alejandro Lucero &lt;alucerop@amd.com&gt;
&gt; 

Yeah i don&#x27;t quite follow the want to keep the objects around, it seems
to cause more issues than it solves - but then i also don&#x27;t think this
is going to be a particularly common problem

~Gregory

</pre>
</details>
<div class="review-comment-signals">Signals: LGTM</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>