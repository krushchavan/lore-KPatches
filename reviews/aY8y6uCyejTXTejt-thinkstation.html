<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [BUG] Fault during memory acceptance for TDX VMs with certain memory sizes</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [BUG] Fault during memory acceptance for TDX VMs with certain memory sizes</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/aY8y6uCyejTXTejt@thinkstation/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-13">2026-02-13</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-13">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Dave Hansen</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Dave Hansen suspects a mismatch between &#x27;unit_size&#x27; and bitmap size, or an unaligned access causing a crash during memory acceptance for TDX VMs with certain memory sizes.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 2/12/26 08:29, Moritz Sanft wrote:
&gt; Based on our current (trial-and-error-based) knowledge, the issue only
&gt; occurs on TDX VMs with memory sizes &gt;64GB, where the memory size is not
&gt; aligned to a multiple of 1024. For instance, the QEMU argument `-m 67G`
&gt; works, while `-m 67000M` results in the crash cited below. The
&gt; configurations we&#x27;ve tested so far are as follows:

I don&#x27;t see any outrageous bugs in the code. I&#x27;m going to take a guess
though: the &#x27;unit_size&#x27; and the bitmap size don&#x27;t match or aren&#x27;t
consistent.

I&#x27;d guess that _something_ is unaligned and you&#x27;re running off the end
of the bitmap or the *mapping* for the bitmap. Any chance you can throw
a bunch of printk()&#x27;s in the kernel and see what all the fields in here are:

struct efi_unaccepted_memory {
        u32 version;
        u32 unit_size;
        u64 phys_base;
        u64 size;
        unsigned long bitmap[];
};

Along with the address of bitmap[] and all the calls to: bitmap_clear()?

That that should shed some light on it.

Any other TDX folks that want to try and reproduce this and do the same
would also be much appreciated!
</pre>
</details>
<div class="review-comment-signals">Signals: requested_changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Moritz Sanft (author)</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Moritz Sanft (author), initially reported a bug causing a kernel panic during memory acceptance for TDX VMs with certain memory sizes. They provided logs and asked for further investigation. After applying patches and additional logging, the issue was resolved, and the VM booted successfully.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">&gt; Any chance you can throw
&gt; a bunch of printk()&#x27;s in the kernel and see what all the fields in here are:
&gt; 
&gt; struct efi_unaccepted_memory {
&gt;         u32 version;
&gt;         u32 unit_size;
&gt;         u64 phys_base;
&gt;         u64 size;
&gt;         unsigned long bitmap[];
&gt; };
&gt; 
&gt; Along with the address of bitmap[] and all the calls to: bitmap_clear()?

Thanks for the guidance. I&#x27;ve added this logging via the patch in [1], 
which produced the following output:

```
[    0.033292] accept_memory(start=0x0000000000099000 size=0x6000)
[    0.037860]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.041469] Using GB pages for direct mapping
[    0.043090] accept_memory(start=0x00000010db600000 size=0x200000)
[    0.045311]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.058123]   bitmap_clear(bitmap=ff1100007d624030, start=32475, len=1)
[    0.060921] accept_memory(start=0x00000010db7ff000 size=0x1000)
[    0.063142]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.066865] accept_memory(start=0x00000010db7fe000 size=0x1000)
[    0.069096]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.073705] accept_memory(start=0x00000010db7fd000 size=0x1000)
[    0.075908]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
// unrelated logs omitted here
[    0.134988] accept_memory(start=0x00000010db7fcf40 size=0x83)
[    0.137152]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.140828] BUG: unable to handle page fault for address: 
ff1100007d625008
```

Find a full log attached in [2].

Please let me know if we need to gather any further logs - we&#x27;re happy 
to do so.

Best Regards,
Moritz Sanft

[1]: https://gist.github.com/msanft/13709e1ec9976a1b4b2723b98163a04b
[2]: https://gist.github.com/msanft/d102475bb28baa4b7958ed35e001e962


---

&gt; Could you check it this patch makes a difference:
&gt; 
&gt; diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c
&gt; index c2c067eff634..f2a00cd429f2 100644
&gt; --- a/drivers/firmware/efi/unaccepted_memory.c
&gt; +++ b/drivers/firmware/efi/unaccepted_memory.c
&gt; @@ -35,7 +35,7 @@ void accept_memory(phys_addr_t start, unsigned long size)
&gt;  	struct efi_unaccepted_memory *unaccepted;
&gt;  	unsigned long range_start, range_end;
&gt;  	struct accept_range range, *entry;
&gt; -	phys_addr_t end = start + size;
&gt; +	phys_addr_t end = start + PAGE_ALIGN(size);
&gt;  	unsigned long flags;
&gt;  	u64 unit_size;

Thanks, I tried this on the `-m 67000M` VM and the crash still occurs. I 
extended the previously-added logging to also log the values for `start 
+ size` and `start + PAGE_ALIGN(size)`. Please find the full patch 
including the logging and your change in [1].

The produced logs are as follows:

```
[    0.046472] accept_memory(start=0x00000010db600000 size=0x200000)
[    0.048747]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.052557]   (start + size)=0x00000010db800000 (start + 
PAGE_ALIGN(size))=0x00000010db800000
[    0.065217]   bitmap_clear(bitmap=ff1100007d624030, start=32475, len=1)
[    0.067928] accept_memory(start=0x00000010db7ff000 size=0x1000)
[    0.070167]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.073917]   (start + size)=0x00000010db800000 (start + 
PAGE_ALIGN(size))=0x00000010db800000
[    0.077150] accept_memory(start=0x00000010db7fe000 size=0x1000)
[    0.079365]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.083080]   (start + size)=0x00000010db7ff000 (start + 
PAGE_ALIGN(size))=0x00000010db7ff000
[    0.087123] accept_memory(start=0x00000010db7fd000 size=0x1000)
[    0.089362]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.093239]   (start + size)=0x00000010db7fe000 (start + 
PAGE_ALIGN(size))=0x00000010db7fe000
// unrelated
[    0.150522] APIC: Switched APIC routing to: cluster x2apic
[    0.152595] accept_memory(start=0x00000010db7fcf40 size=0x83)
[    0.154745]   unaccepted: version=1 unit_size=2097152 
phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
[    0.158479]   (start + size)=0x00000010db7fcfc3 (start + 
PAGE_ALIGN(size))=0x00000010db7fdf40
[    0.161713] BUG: unable to handle page fault for address: 
ff1100007d625008
```

[1]: https://gist.github.com/msanft/d6d7e32a65708f5bd36233649e4facee




---

&gt; What about the patch below. It seems we under-reserve memory for the
&gt; table if it is unaligned.
&gt; 
&gt; I still think that we need align start/size/end to the PAGE_SIZE in
&gt; accept_memory()/range_contains_unaccepted_memory() before doing anything
&gt; else. Otherwise (end % unit_size) check is broken. But it seems to be
&gt; unrelated to the problem you see.
&gt; 
&gt; diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
&gt; index 111e87a618e5..56e9d73412fa 100644
&gt; --- a/drivers/firmware/efi/efi.c
&gt; +++ b/drivers/firmware/efi/efi.c
&gt; @@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,
&gt;  
&gt;  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)
&gt;  {
&gt; -	phys_addr_t start, size;
&gt; +	phys_addr_t start, end;
&gt;  
&gt;  	start = PAGE_ALIGN_DOWN(efi.unaccepted);
&gt; -	size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted-&gt;size);
&gt; +	end = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted-&gt;size);
&gt;  
&gt; -	memblock_add(start, size);
&gt; -	memblock_reserve(start, size);
&gt; +	memblock_add(start, end - start);
&gt; +	memblock_reserve(start, end - start);
&gt;  }
&gt;  
&gt;  int __init efi_config_parse_tables(const efi_config_table_t *config_tables,

Thanks, this patch seems to fix the problem causing the panic. The VM 
boots as expected with this.

Please let me know if any more information is required.

Best Regards,
Moritz Sanft


---

&gt; What about the patch below. It seems we under-reserve memory for the
&gt; table if it is unaligned.
&gt; 
&gt; I still think that we need align start/size/end to the PAGE_SIZE in
&gt; accept_memory()/range_contains_unaccepted_memory() before doing anything
&gt; else. Otherwise (end % unit_size) check is broken. But it seems to be
&gt; unrelated to the problem you see.
&gt; 
&gt; diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
&gt; index 111e87a618e5..56e9d73412fa 100644
&gt; --- a/drivers/firmware/efi/efi.c
&gt; +++ b/drivers/firmware/efi/efi.c
&gt; @@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,
&gt;  
&gt;  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)
&gt;  {
&gt; -	phys_addr_t start, size;
&gt; +	phys_addr_t start, end;
&gt;  
&gt;  	start = PAGE_ALIGN_DOWN(efi.unaccepted);
&gt; -	size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted-&gt;size);
&gt; +	end = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted-&gt;size);
&gt;  
&gt; -	memblock_add(start, size);
&gt; -	memblock_reserve(start, size);
&gt; +	memblock_add(start, end - start);
&gt; +	memblock_reserve(start, end - start);
&gt;  }
&gt;  
&gt;  int __init efi_config_parse_tables(const efi_config_table_t *config_tables,

Thanks, this patch seems to fix the problem causing the panic. The VM 
boots as expected with this.

Please let me know if any more information is required.

Best Regards,
Moritz Sanft
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, patch seems to fix the problem</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Kiryl Shutsemau</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Kiryl Shutsemau raised concerns that the original patch may not fully address the issue, suggesting additional alignment checks in accept_memory() and range_contains_unaccepted_memory(). He also provided two patches to be considered.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Fri, Feb 13, 2026 at 09:34:46AM +0100, Moritz Sanft wrote:
&gt; &gt; Any chance you can throw
&gt; &gt; a bunch of printk()&#x27;s in the kernel and see what all the fields in here are:
&gt; &gt; 
&gt; &gt; struct efi_unaccepted_memory {
&gt; &gt;         u32 version;
&gt; &gt;         u32 unit_size;
&gt; &gt;         u64 phys_base;
&gt; &gt;         u64 size;
&gt; &gt;         unsigned long bitmap[];
&gt; &gt; };
&gt; &gt; 
&gt; &gt; Along with the address of bitmap[] and all the calls to: bitmap_clear()?
&gt; 
&gt; Thanks for the guidance. I&#x27;ve added this logging via the patch in [1], which
&gt; produced the following output:
&gt; 
&gt; ```
&gt; [    0.033292] accept_memory(start=0x0000000000099000 size=0x6000)
&gt; [    0.037860]   unaccepted: version=1 unit_size=2097152
&gt; phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
&gt; [    0.041469] Using GB pages for direct mapping
&gt; [    0.043090] accept_memory(start=0x00000010db600000 size=0x200000)
&gt; [    0.045311]   unaccepted: version=1 unit_size=2097152
&gt; phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
&gt; [    0.058123]   bitmap_clear(bitmap=ff1100007d624030, start=32475, len=1)
&gt; [    0.060921] accept_memory(start=0x00000010db7ff000 size=0x1000)
&gt; [    0.063142]   unaccepted: version=1 unit_size=2097152
&gt; phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
&gt; [    0.066865] accept_memory(start=0x00000010db7fe000 size=0x1000)
&gt; [    0.069096]   unaccepted: version=1 unit_size=2097152
&gt; phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
&gt; [    0.073705] accept_memory(start=0x00000010db7fd000 size=0x1000)
&gt; [    0.075908]   unaccepted: version=1 unit_size=2097152
&gt; phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
&gt; // unrelated logs omitted here
&gt; [    0.134988] accept_memory(start=0x00000010db7fcf40 size=0x83)
&gt; [    0.137152]   unaccepted: version=1 unit_size=2097152
&gt; phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030
&gt; [    0.140828] BUG: unable to handle page fault for address:
&gt; ff1100007d625008
&gt; ```
&gt; 
&gt; Find a full log attached in [2].
&gt; 
&gt; Please let me know if we need to gather any further logs - we&#x27;re happy to do
&gt; so.

Could you check it this patch makes a difference:

diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c
index c2c067eff634..f2a00cd429f2 100644
--- a/drivers/firmware/efi/unaccepted_memory.c
+++ b/drivers/firmware/efi/unaccepted_memory.c
@@ -35,7 +35,7 @@ void accept_memory(phys_addr_t start, unsigned long size)
 	struct efi_unaccepted_memory *unaccepted;
 	unsigned long range_start, range_end;
 	struct accept_range range, *entry;
-	phys_addr_t end = start + size;
+	phys_addr_t end = start + PAGE_ALIGN(size);
 	unsigned long flags;
 	u64 unit_size;
 
-- 
  Kiryl Shutsemau / Kirill A. Shutemov


---

On Fri, Feb 13, 2026 at 01:33:56PM +0100, Moritz Sanft wrote:
&gt; &gt; Could you check it this patch makes a difference:
&gt; &gt; 
&gt; &gt; diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c
&gt; &gt; index c2c067eff634..f2a00cd429f2 100644
&gt; &gt; --- a/drivers/firmware/efi/unaccepted_memory.c
&gt; &gt; +++ b/drivers/firmware/efi/unaccepted_memory.c
&gt; &gt; @@ -35,7 +35,7 @@ void accept_memory(phys_addr_t start, unsigned long size)
&gt; &gt;  	struct efi_unaccepted_memory *unaccepted;
&gt; &gt;  	unsigned long range_start, range_end;
&gt; &gt;  	struct accept_range range, *entry;
&gt; &gt; -	phys_addr_t end = start + size;
&gt; &gt; +	phys_addr_t end = start + PAGE_ALIGN(size);
&gt; &gt;  	unsigned long flags;
&gt; &gt;  	u64 unit_size;
&gt; 
&gt; Thanks, I tried this on the `-m 67000M` VM and the crash still occurs. I
&gt; extended the previously-added logging to also log the values for `start +
&gt; size` and `start + PAGE_ALIGN(size)`. Please find the full patch including
&gt; the logging and your change in [1].

What about the patch below. It seems we under-reserve memory for the
table if it is unaligned.

I still think that we need align start/size/end to the PAGE_SIZE in
accept_memory()/range_contains_unaccepted_memory() before doing anything
else. Otherwise (end % unit_size) check is broken. But it seems to be
unrelated to the problem you see.

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 111e87a618e5..56e9d73412fa 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,
 
 static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)
 {
-	phys_addr_t start, size;
+	phys_addr_t start, end;
 
 	start = PAGE_ALIGN_DOWN(efi.unaccepted);
-	size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted-&gt;size);
+	end = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted-&gt;size);
 
-	memblock_add(start, size);
-	memblock_reserve(start, size);
+	memblock_add(start, end - start);
+	memblock_reserve(start, end - start);
 }
 
 int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
-- 
  Kiryl Shutsemau / Kirill A. Shutemov
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, additional alignment checks</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Verma, L</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Verma, L, agrees that the patch fixes a bug in TDX VMs and reproduces the issue, but suggests an additional change to account for the table&#x27;s offset within its starting page.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Fri, 2026-02-13 at 14:24 +0000, Kiryl Shutsemau wrote:
&gt; 
&gt; I still think that we need align start/size/end to the PAGE_SIZE in
&gt; accept_memory()/range_contains_unaccepted_memory() before doing anything
&gt; else. Otherwise (end % unit_size) check is broken. But it seems to be
&gt; unrelated to the problem you see.
&gt; 
&gt; diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
&gt; index 111e87a618e5..56e9d73412fa 100644
&gt; --- a/drivers/firmware/efi/efi.c
&gt; +++ b/drivers/firmware/efi/efi.c
&gt; @@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,
&gt;  
&gt;  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)
&gt;  {
&gt; -	phys_addr_t start, size;
&gt; +	phys_addr_t start, end;
&gt;  
&gt;  	start = PAGE_ALIGN_DOWN(efi.unaccepted);
&gt; -	size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted-&gt;size);
&gt; +	end = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted-&gt;size);
&gt;  
&gt; -	memblock_add(start, size);
&gt; -	memblock_reserve(start, size);
&gt; +	memblock_add(start, end - start);
&gt; +	memblock_reserve(start, end - start);
&gt;  }
&gt;  
&gt;  int __init efi_config_parse_tables(const efi_config_table_t *config_tables,

I was able to reproduce the original BUG on a TDX system, and after
some LLM-assisted debugging, this similar patch seems to fix it:

---

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 55452e61af31d..9f66f0f535420 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -695,7 +695,8 @@ static __init void reserve_unaccepted(struct
efi_unaccepted_memory *unaccepted)
        phys_addr_t start, size;
 
        start = PAGE_ALIGN_DOWN(efi.unaccepted);
-       size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted-&gt;size);
+       size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted-&gt;size +
+                         offset_in_page(efi.unaccepted));
 
        memblock_add(start, size);
        memblock_reserve(start, size);


---

The hypothesis is that the original size calculation does not account
for the table&#x27;s offset within its starting page. The EFI pool allocator
performs sub-page allocation, so efi.unaccepted may not be page
aligned.
</pre>
</details>
<div class="review-comment-signals">Signals: agreement on fix, additional suggested change</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>