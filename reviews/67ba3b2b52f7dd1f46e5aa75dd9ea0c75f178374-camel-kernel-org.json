{
  "thread_id": "67ba3b2b52f7dd1f46e5aa75dd9ea0c75f178374.camel@kernel.org",
  "subject": "Re: [PATCH v3 1/4] open: new O_REGULAR flag support",
  "url": "https://lore.kernel.org/all/67ba3b2b52f7dd1f46e5aa75dd9ea0c75f178374.camel@kernel.org/",
  "dates": {
    "2026-02-18": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Reviewer Dorjoy Chowdhury raised concerns about the O_REGULAR flag's behavior when combined with other flags like O_CREAT, and asked for suggestions on improvement. They also inquired about handling O_REGULAR in atomic_open code paths and file_operations.open code paths.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "inquired about implementation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "This flag indicates the path should be opened if it's a regular file.\nThis is useful to write secure programs that want to avoid being tricked\ninto opening device nodes with special semantics while thinking they\noperate on regular files.\n\nA corresponding error code ENOTREG has been introduced. For example, if\nopen is called on path /dev/null with O_REGULAR in the flag param, it\nwill return -ENOTREG.\n\nWhen used in combination with O_CREAT, either the regular file is\ncreated, or if the path already exists, it is opened if it's a regular\nfile. Otherwise, -ENOTREG is returned.\n\n-EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\npart of O_TMPFILE) because it doesn't make sense to open a path that\nis both a directory and a regular file.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n arch/alpha/include/uapi/asm/errno.h        | 2 ++\n arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n arch/mips/include/uapi/asm/errno.h         | 2 ++\n arch/parisc/include/uapi/asm/errno.h       | 2 ++\n arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n arch/sparc/include/uapi/asm/errno.h        | 2 ++\n arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n fs/fcntl.c                                 | 2 +-\n fs/namei.c                                 | 6 ++++++\n fs/open.c                                  | 4 +++-\n include/linux/fcntl.h                      | 2 +-\n include/uapi/asm-generic/errno.h           | 2 ++\n include/uapi/asm-generic/fcntl.h           | 4 ++++\n tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n tools/include/uapi/asm-generic/errno.h     | 2 ++\n 18 files changed, 38 insertions(+), 3 deletions(-)\n\ndiff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\nindex 6791f6508632..8bbcaa9024f9 100644\n--- a/arch/alpha/include/uapi/asm/errno.h\n+++ b/arch/alpha/include/uapi/asm/errno.h\n@@ -127,4 +127,6 @@\n \n #define EHWPOISON\t139\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t140\t/* Not a regular file */\n+\n #endif\ndiff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\nindex 50bdc8e8a271..4da5a64c23bd 100644\n--- a/arch/alpha/include/uapi/asm/fcntl.h\n+++ b/arch/alpha/include/uapi/asm/fcntl.h\n@@ -34,6 +34,7 @@\n \n #define O_PATH\t\t040000000\n #define __O_TMPFILE\t0100000000\n+#define O_REGULAR\t0200000000\n \n #define F_GETLK\t\t7\n #define F_SETLK\t\t8\ndiff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\nindex c01ed91b1ef4..293c78777254 100644\n--- a/arch/mips/include/uapi/asm/errno.h\n+++ b/arch/mips/include/uapi/asm/errno.h\n@@ -126,6 +126,8 @@\n \n #define EHWPOISON\t168\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t169\t/* Not a regular file */\n+\n #define EDQUOT\t\t1133\t/* Quota exceeded */\n \n \ndiff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\nindex 8cbc07c1903e..442917484f99 100644\n--- a/arch/parisc/include/uapi/asm/errno.h\n+++ b/arch/parisc/include/uapi/asm/errno.h\n@@ -124,4 +124,6 @@\n \n #define EHWPOISON\t257\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t258\t/* Not a regular file */\n+\n #endif\ndiff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\nindex 03dee816cb13..0cc3320fe326 100644\n--- a/arch/parisc/include/uapi/asm/fcntl.h\n+++ b/arch/parisc/include/uapi/asm/fcntl.h\n@@ -19,6 +19,7 @@\n \n #define O_PATH\t\t020000000\n #define __O_TMPFILE\t040000000\n+#define O_REGULAR\t0100000000\n \n #define F_GETLK64\t8\n #define F_SETLK64\t9\ndiff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\nindex 4a41e7835fd5..8dce0bfeab74 100644\n--- a/arch/sparc/include/uapi/asm/errno.h\n+++ b/arch/sparc/include/uapi/asm/errno.h\n@@ -117,4 +117,6 @@\n \n #define EHWPOISON\t135\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t136\t/* Not a regular file */\n+\n #endif\ndiff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\nindex 67dae75e5274..a93d18d2c23e 100644\n--- a/arch/sparc/include/uapi/asm/fcntl.h\n+++ b/arch/sparc/include/uapi/asm/fcntl.h\n@@ -37,6 +37,7 @@\n \n #define O_PATH\t\t0x1000000\n #define __O_TMPFILE\t0x2000000\n+#define O_REGULAR\t0x4000000\n \n #define F_GETOWN\t5\t/*  for sockets. */\n #define F_SETOWN\t6\t/*  for sockets. */\ndiff --git a/fs/fcntl.c b/fs/fcntl.c\nindex f93dbca08435..62ab4ad2b6f5 100644\n--- a/fs/fcntl.c\n+++ b/fs/fcntl.c\n@@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n \t * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n \t * is defined as O_NONBLOCK on some platforms and not on others.\n \t */\n-\tBUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n+\tBUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n \t\tHWEIGHT32(\n \t\t\t(VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n \t\t\t__FMODE_EXEC));\ndiff --git a/fs/namei.c b/fs/namei.c\nindex b28ecb699f32..f5504ae4b03c 100644\n--- a/fs/namei.c\n+++ b/fs/namei.c\n@@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n \t\tif (unlikely(error))\n \t\t\treturn error;\n \t}\n+\n+\tif ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n+\t\treturn -ENOTREG;\n+\n \tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n \t\treturn -ENOTDIR;\n \n@@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n \tstruct path path;\n \tint error = path_lookupat(nd, flags, &path);\n \tif (!error) {\n+\t\tif ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n+\t\t\treturn -ENOTREG;\n \t\taudit_inode(nd->name, path.dentry, 0);\n \t\terror = vfs_open(&path, file);\n \t\tpath_put(&path);\ndiff --git a/fs/open.c b/fs/open.c\nindex 74c4c1462b3e..82153e21907e 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n EXPORT_SYMBOL_GPL(kernel_file_open);\n \n #define WILL_CREATE(flags)\t(flags & (O_CREAT | __O_TMPFILE))\n-#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n+#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n \n inline struct open_how build_open_how(int flags, umode_t mode)\n {\n@@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n \t\t\treturn -EINVAL;\n \t\tif (!(acc_mode & MAY_WRITE))\n \t\t\treturn -EINVAL;\n+\t} else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n+\t\treturn -EINVAL;\n \t}\n \tif (flags & O_PATH) {\n \t\t/* O_PATH only permits certain other flags to be set. */\ndiff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\nindex a332e79b3207..4fd07b0e0a17 100644\n--- a/include/linux/fcntl.h\n+++ b/include/linux/fcntl.h\n@@ -10,7 +10,7 @@\n \t(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n \t O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n \t FASYNC\t| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n-\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n+\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n \n /* List of all valid flags for the how->resolve argument: */\n #define VALID_RESOLVE_FLAGS \\\ndiff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\nindex 92e7ae493ee3..2216ab9aa32e 100644\n--- a/include/uapi/asm-generic/errno.h\n+++ b/include/uapi/asm-generic/errno.h\n@@ -122,4 +122,6 @@\n \n #define EHWPOISON\t133\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t134\t/* Not a regular file */\n+\n #endif\ndiff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\nindex 613475285643..3468b352a575 100644\n--- a/include/uapi/asm-generic/fcntl.h\n+++ b/include/uapi/asm-generic/fcntl.h\n@@ -88,6 +88,10 @@\n #define __O_TMPFILE\t020000000\n #endif\n \n+#ifndef O_REGULAR\n+#define O_REGULAR\t040000000\n+#endif\n+\n /* a horrid kludge trying to make sure that this will fail on old kernels */\n #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n \ndiff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\nindex 6791f6508632..8bbcaa9024f9 100644\n--- a/tools/arch/alpha/include/uapi/asm/errno.h\n+++ b/tools/arch/alpha/include/uapi/asm/errno.h\n@@ -127,4 +127,6 @@\n \n #define EHWPOISON\t139\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t140\t/* Not a regular file */\n+\n #endif\ndiff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\nindex c01ed91b1ef4..293c78777254 100644\n--- a/tools/arch/mips/include/uapi/asm/errno.h\n+++ b/tools/arch/mips/include/uapi/asm/errno.h\n@@ -126,6 +126,8 @@\n \n #define EHWPOISON\t168\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t169\t/* Not a regular file */\n+\n #define EDQUOT\t\t1133\t/* Quota exceeded */\n \n \ndiff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\nindex 8cbc07c1903e..442917484f99 100644\n--- a/tools/arch/parisc/include/uapi/asm/errno.h\n+++ b/tools/arch/parisc/include/uapi/asm/errno.h\n@@ -124,4 +124,6 @@\n \n #define EHWPOISON\t257\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t258\t/* Not a regular file */\n+\n #endif\ndiff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\nindex 4a41e7835fd5..8dce0bfeab74 100644\n--- a/tools/arch/sparc/include/uapi/asm/errno.h\n+++ b/tools/arch/sparc/include/uapi/asm/errno.h\n@@ -117,4 +117,6 @@\n \n #define EHWPOISON\t135\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t136\t/* Not a regular file */\n+\n #endif\ndiff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\nindex 92e7ae493ee3..2216ab9aa32e 100644\n--- a/tools/include/uapi/asm-generic/errno.h\n+++ b/tools/include/uapi/asm-generic/errno.h\n@@ -122,4 +122,6 @@\n \n #define EHWPOISON\t133\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t134\t/* Not a regular file */\n+\n #endif\n-- \n2.52.0\n\n\n\n---\n\nJust a happy path test.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n .../testing/selftests/openat2/openat2_test.c  | 37 ++++++++++++++++++-\n 1 file changed, 36 insertions(+), 1 deletion(-)\n\ndiff --git a/tools/testing/selftests/openat2/openat2_test.c b/tools/testing/selftests/openat2/openat2_test.c\nindex 0e161ef9e9e4..011ebc9af4e5 100644\n--- a/tools/testing/selftests/openat2/openat2_test.c\n+++ b/tools/testing/selftests/openat2/openat2_test.c\n@@ -320,8 +320,42 @@ void test_openat2_flags(void)\n \t}\n }\n \n+#ifndef O_REGULAR\n+#define O_REGULAR 040000000\n+#endif\n+\n+#ifndef ENOTREG\n+#define ENOTREG 134\n+#endif\n+\n+void test_openat2_o_regular_flag(void)\n+{\n+\tif (!openat2_supported) {\n+\t\tksft_test_result_skip(\"Skipping %s as openat2 is not supported\\n\", __func__);\n+\t\treturn;\n+\t}\n+\n+\tstruct open_how how = {\n+\t\t.flags = O_REGULAR | O_RDONLY\n+\t};\n+\n+\tint fd = sys_openat2(AT_FDCWD, \"/dev/null\", &how);\n+\n+\tif (fd == ENOENT) {\n+\t\tksft_test_result_skip(\"Skipping %s as there is no /dev/null\\n\", __func__);\n+\t\treturn;\n+\t}\n+\n+\tif (fd != -ENOTREG) {\n+\t\tksft_test_result_fail(\"openat2 should return ENOTREG\\n\");\n+\t\treturn;\n+\t}\n+\n+\tksft_test_result_pass(\"%s succeeded\\n\", __func__);\n+}\n+\n #define NUM_TESTS (NUM_OPENAT2_STRUCT_VARIATIONS * NUM_OPENAT2_STRUCT_TESTS + \\\n-\t\t   NUM_OPENAT2_FLAG_TESTS)\n+\t\t   NUM_OPENAT2_FLAG_TESTS + 1)\n \n int main(int argc, char **argv)\n {\n@@ -330,6 +364,7 @@ int main(int argc, char **argv)\n \n \ttest_openat2_struct();\n \ttest_openat2_flags();\n+\ttest_openat2_o_regular_flag();\n \n \tif (ksft_get_fail_cnt() + ksft_get_error_cnt() > 0)\n \t\tksft_exit_fail();\n-- \n2.52.0\n\n\n\n---\n\nFollowing the convention in include/uapi/asm-generic/fcntl.h and other\narchitecture specific arch/*/include/uapi/asm/fcntl.h files.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n arch/sparc/include/uapi/asm/fcntl.h | 36 ++++++++++++++---------------\n 1 file changed, 18 insertions(+), 18 deletions(-)\n\ndiff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\nindex a93d18d2c23e..3c16f1a66a6a 100644\n--- a/arch/sparc/include/uapi/asm/fcntl.h\n+++ b/arch/sparc/include/uapi/asm/fcntl.h\n@@ -2,23 +2,23 @@\n #ifndef _SPARC_FCNTL_H\n #define _SPARC_FCNTL_H\n \n-#define O_APPEND\t0x0008\n-#define FASYNC\t\t0x0040\t/* fcntl, for BSD compatibility */\n-#define O_CREAT\t\t0x0200\t/* not fcntl */\n-#define O_TRUNC\t\t0x0400\t/* not fcntl */\n-#define O_EXCL\t\t0x0800\t/* not fcntl */\n-#define O_DSYNC\t\t0x2000\t/* used to be O_SYNC, see below */\n-#define O_NONBLOCK\t0x4000\n+#define O_APPEND\t0000000010\n+#define FASYNC\t\t0000000100\t/* fcntl, for BSD compatibility */\n+#define O_CREAT\t\t0000001000\t/* not fcntl */\n+#define O_TRUNC\t\t0000002000\t/* not fcntl */\n+#define O_EXCL\t\t0000004000\t/* not fcntl */\n+#define O_DSYNC\t\t0000020000\t/* used to be O_SYNC, see below */\n+#define O_NONBLOCK\t0000040000\n #if defined(__sparc__) && defined(__arch64__)\n-#define O_NDELAY\t0x0004\n+#define O_NDELAY\t0000000004\n #else\n-#define O_NDELAY\t(0x0004 | O_NONBLOCK)\n+#define O_NDELAY\t(0000000004 | O_NONBLOCK)\n #endif\n-#define O_NOCTTY\t0x8000\t/* not fcntl */\n-#define O_LARGEFILE\t0x40000\n-#define O_DIRECT        0x100000 /* direct disk access hint */\n-#define O_NOATIME\t0x200000\n-#define O_CLOEXEC\t0x400000\n+#define O_NOCTTY\t0000100000\t/* not fcntl */\n+#define O_LARGEFILE\t0001000000\n+#define O_DIRECT        0004000000 /* direct disk access hint */\n+#define O_NOATIME\t0010000000\n+#define O_CLOEXEC\t0020000000\n /*\n  * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using\n  * the O_SYNC flag.  We continue to use the existing numerical value\n@@ -32,12 +32,12 @@\n  *\n  * Note: __O_SYNC must never be used directly.\n  */\n-#define __O_SYNC\t0x800000\n+#define __O_SYNC\t0040000000\n #define O_SYNC\t\t(__O_SYNC|O_DSYNC)\n \n-#define O_PATH\t\t0x1000000\n-#define __O_TMPFILE\t0x2000000\n-#define O_REGULAR\t0x4000000\n+#define O_PATH\t\t0100000000\n+#define __O_TMPFILE\t0200000000\n+#define O_REGULAR\t0400000000\n \n #define F_GETOWN\t5\t/*  for sockets. */\n #define F_SETOWN\t6\t/*  for sockets. */\n-- \n2.52.0\n\n\n\n---\n\nFollowing the convention in include/uapi/asm-generic/fcntl.h and other\narchitecture specific arch/*/include/uapi/asm/fcntl.h files.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n arch/mips/include/uapi/asm/fcntl.h | 22 +++++++++++-----------\n 1 file changed, 11 insertions(+), 11 deletions(-)\n\ndiff --git a/arch/mips/include/uapi/asm/fcntl.h b/arch/mips/include/uapi/asm/fcntl.h\nindex 0369a38e3d4f..6aa3f49df17e 100644\n--- a/arch/mips/include/uapi/asm/fcntl.h\n+++ b/arch/mips/include/uapi/asm/fcntl.h\n@@ -11,15 +11,15 @@\n \n #include <asm/sgidefs.h>\n \n-#define O_APPEND\t0x0008\n-#define O_DSYNC\t\t0x0010\t/* used to be O_SYNC, see below */\n-#define O_NONBLOCK\t0x0080\n-#define O_CREAT\t\t0x0100\t/* not fcntl */\n-#define O_TRUNC\t\t0x0200\t/* not fcntl */\n-#define O_EXCL\t\t0x0400\t/* not fcntl */\n-#define O_NOCTTY\t0x0800\t/* not fcntl */\n-#define FASYNC\t\t0x1000\t/* fcntl, for BSD compatibility */\n-#define O_LARGEFILE\t0x2000\t/* allow large file opens */\n+#define O_APPEND\t0000010\n+#define O_DSYNC\t\t0000020\t/* used to be O_SYNC, see below */\n+#define O_NONBLOCK\t0000200\n+#define O_CREAT\t\t0000400\t/* not fcntl */\n+#define O_TRUNC\t\t0001000\t/* not fcntl */\n+#define O_EXCL\t\t0002000\t/* not fcntl */\n+#define O_NOCTTY\t0004000\t/* not fcntl */\n+#define FASYNC\t\t0010000\t/* fcntl, for BSD compatibility */\n+#define O_LARGEFILE\t0020000\t/* allow large file opens */\n /*\n  * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using\n  * the O_SYNC flag.  We continue to use the existing numerical value\n@@ -33,9 +33,9 @@\n  *\n  * Note: __O_SYNC must never be used directly.\n  */\n-#define __O_SYNC\t0x4000\n+#define __O_SYNC\t0040000\n #define O_SYNC\t\t(__O_SYNC|O_DSYNC)\n-#define O_DIRECT\t0x8000\t/* direct disk access hint */\n+#define O_DIRECT\t0100000\t/* direct disk access hint */\n \n #define F_GETLK\t\t14\n #define F_SETLK\t\t6\n-- \n2.52.0\n\n\n\n---\n\nOn Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n>\n> On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > This flag indicates the path should be opened if it's a regular file.\n> > This is useful to write secure programs that want to avoid being tricked\n> > into opening device nodes with special semantics while thinking they\n> > operate on regular files.\n> >\n> > A corresponding error code ENOTREG has been introduced. For example, if\n> > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > will return -ENOTREG.\n> >\n> > When used in combination with O_CREAT, either the regular file is\n> > created, or if the path already exists, it is opened if it's a regular\n> > file. Otherwise, -ENOTREG is returned.\n> >\n> > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > is both a directory and a regular file.\n> >\n> > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > ---\n> >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> >  fs/fcntl.c                                 | 2 +-\n> >  fs/namei.c                                 | 6 ++++++\n> >  fs/open.c                                  | 4 +++-\n> >  include/linux/fcntl.h                      | 2 +-\n> >  include/uapi/asm-generic/errno.h           | 2 ++\n> >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> >  18 files changed, 38 insertions(+), 3 deletions(-)\n> >\n> > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > index 6791f6508632..8bbcaa9024f9 100644\n> > --- a/arch/alpha/include/uapi/asm/errno.h\n> > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > @@ -127,4 +127,6 @@\n> >\n> >  #define EHWPOISON    139     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              140     /* Not a regular file */\n> > +\n> >  #endif\n> > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > index 50bdc8e8a271..4da5a64c23bd 100644\n> > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > @@ -34,6 +34,7 @@\n> >\n> >  #define O_PATH               040000000\n> >  #define __O_TMPFILE  0100000000\n> > +#define O_REGULAR    0200000000\n> >\n> >  #define F_GETLK              7\n> >  #define F_SETLK              8\n> > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > index c01ed91b1ef4..293c78777254 100644\n> > --- a/arch/mips/include/uapi/asm/errno.h\n> > +++ b/arch/mips/include/uapi/asm/errno.h\n> > @@ -126,6 +126,8 @@\n> >\n> >  #define EHWPOISON    168     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              169     /* Not a regular file */\n> > +\n> >  #define EDQUOT               1133    /* Quota exceeded */\n> >\n> >\n> > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > index 8cbc07c1903e..442917484f99 100644\n> > --- a/arch/parisc/include/uapi/asm/errno.h\n> > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > @@ -124,4 +124,6 @@\n> >\n> >  #define EHWPOISON    257     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              258     /* Not a regular file */\n> > +\n> >  #endif\n> > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > index 03dee816cb13..0cc3320fe326 100644\n> > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > @@ -19,6 +19,7 @@\n> >\n> >  #define O_PATH               020000000\n> >  #define __O_TMPFILE  040000000\n> > +#define O_REGULAR    0100000000\n> >\n> >  #define F_GETLK64    8\n> >  #define F_SETLK64    9\n> > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > index 4a41e7835fd5..8dce0bfeab74 100644\n> > --- a/arch/sparc/include/uapi/asm/errno.h\n> > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > @@ -117,4 +117,6 @@\n> >\n> >  #define EHWPOISON    135     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              136     /* Not a regular file */\n> > +\n> >  #endif\n> > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > index 67dae75e5274..a93d18d2c23e 100644\n> > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > @@ -37,6 +37,7 @@\n> >\n> >  #define O_PATH               0x1000000\n> >  #define __O_TMPFILE  0x2000000\n> > +#define O_REGULAR    0x4000000\n> >\n> >  #define F_GETOWN     5       /*  for sockets. */\n> >  #define F_SETOWN     6       /*  for sockets. */\n> > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > index f93dbca08435..62ab4ad2b6f5 100644\n> > --- a/fs/fcntl.c\n> > +++ b/fs/fcntl.c\n> > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> >        * is defined as O_NONBLOCK on some platforms and not on others.\n> >        */\n> > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> >               HWEIGHT32(\n> >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> >                       __FMODE_EXEC));\n> > diff --git a/fs/namei.c b/fs/namei.c\n> > index b28ecb699f32..f5504ae4b03c 100644\n> > --- a/fs/namei.c\n> > +++ b/fs/namei.c\n> > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> >               if (unlikely(error))\n> >                       return error;\n> >       }\n> > +\n> > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > +             return -ENOTREG;\n> > +\n> >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> >               return -ENOTDIR;\n> >\n> > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> >       struct path path;\n> >       int error = path_lookupat(nd, flags, &path);\n> >       if (!error) {\n> > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > +                     return -ENOTREG;\n> >               audit_inode(nd->name, path.dentry, 0);\n> >               error = vfs_open(&path, file);\n> >               path_put(&path);\n> > diff --git a/fs/open.c b/fs/open.c\n> > index 74c4c1462b3e..82153e21907e 100644\n> > --- a/fs/open.c\n> > +++ b/fs/open.c\n> > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> >\n> >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> >\n> >  inline struct open_how build_open_how(int flags, umode_t mode)\n> >  {\n> > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> >                       return -EINVAL;\n> >               if (!(acc_mode & MAY_WRITE))\n> >                       return -EINVAL;\n> > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > +             return -EINVAL;\n> >       }\n> >       if (flags & O_PATH) {\n> >               /* O_PATH only permits certain other flags to be set. */\n> > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > index a332e79b3207..4fd07b0e0a17 100644\n> > --- a/include/linux/fcntl.h\n> > +++ b/include/linux/fcntl.h\n> > @@ -10,7 +10,7 @@\n> >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> >\n> >  /* List of all valid flags for the how->resolve argument: */\n> >  #define VALID_RESOLVE_FLAGS \\\n> > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > index 92e7ae493ee3..2216ab9aa32e 100644\n> > --- a/include/uapi/asm-generic/errno.h\n> > +++ b/include/uapi/asm-generic/errno.h\n> > @@ -122,4 +122,6 @@\n> >\n> >  #define EHWPOISON    133     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              134     /* Not a regular file */\n> > +\n> >  #endif\n> > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > index 613475285643..3468b352a575 100644\n> > --- a/include/uapi/asm-generic/fcntl.h\n> > +++ b/include/uapi/asm-generic/fcntl.h\n> > @@ -88,6 +88,10 @@\n> >  #define __O_TMPFILE  020000000\n> >  #endif\n> >\n> > +#ifndef O_REGULAR\n> > +#define O_REGULAR    040000000\n> > +#endif\n> > +\n> >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> >\n> > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > index 6791f6508632..8bbcaa9024f9 100644\n> > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > @@ -127,4 +127,6 @@\n> >\n> >  #define EHWPOISON    139     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              140     /* Not a regular file */\n> > +\n> >  #endif\n> > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > index c01ed91b1ef4..293c78777254 100644\n> > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > @@ -126,6 +126,8 @@\n> >\n> >  #define EHWPOISON    168     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              169     /* Not a regular file */\n> > +\n> >  #define EDQUOT               1133    /* Quota exceeded */\n> >\n> >\n> > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > index 8cbc07c1903e..442917484f99 100644\n> > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > @@ -124,4 +124,6 @@\n> >\n> >  #define EHWPOISON    257     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              258     /* Not a regular file */\n> > +\n> >  #endif\n> > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > index 4a41e7835fd5..8dce0bfeab74 100644\n> > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > @@ -117,4 +117,6 @@\n> >\n> >  #define EHWPOISON    135     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              136     /* Not a regular file */\n> > +\n> >  #endif\n> > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > index 92e7ae493ee3..2216ab9aa32e 100644\n> > --- a/tools/include/uapi/asm-generic/errno.h\n> > +++ b/tools/include/uapi/asm-generic/errno.h\n> > @@ -122,4 +122,6 @@\n> >\n> >  #define EHWPOISON    133     /* Memory page has hardware error */\n> >\n> > +#define ENOTREG              134     /* Not a regular file */\n> > +\n> >  #endif\n>\n> One thing this patch is missing is handling for ->atomic_open(). I\n> imagine most of the filesystems that provide that op can't support\n> O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> is add in some patches that make all of the atomic_open operations in\n> the kernel return -EINVAL if O_REGULAR is set.\n>\n> Then, once the basic support is in, you or someone else can go back and\n> implement support for O_REGULAR where possible.\n\nThank you for the feedback. I don't quite understand what I need to\nfix. I thought open system calls always create regular files, so\natomic_open probably always creates regular files? Can you please give\nme some more details as to where I need to fix this and what the\nactual bug here is that is related to atomic_open?  I think I had done\nsome normal testing and when using O_CREAT | O_REGULAR, if the file\ndoesn't exist, the file gets created and the file that gets created is\na regular file, so it probably makes sense? Or should the behavior be\nthat if file doesn't exist, -EINVAL is returned and if file exists it\nis opened if regular, otherwise -ENOTREG is returned?\n\nRegards,\nDorjoy\n\n\n---\n\nOn Wed, Jan 28, 2026 at 9:51 PM Jeff Layton <jlayton@kernel.org> wrote:\n>\n> On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > >\n> > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > This flag indicates the path should be opened if it's a regular file.\n> > > > This is useful to write secure programs that want to avoid being tricked\n> > > > into opening device nodes with special semantics while thinking they\n> > > > operate on regular files.\n> > > >\n> > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > will return -ENOTREG.\n> > > >\n> > > > When used in combination with O_CREAT, either the regular file is\n> > > > created, or if the path already exists, it is opened if it's a regular\n> > > > file. Otherwise, -ENOTREG is returned.\n> > > >\n> > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > is both a directory and a regular file.\n> > > >\n> > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > ---\n> > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > >  fs/fcntl.c                                 | 2 +-\n> > > >  fs/namei.c                                 | 6 ++++++\n> > > >  fs/open.c                                  | 4 +++-\n> > > >  include/linux/fcntl.h                      | 2 +-\n> > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > >\n> > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > @@ -127,4 +127,6 @@\n> > > >\n> > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > @@ -34,6 +34,7 @@\n> > > >\n> > > >  #define O_PATH               040000000\n> > > >  #define __O_TMPFILE  0100000000\n> > > > +#define O_REGULAR    0200000000\n> > > >\n> > > >  #define F_GETLK              7\n> > > >  #define F_SETLK              8\n> > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > index c01ed91b1ef4..293c78777254 100644\n> > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > @@ -126,6 +126,8 @@\n> > > >\n> > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > +\n> > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > >\n> > > >\n> > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > index 8cbc07c1903e..442917484f99 100644\n> > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > @@ -124,4 +124,6 @@\n> > > >\n> > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > @@ -19,6 +19,7 @@\n> > > >\n> > > >  #define O_PATH               020000000\n> > > >  #define __O_TMPFILE  040000000\n> > > > +#define O_REGULAR    0100000000\n> > > >\n> > > >  #define F_GETLK64    8\n> > > >  #define F_SETLK64    9\n> > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > @@ -117,4 +117,6 @@\n> > > >\n> > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > @@ -37,6 +37,7 @@\n> > > >\n> > > >  #define O_PATH               0x1000000\n> > > >  #define __O_TMPFILE  0x2000000\n> > > > +#define O_REGULAR    0x4000000\n> > > >\n> > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > --- a/fs/fcntl.c\n> > > > +++ b/fs/fcntl.c\n> > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > >        */\n> > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > >               HWEIGHT32(\n> > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > >                       __FMODE_EXEC));\n> > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > --- a/fs/namei.c\n> > > > +++ b/fs/namei.c\n> > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > >               if (unlikely(error))\n> > > >                       return error;\n> > > >       }\n> > > > +\n> > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > +             return -ENOTREG;\n> > > > +\n> > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > >               return -ENOTDIR;\n> > > >\n> > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > >       struct path path;\n> > > >       int error = path_lookupat(nd, flags, &path);\n> > > >       if (!error) {\n> > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > +                     return -ENOTREG;\n> > > >               audit_inode(nd->name, path.dentry, 0);\n> > > >               error = vfs_open(&path, file);\n> > > >               path_put(&path);\n> > > > diff --git a/fs/open.c b/fs/open.c\n> > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > --- a/fs/open.c\n> > > > +++ b/fs/open.c\n> > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > >\n> > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > >\n> > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > >  {\n> > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > >                       return -EINVAL;\n> > > >               if (!(acc_mode & MAY_WRITE))\n> > > >                       return -EINVAL;\n> > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > +             return -EINVAL;\n> > > >       }\n> > > >       if (flags & O_PATH) {\n> > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > --- a/include/linux/fcntl.h\n> > > > +++ b/include/linux/fcntl.h\n> > > > @@ -10,7 +10,7 @@\n> > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > >\n> > > >  /* List of all valid flags for the how->resolve argument: */\n> > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > --- a/include/uapi/asm-generic/errno.h\n> > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > @@ -122,4 +122,6 @@\n> > > >\n> > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > index 613475285643..3468b352a575 100644\n> > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > @@ -88,6 +88,10 @@\n> > > >  #define __O_TMPFILE  020000000\n> > > >  #endif\n> > > >\n> > > > +#ifndef O_REGULAR\n> > > > +#define O_REGULAR    040000000\n> > > > +#endif\n> > > > +\n> > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > >\n> > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > @@ -127,4 +127,6 @@\n> > > >\n> > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > index c01ed91b1ef4..293c78777254 100644\n> > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > @@ -126,6 +126,8 @@\n> > > >\n> > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > +\n> > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > >\n> > > >\n> > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > index 8cbc07c1903e..442917484f99 100644\n> > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > @@ -124,4 +124,6 @@\n> > > >\n> > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > @@ -117,4 +117,6 @@\n> > > >\n> > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > @@ -122,4 +122,6 @@\n> > > >\n> > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > >\n> > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > >\n> > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > imagine most of the filesystems that provide that op can't support\n> > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > is add in some patches that make all of the atomic_open operations in\n> > > the kernel return -EINVAL if O_REGULAR is set.\n> > >\n> > > Then, once the basic support is in, you or someone else can go back and\n> > > implement support for O_REGULAR where possible.\n> >\n> > Thank you for the feedback. I don't quite understand what I need to\n> > fix. I thought open system calls always create regular files, so\n> > atomic_open probably always creates regular files? Can you please give\n> > me some more details as to where I need to fix this and what the\n> > actual bug here is that is related to atomic_open?  I think I had done\n> > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > doesn't exist, the file gets created and the file that gets created is\n> > a regular file, so it probably makes sense? Or should the behavior be\n> > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > is opened if regular, otherwise -ENOTREG is returned?\n> >\n>\n> atomic_open() is a combination lookup+open for when the dentry isn't\n> present in the dcache. The normal open codepath that you're patching\n> does not get called in this case when ->atomic_open is set for the\n> filesystem. It's mostly used by network filesystems that need to\n> optimize away the lookup since it's wasted round trip, and is often\n> racy anyway. Your patchset doesn't address those filesystems. They will\n> likely end up ignoring O_REGULAR in that case, which is not what you\n> want.\n>\n> What I was suggesting is that, as an interim step, you find all of the\n> atomic_open operations in the kernel (there are maybe a dozen or so),\n> and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n\nSorry, I am just trying to fully understand this. Do you mean to\nreturn -EINVAL from all atomic_open implementations in the kernel if\nboth O_REGULAR and O_DIRECTORY are set (or just only if O_REGULAR is\nset, we need to return -EINVAL)? I am already returning -EINVAL when\nboth these are set from the build_open_flags function, so that should\nalready handle the cases, right? I think after atomic_open get called,\nall code paths eventually go through the do_open function where I have\nthis check \"if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\nreturn -ENOTREG\". This is right before if ((nd->flags &\nLOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry)) return -ENOTDIR;\nwhich I had initially followed. So should I just return -EINVAL from\nthe atomic_open functions too if both O_REGULAR and O_DIRECTORY are\nset? Sorry if I am misunderstanding this.\n\nRegards,\nDorjoy\n\n\n---\n\nOn Wed, Jan 28, 2026 at 1:12 PM Mateusz Guzik <mjguzik@gmail.com> wrote:\n>\n> On Wed, Jan 28, 2026 at 12:23:45AM +0100, Aleksa Sarai wrote:\n> > In my view, this should be an openat2(2)-only API.\n>\n> fwiw +1 from me, the O_ flag situation is already terrible even without\n> the validation woes.\n>\n> I find it most unfortunate the openat2 syscall reuses the O_ namespace.\n> For my taste it would be best closed for business, with all new flag\n> additions using a different space.\n>\n> I can easily see people passing O_WHATEVER to open and openat by blindly\n> assuming they are supported just based on the name.\n>\n> that's a side mini-rant, too late to do anything here now\n>\n> > In addition, I would\n> > propose that (instead of burning another O_* flag bit for this as a\n> > special-purpose API just for regular files) you could have a mask of\n> > which S_IFMT bits should be rejected as a new field in \"struct\n> > open_how\". This would let you reject sockets or device inodes but permit\n> > FIFOs and regular files or directories, for instance. This could even be\n> > done without a new O_* flag at all (the zero-value how->sfmt_mask would\n> > allow everything and so would work well with extensible structs), but we\n> > could add an O2_* flag anyway.\n>\n> I don't think this works because the vars have overlapping bits:\n>   #define S_IFBLK  0060000\n>   #define S_IFDIR  0040000\n>\n> So you very much can't select what you want off of a bitmask.\n>\n> At best the field could be used to select the one type you are fine with.\n>\n> If one was to pursue the idea, some other defines with unique bits would\n> need to be provided. But even then, semantics should be to only *allow*\n> the bits you are fine with and reject the rest.\n>\n> But I'm not at all confident this is worth any effort -- with\n> O_DIRECTORY already being there and O_REGULAR proposed, is there a use\n> case which wants something else?\n>\n\nGood discussion. So should I just rename the O_REGULAR to O2_REGULAR\nand create a VALID_OPENAT2_FLAGS and no need to do how->sfmt_mask\nstuff?\n\n> >\n> > > +#define ENOTREG            134     /* Not a regular file */\n> > > +\n> >\n> [..]\n> > Then to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind\n> > of justify the existence of ENOTREG too. Unfortunately, you won't be\n> > able to use ENOTREG if you go with my idea of having mask bits in\n> > open_how... (And what errno should we use then...? Hm.)\n> >\n>\n> The most useful behavior would indicate what was found (e.g., a pipe).\n>\n> The easiest way to do it would create errnos for all types (EISDIR\n> already exists for one), but I can't seriously propose that.\n>\n> Going the other way, EBADTYPE or something else reusable would be my\n> idea.\n\nGood point. Maybe ENOTREG is acceptable too?\n\nRegards,\nDorjoy\n\n\n---\n\nOn Thu, Jan 29, 2026 at 4:49 PM Christian Brauner <brauner@kernel.org> wrote:\n>\n> On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:\n> > This flag indicates the path should be opened if it's a regular file.\n> > This is useful to write secure programs that want to avoid being tricked\n> > into opening device nodes with special semantics while thinking they\n> > operate on regular files.\n> >\n> > A corresponding error code ENOTREG has been introduced. For example, if\n> > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > will return -ENOTREG.\n> >\n> > When used in combination with O_CREAT, either the regular file is\n> > created, or if the path already exists, it is opened if it's a regular\n> > file. Otherwise, -ENOTREG is returned.\n> >\n> > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > is both a directory and a regular file.\n> >\n> > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > ---\n>\n> Yeah, we shouldn't add support for this outside of openat2(). We also\n> shouldn't call this OEXT_* or O2_*. Let's just follow the pattern where\n> we prefix the flag space with the name of the system call\n> OPENAT2_REGULAR.\n>\n\nThanks for the feedback. I agree that OPENAT2_REGULAR is better than\nthe other OEXT_*/O2_* options. Right now in the patch, the O_REGULAR\ntook the next slot in all the fcntl files. Should OPENAT2_REGULAR be a\nbit outside of the 32bits? That way it won't take any of the regular\nO_* bits and we would only need to define it in\ninclude/uapi/asm-generic/fcntl.h file and not need it in\narch/*/fcntl.h files. What do you think?\n\n> There's also no real need to make O_DIRECTORY exclusive with\n> OPENAT2_REGULAR. Callers could legimitately want to open a directory or\n> regular file but not anything else. If someone wants to operate on a\n> whole filesystem tree but only wants to interact with regular files and\n> directories and ignore devices, sockets, fifos etc it's very handy to\n> just be able to set both in flags.\n>\n> Frankly, this shouldn't be a flag at all but we already have O_DIRECTORY\n> in there so no need to move this into a new field.\n>\n> Add EFTYPE as the errno code. Some of the bsds including macos already\n> have that.\n\nGreat suggestion. Will fixup in v4 submission.\n\nRegards,\nDorjoy\n\n\n---\n\nOn Thu, Jan 29, 2026 at 11:03 PM Aleksa Sarai <cyphar@cyphar.com> wrote:\n>\n> On 2026-01-29, Christian Brauner <brauner@kernel.org> wrote:\n> > On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:\n> > > This flag indicates the path should be opened if it's a regular file.\n> > > This is useful to write secure programs that want to avoid being tricked\n> > > into opening device nodes with special semantics while thinking they\n> > > operate on regular files.\n> > >\n> > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > will return -ENOTREG.\n> > >\n> > > When used in combination with O_CREAT, either the regular file is\n> > > created, or if the path already exists, it is opened if it's a regular\n> > > file. Otherwise, -ENOTREG is returned.\n> > >\n> > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > is both a directory and a regular file.\n> > >\n> > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > ---\n> >\n> > Yeah, we shouldn't add support for this outside of openat2(). We also\n> > shouldn't call this OEXT_* or O2_*. Let's just follow the pattern where\n> > we prefix the flag space with the name of the system call\n> > OPENAT2_REGULAR.\n> >\n> > There's also no real need to make O_DIRECTORY exclusive with\n> > OPENAT2_REGULAR. Callers could legimitately want to open a directory or\n> > regular file but not anything else. If someone wants to operate on a\n> > whole filesystem tree but only wants to interact with regular files and\n> > directories and ignore devices, sockets, fifos etc it's very handy to\n> > just be able to set both in flags.\n> >\n> > Frankly, this shouldn't be a flag at all but we already have O_DIRECTORY\n> > in there so no need to move this into a new field.\n>\n> You could even say O_NOFOLLOW is kinda like that too.\n>\n> In my other mail I proposed a bitmask of S_IFMT to reject opening (which\n> would let you allow FIFOs and regular files but block devices, etc).\n> Unfortunately I forgot that S_IFBLK is S_IFCHR|S_IFDIR. This isn't fatal\n> to the idea but it kinda sucks. Grr.\n>\n\nIt is a good suggestion. I guess we can still introduce a new\nhow->sfmt_allow field and have new bits (instead of keeping in sync\nwith S_IF* ones) that allow types and just start with regular file\nallow bit for now, right? But I guess it would be cumbersome for users\nas an api to use different bits?\n\nRegards,\nDorjoy\n\n\n---\n\nOn Thu, Jan 29, 2026 at 7:12 PM Jeff Layton <jlayton@kernel.org> wrote:\n>\n> On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> > On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > >\n> > > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > > into opening device nodes with special semantics while thinking they\n> > > > > > operate on regular files.\n> > > > > >\n> > > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > > will return -ENOTREG.\n> > > > > >\n> > > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > >\n> > > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > > is both a directory and a regular file.\n> > > > > >\n> > > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > > ---\n> > > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > > >  fs/fcntl.c                                 | 2 +-\n> > > > > >  fs/namei.c                                 | 6 ++++++\n> > > > > >  fs/open.c                                  | 4 +++-\n> > > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > >\n> > > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > @@ -127,4 +127,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > @@ -34,6 +34,7 @@\n> > > > > >\n> > > > > >  #define O_PATH               040000000\n> > > > > >  #define __O_TMPFILE  0100000000\n> > > > > > +#define O_REGULAR    0200000000\n> > > > > >\n> > > > > >  #define F_GETLK              7\n> > > > > >  #define F_SETLK              8\n> > > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > > @@ -126,6 +126,8 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > +\n> > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > >\n> > > > > >\n> > > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > @@ -124,4 +124,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > @@ -19,6 +19,7 @@\n> > > > > >\n> > > > > >  #define O_PATH               020000000\n> > > > > >  #define __O_TMPFILE  040000000\n> > > > > > +#define O_REGULAR    0100000000\n> > > > > >\n> > > > > >  #define F_GETLK64    8\n> > > > > >  #define F_SETLK64    9\n> > > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > @@ -117,4 +117,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > @@ -37,6 +37,7 @@\n> > > > > >\n> > > > > >  #define O_PATH               0x1000000\n> > > > > >  #define __O_TMPFILE  0x2000000\n> > > > > > +#define O_REGULAR    0x4000000\n> > > > > >\n> > > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > > --- a/fs/fcntl.c\n> > > > > > +++ b/fs/fcntl.c\n> > > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > > >        */\n> > > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > >               HWEIGHT32(\n> > > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > > >                       __FMODE_EXEC));\n> > > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > > --- a/fs/namei.c\n> > > > > > +++ b/fs/namei.c\n> > > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > > >               if (unlikely(error))\n> > > > > >                       return error;\n> > > > > >       }\n> > > > > > +\n> > > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > > +             return -ENOTREG;\n> > > > > > +\n> > > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > > >               return -ENOTDIR;\n> > > > > >\n> > > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > > >       struct path path;\n> > > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > > >       if (!error) {\n> > > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > > +                     return -ENOTREG;\n> > > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > > >               error = vfs_open(&path, file);\n> > > > > >               path_put(&path);\n> > > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > > --- a/fs/open.c\n> > > > > > +++ b/fs/open.c\n> > > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > >\n> > > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > >\n> > > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > > >  {\n> > > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > > >                       return -EINVAL;\n> > > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > > >                       return -EINVAL;\n> > > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > > +             return -EINVAL;\n> > > > > >       }\n> > > > > >       if (flags & O_PATH) {\n> > > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > > --- a/include/linux/fcntl.h\n> > > > > > +++ b/include/linux/fcntl.h\n> > > > > > @@ -10,7 +10,7 @@\n> > > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > >\n> > > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > > @@ -122,4 +122,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > > index 613475285643..3468b352a575 100644\n> > > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > > @@ -88,6 +88,10 @@\n> > > > > >  #define __O_TMPFILE  020000000\n> > > > > >  #endif\n> > > > > >\n> > > > > > +#ifndef O_REGULAR\n> > > > > > +#define O_REGULAR    040000000\n> > > > > > +#endif\n> > > > > > +\n> > > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > >\n> > > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > @@ -127,4 +127,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > @@ -126,6 +126,8 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > +\n> > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > >\n> > > > > >\n> > > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > @@ -124,4 +124,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > @@ -117,4 +117,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > > @@ -122,4 +122,6 @@\n> > > > > >\n> > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > >\n> > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > >\n> > > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > > imagine most of the filesystems that provide that op can't support\n> > > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > > is add in some patches that make all of the atomic_open operations in\n> > > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > >\n> > > > > Then, once the basic support is in, you or someone else can go back and\n> > > > > implement support for O_REGULAR where possible.\n> > > >\n> > > > Thank you for the feedback. I don't quite understand what I need to\n> > > > fix. I thought open system calls always create regular files, so\n> > > > atomic_open probably always creates regular files? Can you please give\n> > > > me some more details as to where I need to fix this and what the\n> > > > actual bug here is that is related to atomic_open?  I think I had done\n> > > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > > doesn't exist, the file gets created and the file that gets created is\n> > > > a regular file, so it probably makes sense? Or should the behavior be\n> > > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > > is opened if regular, otherwise -ENOTREG is returned?\n> > > >\n> > >\n> > > atomic_open() is a combination lookup+open for when the dentry isn't\n> > > present in the dcache. The normal open codepath that you're patching\n> > > does not get called in this case when ->atomic_open is set for the\n> > > filesystem. It's mostly used by network filesystems that need to\n> > > optimize away the lookup since it's wasted round trip, and is often\n> > > racy anyway. Your patchset doesn't address those filesystems. They will\n> > > likely end up ignoring O_REGULAR in that case, which is not what you\n> > > want.\n> > >\n> > > What I was suggesting is that, as an interim step, you find all of the\n> > > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > > you or someone else can then go back and do a proper implementation of\n> > > O_REGULAR handling on those filesystems, at least on the ones where\n> > > it's possible. You will probably also need to similarly patch the\n> > > open() routines for those filesystems too. Otherwise you'll get\n> > > inconsistent behavior vs. when the dentry is in the cache.\n> > >\n> > > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > > call only works on files. We'll need to change how we handle errors\n> > > from the server when it's set though.\n> >\n> > So I think you're proposing two separate things or there's a typo:\n> >\n> > (1) blocking O_DIRECTORY for ->atomic_open::\n> > (2) blocking O_REGULAR for ->atomic_open::\n> >\n> > The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> > with atomic open for all filesystems.\n> >\n> > Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> > O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> > and completely broken before that.\n> >\n> > For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> > ->atomic_open:: to the filesystem.\n> >\n> > The worry that I see is that a network filesystem via ->atomic_open::\n> > somehow already called open on the server side on something that wasn't\n> > a directory. At that point the damage such as side-effects from device\n> > opening is already done.\n> >\n> >\n>\n> Exactly. I guess you could send an immediate close, but that's not\n> without side effects.\n>\n> >\n> > But I suspect that every filesystem implementing ->atomic_open:: just\n> > does finish_no_open() and punts to the VFS for the actual open. And the\n> > VFS will catch it in do_open() for it actually opens the file. So the\n> > only real worry for O_DIRECTORY I see is that there's an fs that handles\n> > it wrong.\n> >\n> > For (2) it is problematic as there surely are filesystems with\n> > ->atomic_open:: that do handle the ~O_CREAT case and return with\n> > FMODE_OPENED. So that'll be problematic if the intention is to not\n> > trigger an actual open on a non-regular file such as a\n> > device/socket/fifo etc. before the VFS had a chance to validate what's\n> > going on.\n> >\n> > So I'm not excited about having this 70% working and punting on\n> > ->atomic_open:: waiting for someone to fix this. One option would be to\n> > bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> > to racy and pricy lookup + open for now. How problematic would that be?\n> > If possible I'd prefer this a lot over merging something that works\n> > half-way.\n> >\n> > I guess to make that really work you'd need some protocol extension?\n>\n> For NFS, I think we're OK. The OPEN call on NFSv4 only works for\n> regular files, so it should be able to handle O_REGULAR. We just need\n> to rejigger the error handling when it's set (just return an error\n> instead of doing the open of a directory or whatever it is).\n>\n\nThank you for the details. Do you remember which codepath this is? Is\nthis the inode_operations.atomic_open codepath or file_operations.open\ncodepath? I am a bit confused also about where exactly the error\nhandling that needs to be done.\n\n> The others (at a quick glance):\n>\n> cifs: I don't see a way to specify an O_REGULAR equivalent to the\n> SMB2_CREATE call and it looks like it can create directories. Maybe\n> SteveF (cc'ed) knows if this is possible?\n>\n> ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\n> O_REGULAR can probably be supported similarly to NFS.\n>\n> fuse: probably ok? Does finish_no_open() in most cases. May depend on\n> the userland driver though.\n>\n> gfs2: is ok, it just does finish_no_open() in most cases anyway\n>\n> vboxsf: does finish_no_open on non-creates, so you could probably just\n> punt to that if O_REGULAR is set.\n>\n\nThese are all inode_operations.atomic_open code paths, right? Because\nyou mentioned finish_no_open and I see finish_no_open in the\natomic_open code paths as opposed to file_operations.open code paths.\n\nRegards,\nDorjoy\n\n\n---\n\nOn Thu, Feb 19, 2026 at 1:01 AM Jeff Layton <jlayton@kernel.org> wrote:\n>\n> On Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:\n> > On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton <jlayton@kernel.org> wrote:\n> > >\n> > > On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> > > > On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > > > > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > > > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > > > >\n> > > > > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > > > > into opening device nodes with special semantics while thinking they\n> > > > > > > > operate on regular files.\n> > > > > > > >\n> > > > > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > > > > will return -ENOTREG.\n> > > > > > > >\n> > > > > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > > > >\n> > > > > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > > > > is both a directory and a regular file.\n> > > > > > > >\n> > > > > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > > > > ---\n> > > > > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > > >  fs/fcntl.c                                 | 2 +-\n> > > > > > > >  fs/namei.c                                 | 6 ++++++\n> > > > > > > >  fs/open.c                                  | 4 +++-\n> > > > > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > > > >\n> > > > > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > @@ -34,6 +34,7 @@\n> > > > > > > >\n> > > > > > > >  #define O_PATH               040000000\n> > > > > > > >  #define __O_TMPFILE  0100000000\n> > > > > > > > +#define O_REGULAR    0200000000\n> > > > > > > >\n> > > > > > > >  #define F_GETLK              7\n> > > > > > > >  #define F_SETLK              8\n> > > > > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > >\n> > > > > > > >\n> > > > > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > @@ -19,6 +19,7 @@\n> > > > > > > >\n> > > > > > > >  #define O_PATH               020000000\n> > > > > > > >  #define __O_TMPFILE  040000000\n> > > > > > > > +#define O_REGULAR    0100000000\n> > > > > > > >\n> > > > > > > >  #define F_GETLK64    8\n> > > > > > > >  #define F_SETLK64    9\n> > > > > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > @@ -37,6 +37,7 @@\n> > > > > > > >\n> > > > > > > >  #define O_PATH               0x1000000\n> > > > > > > >  #define __O_TMPFILE  0x2000000\n> > > > > > > > +#define O_REGULAR    0x4000000\n> > > > > > > >\n> > > > > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > > > > --- a/fs/fcntl.c\n> > > > > > > > +++ b/fs/fcntl.c\n> > > > > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > > > > >        */\n> > > > > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > > >               HWEIGHT32(\n> > > > > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > > > > >                       __FMODE_EXEC));\n> > > > > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > > > > --- a/fs/namei.c\n> > > > > > > > +++ b/fs/namei.c\n> > > > > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > > > > >               if (unlikely(error))\n> > > > > > > >                       return error;\n> > > > > > > >       }\n> > > > > > > > +\n> > > > > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > > > > +             return -ENOTREG;\n> > > > > > > > +\n> > > > > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > > > > >               return -ENOTDIR;\n> > > > > > > >\n> > > > > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > > > > >       struct path path;\n> > > > > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > > > > >       if (!error) {\n> > > > > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > > > > +                     return -ENOTREG;\n> > > > > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > > > > >               error = vfs_open(&path, file);\n> > > > > > > >               path_put(&path);\n> > > > > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > > > > --- a/fs/open.c\n> > > > > > > > +++ b/fs/open.c\n> > > > > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > > > >\n> > > > > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > > > >\n> > > > > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > > > > >  {\n> > > > > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > > > > >                       return -EINVAL;\n> > > > > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > > > > >                       return -EINVAL;\n> > > > > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > > > > +             return -EINVAL;\n> > > > > > > >       }\n> > > > > > > >       if (flags & O_PATH) {\n> > > > > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > > > > --- a/include/linux/fcntl.h\n> > > > > > > > +++ b/include/linux/fcntl.h\n> > > > > > > > @@ -10,7 +10,7 @@\n> > > > > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > > > >\n> > > > > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > > > > index 613475285643..3468b352a575 100644\n> > > > > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > > > > @@ -88,6 +88,10 @@\n> > > > > > > >  #define __O_TMPFILE  020000000\n> > > > > > > >  #endif\n> > > > > > > >\n> > > > > > > > +#ifndef O_REGULAR\n> > > > > > > > +#define O_REGULAR    040000000\n> > > > > > > > +#endif\n> > > > > > > > +\n> > > > > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > > > >\n> > > > > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > >\n> > > > > > > >\n> > > > > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > >\n> > > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > >\n> > > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > > +\n> > > > > > > >  #endif\n> > > > > > >\n> > > > > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > > > > imagine most of the filesystems that provide that op can't support\n> > > > > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > > > > is add in some patches that make all of the atomic_open operations in\n> > > > > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > > > >\n> > > > > > > Then, once the basic support is in, you or someone else can go back and\n> > > > > > > implement support for O_REGULAR where possible.\n> > > > > >\n> > > > > > Thank you for the feedback. I don't quite understand what I need to\n> > > > > > fix. I thought open system calls always create regular files, so\n> > > > > > atomic_open probably always creates regular files? Can you please give\n> > > > > > me some more details as to where I need to fix this and what the\n> > > > > > actual bug here is that is related to atomic_open?  I think I had done\n> > > > > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > > > > doesn't exist, the file gets created and the file that gets created is\n> > > > > > a regular file, so it probably makes sense? Or should the behavior be\n> > > > > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > > > > is opened if regular, otherwise -ENOTREG is returned?\n> > > > > >\n> > > > >\n> > > > > atomic_open() is a combination lookup+open for when the dentry isn't\n> > > > > present in the dcache. The normal open codepath that you're patching\n> > > > > does not get called in this case when ->atomic_open is set for the\n> > > > > filesystem. It's mostly used by network filesystems that need to\n> > > > > optimize away the lookup since it's wasted round trip, and is often\n> > > > > racy anyway. Your patchset doesn't address those filesystems. They will\n> > > > > likely end up ignoring O_REGULAR in that case, which is not what you\n> > > > > want.\n> > > > >\n> > > > > What I was suggesting is that, as an interim step, you find all of the\n> > > > > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > > > > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > > > > you or someone else can then go back and do a proper implementation of\n> > > > > O_REGULAR handling on those filesystems, at least on the ones where\n> > > > > it's possible. You will probably also need to similarly patch the\n> > > > > open() routines for those filesystems too. Otherwise you'll get\n> > > > > inconsistent behavior vs. when the dentry is in the cache.\n> > > > >\n> > > > > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > > > > call only works on files. We'll need to change how we handle errors\n> > > > > from the server when it's set though.\n> > > >\n> > > > So I think you're proposing two separate things or there's a typo:\n> > > >\n> > > > (1) blocking O_DIRECTORY for ->atomic_open::\n> > > > (2) blocking O_REGULAR for ->atomic_open::\n> > > >\n> > > > The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> > > > with atomic open for all filesystems.\n> > > >\n> > > > Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> > > > O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> > > > and completely broken before that.\n> > > >\n> > > > For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> > > > ->atomic_open:: to the filesystem.\n> > > >\n> > > > The worry that I see is that a network filesystem via ->atomic_open::\n> > > > somehow already called open on the server side on something that wasn't\n> > > > a directory. At that point the damage such as side-effects from device\n> > > > opening is already done.\n> > > >\n> > > >\n> > >\n> > > Exactly. I guess you could send an immediate close, but that's not\n> > > without side effects.\n> > >\n> > > >\n> > > > But I suspect that every filesystem implementing ->atomic_open:: just\n> > > > does finish_no_open() and punts to the VFS for the actual open. And the\n> > > > VFS will catch it in do_open() for it actually opens the file. So the\n> > > > only real worry for O_DIRECTORY I see is that there's an fs that handles\n> > > > it wrong.\n> > > >\n> > > > For (2) it is problematic as there surely are filesystems with\n> > > > ->atomic_open:: that do handle the ~O_CREAT case and return with\n> > > > FMODE_OPENED. So that'll be problematic if the intention is to not\n> > > > trigger an actual open on a non-regular file such as a\n> > > > device/socket/fifo etc. before the VFS had a chance to validate what's\n> > > > going on.\n> > > >\n> > > > So I'm not excited about having this 70% working and punting on\n> > > > ->atomic_open:: waiting for someone to fix this. One option would be to\n> > > > bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> > > > to racy and pricy lookup + open for now. How problematic would that be?\n> > > > If possible I'd prefer this a lot over merging something that works\n> > > > half-way.\n> > > >\n> > > > I guess to make that really work you'd need some protocol extension?\n> > >\n> > > For NFS, I think we're OK. The OPEN call on NFSv4 only works for\n> > > regular files, so it should be able to handle O_REGULAR. We just need\n> > > to rejigger the error handling when it's set (just return an error\n> > > instead of doing the open of a directory or whatever it is).\n> > >\n> >\n> > Thank you for the details. Do you remember which codepath this is? Is\n> > this the inode_operations.atomic_open codepath or file_operations.open\n> > codepath? I am a bit confused also about where exactly the error\n> > handling that needs to be done.\n> >\n>\n> I was thinking nfs_atomic_open().\n>\n> Looking now, I think it might actually work OK without changes. It just\n> might not be terribly efficient about it.\n>\n> If the open_context() call returns -EISDIR or similar, then you really\n> don't need to do the call to nfs_lookup() and the like. You can just\n> return an immediate error when O_REGULAR is set since you know it's not\n> suitable to be opened.\n>\n\nRight. And I guess we don't need to worry about O_REGULAR being an\nunknown flag when it gets sent to the server (not only for NFS / but\nothers as well)?\n\n> > > The others (at a quick glance):\n> > >\n> > > cifs: I don't see a way to specify an O_REGULAR equivalent to the\n> > > SMB2_CREATE call and it looks like it can create directories. Maybe\n> > > SteveF (cc'ed) knows if this is possible?\n> > >\n> > > ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\n> > > O_REGULAR can probably be supported similarly to NFS.\n> > >\n> > > fuse: probably ok? Does finish_no_open() in most cases. May depend on\n> > > the userland driver though.\n> > >\n> > > gfs2: is ok, it just does finish_no_open() in most cases anyway\n> > >\n> > > vboxsf: does finish_no_open on non-creates, so you could probably just\n> > > punt to that if O_REGULAR is set.\n> > >\n> >\n> > These are all inode_operations.atomic_open code paths, right? Because\n> > you mentioned finish_no_open and I see finish_no_open in the\n> > atomic_open code paths as opposed to file_operations.open code paths.\n> >\n>\n> Note that this was just a cursory look. Someone will need to do a\n> deeper dive and test these cases.\n>\n> I think most will end up working ok, since most fall back to doing a\n> finish_no_open(). There may be opportunities to optimize some of these\n> cases though (similarly to how I mentioned with NFS).\n\nI can try to look into these and see if I can implement handling for\nO_REGULAR flag for these filesystems in the atomic_open code paths.\nThanks for the details.\n\nWill I need to modify the corresponding file_operations.open code\npaths as well along with atomic_open code paths?\n\nRegards,\nDorjoy\n\n\n---\n\nOn Thu, Feb 19, 2026 at 1:32 AM Jeff Layton <jlayton@kernel.org> wrote:\n>\n> On Thu, 2026-02-19 at 01:19 +0600, Dorjoy Chowdhury wrote:\n> > On Thu, Feb 19, 2026 at 1:01 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > >\n> > > On Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:\n> > > > On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > >\n> > > > > On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> > > > > > On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > > > > > > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > > > > > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > > > > > >\n> > > > > > > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > > > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > > > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > > > > > > into opening device nodes with special semantics while thinking they\n> > > > > > > > > > operate on regular files.\n> > > > > > > > > >\n> > > > > > > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > > > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > > > > > > will return -ENOTREG.\n> > > > > > > > > >\n> > > > > > > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > > > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > > > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > > > > > >\n> > > > > > > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > > > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > > > > > > is both a directory and a regular file.\n> > > > > > > > > >\n> > > > > > > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > > > > > > ---\n> > > > > > > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > > > > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > > > > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > > > > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > > > > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > > > > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > > > > >  fs/fcntl.c                                 | 2 +-\n> > > > > > > > > >  fs/namei.c                                 | 6 ++++++\n> > > > > > > > > >  fs/open.c                                  | 4 +++-\n> > > > > > > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > > > > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > > > > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > > > > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > > > > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > > > > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > > > > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > > > > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > > > > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > > > > > >\n> > > > > > > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > > > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > > > @@ -34,6 +34,7 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define O_PATH               040000000\n> > > > > > > > > >  #define __O_TMPFILE  0100000000\n> > > > > > > > > > +#define O_REGULAR    0200000000\n> > > > > > > > > >\n> > > > > > > > > >  #define F_GETLK              7\n> > > > > > > > > >  #define F_SETLK              8\n> > > > > > > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > > > >\n> > > > > > > > > >\n> > > > > > > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > > > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > > > @@ -19,6 +19,7 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define O_PATH               020000000\n> > > > > > > > > >  #define __O_TMPFILE  040000000\n> > > > > > > > > > +#define O_REGULAR    0100000000\n> > > > > > > > > >\n> > > > > > > > > >  #define F_GETLK64    8\n> > > > > > > > > >  #define F_SETLK64    9\n> > > > > > > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > > > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > > > @@ -37,6 +37,7 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define O_PATH               0x1000000\n> > > > > > > > > >  #define __O_TMPFILE  0x2000000\n> > > > > > > > > > +#define O_REGULAR    0x4000000\n> > > > > > > > > >\n> > > > > > > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > > > > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > > > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > > > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > > > > > > --- a/fs/fcntl.c\n> > > > > > > > > > +++ b/fs/fcntl.c\n> > > > > > > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > > > > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > > > > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > > > > > > >        */\n> > > > > > > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > > > > >               HWEIGHT32(\n> > > > > > > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > > > > > > >                       __FMODE_EXEC));\n> > > > > > > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > > > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > > > > > > --- a/fs/namei.c\n> > > > > > > > > > +++ b/fs/namei.c\n> > > > > > > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > > > > > > >               if (unlikely(error))\n> > > > > > > > > >                       return error;\n> > > > > > > > > >       }\n> > > > > > > > > > +\n> > > > > > > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > > > > > > +             return -ENOTREG;\n> > > > > > > > > > +\n> > > > > > > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > > > > > > >               return -ENOTDIR;\n> > > > > > > > > >\n> > > > > > > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > > > > > > >       struct path path;\n> > > > > > > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > > > > > > >       if (!error) {\n> > > > > > > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > > > > > > +                     return -ENOTREG;\n> > > > > > > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > > > > > > >               error = vfs_open(&path, file);\n> > > > > > > > > >               path_put(&path);\n> > > > > > > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > > > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > > > > > > --- a/fs/open.c\n> > > > > > > > > > +++ b/fs/open.c\n> > > > > > > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > > > > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > > > > > >\n> > > > > > > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > > > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > > > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > > > > > >\n> > > > > > > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > > > > > > >  {\n> > > > > > > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > > > > > > >                       return -EINVAL;\n> > > > > > > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > > > > > > >                       return -EINVAL;\n> > > > > > > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > > > > > > +             return -EINVAL;\n> > > > > > > > > >       }\n> > > > > > > > > >       if (flags & O_PATH) {\n> > > > > > > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > > > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > > > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > > > > > > --- a/include/linux/fcntl.h\n> > > > > > > > > > +++ b/include/linux/fcntl.h\n> > > > > > > > > > @@ -10,7 +10,7 @@\n> > > > > > > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > > > > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > > > > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > > > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > > > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > > > > > >\n> > > > > > > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > > > > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > > > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > > > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > > > > > > index 613475285643..3468b352a575 100644\n> > > > > > > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > > > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > > > > > > @@ -88,6 +88,10 @@\n> > > > > > > > > >  #define __O_TMPFILE  020000000\n> > > > > > > > > >  #endif\n> > > > > > > > > >\n> > > > > > > > > > +#ifndef O_REGULAR\n> > > > > > > > > > +#define O_REGULAR    040000000\n> > > > > > > > > > +#endif\n> > > > > > > > > > +\n> > > > > > > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > > > > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > > > > > >\n> > > > > > > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > > > >\n> > > > > > > > > >\n> > > > > > > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > > > >\n> > > > > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > > > >\n> > > > > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > > > > +\n> > > > > > > > > >  #endif\n> > > > > > > > >\n> > > > > > > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > > > > > > imagine most of the filesystems that provide that op can't support\n> > > > > > > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > > > > > > is add in some patches that make all of the atomic_open operations in\n> > > > > > > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > > > > > >\n> > > > > > > > > Then, once the basic support is in, you or someone else can go back and\n> > > > > > > > > implement support for O_REGULAR where possible.\n> > > > > > > >\n> > > > > > > > Thank you for the feedback. I don't quite understand what I need to\n> > > > > > > > fix. I thought open system calls always create regular files, so\n> > > > > > > > atomic_open probably always creates regular files? Can you please give\n> > > > > > > > me some more details as to where I need to fix this and what the\n> > > > > > > > actual bug here is that is related to atomic_open?  I think I had done\n> > > > > > > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > > > > > > doesn't exist, the file gets created and the file that gets created is\n> > > > > > > > a regular file, so it probably makes sense? Or should the behavior be\n> > > > > > > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > > > > > > is opened if regular, otherwise -ENOTREG is returned?\n> > > > > > > >\n> > > > > > >\n> > > > > > > atomic_open() is a combination lookup+open for when the dentry isn't\n> > > > > > > present in the dcache. The normal open codepath that you're patching\n> > > > > > > does not get called in this case when ->atomic_open is set for the\n> > > > > > > filesystem. It's mostly used by network filesystems that need to\n> > > > > > > optimize away the lookup since it's wasted round trip, and is often\n> > > > > > > racy anyway. Your patchset doesn't address those filesystems. They will\n> > > > > > > likely end up ignoring O_REGULAR in that case, which is not what you\n> > > > > > > want.\n> > > > > > >\n> > > > > > > What I was suggesting is that, as an interim step, you find all of the\n> > > > > > > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > > > > > > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > > > > > > you or someone else can then go back and do a proper implementation of\n> > > > > > > O_REGULAR handling on those filesystems, at least on the ones where\n> > > > > > > it's possible. You will probably also need to similarly patch the\n> > > > > > > open() routines for those filesystems too. Otherwise you'll get\n> > > > > > > inconsistent behavior vs. when the dentry is in the cache.\n> > > > > > >\n> > > > > > > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > > > > > > call only works on files. We'll need to change how we handle errors\n> > > > > > > from the server when it's set though.\n> > > > > >\n> > > > > > So I think you're proposing two separate things or there's a typo:\n> > > > > >\n> > > > > > (1) blocking O_DIRECTORY for ->atomic_open::\n> > > > > > (2) blocking O_REGULAR for ->atomic_open::\n> > > > > >\n> > > > > > The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> > > > > > with atomic open for all filesystems.\n> > > > > >\n> > > > > > Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> > > > > > O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> > > > > > and completely broken before that.\n> > > > > >\n> > > > > > For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> > > > > > ->atomic_open:: to the filesystem.\n> > > > > >\n> > > > > > The worry that I see is that a network filesystem via ->atomic_open::\n> > > > > > somehow already called open on the server side on something that wasn't\n> > > > > > a directory. At that point the damage such as side-effects from device\n> > > > > > opening is already done.\n> > > > > >\n> > > > > >\n> > > > >\n> > > > > Exactly. I guess you could send an immediate close, but that's not\n> > > > > without side effects.\n> > > > >\n> > > > > >\n> > > > > > But I suspect that every filesystem implementing ->atomic_open:: just\n> > > > > > does finish_no_open() and punts to the VFS for the actual open. And the\n> > > > > > VFS will catch it in do_open() for it actually opens the file. So the\n> > > > > > only real worry for O_DIRECTORY I see is that there's an fs that handles\n> > > > > > it wrong.\n> > > > > >\n> > > > > > For (2) it is problematic as there surely are filesystems with\n> > > > > > ->atomic_open:: that do handle the ~O_CREAT case and return with\n> > > > > > FMODE_OPENED. So that'll be problematic if the intention is to not\n> > > > > > trigger an actual open on a non-regular file such as a\n> > > > > > device/socket/fifo etc. before the VFS had a chance to validate what's\n> > > > > > going on.\n> > > > > >\n> > > > > > So I'm not excited about having this 70% working and punting on\n> > > > > > ->atomic_open:: waiting for someone to fix this. One option would be to\n> > > > > > bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> > > > > > to racy and pricy lookup + open for now. How problematic would that be?\n> > > > > > If possible I'd prefer this a lot over merging something that works\n> > > > > > half-way.\n> > > > > >\n> > > > > > I guess to make that really work you'd need some protocol extension?\n> > > > >\n> > > > > For NFS, I think we're OK. The OPEN call on NFSv4 only works for\n> > > > > regular files, so it should be able to handle O_REGULAR. We just need\n> > > > > to rejigger the error handling when it's set (just return an error\n> > > > > instead of doing the open of a directory or whatever it is).\n> > > > >\n> > > >\n> > > > Thank you for the details. Do you remember which codepath this is? Is\n> > > > this the inode_operations.atomic_open codepath or file_operations.open\n> > > > codepath? I am a bit confused also about where exactly the error\n> > > > handling that needs to be done.\n> > > >\n> > >\n> > > I was thinking nfs_atomic_open().\n> > >\n> > > Looking now, I think it might actually work OK without changes. It just\n> > > might not be terribly efficient about it.\n> > >\n> > > If the open_context() call returns -EISDIR or similar, then you really\n> > > don't need to do the call to nfs_lookup() and the like. You can just\n> > > return an immediate error when O_REGULAR is set since you know it's not\n> > > suitable to be opened.\n> > >\n> >\n> > Right. And I guess we don't need to worry about O_REGULAR being an\n> > unknown flag when it gets sent to the server (not only for NFS / but\n> > others as well)?\n> >\n>\n> You shouldn't. We don't send POSIX flags in NFSv4 requests. It has its\n> own set of flags. In the case of NFSv4, O_REGULAR is already implied in\n> an OPEN call on the wire. OPEN only operates on regular files.\n>\n\nAlright. Thanks for the details again!\n\n> > > > > The others (at a quick glance):\n> > > > >\n> > > > > cifs: I don't see a way to specify an O_REGULAR equivalent to the\n> > > > > SMB2_CREATE call and it looks like it can create directories. Maybe\n> > > > > SteveF (cc'ed) knows if this is possible?\n> > > > >\n> > > > > ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\n> > > > > O_REGULAR can probably be supported similarly to NFS.\n> > > > >\n> > > > > fuse: probably ok? Does finish_no_open() in most cases. May depend on\n> > > > > the userland driver though.\n> > > > >\n> > > > > gfs2: is ok, it just does finish_no_open() in most cases anyway\n> > > > >\n> > > > > vboxsf: does finish_no_open on non-creates, so you could probably just\n> > > > > punt to that if O_REGULAR is set.\n> > > > >\n> > > >\n> > > > These are all inode_operations.atomic_open code paths, right? Because\n> > > > you mentioned finish_no_open and I see finish_no_open in the\n> > > > atomic_open code paths as opposed to file_operations.open code paths.\n> > > >\n> > >\n> > > Note that this was just a cursory look. Someone will need to do a\n> > > deeper dive and test these cases.\n> > >\n> > > I think most will end up working ok, since most fall back to doing a\n> > > finish_no_open(). There may be opportunities to optimize some of these\n> > > cases though (similarly to how I mentioned with NFS).\n> >\n> > I can try to look into these and see if I can implement handling for\n> > O_REGULAR flag for these filesystems in the atomic_open code paths.\n> > Thanks for the details.\n> >\n> > Will I need to modify the corresponding file_operations.open code\n> > paths as well along with atomic_open code paths?\n> >\n>\n> Probably not.\n>\n> The main thing to keep in mind is that ->open is used when we already\n> have a dentry for the target of the open. ->atomic_open is used when we\n> don't have one yet or the one we have has failed revalidation.\n>\n> If you have a valid dentry, then you should be able to satisfy the\n> O_REGULAR check without having to call into ->open at all.\n\nUnderstood. Thanks!\n\nRegards,\nDorjoy\n\n",
          "reply_to": ""
        },
        {
          "author": "Aleksa Sarai",
          "summary": "The reviewer, Aleksa Sarai, raised concerns about the O_REGULAR flag's interaction with other flags and its potential impact on legacy open(2)/openat(2) behavior. They suggested including information about the UAPI group's request in the commit message and proposed a bitmask approach to reject opening certain types of files.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "potential issues"
          ],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On 2026-01-27, Dorjoy Chowdhury <dorjoychy111@gmail.com> wrote:\n> This flag indicates the path should be opened if it's a regular file.\n> This is useful to write secure programs that want to avoid being tricked\n> into opening device nodes with special semantics while thinking they\n> operate on regular files.\n> \n> A corresponding error code ENOTREG has been introduced. For example, if\n> open is called on path /dev/null with O_REGULAR in the flag param, it\n> will return -ENOTREG.\n> \n> When used in combination with O_CREAT, either the regular file is\n> created, or if the path already exists, it is opened if it's a regular\n> file. Otherwise, -ENOTREG is returned.\n> \n> -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> part of O_TMPFILE) because it doesn't make sense to open a path that\n> is both a directory and a regular file.\n\nAs you mention in your cover letter, this is something that the UAPI\ngroup has asked for in the past[1] and was even discussed at a recent\nLPC (maybe LPC 2024?) -- thanks for the patch!\n\nIn the next posting of this patchset, I would suggest including this\ninformation in the *commit message* with a link (commit messages end up\nin the git history, cover letters are a little harder to search for when\ndoing \"git blame\").\n\n[1]: https://uapi-group.org/kernel-features/#ability-to-only-open-regular-files\n\n>  #define WILL_CREATE(flags)\t(flags & (O_CREAT | __O_TMPFILE))\n> -#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> +#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n\nIt doesn't really make sense to use this flag with O_PATH -- O_PATH file\ndescriptors do not actually open the target inode and so there is no\nrisk to doing this.\n\nIn fact the method of safely opening files while avoiding device inodes\non Linux today is to open an O_PATH, then use fstat(2) to check whether\nit is a regular file, and then re-open the file descriptor through\n/proc/self/fd/$n. (This is totally race-safe.)\n\nMy main reason for pushing back against this it's really quite\npreferable to avoid expanding the set of O_* flags which work with\nO_PATH if they don't add much -- O_PATH has really unfortunate behaviour\nwith ignoring other flags and openat2(2) finally fixed that by blocking\nignored flag combinations.\n\n>  inline struct open_how build_open_how(int flags, umode_t mode)\n>  {\n> @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n>  \t\t\treturn -EINVAL;\n>  \t\tif (!(acc_mode & MAY_WRITE))\n>  \t\t\treturn -EINVAL;\n> +\t} else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> +\t\treturn -EINVAL;\n>  \t}\n>  \tif (flags & O_PATH) {\n>  \t\t/* O_PATH only permits certain other flags to be set. */\n> diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> index a332e79b3207..4fd07b0e0a17 100644\n> --- a/include/linux/fcntl.h\n> +++ b/include/linux/fcntl.h\n> @@ -10,7 +10,7 @@\n>  \t(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n>  \t O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n>  \t FASYNC\t| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> -\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> +\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n\nLegacy open(2)/openat(2) do not reject invalid flag arguments, which\nmeans that you cannot trivially add a new security-critical flag to them\nfor two reasons:\n\n * You cannot easily rely on them because old kernels will not return\n   -EINVAL, meaning you cannot be sure that the flag is supported. You\n   can try to test-run it, but the operation needs to be a non-dangerous\n   operation to try (and caching this has its own issues, such as with\n   programs that apply seccomp filters later).\n\n   To be fair, since you reject O_DIRECTORY|O_REGULAR there is a\n   relatively easy way to detect this, but the caveats about problems\n   with caching still apply.\n\n * Old programs might pass garbage bits that have been ignored thus far,\n   which means that making them have meaning can break userspace. Given\n   the age of open(2) this is a very hard thing to guarantee and is one\n   of many reasons I wrote openat2(2) and finally added proper flag\n   checking.\n\n   This is something your patch doesn't deal with and I don't think can\n   be done in a satisfactory way (because the behaviour relies on more\n   than just the arguments).\n\nFor reference, this is why O_TMPFILE includes O_DIRECTORY and requires\nan O_ACCMODE with write bits -- this combination will fail on old\nkernels, which allows you to rely on it and also guarantees that no\nexisting older programs passed that flag combination already and\nhappened to work on older kernels. This kind of trick won't work for\nO_REGULAR, unfortunately.\n\nIn my view, this should be an openat2(2)-only API. In addition, I would\npropose that (instead of burning another O_* flag bit for this as a\nspecial-purpose API just for regular files) you could have a mask of\nwhich S_IFMT bits should be rejected as a new field in \"struct\nopen_how\". This would let you reject sockets or device inodes but permit\nFIFOs and regular files or directories, for instance. This could even be\ndone without a new O_* flag at all (the zero-value how->sfmt_mask would\nallow everything and so would work well with extensible structs), but we\ncould add an O2_* flag anyway.\n\n> +#define ENOTREG\t\t134\t/* Not a regular file */\n> +\n\nWe are probably a little too reticent to add new errnos, but in this\ncase I think that there should be some description in the commit or\ncover letter about why a new errno is needed. ENXIO or\nEPROTONOSUPPORT/EPROTOTYPE is what you would typically use (yes, they\naren't a _perfect_ match but one of the common occurrences in syscall\ndesign is to read through errno(7) and figure out what errnos kind of\nfit what you need to express).\n\nThen to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind\nof justify the existence of ENOTREG too. Unfortunately, you won't be\nable to use ENOTREG if you go with my idea of having mask bits in\nopen_how... (And what errno should we use then...? Hm.)\n\n-- \nAleksa Sarai\nhttps://www.cyphar.com/\n\n\n---\n\nOn 2026-01-28, Mateusz Guzik <mjguzik@gmail.com> wrote:\n> On Wed, Jan 28, 2026 at 12:23:45AM +0100, Aleksa Sarai wrote:\n> > In my view, this should be an openat2(2)-only API.\n> \n> fwiw +1 from me, the O_ flag situation is already terrible even without\n> the validation woes.\n> \n> I find it most unfortunate the openat2 syscall reuses the O_ namespace.\n> For my taste it would be best closed for business, with all new flag\n> additions using a different space.\n\nWe don't have any openat2(2)-only O_* flags yet, I agree that new flag\nadditions (except for very rare cases where you can make them backward\ncompatible -- such as a hypothetical O_EMPTYPATH) should be O2_* or\nOEXT_* or something.\n\n> I can easily see people passing O_WHATEVER to open and openat by blindly\n> assuming they are supported just based on the name.\n\nYeah, if we don't do that it'll lead to confusion. openat2(2) has\nexclusive rights to the 64-bit flag bits so we could start with those\nbefore we need to cross with the O_* flag space.\n\n> that's a side mini-rant, too late to do anything here now\n> \n> > In addition, I would\n> > propose that (instead of burning another O_* flag bit for this as a\n> > special-purpose API just for regular files) you could have a mask of\n> > which S_IFMT bits should be rejected as a new field in \"struct\n> > open_how\". This would let you reject sockets or device inodes but permit\n> > FIFOs and regular files or directories, for instance. This could even be\n> > done without a new O_* flag at all (the zero-value how->sfmt_mask would\n> > allow everything and so would work well with extensible structs), but we\n> > could add an O2_* flag anyway.\n> \n> I don't think this works because the vars have overlapping bits:\n>   #define S_IFBLK  0060000\n>   #define S_IFDIR  0040000\n> \n> So you very much can't select what you want off of a bitmask.\n\nWell, you can filter on S_IFCHR if you want to block both block/char\ndevices, but yeah the overlap is quite unfortunate... (That would also\nmean blocking directories would also block S_IFBLK -- I remembered there\nwas an overlap but I forgot it coincided with S_IFDIR... Damn wacky\nAPIs.)\n\n> At best the field could be used to select the one type you are fine with.\n> \n> If one was to pursue the idea, some other defines with unique bits would\n> need to be provided. But even then, semantics should be to only *allow*\n> the bits you are fine with and reject the rest.\n> \n> But I'm not at all confident this is worth any effort -- with\n> O_DIRECTORY already being there and O_REGULAR proposed, is there a use\n> case which wants something else?\n\nThere's also O_NOFOLLOW in a similar vein.\n\nI can see someone wanting to permit FIFOs, regular files, and\ndirectories being fine but blocking everything else. None of O_REGULAR,\nO_DIRECTORY, nor O_NOFOLLOW provide that.\n\n> > > +#define ENOTREG\t\t134\t/* Not a regular file */\n> > > +\n> > \n> [..]\n> > Then to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind\n> > of justify the existence of ENOTREG too. Unfortunately, you won't be\n> > able to use ENOTREG if you go with my idea of having mask bits in\n> > open_how... (And what errno should we use then...? Hm.)\n> > \n> \n> The most useful behavior would indicate what was found (e.g., a pipe).\n> \n> The easiest way to do it would create errnos for all types (EISDIR\n> already exists for one), but I can't seriously propose that.\n\nIt might be kinda neat from a potential re-use perspective in other APIs\nbut yeah it would be quite wasteful to burn 3-5 errnos for this when we\nalready have ~4 that are logical inverses.\n\n> Going the other way, EBADTYPE or something else reusable would be my\n> idea.\n\nI think that would be reasonable and if you word the error message\ncarefully you can even see it being a fairly generic errno for other\nplaces to use.\n\n-- \nAleksa Sarai\nhttps://www.cyphar.com/\n\n\n---\n\nOn 2026-01-29, Christian Brauner <brauner@kernel.org> wrote:\n> On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:\n> > This flag indicates the path should be opened if it's a regular file.\n> > This is useful to write secure programs that want to avoid being tricked\n> > into opening device nodes with special semantics while thinking they\n> > operate on regular files.\n> > \n> > A corresponding error code ENOTREG has been introduced. For example, if\n> > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > will return -ENOTREG.\n> > \n> > When used in combination with O_CREAT, either the regular file is\n> > created, or if the path already exists, it is opened if it's a regular\n> > file. Otherwise, -ENOTREG is returned.\n> > \n> > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > is both a directory and a regular file.\n> > \n> > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > ---\n> \n> Yeah, we shouldn't add support for this outside of openat2(). We also\n> shouldn't call this OEXT_* or O2_*. Let's just follow the pattern where\n> we prefix the flag space with the name of the system call\n> OPENAT2_REGULAR.\n> \n> There's also no real need to make O_DIRECTORY exclusive with\n> OPENAT2_REGULAR. Callers could legimitately want to open a directory or\n> regular file but not anything else. If someone wants to operate on a\n> whole filesystem tree but only wants to interact with regular files and\n> directories and ignore devices, sockets, fifos etc it's very handy to\n> just be able to set both in flags.\n> \n> Frankly, this shouldn't be a flag at all but we already have O_DIRECTORY\n> in there so no need to move this into a new field.\n\nYou could even say O_NOFOLLOW is kinda like that too.\n\nIn my other mail I proposed a bitmask of S_IFMT to reject opening (which\nwould let you allow FIFOs and regular files but block devices, etc).\nUnfortunately I forgot that S_IFBLK is S_IFCHR|S_IFDIR. This isn't fatal\nto the idea but it kinda sucks. Grr.\n\n> Add EFTYPE as the errno code. Some of the bsds including macos already\n> have that.\n\n-- \nAleksa Sarai\nhttps://www.cyphar.com/\n",
          "reply_to": ""
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton raised concerns about handling of O_REGULAR flag in atomic_open operations, suggesting that most filesystems cannot support it properly and proposed adding patches to make all atomic_open operations return -EINVAL if O_REGULAR is set.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "proposed additional work"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> This flag indicates the path should be opened if it's a regular file.\n> This is useful to write secure programs that want to avoid being tricked\n> into opening device nodes with special semantics while thinking they\n> operate on regular files.\n> \n> A corresponding error code ENOTREG has been introduced. For example, if\n> open is called on path /dev/null with O_REGULAR in the flag param, it\n> will return -ENOTREG.\n> \n> When used in combination with O_CREAT, either the regular file is\n> created, or if the path already exists, it is opened if it's a regular\n> file. Otherwise, -ENOTREG is returned.\n> \n> -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> part of O_TMPFILE) because it doesn't make sense to open a path that\n> is both a directory and a regular file.\n> \n> Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> ---\n>  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n>  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n>  arch/mips/include/uapi/asm/errno.h         | 2 ++\n>  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n>  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n>  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n>  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n>  fs/fcntl.c                                 | 2 +-\n>  fs/namei.c                                 | 6 ++++++\n>  fs/open.c                                  | 4 +++-\n>  include/linux/fcntl.h                      | 2 +-\n>  include/uapi/asm-generic/errno.h           | 2 ++\n>  include/uapi/asm-generic/fcntl.h           | 4 ++++\n>  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n>  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n>  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n>  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n>  tools/include/uapi/asm-generic/errno.h     | 2 ++\n>  18 files changed, 38 insertions(+), 3 deletions(-)\n> \n> diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> index 6791f6508632..8bbcaa9024f9 100644\n> --- a/arch/alpha/include/uapi/asm/errno.h\n> +++ b/arch/alpha/include/uapi/asm/errno.h\n> @@ -127,4 +127,6 @@\n>  \n>  #define EHWPOISON\t139\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t140\t/* Not a regular file */\n> +\n>  #endif\n> diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> index 50bdc8e8a271..4da5a64c23bd 100644\n> --- a/arch/alpha/include/uapi/asm/fcntl.h\n> +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> @@ -34,6 +34,7 @@\n>  \n>  #define O_PATH\t\t040000000\n>  #define __O_TMPFILE\t0100000000\n> +#define O_REGULAR\t0200000000\n>  \n>  #define F_GETLK\t\t7\n>  #define F_SETLK\t\t8\n> diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> index c01ed91b1ef4..293c78777254 100644\n> --- a/arch/mips/include/uapi/asm/errno.h\n> +++ b/arch/mips/include/uapi/asm/errno.h\n> @@ -126,6 +126,8 @@\n>  \n>  #define EHWPOISON\t168\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t169\t/* Not a regular file */\n> +\n>  #define EDQUOT\t\t1133\t/* Quota exceeded */\n>  \n>  \n> diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> index 8cbc07c1903e..442917484f99 100644\n> --- a/arch/parisc/include/uapi/asm/errno.h\n> +++ b/arch/parisc/include/uapi/asm/errno.h\n> @@ -124,4 +124,6 @@\n>  \n>  #define EHWPOISON\t257\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t258\t/* Not a regular file */\n> +\n>  #endif\n> diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> index 03dee816cb13..0cc3320fe326 100644\n> --- a/arch/parisc/include/uapi/asm/fcntl.h\n> +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> @@ -19,6 +19,7 @@\n>  \n>  #define O_PATH\t\t020000000\n>  #define __O_TMPFILE\t040000000\n> +#define O_REGULAR\t0100000000\n>  \n>  #define F_GETLK64\t8\n>  #define F_SETLK64\t9\n> diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> index 4a41e7835fd5..8dce0bfeab74 100644\n> --- a/arch/sparc/include/uapi/asm/errno.h\n> +++ b/arch/sparc/include/uapi/asm/errno.h\n> @@ -117,4 +117,6 @@\n>  \n>  #define EHWPOISON\t135\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t136\t/* Not a regular file */\n> +\n>  #endif\n> diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> index 67dae75e5274..a93d18d2c23e 100644\n> --- a/arch/sparc/include/uapi/asm/fcntl.h\n> +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> @@ -37,6 +37,7 @@\n>  \n>  #define O_PATH\t\t0x1000000\n>  #define __O_TMPFILE\t0x2000000\n> +#define O_REGULAR\t0x4000000\n>  \n>  #define F_GETOWN\t5\t/*  for sockets. */\n>  #define F_SETOWN\t6\t/*  for sockets. */\n> diff --git a/fs/fcntl.c b/fs/fcntl.c\n> index f93dbca08435..62ab4ad2b6f5 100644\n> --- a/fs/fcntl.c\n> +++ b/fs/fcntl.c\n> @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n>  \t * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n>  \t * is defined as O_NONBLOCK on some platforms and not on others.\n>  \t */\n> -\tBUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> +\tBUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n>  \t\tHWEIGHT32(\n>  \t\t\t(VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n>  \t\t\t__FMODE_EXEC));\n> diff --git a/fs/namei.c b/fs/namei.c\n> index b28ecb699f32..f5504ae4b03c 100644\n> --- a/fs/namei.c\n> +++ b/fs/namei.c\n> @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n>  \t\tif (unlikely(error))\n>  \t\t\treturn error;\n>  \t}\n> +\n> +\tif ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> +\t\treturn -ENOTREG;\n> +\n>  \tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n>  \t\treturn -ENOTDIR;\n>  \n> @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n>  \tstruct path path;\n>  \tint error = path_lookupat(nd, flags, &path);\n>  \tif (!error) {\n> +\t\tif ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> +\t\t\treturn -ENOTREG;\n>  \t\taudit_inode(nd->name, path.dentry, 0);\n>  \t\terror = vfs_open(&path, file);\n>  \t\tpath_put(&path);\n> diff --git a/fs/open.c b/fs/open.c\n> index 74c4c1462b3e..82153e21907e 100644\n> --- a/fs/open.c\n> +++ b/fs/open.c\n> @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n>  EXPORT_SYMBOL_GPL(kernel_file_open);\n>  \n>  #define WILL_CREATE(flags)\t(flags & (O_CREAT | __O_TMPFILE))\n> -#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> +#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n>  \n>  inline struct open_how build_open_how(int flags, umode_t mode)\n>  {\n> @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n>  \t\t\treturn -EINVAL;\n>  \t\tif (!(acc_mode & MAY_WRITE))\n>  \t\t\treturn -EINVAL;\n> +\t} else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> +\t\treturn -EINVAL;\n>  \t}\n>  \tif (flags & O_PATH) {\n>  \t\t/* O_PATH only permits certain other flags to be set. */\n> diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> index a332e79b3207..4fd07b0e0a17 100644\n> --- a/include/linux/fcntl.h\n> +++ b/include/linux/fcntl.h\n> @@ -10,7 +10,7 @@\n>  \t(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n>  \t O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n>  \t FASYNC\t| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> -\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> +\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n>  \n>  /* List of all valid flags for the how->resolve argument: */\n>  #define VALID_RESOLVE_FLAGS \\\n> diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> index 92e7ae493ee3..2216ab9aa32e 100644\n> --- a/include/uapi/asm-generic/errno.h\n> +++ b/include/uapi/asm-generic/errno.h\n> @@ -122,4 +122,6 @@\n>  \n>  #define EHWPOISON\t133\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t134\t/* Not a regular file */\n> +\n>  #endif\n> diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> index 613475285643..3468b352a575 100644\n> --- a/include/uapi/asm-generic/fcntl.h\n> +++ b/include/uapi/asm-generic/fcntl.h\n> @@ -88,6 +88,10 @@\n>  #define __O_TMPFILE\t020000000\n>  #endif\n>  \n> +#ifndef O_REGULAR\n> +#define O_REGULAR\t040000000\n> +#endif\n> +\n>  /* a horrid kludge trying to make sure that this will fail on old kernels */\n>  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n>  \n> diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> index 6791f6508632..8bbcaa9024f9 100644\n> --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> @@ -127,4 +127,6 @@\n>  \n>  #define EHWPOISON\t139\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t140\t/* Not a regular file */\n> +\n>  #endif\n> diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> index c01ed91b1ef4..293c78777254 100644\n> --- a/tools/arch/mips/include/uapi/asm/errno.h\n> +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> @@ -126,6 +126,8 @@\n>  \n>  #define EHWPOISON\t168\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t169\t/* Not a regular file */\n> +\n>  #define EDQUOT\t\t1133\t/* Quota exceeded */\n>  \n>  \n> diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> index 8cbc07c1903e..442917484f99 100644\n> --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> @@ -124,4 +124,6 @@\n>  \n>  #define EHWPOISON\t257\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t258\t/* Not a regular file */\n> +\n>  #endif\n> diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> index 4a41e7835fd5..8dce0bfeab74 100644\n> --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> @@ -117,4 +117,6 @@\n>  \n>  #define EHWPOISON\t135\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t136\t/* Not a regular file */\n> +\n>  #endif\n> diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> index 92e7ae493ee3..2216ab9aa32e 100644\n> --- a/tools/include/uapi/asm-generic/errno.h\n> +++ b/tools/include/uapi/asm-generic/errno.h\n> @@ -122,4 +122,6 @@\n>  \n>  #define EHWPOISON\t133\t/* Memory page has hardware error */\n>  \n> +#define ENOTREG\t\t134\t/* Not a regular file */\n> +\n>  #endif\n\nOne thing this patch is missing is handling for ->atomic_open(). I\nimagine most of the filesystems that provide that op can't support\nO_REGULAR properly (maybe cifs can? idk). What you probably want to do\nis add in some patches that make all of the atomic_open operations in\nthe kernel return -EINVAL if O_REGULAR is set.\n\nThen, once the basic support is in, you or someone else can go back and\nimplement support for O_REGULAR where possible.\n-- \nJeff Layton <jlayton@kernel.org>\n\n\n---\n\nOn Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > \n> > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > This flag indicates the path should be opened if it's a regular file.\n> > > This is useful to write secure programs that want to avoid being tricked\n> > > into opening device nodes with special semantics while thinking they\n> > > operate on regular files.\n> > > \n> > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > will return -ENOTREG.\n> > > \n> > > When used in combination with O_CREAT, either the regular file is\n> > > created, or if the path already exists, it is opened if it's a regular\n> > > file. Otherwise, -ENOTREG is returned.\n> > > \n> > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > is both a directory and a regular file.\n> > > \n> > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > ---\n> > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > >  fs/fcntl.c                                 | 2 +-\n> > >  fs/namei.c                                 | 6 ++++++\n> > >  fs/open.c                                  | 4 +++-\n> > >  include/linux/fcntl.h                      | 2 +-\n> > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > \n> > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > index 6791f6508632..8bbcaa9024f9 100644\n> > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > @@ -127,4 +127,6 @@\n> > > \n> > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              140     /* Not a regular file */\n> > > +\n> > >  #endif\n> > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > @@ -34,6 +34,7 @@\n> > > \n> > >  #define O_PATH               040000000\n> > >  #define __O_TMPFILE  0100000000\n> > > +#define O_REGULAR    0200000000\n> > > \n> > >  #define F_GETLK              7\n> > >  #define F_SETLK              8\n> > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > index c01ed91b1ef4..293c78777254 100644\n> > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > @@ -126,6 +126,8 @@\n> > > \n> > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              169     /* Not a regular file */\n> > > +\n> > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > \n> > > \n> > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > index 8cbc07c1903e..442917484f99 100644\n> > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > @@ -124,4 +124,6 @@\n> > > \n> > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              258     /* Not a regular file */\n> > > +\n> > >  #endif\n> > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > index 03dee816cb13..0cc3320fe326 100644\n> > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > @@ -19,6 +19,7 @@\n> > > \n> > >  #define O_PATH               020000000\n> > >  #define __O_TMPFILE  040000000\n> > > +#define O_REGULAR    0100000000\n> > > \n> > >  #define F_GETLK64    8\n> > >  #define F_SETLK64    9\n> > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > @@ -117,4 +117,6 @@\n> > > \n> > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              136     /* Not a regular file */\n> > > +\n> > >  #endif\n> > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > index 67dae75e5274..a93d18d2c23e 100644\n> > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > @@ -37,6 +37,7 @@\n> > > \n> > >  #define O_PATH               0x1000000\n> > >  #define __O_TMPFILE  0x2000000\n> > > +#define O_REGULAR    0x4000000\n> > > \n> > >  #define F_GETOWN     5       /*  for sockets. */\n> > >  #define F_SETOWN     6       /*  for sockets. */\n> > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > --- a/fs/fcntl.c\n> > > +++ b/fs/fcntl.c\n> > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > >        */\n> > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > >               HWEIGHT32(\n> > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > >                       __FMODE_EXEC));\n> > > diff --git a/fs/namei.c b/fs/namei.c\n> > > index b28ecb699f32..f5504ae4b03c 100644\n> > > --- a/fs/namei.c\n> > > +++ b/fs/namei.c\n> > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > >               if (unlikely(error))\n> > >                       return error;\n> > >       }\n> > > +\n> > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > +             return -ENOTREG;\n> > > +\n> > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > >               return -ENOTDIR;\n> > > \n> > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > >       struct path path;\n> > >       int error = path_lookupat(nd, flags, &path);\n> > >       if (!error) {\n> > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > +                     return -ENOTREG;\n> > >               audit_inode(nd->name, path.dentry, 0);\n> > >               error = vfs_open(&path, file);\n> > >               path_put(&path);\n> > > diff --git a/fs/open.c b/fs/open.c\n> > > index 74c4c1462b3e..82153e21907e 100644\n> > > --- a/fs/open.c\n> > > +++ b/fs/open.c\n> > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > \n> > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > \n> > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > >  {\n> > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > >                       return -EINVAL;\n> > >               if (!(acc_mode & MAY_WRITE))\n> > >                       return -EINVAL;\n> > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > +             return -EINVAL;\n> > >       }\n> > >       if (flags & O_PATH) {\n> > >               /* O_PATH only permits certain other flags to be set. */\n> > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > index a332e79b3207..4fd07b0e0a17 100644\n> > > --- a/include/linux/fcntl.h\n> > > +++ b/include/linux/fcntl.h\n> > > @@ -10,7 +10,7 @@\n> > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > \n> > >  /* List of all valid flags for the how->resolve argument: */\n> > >  #define VALID_RESOLVE_FLAGS \\\n> > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > --- a/include/uapi/asm-generic/errno.h\n> > > +++ b/include/uapi/asm-generic/errno.h\n> > > @@ -122,4 +122,6 @@\n> > > \n> > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              134     /* Not a regular file */\n> > > +\n> > >  #endif\n> > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > index 613475285643..3468b352a575 100644\n> > > --- a/include/uapi/asm-generic/fcntl.h\n> > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > @@ -88,6 +88,10 @@\n> > >  #define __O_TMPFILE  020000000\n> > >  #endif\n> > > \n> > > +#ifndef O_REGULAR\n> > > +#define O_REGULAR    040000000\n> > > +#endif\n> > > +\n> > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > \n> > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > index 6791f6508632..8bbcaa9024f9 100644\n> > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > @@ -127,4 +127,6 @@\n> > > \n> > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              140     /* Not a regular file */\n> > > +\n> > >  #endif\n> > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > index c01ed91b1ef4..293c78777254 100644\n> > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > @@ -126,6 +126,8 @@\n> > > \n> > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              169     /* Not a regular file */\n> > > +\n> > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > \n> > > \n> > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > index 8cbc07c1903e..442917484f99 100644\n> > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > @@ -124,4 +124,6 @@\n> > > \n> > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              258     /* Not a regular file */\n> > > +\n> > >  #endif\n> > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > @@ -117,4 +117,6 @@\n> > > \n> > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              136     /* Not a regular file */\n> > > +\n> > >  #endif\n> > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > @@ -122,4 +122,6 @@\n> > > \n> > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > \n> > > +#define ENOTREG              134     /* Not a regular file */\n> > > +\n> > >  #endif\n> > \n> > One thing this patch is missing is handling for ->atomic_open(). I\n> > imagine most of the filesystems that provide that op can't support\n> > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > is add in some patches that make all of the atomic_open operations in\n> > the kernel return -EINVAL if O_REGULAR is set.\n> > \n> > Then, once the basic support is in, you or someone else can go back and\n> > implement support for O_REGULAR where possible.\n> \n> Thank you for the feedback. I don't quite understand what I need to\n> fix. I thought open system calls always create regular files, so\n> atomic_open probably always creates regular files? Can you please give\n> me some more details as to where I need to fix this and what the\n> actual bug here is that is related to atomic_open?  I think I had done\n> some normal testing and when using O_CREAT | O_REGULAR, if the file\n> doesn't exist, the file gets created and the file that gets created is\n> a regular file, so it probably makes sense? Or should the behavior be\n> that if file doesn't exist, -EINVAL is returned and if file exists it\n> is opened if regular, otherwise -ENOTREG is returned?\n> \n\natomic_open() is a combination lookup+open for when the dentry isn't\npresent in the dcache. The normal open codepath that you're patching\ndoes not get called in this case when ->atomic_open is set for the\nfilesystem. It's mostly used by network filesystems that need to\noptimize away the lookup since it's wasted round trip, and is often\nracy anyway. Your patchset doesn't address those filesystems. They will\nlikely end up ignoring O_REGULAR in that case, which is not what you\nwant.\n\nWhat I was suggesting is that, as an interim step, you find all of the\natomic_open operations in the kernel (there are maybe a dozen or so),\nand just make them return -EINVAL if someone sets O_DIRECTORY. Later,\nyou or someone else can then go back and do a proper implementation of\nO_REGULAR handling on those filesystems, at least on the ones where\nit's possible. You will probably also need to similarly patch the\nopen() routines for those filesystems too. Otherwise you'll get\ninconsistent behavior vs. when the dentry is in the cache.\n\nOne note: I think NFS probably can support O_DIRECTORY, since its OPEN\ncall only works on files. We'll need to change how we handle errors\nfrom the server when it's set though.\n-- \nJeff Layton <jlayton@kernel.org>\n\n\n---\n\nOn Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > \n> > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > into opening device nodes with special semantics while thinking they\n> > > > > operate on regular files.\n> > > > > \n> > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > will return -ENOTREG.\n> > > > > \n> > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > \n> > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > is both a directory and a regular file.\n> > > > > \n> > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > ---\n> > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > >  fs/fcntl.c                                 | 2 +-\n> > > > >  fs/namei.c                                 | 6 ++++++\n> > > > >  fs/open.c                                  | 4 +++-\n> > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > \n> > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > @@ -127,4 +127,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > @@ -34,6 +34,7 @@\n> > > > > \n> > > > >  #define O_PATH               040000000\n> > > > >  #define __O_TMPFILE  0100000000\n> > > > > +#define O_REGULAR    0200000000\n> > > > > \n> > > > >  #define F_GETLK              7\n> > > > >  #define F_SETLK              8\n> > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > @@ -126,6 +126,8 @@\n> > > > > \n> > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > +\n> > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > \n> > > > > \n> > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > @@ -124,4 +124,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > @@ -19,6 +19,7 @@\n> > > > > \n> > > > >  #define O_PATH               020000000\n> > > > >  #define __O_TMPFILE  040000000\n> > > > > +#define O_REGULAR    0100000000\n> > > > > \n> > > > >  #define F_GETLK64    8\n> > > > >  #define F_SETLK64    9\n> > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > @@ -117,4 +117,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > @@ -37,6 +37,7 @@\n> > > > > \n> > > > >  #define O_PATH               0x1000000\n> > > > >  #define __O_TMPFILE  0x2000000\n> > > > > +#define O_REGULAR    0x4000000\n> > > > > \n> > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > --- a/fs/fcntl.c\n> > > > > +++ b/fs/fcntl.c\n> > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > >        */\n> > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > >               HWEIGHT32(\n> > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > >                       __FMODE_EXEC));\n> > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > --- a/fs/namei.c\n> > > > > +++ b/fs/namei.c\n> > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > >               if (unlikely(error))\n> > > > >                       return error;\n> > > > >       }\n> > > > > +\n> > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > +             return -ENOTREG;\n> > > > > +\n> > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > >               return -ENOTDIR;\n> > > > > \n> > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > >       struct path path;\n> > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > >       if (!error) {\n> > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > +                     return -ENOTREG;\n> > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > >               error = vfs_open(&path, file);\n> > > > >               path_put(&path);\n> > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > --- a/fs/open.c\n> > > > > +++ b/fs/open.c\n> > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > \n> > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > \n> > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > >  {\n> > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > >                       return -EINVAL;\n> > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > >                       return -EINVAL;\n> > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > +             return -EINVAL;\n> > > > >       }\n> > > > >       if (flags & O_PATH) {\n> > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > --- a/include/linux/fcntl.h\n> > > > > +++ b/include/linux/fcntl.h\n> > > > > @@ -10,7 +10,7 @@\n> > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > \n> > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > @@ -122,4 +122,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > index 613475285643..3468b352a575 100644\n> > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > @@ -88,6 +88,10 @@\n> > > > >  #define __O_TMPFILE  020000000\n> > > > >  #endif\n> > > > > \n> > > > > +#ifndef O_REGULAR\n> > > > > +#define O_REGULAR    040000000\n> > > > > +#endif\n> > > > > +\n> > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > \n> > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > @@ -127,4 +127,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > @@ -126,6 +126,8 @@\n> > > > > \n> > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > +\n> > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > \n> > > > > \n> > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > @@ -124,4 +124,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > @@ -117,4 +117,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > @@ -122,4 +122,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > \n> > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > imagine most of the filesystems that provide that op can't support\n> > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > is add in some patches that make all of the atomic_open operations in\n> > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > \n> > > > Then, once the basic support is in, you or someone else can go back and\n> > > > implement support for O_REGULAR where possible.\n> > > \n> > > Thank you for the feedback. I don't quite understand what I need to\n> > > fix. I thought open system calls always create regular files, so\n> > > atomic_open probably always creates regular files? Can you please give\n> > > me some more details as to where I need to fix this and what the\n> > > actual bug here is that is related to atomic_open?  I think I had done\n> > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > doesn't exist, the file gets created and the file that gets created is\n> > > a regular file, so it probably makes sense? Or should the behavior be\n> > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > is opened if regular, otherwise -ENOTREG is returned?\n> > > \n> > \n> > atomic_open() is a combination lookup+open for when the dentry isn't\n> > present in the dcache. The normal open codepath that you're patching\n> > does not get called in this case when ->atomic_open is set for the\n> > filesystem. It's mostly used by network filesystems that need to\n> > optimize away the lookup since it's wasted round trip, and is often\n> > racy anyway. Your patchset doesn't address those filesystems. They will\n> > likely end up ignoring O_REGULAR in that case, which is not what you\n> > want.\n> > \n> > What I was suggesting is that, as an interim step, you find all of the\n> > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > you or someone else can then go back and do a proper implementation of\n> > O_REGULAR handling on those filesystems, at least on the ones where\n> > it's possible. You will probably also need to similarly patch the\n> > open() routines for those filesystems too. Otherwise you'll get\n> > inconsistent behavior vs. when the dentry is in the cache.\n> > \n> > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > call only works on files. We'll need to change how we handle errors\n> > from the server when it's set though.\n> \n> So I think you're proposing two separate things or there's a typo:\n> \n> (1) blocking O_DIRECTORY for ->atomic_open::\n> (2) blocking O_REGULAR for ->atomic_open::\n> \n> The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> with atomic open for all filesystems.\n> \n> Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> and completely broken before that.\n> \n> For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> ->atomic_open:: to the filesystem.\n> \n> The worry that I see is that a network filesystem via ->atomic_open::\n> somehow already called open on the server side on something that wasn't\n> a directory. At that point the damage such as side-effects from device\n> opening is already done.\n>                           \n> \n\nExactly. I guess you could send an immediate close, but that's not\nwithout side effects.\n\n>           \n> But I suspect that every filesystem implementing ->atomic_open:: just\n> does finish_no_open() and punts to the VFS for the actual open. And the\n> VFS will catch it in do_open() for it actually opens the file. So the\n> only real worry for O_DIRECTORY I see is that there's an fs that handles\n> it wrong.\n> \n> For (2) it is problematic as there surely are filesystems with\n> ->atomic_open:: that do handle the ~O_CREAT case and return with\n> FMODE_OPENED. So that'll be problematic if the intention is to not\n> trigger an actual open on a non-regular file such as a\n> device/socket/fifo etc. before the VFS had a chance to validate what's\n> going on.\n> \n> So I'm not excited about having this 70% working and punting on\n> ->atomic_open:: waiting for someone to fix this. One option would be to\n> bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> to racy and pricy lookup + open for now. How problematic would that be?\n> If possible I'd prefer this a lot over merging something that works\n> half-way.\n> \n> I guess to make that really work you'd need some protocol extension?\n\nFor NFS, I think we're OK. The OPEN call on NFSv4 only works for\nregular files, so it should be able to handle O_REGULAR. We just need\nto rejigger the error handling when it's set (just return an error\ninstead of doing the open of a directory or whatever it is).\n\nThe others (at a quick glance):\n\ncifs: I don't see a way to specify an O_REGULAR equivalent to the\nSMB2_CREATE call and it looks like it can create directories. Maybe\nSteveF (cc'ed) knows if this is possible?\n\nceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\nO_REGULAR can probably be supported similarly to NFS.\n\nfuse: probably ok? Does finish_no_open() in most cases. May depend on\nthe userland driver though.\n\ngfs2: is ok, it just does finish_no_open() in most cases anyway\n\nvboxsf: does finish_no_open on non-creates, so you could probably just\npunt to that if O_REGULAR is set.\n\nSo, it's probably possible to do this across the board. I'm not sure\nabout cifs though.\n-- \nJeff Layton <jlayton@kernel.org>\n\n\n---\n\nOn Thu, 2026-01-29 at 08:12 -0500, Jeff Layton wrote:\n> On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> > On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > > \n> > > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > > into opening device nodes with special semantics while thinking they\n> > > > > > operate on regular files.\n> > > > > > \n> > > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > > will return -ENOTREG.\n> > > > > > \n> > > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > > \n> > > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > > is both a directory and a regular file.\n> > > > > > \n> > > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > > ---\n> > > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > > >  fs/fcntl.c                                 | 2 +-\n> > > > > >  fs/namei.c                                 | 6 ++++++\n> > > > > >  fs/open.c                                  | 4 +++-\n> > > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > > \n> > > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > @@ -127,4 +127,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > @@ -34,6 +34,7 @@\n> > > > > > \n> > > > > >  #define O_PATH               040000000\n> > > > > >  #define __O_TMPFILE  0100000000\n> > > > > > +#define O_REGULAR    0200000000\n> > > > > > \n> > > > > >  #define F_GETLK              7\n> > > > > >  #define F_SETLK              8\n> > > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > > @@ -126,6 +126,8 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > +\n> > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > \n> > > > > > \n> > > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > @@ -124,4 +124,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > @@ -19,6 +19,7 @@\n> > > > > > \n> > > > > >  #define O_PATH               020000000\n> > > > > >  #define __O_TMPFILE  040000000\n> > > > > > +#define O_REGULAR    0100000000\n> > > > > > \n> > > > > >  #define F_GETLK64    8\n> > > > > >  #define F_SETLK64    9\n> > > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > @@ -117,4 +117,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > @@ -37,6 +37,7 @@\n> > > > > > \n> > > > > >  #define O_PATH               0x1000000\n> > > > > >  #define __O_TMPFILE  0x2000000\n> > > > > > +#define O_REGULAR    0x4000000\n> > > > > > \n> > > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > > --- a/fs/fcntl.c\n> > > > > > +++ b/fs/fcntl.c\n> > > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > > >        */\n> > > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > >               HWEIGHT32(\n> > > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > > >                       __FMODE_EXEC));\n> > > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > > --- a/fs/namei.c\n> > > > > > +++ b/fs/namei.c\n> > > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > > >               if (unlikely(error))\n> > > > > >                       return error;\n> > > > > >       }\n> > > > > > +\n> > > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > > +             return -ENOTREG;\n> > > > > > +\n> > > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > > >               return -ENOTDIR;\n> > > > > > \n> > > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > > >       struct path path;\n> > > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > > >       if (!error) {\n> > > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > > +                     return -ENOTREG;\n> > > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > > >               error = vfs_open(&path, file);\n> > > > > >               path_put(&path);\n> > > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > > --- a/fs/open.c\n> > > > > > +++ b/fs/open.c\n> > > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > > \n> > > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > > \n> > > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > > >  {\n> > > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > > >                       return -EINVAL;\n> > > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > > >                       return -EINVAL;\n> > > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > > +             return -EINVAL;\n> > > > > >       }\n> > > > > >       if (flags & O_PATH) {\n> > > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > > --- a/include/linux/fcntl.h\n> > > > > > +++ b/include/linux/fcntl.h\n> > > > > > @@ -10,7 +10,7 @@\n> > > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > > \n> > > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > > @@ -122,4 +122,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > > index 613475285643..3468b352a575 100644\n> > > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > > @@ -88,6 +88,10 @@\n> > > > > >  #define __O_TMPFILE  020000000\n> > > > > >  #endif\n> > > > > > \n> > > > > > +#ifndef O_REGULAR\n> > > > > > +#define O_REGULAR    040000000\n> > > > > > +#endif\n> > > > > > +\n> > > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > > \n> > > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > @@ -127,4 +127,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > @@ -126,6 +126,8 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > +\n> > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > \n> > > > > > \n> > > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > @@ -124,4 +124,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > @@ -117,4 +117,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > > @@ -122,4 +122,6 @@\n> > > > > > \n> > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > \n> > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > +\n> > > > > >  #endif\n> > > > > \n> > > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > > imagine most of the filesystems that provide that op can't support\n> > > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > > is add in some patches that make all of the atomic_open operations in\n> > > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > > \n> > > > > Then, once the basic support is in, you or someone else can go back and\n> > > > > implement support for O_REGULAR where possible.\n> > > > \n> > > > Thank you for the feedback. I don't quite understand what I need to\n> > > > fix. I thought open system calls always create regular files, so\n> > > > atomic_open probably always creates regular files? Can you please give\n> > > > me some more details as to where I need to fix this and what the\n> > > > actual bug here is that is related to atomic_open?  I think I had done\n> > > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > > doesn't exist, the file gets created and the file that gets created is\n> > > > a regular file, so it probably makes sense? Or should the behavior be\n> > > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > > is opened if regular, otherwise -ENOTREG is returned?\n> > > > \n> > > \n> > > atomic_open() is a combination lookup+open for when the dentry isn't\n> > > present in the dcache. The normal open codepath that you're patching\n> > > does not get called in this case when ->atomic_open is set for the\n> > > filesystem. It's mostly used by network filesystems that need to\n> > > optimize away the lookup since it's wasted round trip, and is often\n> > > racy anyway. Your patchset doesn't address those filesystems. They will\n> > > likely end up ignoring O_REGULAR in that case, which is not what you\n> > > want.\n> > > \n> > > What I was suggesting is that, as an interim step, you find all of the\n> > > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > > you or someone else can then go back and do a proper implementation of\n> > > O_REGULAR handling on those filesystems, at least on the ones where\n> > > it's possible. You will probably also need to similarly patch the\n> > > open() routines for those filesystems too. Otherwise you'll get\n> > > inconsistent behavior vs. when the dentry is in the cache.\n> > > \n> > > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > > call only works on files. We'll need to change how we handle errors\n> > > from the server when it's set though.\n> > \n> > So I think you're proposing two separate things or there's a typo:\n> > \n> > (1) blocking O_DIRECTORY for ->atomic_open::\n> > (2) blocking O_REGULAR for ->atomic_open::\n> > \n> > The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> > with atomic open for all filesystems.\n> > \n> > Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> > O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> > and completely broken before that.\n> > \n> > For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> > ->atomic_open:: to the filesystem.\n> > \n> > The worry that I see is that a network filesystem via ->atomic_open::\n> > somehow already called open on the server side on something that wasn't\n> > a directory. At that point the damage such as side-effects from device\n> > opening is already done.\n> >                           \n> > \n> \n> Exactly. I guess you could send an immediate close, but that's not\n> without side effects.\n> \n> >           \n> > But I suspect that every filesystem implementing ->atomic_open:: just\n> > does finish_no_open() and punts to the VFS for the actual open. And the\n> > VFS will catch it in do_open() for it actually opens the file. So the\n> > only real worry for O_DIRECTORY I see is that there's an fs that handles\n> > it wrong.\n> > \n> > For (2) it is problematic as there surely are filesystems with\n> > ->atomic_open:: that do handle the ~O_CREAT case and return with\n> > FMODE_OPENED. So that'll be problematic if the intention is to not\n> > trigger an actual open on a non-regular file such as a\n> > device/socket/fifo etc. before the VFS had a chance to validate what's\n> > going on.\n> > \n> > So I'm not excited about having this 70% working and punting on\n> > ->atomic_open:: waiting for someone to fix this. One option would be to\n> > bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> > to racy and pricy lookup + open for now. How problematic would that be?\n> > If possible I'd prefer this a lot over merging something that works\n> > half-way.\n> > \n> > I guess to make that really work you'd need some protocol extension?\n> \n> For NFS, I think we're OK. The OPEN call on NFSv4 only works for\n> regular files, so it should be able to handle O_REGULAR. We just need\n> to rejigger the error handling when it's set (just return an error\n> instead of doing the open of a directory or whatever it is).\n> \n> The others (at a quick glance):\n> \n> cifs: I don't see a way to specify an O_REGULAR equivalent to the\n> SMB2_CREATE call and it looks like it can create directories. Maybe\n> SteveF (cc'ed) knows if this is possible?\n> \n\nSMB2 does have this flag:\n\nFILE_NON_DIRECTORY_FILE 0x00000040\n\nIf the name of the file being created or opened matches with an\nexisting directory file, the server MUST fail the request with\nSTATUS_FILE_IS_A_DIRECTORY. This flag MUST NOT be used with\nFILE_DIRECTORY_FILE or the server MUST fail the request with\nSTATUS_INVALID_PARAMETER.\n\nSMB2 can also present named pipes and printer files. Not sure if there\nis a way to exclude those with this.\n\n> ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\n> O_REGULAR can probably be supported similarly to NFS.\n> \n\nActually I'm wrong here. That op can open a directory. We'll need\nsomeone to look at the MDS code and tell us whether this can be done in\na non-racy way.\n\n> fuse: probably ok? Does finish_no_open() in most cases. May depend on\n> the userland driver though.\n> \n> gfs2: is ok, it just does finish_no_open() in most cases anyway\n> \n> vboxsf: does finish_no_open on non-creates, so you could probably just\n> punt to that if O_REGULAR is set.\n> \n> So, it's probably possible to do this across the board. I'm not sure\n> about cifs though.\n\n-- \nJeff Layton <jlayton@kernel.org>\n\n\n---\n\nOn Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > \n> > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > into opening device nodes with special semantics while thinking they\n> > > > > operate on regular files.\n> > > > > \n> > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > will return -ENOTREG.\n> > > > > \n> > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > \n> > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > is both a directory and a regular file.\n> > > > > \n> > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > ---\n> > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > >  fs/fcntl.c                                 | 2 +-\n> > > > >  fs/namei.c                                 | 6 ++++++\n> > > > >  fs/open.c                                  | 4 +++-\n> > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > \n> > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > @@ -127,4 +127,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > @@ -34,6 +34,7 @@\n> > > > > \n> > > > >  #define O_PATH               040000000\n> > > > >  #define __O_TMPFILE  0100000000\n> > > > > +#define O_REGULAR    0200000000\n> > > > > \n> > > > >  #define F_GETLK              7\n> > > > >  #define F_SETLK              8\n> > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > @@ -126,6 +126,8 @@\n> > > > > \n> > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > +\n> > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > \n> > > > > \n> > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > @@ -124,4 +124,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > @@ -19,6 +19,7 @@\n> > > > > \n> > > > >  #define O_PATH               020000000\n> > > > >  #define __O_TMPFILE  040000000\n> > > > > +#define O_REGULAR    0100000000\n> > > > > \n> > > > >  #define F_GETLK64    8\n> > > > >  #define F_SETLK64    9\n> > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > @@ -117,4 +117,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > @@ -37,6 +37,7 @@\n> > > > > \n> > > > >  #define O_PATH               0x1000000\n> > > > >  #define __O_TMPFILE  0x2000000\n> > > > > +#define O_REGULAR    0x4000000\n> > > > > \n> > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > --- a/fs/fcntl.c\n> > > > > +++ b/fs/fcntl.c\n> > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > >        */\n> > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > >               HWEIGHT32(\n> > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > >                       __FMODE_EXEC));\n> > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > --- a/fs/namei.c\n> > > > > +++ b/fs/namei.c\n> > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > >               if (unlikely(error))\n> > > > >                       return error;\n> > > > >       }\n> > > > > +\n> > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > +             return -ENOTREG;\n> > > > > +\n> > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > >               return -ENOTDIR;\n> > > > > \n> > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > >       struct path path;\n> > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > >       if (!error) {\n> > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > +                     return -ENOTREG;\n> > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > >               error = vfs_open(&path, file);\n> > > > >               path_put(&path);\n> > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > --- a/fs/open.c\n> > > > > +++ b/fs/open.c\n> > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > \n> > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > \n> > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > >  {\n> > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > >                       return -EINVAL;\n> > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > >                       return -EINVAL;\n> > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > +             return -EINVAL;\n> > > > >       }\n> > > > >       if (flags & O_PATH) {\n> > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > --- a/include/linux/fcntl.h\n> > > > > +++ b/include/linux/fcntl.h\n> > > > > @@ -10,7 +10,7 @@\n> > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > \n> > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > @@ -122,4 +122,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > index 613475285643..3468b352a575 100644\n> > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > @@ -88,6 +88,10 @@\n> > > > >  #define __O_TMPFILE  020000000\n> > > > >  #endif\n> > > > > \n> > > > > +#ifndef O_REGULAR\n> > > > > +#define O_REGULAR    040000000\n> > > > > +#endif\n> > > > > +\n> > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > \n> > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > @@ -127,4 +127,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > @@ -126,6 +126,8 @@\n> > > > > \n> > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > +\n> > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > \n> > > > > \n> > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > @@ -124,4 +124,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > @@ -117,4 +117,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > @@ -122,4 +122,6 @@\n> > > > > \n> > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > \n> > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > +\n> > > > >  #endif\n> > > > \n> > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > imagine most of the filesystems that provide that op can't support\n> > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > is add in some patches that make all of the atomic_open operations in\n> > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > \n> > > > Then, once the basic support is in, you or someone else can go back and\n> > > > implement support for O_REGULAR where possible.\n> > > \n> > > Thank you for the feedback. I don't quite understand what I need to\n> > > fix. I thought open system calls always create regular files, so\n> > > atomic_open probably always creates regular files? Can you please give\n> > > me some more details as to where I need to fix this and what the\n> > > actual bug here is that is related to atomic_open?  I think I had done\n> > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > doesn't exist, the file gets created and the file that gets created is\n> > > a regular file, so it probably makes sense? Or should the behavior be\n> > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > is opened if regular, otherwise -ENOTREG is returned?\n> > > \n> > \n> > atomic_open() is a combination lookup+open for when the dentry isn't\n> > present in the dcache. The normal open codepath that you're patching\n> > does not get called in this case when ->atomic_open is set for the\n> > filesystem. It's mostly used by network filesystems that need to\n> > optimize away the lookup since it's wasted round trip, and is often\n> > racy anyway. Your patchset doesn't address those filesystems. They will\n> > likely end up ignoring O_REGULAR in that case, which is not what you\n> > want.\n> > \n> > What I was suggesting is that, as an interim step, you find all of the\n> > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > you or someone else can then go back and do a proper implementation of\n> > O_REGULAR handling on those filesystems, at least on the ones where\n> > it's possible. You will probably also need to similarly patch the\n> > open() routines for those filesystems too. Otherwise you'll get\n> > inconsistent behavior vs. when the dentry is in the cache.\n> > \n> > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > call only works on files. We'll need to change how we handle errors\n> > from the server when it's set though.\n> \n> So I think you're proposing two separate things or there's a typo:\n> \n\nOops, that was a typo.\n\n> (1) blocking O_DIRECTORY for ->atomic_open::\n> (2) blocking O_REGULAR for ->atomic_open::\n> \n> The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> with atomic open for all filesystems.\n> \n\nIt looks like NFS at least handles O_DIRECTORY properly. I don't have\nany reason to believe that O_DIRECTORY handling is broken on the\nothers.\n\n> Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> and completely broken before that.\n> \n> For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> ->atomic_open:: to the filesystem.\n> \n> The worry that I see is that a network filesystem via ->atomic_open::\n> somehow already called open on the server side on something that wasn't\n> a directory. At that point the damage such as side-effects from device\n> opening is already done.\n>                                     \n> But I suspect that every filesystem implementing ->atomic_open:: just\n> does finish_no_open() and punts to the VFS for the actual open. And the\n> VFS will catch it in do_open() for it actually opens the file. So the\n> only real worry for O_DIRECTORY I see is that there's an fs that handles\n> it wrong.\n> \n> For (2) it is problematic as there surely are filesystems with\n> ->atomic_open:: that do handle the ~O_CREAT case and return with\n> FMODE_OPENED. So that'll be problematic if the intention is to not\n> trigger an actual open on a non-regular file such as a\n> device/socket/fifo etc. before the VFS had a chance to validate what's\n> going on.\n> \n> So I'm not excited about having this 70% working and punting on\n> ->atomic_open:: waiting for someone to fix this. One option would be to\n> bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> to racy and pricy lookup + open for now. How problematic would that be?\n> If possible I'd prefer this a lot over merging something that works\n> half-way.\n> \n> I guess to make that really work you'd need some protocol extension?\n\n-- \nJeff Layton <jlayton@kernel.org>\n\n\n---\n\nOn Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:\n> On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton <jlayton@kernel.org> wrote:\n> > \n> > On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> > > On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > > > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > > > \n> > > > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > > > into opening device nodes with special semantics while thinking they\n> > > > > > > operate on regular files.\n> > > > > > > \n> > > > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > > > will return -ENOTREG.\n> > > > > > > \n> > > > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > > > \n> > > > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > > > is both a directory and a regular file.\n> > > > > > > \n> > > > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > > > ---\n> > > > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > >  fs/fcntl.c                                 | 2 +-\n> > > > > > >  fs/namei.c                                 | 6 ++++++\n> > > > > > >  fs/open.c                                  | 4 +++-\n> > > > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > > > \n> > > > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > @@ -34,6 +34,7 @@\n> > > > > > > \n> > > > > > >  #define O_PATH               040000000\n> > > > > > >  #define __O_TMPFILE  0100000000\n> > > > > > > +#define O_REGULAR    0200000000\n> > > > > > > \n> > > > > > >  #define F_GETLK              7\n> > > > > > >  #define F_SETLK              8\n> > > > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > \n> > > > > > > \n> > > > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > @@ -19,6 +19,7 @@\n> > > > > > > \n> > > > > > >  #define O_PATH               020000000\n> > > > > > >  #define __O_TMPFILE  040000000\n> > > > > > > +#define O_REGULAR    0100000000\n> > > > > > > \n> > > > > > >  #define F_GETLK64    8\n> > > > > > >  #define F_SETLK64    9\n> > > > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > @@ -37,6 +37,7 @@\n> > > > > > > \n> > > > > > >  #define O_PATH               0x1000000\n> > > > > > >  #define __O_TMPFILE  0x2000000\n> > > > > > > +#define O_REGULAR    0x4000000\n> > > > > > > \n> > > > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > > > --- a/fs/fcntl.c\n> > > > > > > +++ b/fs/fcntl.c\n> > > > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > > > >        */\n> > > > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > >               HWEIGHT32(\n> > > > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > > > >                       __FMODE_EXEC));\n> > > > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > > > --- a/fs/namei.c\n> > > > > > > +++ b/fs/namei.c\n> > > > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > > > >               if (unlikely(error))\n> > > > > > >                       return error;\n> > > > > > >       }\n> > > > > > > +\n> > > > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > > > +             return -ENOTREG;\n> > > > > > > +\n> > > > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > > > >               return -ENOTDIR;\n> > > > > > > \n> > > > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > > > >       struct path path;\n> > > > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > > > >       if (!error) {\n> > > > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > > > +                     return -ENOTREG;\n> > > > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > > > >               error = vfs_open(&path, file);\n> > > > > > >               path_put(&path);\n> > > > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > > > --- a/fs/open.c\n> > > > > > > +++ b/fs/open.c\n> > > > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > > > \n> > > > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > > > \n> > > > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > > > >  {\n> > > > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > > > >                       return -EINVAL;\n> > > > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > > > >                       return -EINVAL;\n> > > > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > > > +             return -EINVAL;\n> > > > > > >       }\n> > > > > > >       if (flags & O_PATH) {\n> > > > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > > > --- a/include/linux/fcntl.h\n> > > > > > > +++ b/include/linux/fcntl.h\n> > > > > > > @@ -10,7 +10,7 @@\n> > > > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > > > \n> > > > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > > > index 613475285643..3468b352a575 100644\n> > > > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > > > @@ -88,6 +88,10 @@\n> > > > > > >  #define __O_TMPFILE  020000000\n> > > > > > >  #endif\n> > > > > > > \n> > > > > > > +#ifndef O_REGULAR\n> > > > > > > +#define O_REGULAR    040000000\n> > > > > > > +#endif\n> > > > > > > +\n> > > > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > > > \n> > > > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > \n> > > > > > > \n> > > > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > \n> > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > \n> > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > +\n> > > > > > >  #endif\n> > > > > > \n> > > > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > > > imagine most of the filesystems that provide that op can't support\n> > > > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > > > is add in some patches that make all of the atomic_open operations in\n> > > > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > > > \n> > > > > > Then, once the basic support is in, you or someone else can go back and\n> > > > > > implement support for O_REGULAR where possible.\n> > > > > \n> > > > > Thank you for the feedback. I don't quite understand what I need to\n> > > > > fix. I thought open system calls always create regular files, so\n> > > > > atomic_open probably always creates regular files? Can you please give\n> > > > > me some more details as to where I need to fix this and what the\n> > > > > actual bug here is that is related to atomic_open?  I think I had done\n> > > > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > > > doesn't exist, the file gets created and the file that gets created is\n> > > > > a regular file, so it probably makes sense? Or should the behavior be\n> > > > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > > > is opened if regular, otherwise -ENOTREG is returned?\n> > > > > \n> > > > \n> > > > atomic_open() is a combination lookup+open for when the dentry isn't\n> > > > present in the dcache. The normal open codepath that you're patching\n> > > > does not get called in this case when ->atomic_open is set for the\n> > > > filesystem. It's mostly used by network filesystems that need to\n> > > > optimize away the lookup since it's wasted round trip, and is often\n> > > > racy anyway. Your patchset doesn't address those filesystems. They will\n> > > > likely end up ignoring O_REGULAR in that case, which is not what you\n> > > > want.\n> > > > \n> > > > What I was suggesting is that, as an interim step, you find all of the\n> > > > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > > > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > > > you or someone else can then go back and do a proper implementation of\n> > > > O_REGULAR handling on those filesystems, at least on the ones where\n> > > > it's possible. You will probably also need to similarly patch the\n> > > > open() routines for those filesystems too. Otherwise you'll get\n> > > > inconsistent behavior vs. when the dentry is in the cache.\n> > > > \n> > > > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > > > call only works on files. We'll need to change how we handle errors\n> > > > from the server when it's set though.\n> > > \n> > > So I think you're proposing two separate things or there's a typo:\n> > > \n> > > (1) blocking O_DIRECTORY for ->atomic_open::\n> > > (2) blocking O_REGULAR for ->atomic_open::\n> > > \n> > > The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> > > with atomic open for all filesystems.\n> > > \n> > > Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> > > O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> > > and completely broken before that.\n> > > \n> > > For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> > > ->atomic_open:: to the filesystem.\n> > > \n> > > The worry that I see is that a network filesystem via ->atomic_open::\n> > > somehow already called open on the server side on something that wasn't\n> > > a directory. At that point the damage such as side-effects from device\n> > > opening is already done.\n> > > \n> > > \n> > \n> > Exactly. I guess you could send an immediate close, but that's not\n> > without side effects.\n> > \n> > > \n> > > But I suspect that every filesystem implementing ->atomic_open:: just\n> > > does finish_no_open() and punts to the VFS for the actual open. And the\n> > > VFS will catch it in do_open() for it actually opens the file. So the\n> > > only real worry for O_DIRECTORY I see is that there's an fs that handles\n> > > it wrong.\n> > > \n> > > For (2) it is problematic as there surely are filesystems with\n> > > ->atomic_open:: that do handle the ~O_CREAT case and return with\n> > > FMODE_OPENED. So that'll be problematic if the intention is to not\n> > > trigger an actual open on a non-regular file such as a\n> > > device/socket/fifo etc. before the VFS had a chance to validate what's\n> > > going on.\n> > > \n> > > So I'm not excited about having this 70% working and punting on\n> > > ->atomic_open:: waiting for someone to fix this. One option would be to\n> > > bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> > > to racy and pricy lookup + open for now. How problematic would that be?\n> > > If possible I'd prefer this a lot over merging something that works\n> > > half-way.\n> > > \n> > > I guess to make that really work you'd need some protocol extension?\n> > \n> > For NFS, I think we're OK. The OPEN call on NFSv4 only works for\n> > regular files, so it should be able to handle O_REGULAR. We just need\n> > to rejigger the error handling when it's set (just return an error\n> > instead of doing the open of a directory or whatever it is).\n> > \n> \n> Thank you for the details. Do you remember which codepath this is? Is\n> this the inode_operations.atomic_open codepath or file_operations.open\n> codepath? I am a bit confused also about where exactly the error\n> handling that needs to be done.\n> \n\nI was thinking nfs_atomic_open().\n\nLooking now, I think it might actually work OK without changes. It just\nmight not be terribly efficient about it.\n\nIf the open_context() call returns -EISDIR or similar, then you really\ndon't need to do the call to nfs_lookup() and the like. You can just\nreturn an immediate error when O_REGULAR is set since you know it's not\nsuitable to be opened.\n\n> > The others (at a quick glance):\n> > \n> > cifs: I don't see a way to specify an O_REGULAR equivalent to the\n> > SMB2_CREATE call and it looks like it can create directories. Maybe\n> > SteveF (cc'ed) knows if this is possible?\n> > \n> > ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\n> > O_REGULAR can probably be supported similarly to NFS.\n> > \n> > fuse: probably ok? Does finish_no_open() in most cases. May depend on\n> > the userland driver though.\n> > \n> > gfs2: is ok, it just does finish_no_open() in most cases anyway\n> > \n> > vboxsf: does finish_no_open on non-creates, so you could probably just\n> > punt to that if O_REGULAR is set.\n> > \n> \n> These are all inode_operations.atomic_open code paths, right? Because\n> you mentioned finish_no_open and I see finish_no_open in the\n> atomic_open code paths as opposed to file_operations.open code paths.\n> \n\nNote that this was just a cursory look. Someone will need to do a\ndeeper dive and test these cases.\n\nI think most will end up working ok, since most fall back to doing a\nfinish_no_open(). There may be opportunities to optimize some of these\ncases though (similarly to how I mentioned with NFS).\n-- \nJeff Layton <jlayton@kernel.org>\n\n\n---\n\nOn Thu, 2026-02-19 at 01:19 +0600, Dorjoy Chowdhury wrote:\n> On Thu, Feb 19, 2026 at 1:01 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > \n> > On Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:\n> > > On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > \n> > > > On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:\n> > > > > On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> > > > > > On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > > > > > > On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton <jlayton@kernel.org> wrote:\n> > > > > > > > \n> > > > > > > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > > > > > > This flag indicates the path should be opened if it's a regular file.\n> > > > > > > > > This is useful to write secure programs that want to avoid being tricked\n> > > > > > > > > into opening device nodes with special semantics while thinking they\n> > > > > > > > > operate on regular files.\n> > > > > > > > > \n> > > > > > > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > > > > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > > > > > > will return -ENOTREG.\n> > > > > > > > > \n> > > > > > > > > When used in combination with O_CREAT, either the regular file is\n> > > > > > > > > created, or if the path already exists, it is opened if it's a regular\n> > > > > > > > > file. Otherwise, -ENOTREG is returned.\n> > > > > > > > > \n> > > > > > > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > > > > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > > > > > > is both a directory and a regular file.\n> > > > > > > > > \n> > > > > > > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > > > > > > ---\n> > > > > > > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > > > > > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > > > > > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > > > > > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > > > > > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > > > > > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > > > > > > >  fs/fcntl.c                                 | 2 +-\n> > > > > > > > >  fs/namei.c                                 | 6 ++++++\n> > > > > > > > >  fs/open.c                                  | 4 +++-\n> > > > > > > > >  include/linux/fcntl.h                      | 2 +-\n> > > > > > > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > > > > > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > > > > > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > > > > > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > > > > > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > > > > > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > > > > > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > > > > > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > > > > > > \n> > > > > > > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > > > > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > > > > > > @@ -34,6 +34,7 @@\n> > > > > > > > > \n> > > > > > > > >  #define O_PATH               040000000\n> > > > > > > > >  #define __O_TMPFILE  0100000000\n> > > > > > > > > +#define O_REGULAR    0200000000\n> > > > > > > > > \n> > > > > > > > >  #define F_GETLK              7\n> > > > > > > > >  #define F_SETLK              8\n> > > > > > > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > > > \n> > > > > > > > > \n> > > > > > > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > > > > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > > > > > > @@ -19,6 +19,7 @@\n> > > > > > > > > \n> > > > > > > > >  #define O_PATH               020000000\n> > > > > > > > >  #define __O_TMPFILE  040000000\n> > > > > > > > > +#define O_REGULAR    0100000000\n> > > > > > > > > \n> > > > > > > > >  #define F_GETLK64    8\n> > > > > > > > >  #define F_SETLK64    9\n> > > > > > > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > > > > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > > > > > > @@ -37,6 +37,7 @@\n> > > > > > > > > \n> > > > > > > > >  #define O_PATH               0x1000000\n> > > > > > > > >  #define __O_TMPFILE  0x2000000\n> > > > > > > > > +#define O_REGULAR    0x4000000\n> > > > > > > > > \n> > > > > > > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > > > > > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > > > > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > > > > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > > > > > > --- a/fs/fcntl.c\n> > > > > > > > > +++ b/fs/fcntl.c\n> > > > > > > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > > > > > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > > > > > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > > > > > > >        */\n> > > > > > > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > > > > > > >               HWEIGHT32(\n> > > > > > > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > > > > > > >                       __FMODE_EXEC));\n> > > > > > > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > > > > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > > > > > > --- a/fs/namei.c\n> > > > > > > > > +++ b/fs/namei.c\n> > > > > > > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > > > > > > >               if (unlikely(error))\n> > > > > > > > >                       return error;\n> > > > > > > > >       }\n> > > > > > > > > +\n> > > > > > > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > > > > > > +             return -ENOTREG;\n> > > > > > > > > +\n> > > > > > > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > > > > > > >               return -ENOTDIR;\n> > > > > > > > > \n> > > > > > > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > > > > > > >       struct path path;\n> > > > > > > > >       int error = path_lookupat(nd, flags, &path);\n> > > > > > > > >       if (!error) {\n> > > > > > > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > > > > > > +                     return -ENOTREG;\n> > > > > > > > >               audit_inode(nd->name, path.dentry, 0);\n> > > > > > > > >               error = vfs_open(&path, file);\n> > > > > > > > >               path_put(&path);\n> > > > > > > > > diff --git a/fs/open.c b/fs/open.c\n> > > > > > > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > > > > > > --- a/fs/open.c\n> > > > > > > > > +++ b/fs/open.c\n> > > > > > > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > > > > > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > > > > > > \n> > > > > > > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > > > > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > > > > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > > > > > > \n> > > > > > > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > > > > > > >  {\n> > > > > > > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > > > > > > >                       return -EINVAL;\n> > > > > > > > >               if (!(acc_mode & MAY_WRITE))\n> > > > > > > > >                       return -EINVAL;\n> > > > > > > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > > > > > > +             return -EINVAL;\n> > > > > > > > >       }\n> > > > > > > > >       if (flags & O_PATH) {\n> > > > > > > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > > > > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > > > > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > > > > > > --- a/include/linux/fcntl.h\n> > > > > > > > > +++ b/include/linux/fcntl.h\n> > > > > > > > > @@ -10,7 +10,7 @@\n> > > > > > > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > > > > > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > > > > > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > > > > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > > > > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > > > > > > \n> > > > > > > > >  /* List of all valid flags for the how->resolve argument: */\n> > > > > > > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > > > > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > > > --- a/include/uapi/asm-generic/errno.h\n> > > > > > > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > > > > > > index 613475285643..3468b352a575 100644\n> > > > > > > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > > > > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > > > > > > @@ -88,6 +88,10 @@\n> > > > > > > > >  #define __O_TMPFILE  020000000\n> > > > > > > > >  #endif\n> > > > > > > > > \n> > > > > > > > > +#ifndef O_REGULAR\n> > > > > > > > > +#define O_REGULAR    040000000\n> > > > > > > > > +#endif\n> > > > > > > > > +\n> > > > > > > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > > > > > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > > > > > > \n> > > > > > > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > > > > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > > > > > > @@ -127,4 +127,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > index c01ed91b1ef4..293c78777254 100644\n> > > > > > > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > > > > > > @@ -126,6 +126,8 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > > > > > > \n> > > > > > > > > \n> > > > > > > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > index 8cbc07c1903e..442917484f99 100644\n> > > > > > > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > > > > > > @@ -124,4 +124,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > > > > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > > > > > > @@ -117,4 +117,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > > > > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > > > > > > @@ -122,4 +122,6 @@\n> > > > > > > > > \n> > > > > > > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > > > > > > \n> > > > > > > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > > > > > > +\n> > > > > > > > >  #endif\n> > > > > > > > \n> > > > > > > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > > > > > > imagine most of the filesystems that provide that op can't support\n> > > > > > > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > > > > > > is add in some patches that make all of the atomic_open operations in\n> > > > > > > > the kernel return -EINVAL if O_REGULAR is set.\n> > > > > > > > \n> > > > > > > > Then, once the basic support is in, you or someone else can go back and\n> > > > > > > > implement support for O_REGULAR where possible.\n> > > > > > > \n> > > > > > > Thank you for the feedback. I don't quite understand what I need to\n> > > > > > > fix. I thought open system calls always create regular files, so\n> > > > > > > atomic_open probably always creates regular files? Can you please give\n> > > > > > > me some more details as to where I need to fix this and what the\n> > > > > > > actual bug here is that is related to atomic_open?  I think I had done\n> > > > > > > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > > > > > > doesn't exist, the file gets created and the file that gets created is\n> > > > > > > a regular file, so it probably makes sense? Or should the behavior be\n> > > > > > > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > > > > > > is opened if regular, otherwise -ENOTREG is returned?\n> > > > > > > \n> > > > > > \n> > > > > > atomic_open() is a combination lookup+open for when the dentry isn't\n> > > > > > present in the dcache. The normal open codepath that you're patching\n> > > > > > does not get called in this case when ->atomic_open is set for the\n> > > > > > filesystem. It's mostly used by network filesystems that need to\n> > > > > > optimize away the lookup since it's wasted round trip, and is often\n> > > > > > racy anyway. Your patchset doesn't address those filesystems. They will\n> > > > > > likely end up ignoring O_REGULAR in that case, which is not what you\n> > > > > > want.\n> > > > > > \n> > > > > > What I was suggesting is that, as an interim step, you find all of the\n> > > > > > atomic_open operations in the kernel (there are maybe a dozen or so),\n> > > > > > and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> > > > > > you or someone else can then go back and do a proper implementation of\n> > > > > > O_REGULAR handling on those filesystems, at least on the ones where\n> > > > > > it's possible. You will probably also need to similarly patch the\n> > > > > > open() routines for those filesystems too. Otherwise you'll get\n> > > > > > inconsistent behavior vs. when the dentry is in the cache.\n> > > > > > \n> > > > > > One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> > > > > > call only works on files. We'll need to change how we handle errors\n> > > > > > from the server when it's set though.\n> > > > > \n> > > > > So I think you're proposing two separate things or there's a typo:\n> > > > > \n> > > > > (1) blocking O_DIRECTORY for ->atomic_open::\n> > > > > (2) blocking O_REGULAR for ->atomic_open::\n> > > > > \n> > > > > The (1) point implies that O_DIRECTORY currently doesn't work correctly\n> > > > > with atomic open for all filesystems.\n> > > > > \n> > > > > Ever since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\n> > > > > O_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\n> > > > > and completely broken before that.\n> > > > > \n> > > > > For O_DIRECTORY without O_CREAT the kernel will pass that down through\n> > > > > ->atomic_open:: to the filesystem.\n> > > > > \n> > > > > The worry that I see is that a network filesystem via ->atomic_open::\n> > > > > somehow already called open on the server side on something that wasn't\n> > > > > a directory. At that point the damage such as side-effects from device\n> > > > > opening is already done.\n> > > > > \n> > > > > \n> > > > \n> > > > Exactly. I guess you could send an immediate close, but that's not\n> > > > without side effects.\n> > > > \n> > > > > \n> > > > > But I suspect that every filesystem implementing ->atomic_open:: just\n> > > > > does finish_no_open() and punts to the VFS for the actual open. And the\n> > > > > VFS will catch it in do_open() for it actually opens the file. So the\n> > > > > only real worry for O_DIRECTORY I see is that there's an fs that handles\n> > > > > it wrong.\n> > > > > \n> > > > > For (2) it is problematic as there surely are filesystems with\n> > > > > ->atomic_open:: that do handle the ~O_CREAT case and return with\n> > > > > FMODE_OPENED. So that'll be problematic if the intention is to not\n> > > > > trigger an actual open on a non-regular file such as a\n> > > > > device/socket/fifo etc. before the VFS had a chance to validate what's\n> > > > > going on.\n> > > > > \n> > > > > So I'm not excited about having this 70% working and punting on\n> > > > > ->atomic_open:: waiting for someone to fix this. One option would be to\n> > > > > bypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\n> > > > > to racy and pricy lookup + open for now. How problematic would that be?\n> > > > > If possible I'd prefer this a lot over merging something that works\n> > > > > half-way.\n> > > > > \n> > > > > I guess to make that really work you'd need some protocol extension?\n> > > > \n> > > > For NFS, I think we're OK. The OPEN call on NFSv4 only works for\n> > > > regular files, so it should be able to handle O_REGULAR. We just need\n> > > > to rejigger the error handling when it's set (just return an error\n> > > > instead of doing the open of a directory or whatever it is).\n> > > > \n> > > \n> > > Thank you for the details. Do you remember which codepath this is? Is\n> > > this the inode_operations.atomic_open codepath or file_operations.open\n> > > codepath? I am a bit confused also about where exactly the error\n> > > handling that needs to be done.\n> > > \n> > \n> > I was thinking nfs_atomic_open().\n> > \n> > Looking now, I think it might actually work OK without changes. It just\n> > might not be terribly efficient about it.\n> > \n> > If the open_context() call returns -EISDIR or similar, then you really\n> > don't need to do the call to nfs_lookup() and the like. You can just\n> > return an immediate error when O_REGULAR is set since you know it's not\n> > suitable to be opened.\n> > \n> \n> Right. And I guess we don't need to worry about O_REGULAR being an\n> unknown flag when it gets sent to the server (not only for NFS / but\n> others as well)?\n> \n\nYou shouldn't. We don't send POSIX flags in NFSv4 requests. It has its\nown set of flags. In the case of NFSv4, O_REGULAR is already implied in\nan OPEN call on the wire. OPEN only operates on regular files.\n\n> > > > The others (at a quick glance):\n> > > > \n> > > > cifs: I don't see a way to specify an O_REGULAR equivalent to the\n> > > > SMB2_CREATE call and it looks like it can create directories. Maybe\n> > > > SteveF (cc'ed) knows if this is possible?\n> > > > \n> > > > ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\n> > > > O_REGULAR can probably be supported similarly to NFS.\n> > > > \n> > > > fuse: probably ok? Does finish_no_open() in most cases. May depend on\n> > > > the userland driver though.\n> > > > \n> > > > gfs2: is ok, it just does finish_no_open() in most cases anyway\n> > > > \n> > > > vboxsf: does finish_no_open on non-creates, so you could probably just\n> > > > punt to that if O_REGULAR is set.\n> > > > \n> > > \n> > > These are all inode_operations.atomic_open code paths, right? Because\n> > > you mentioned finish_no_open and I see finish_no_open in the\n> > > atomic_open code paths as opposed to file_operations.open code paths.\n> > > \n> > \n> > Note that this was just a cursory look. Someone will need to do a\n> > deeper dive and test these cases.\n> > \n> > I think most will end up working ok, since most fall back to doing a\n> > finish_no_open(). There may be opportunities to optimize some of these\n> > cases though (similarly to how I mentioned with NFS).\n> \n> I can try to look into these and see if I can implement handling for\n> O_REGULAR flag for these filesystems in the atomic_open code paths.\n> Thanks for the details.\n> \n> Will I need to modify the corresponding file_operations.open code\n> paths as well along with atomic_open code paths?\n> \n\nProbably not.\n\nThe main thing to keep in mind is that ->open is used when we already\nhave a dentry for the target of the open. ->atomic_open is used when we\ndon't have one yet or the one we have has failed revalidation.\n\nIf you have a valid dentry, then you should be able to satisfy the\nO_REGULAR check without having to call into ->open at all.\n-- \nJeff Layton <jlayton@kernel.org>\n",
          "reply_to": ""
        },
        {
          "author": "Mateusz Guzik",
          "summary": "Mateusz Guzik raised concerns about the O_REGULAR flag's behavior and suggested it may not work as intended due to overlapping bits in the bitmask. He also questioned whether there is a use case for additional flags beyond O_DIRECTORY and O_REGULAR.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "concerns about code functionality",
            "questioning usefulness of feature"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Wed, Jan 28, 2026 at 12:23:45AM +0100, Aleksa Sarai wrote:\n> In my view, this should be an openat2(2)-only API.\n\nfwiw +1 from me, the O_ flag situation is already terrible even without\nthe validation woes.\n\nI find it most unfortunate the openat2 syscall reuses the O_ namespace.\nFor my taste it would be best closed for business, with all new flag\nadditions using a different space.\n\nI can easily see people passing O_WHATEVER to open and openat by blindly\nassuming they are supported just based on the name.\n\nthat's a side mini-rant, too late to do anything here now\n\n> In addition, I would\n> propose that (instead of burning another O_* flag bit for this as a\n> special-purpose API just for regular files) you could have a mask of\n> which S_IFMT bits should be rejected as a new field in \"struct\n> open_how\". This would let you reject sockets or device inodes but permit\n> FIFOs and regular files or directories, for instance. This could even be\n> done without a new O_* flag at all (the zero-value how->sfmt_mask would\n> allow everything and so would work well with extensible structs), but we\n> could add an O2_* flag anyway.\n\nI don't think this works because the vars have overlapping bits:\n  #define S_IFBLK  0060000\n  #define S_IFDIR  0040000\n\nSo you very much can't select what you want off of a bitmask.\n\nAt best the field could be used to select the one type you are fine with.\n\nIf one was to pursue the idea, some other defines with unique bits would\nneed to be provided. But even then, semantics should be to only *allow*\nthe bits you are fine with and reject the rest.\n\nBut I'm not at all confident this is worth any effort -- with\nO_DIRECTORY already being there and O_REGULAR proposed, is there a use\ncase which wants something else?\n\n> \n> > +#define ENOTREG\t\t134\t/* Not a regular file */\n> > +\n> \n[..]\n> Then to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind\n> of justify the existence of ENOTREG too. Unfortunately, you won't be\n> able to use ENOTREG if you go with my idea of having mask bits in\n> open_how... (And what errno should we use then...? Hm.)\n> \n\nThe most useful behavior would indicate what was found (e.g., a pipe).\n\nThe easiest way to do it would create errnos for all types (EISDIR\nalready exists for one), but I can't seriously propose that.\n\nGoing the other way, EBADTYPE or something else reusable would be my\nidea.\n",
          "reply_to": ""
        },
        {
          "author": "Christian Brauner",
          "summary": "The reviewer raised concerns about the implementation of O_REGULAR flag, suggesting it should be added outside of openat2() and following a specific naming pattern. They also questioned the need for O_DIRECTORY to be exclusive with OPENAT2_REGULAR.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "technical concerns"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:\n> This flag indicates the path should be opened if it's a regular file.\n> This is useful to write secure programs that want to avoid being tricked\n> into opening device nodes with special semantics while thinking they\n> operate on regular files.\n> \n> A corresponding error code ENOTREG has been introduced. For example, if\n> open is called on path /dev/null with O_REGULAR in the flag param, it\n> will return -ENOTREG.\n> \n> When used in combination with O_CREAT, either the regular file is\n> created, or if the path already exists, it is opened if it's a regular\n> file. Otherwise, -ENOTREG is returned.\n> \n> -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> part of O_TMPFILE) because it doesn't make sense to open a path that\n> is both a directory and a regular file.\n> \n> Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> ---\n\nYeah, we shouldn't add support for this outside of openat2(). We also\nshouldn't call this OEXT_* or O2_*. Let's just follow the pattern where\nwe prefix the flag space with the name of the system call\nOPENAT2_REGULAR.\n\nThere's also no real need to make O_DIRECTORY exclusive with\nOPENAT2_REGULAR. Callers could legimitately want to open a directory or\nregular file but not anything else. If someone wants to operate on a\nwhole filesystem tree but only wants to interact with regular files and\ndirectories and ignore devices, sockets, fifos etc it's very handy to\njust be able to set both in flags.\n\nFrankly, this shouldn't be a flag at all but we already have O_DIRECTORY\nin there so no need to move this into a new field.\n\nAdd EFTYPE as the errno code. Some of the bsds including macos already\nhave that.\n\n\n---\n\nOn Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:\n> On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:\n> > On Wed, Jan 28, 2026 at 5:52\\u202fAM Jeff Layton <jlayton@kernel.org> wrote:\n> > > \n> > > On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:\n> > > > This flag indicates the path should be opened if it's a regular file.\n> > > > This is useful to write secure programs that want to avoid being tricked\n> > > > into opening device nodes with special semantics while thinking they\n> > > > operate on regular files.\n> > > > \n> > > > A corresponding error code ENOTREG has been introduced. For example, if\n> > > > open is called on path /dev/null with O_REGULAR in the flag param, it\n> > > > will return -ENOTREG.\n> > > > \n> > > > When used in combination with O_CREAT, either the regular file is\n> > > > created, or if the path already exists, it is opened if it's a regular\n> > > > file. Otherwise, -ENOTREG is returned.\n> > > > \n> > > > -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\n> > > > part of O_TMPFILE) because it doesn't make sense to open a path that\n> > > > is both a directory and a regular file.\n> > > > \n> > > > Signed-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n> > > > ---\n> > > >  arch/alpha/include/uapi/asm/errno.h        | 2 ++\n> > > >  arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n> > > >  arch/mips/include/uapi/asm/errno.h         | 2 ++\n> > > >  arch/parisc/include/uapi/asm/errno.h       | 2 ++\n> > > >  arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n> > > >  arch/sparc/include/uapi/asm/errno.h        | 2 ++\n> > > >  arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n> > > >  fs/fcntl.c                                 | 2 +-\n> > > >  fs/namei.c                                 | 6 ++++++\n> > > >  fs/open.c                                  | 4 +++-\n> > > >  include/linux/fcntl.h                      | 2 +-\n> > > >  include/uapi/asm-generic/errno.h           | 2 ++\n> > > >  include/uapi/asm-generic/fcntl.h           | 4 ++++\n> > > >  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n> > > >  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n> > > >  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n> > > >  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n> > > >  tools/include/uapi/asm-generic/errno.h     | 2 ++\n> > > >  18 files changed, 38 insertions(+), 3 deletions(-)\n> > > > \n> > > > diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\n> > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > --- a/arch/alpha/include/uapi/asm/errno.h\n> > > > +++ b/arch/alpha/include/uapi/asm/errno.h\n> > > > @@ -127,4 +127,6 @@\n> > > > \n> > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > index 50bdc8e8a271..4da5a64c23bd 100644\n> > > > --- a/arch/alpha/include/uapi/asm/fcntl.h\n> > > > +++ b/arch/alpha/include/uapi/asm/fcntl.h\n> > > > @@ -34,6 +34,7 @@\n> > > > \n> > > >  #define O_PATH               040000000\n> > > >  #define __O_TMPFILE  0100000000\n> > > > +#define O_REGULAR    0200000000\n> > > > \n> > > >  #define F_GETLK              7\n> > > >  #define F_SETLK              8\n> > > > diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\n> > > > index c01ed91b1ef4..293c78777254 100644\n> > > > --- a/arch/mips/include/uapi/asm/errno.h\n> > > > +++ b/arch/mips/include/uapi/asm/errno.h\n> > > > @@ -126,6 +126,8 @@\n> > > > \n> > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > +\n> > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > \n> > > > \n> > > > diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\n> > > > index 8cbc07c1903e..442917484f99 100644\n> > > > --- a/arch/parisc/include/uapi/asm/errno.h\n> > > > +++ b/arch/parisc/include/uapi/asm/errno.h\n> > > > @@ -124,4 +124,6 @@\n> > > > \n> > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > index 03dee816cb13..0cc3320fe326 100644\n> > > > --- a/arch/parisc/include/uapi/asm/fcntl.h\n> > > > +++ b/arch/parisc/include/uapi/asm/fcntl.h\n> > > > @@ -19,6 +19,7 @@\n> > > > \n> > > >  #define O_PATH               020000000\n> > > >  #define __O_TMPFILE  040000000\n> > > > +#define O_REGULAR    0100000000\n> > > > \n> > > >  #define F_GETLK64    8\n> > > >  #define F_SETLK64    9\n> > > > diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\n> > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > --- a/arch/sparc/include/uapi/asm/errno.h\n> > > > +++ b/arch/sparc/include/uapi/asm/errno.h\n> > > > @@ -117,4 +117,6 @@\n> > > > \n> > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > index 67dae75e5274..a93d18d2c23e 100644\n> > > > --- a/arch/sparc/include/uapi/asm/fcntl.h\n> > > > +++ b/arch/sparc/include/uapi/asm/fcntl.h\n> > > > @@ -37,6 +37,7 @@\n> > > > \n> > > >  #define O_PATH               0x1000000\n> > > >  #define __O_TMPFILE  0x2000000\n> > > > +#define O_REGULAR    0x4000000\n> > > > \n> > > >  #define F_GETOWN     5       /*  for sockets. */\n> > > >  #define F_SETOWN     6       /*  for sockets. */\n> > > > diff --git a/fs/fcntl.c b/fs/fcntl.c\n> > > > index f93dbca08435..62ab4ad2b6f5 100644\n> > > > --- a/fs/fcntl.c\n> > > > +++ b/fs/fcntl.c\n> > > > @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n> > > >        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n> > > >        * is defined as O_NONBLOCK on some platforms and not on others.\n> > > >        */\n> > > > -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n> > > > +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n> > > >               HWEIGHT32(\n> > > >                       (VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n> > > >                       __FMODE_EXEC));\n> > > > diff --git a/fs/namei.c b/fs/namei.c\n> > > > index b28ecb699f32..f5504ae4b03c 100644\n> > > > --- a/fs/namei.c\n> > > > +++ b/fs/namei.c\n> > > > @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n> > > >               if (unlikely(error))\n> > > >                       return error;\n> > > >       }\n> > > > +\n> > > > +     if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n> > > > +             return -ENOTREG;\n> > > > +\n> > > >       if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n> > > >               return -ENOTDIR;\n> > > > \n> > > > @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n> > > >       struct path path;\n> > > >       int error = path_lookupat(nd, flags, &path);\n> > > >       if (!error) {\n> > > > +             if ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n> > > > +                     return -ENOTREG;\n> > > >               audit_inode(nd->name, path.dentry, 0);\n> > > >               error = vfs_open(&path, file);\n> > > >               path_put(&path);\n> > > > diff --git a/fs/open.c b/fs/open.c\n> > > > index 74c4c1462b3e..82153e21907e 100644\n> > > > --- a/fs/open.c\n> > > > +++ b/fs/open.c\n> > > > @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n> > > >  EXPORT_SYMBOL_GPL(kernel_file_open);\n> > > > \n> > > >  #define WILL_CREATE(flags)   (flags & (O_CREAT | __O_TMPFILE))\n> > > > -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n> > > > +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n> > > > \n> > > >  inline struct open_how build_open_how(int flags, umode_t mode)\n> > > >  {\n> > > > @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n> > > >                       return -EINVAL;\n> > > >               if (!(acc_mode & MAY_WRITE))\n> > > >                       return -EINVAL;\n> > > > +     } else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n> > > > +             return -EINVAL;\n> > > >       }\n> > > >       if (flags & O_PATH) {\n> > > >               /* O_PATH only permits certain other flags to be set. */\n> > > > diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\n> > > > index a332e79b3207..4fd07b0e0a17 100644\n> > > > --- a/include/linux/fcntl.h\n> > > > +++ b/include/linux/fcntl.h\n> > > > @@ -10,7 +10,7 @@\n> > > >       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n> > > >        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n> > > >        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n> > > > -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n> > > > +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n> > > > \n> > > >  /* List of all valid flags for the how->resolve argument: */\n> > > >  #define VALID_RESOLVE_FLAGS \\\n> > > > diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\n> > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > --- a/include/uapi/asm-generic/errno.h\n> > > > +++ b/include/uapi/asm-generic/errno.h\n> > > > @@ -122,4 +122,6 @@\n> > > > \n> > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\n> > > > index 613475285643..3468b352a575 100644\n> > > > --- a/include/uapi/asm-generic/fcntl.h\n> > > > +++ b/include/uapi/asm-generic/fcntl.h\n> > > > @@ -88,6 +88,10 @@\n> > > >  #define __O_TMPFILE  020000000\n> > > >  #endif\n> > > > \n> > > > +#ifndef O_REGULAR\n> > > > +#define O_REGULAR    040000000\n> > > > +#endif\n> > > > +\n> > > >  /* a horrid kludge trying to make sure that this will fail on old kernels */\n> > > >  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n> > > > \n> > > > diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > index 6791f6508632..8bbcaa9024f9 100644\n> > > > --- a/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/alpha/include/uapi/asm/errno.h\n> > > > @@ -127,4 +127,6 @@\n> > > > \n> > > >  #define EHWPOISON    139     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              140     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > index c01ed91b1ef4..293c78777254 100644\n> > > > --- a/tools/arch/mips/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/mips/include/uapi/asm/errno.h\n> > > > @@ -126,6 +126,8 @@\n> > > > \n> > > >  #define EHWPOISON    168     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              169     /* Not a regular file */\n> > > > +\n> > > >  #define EDQUOT               1133    /* Quota exceeded */\n> > > > \n> > > > \n> > > > diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > index 8cbc07c1903e..442917484f99 100644\n> > > > --- a/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/parisc/include/uapi/asm/errno.h\n> > > > @@ -124,4 +124,6 @@\n> > > > \n> > > >  #define EHWPOISON    257     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              258     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > index 4a41e7835fd5..8dce0bfeab74 100644\n> > > > --- a/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > +++ b/tools/arch/sparc/include/uapi/asm/errno.h\n> > > > @@ -117,4 +117,6 @@\n> > > > \n> > > >  #define EHWPOISON    135     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              136     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > > diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\n> > > > index 92e7ae493ee3..2216ab9aa32e 100644\n> > > > --- a/tools/include/uapi/asm-generic/errno.h\n> > > > +++ b/tools/include/uapi/asm-generic/errno.h\n> > > > @@ -122,4 +122,6 @@\n> > > > \n> > > >  #define EHWPOISON    133     /* Memory page has hardware error */\n> > > > \n> > > > +#define ENOTREG              134     /* Not a regular file */\n> > > > +\n> > > >  #endif\n> > > \n> > > One thing this patch is missing is handling for ->atomic_open(). I\n> > > imagine most of the filesystems that provide that op can't support\n> > > O_REGULAR properly (maybe cifs can? idk). What you probably want to do\n> > > is add in some patches that make all of the atomic_open operations in\n> > > the kernel return -EINVAL if O_REGULAR is set.\n> > > \n> > > Then, once the basic support is in, you or someone else can go back and\n> > > implement support for O_REGULAR where possible.\n> > \n> > Thank you for the feedback. I don't quite understand what I need to\n> > fix. I thought open system calls always create regular files, so\n> > atomic_open probably always creates regular files? Can you please give\n> > me some more details as to where I need to fix this and what the\n> > actual bug here is that is related to atomic_open?  I think I had done\n> > some normal testing and when using O_CREAT | O_REGULAR, if the file\n> > doesn't exist, the file gets created and the file that gets created is\n> > a regular file, so it probably makes sense? Or should the behavior be\n> > that if file doesn't exist, -EINVAL is returned and if file exists it\n> > is opened if regular, otherwise -ENOTREG is returned?\n> > \n> \n> atomic_open() is a combination lookup+open for when the dentry isn't\n> present in the dcache. The normal open codepath that you're patching\n> does not get called in this case when ->atomic_open is set for the\n> filesystem. It's mostly used by network filesystems that need to\n> optimize away the lookup since it's wasted round trip, and is often\n> racy anyway. Your patchset doesn't address those filesystems. They will\n> likely end up ignoring O_REGULAR in that case, which is not what you\n> want.\n> \n> What I was suggesting is that, as an interim step, you find all of the\n> atomic_open operations in the kernel (there are maybe a dozen or so),\n> and just make them return -EINVAL if someone sets O_DIRECTORY. Later,\n> you or someone else can then go back and do a proper implementation of\n> O_REGULAR handling on those filesystems, at least on the ones where\n> it's possible. You will probably also need to similarly patch the\n> open() routines for those filesystems too. Otherwise you'll get\n> inconsistent behavior vs. when the dentry is in the cache.\n> \n> One note: I think NFS probably can support O_DIRECTORY, since its OPEN\n> call only works on files. We'll need to change how we handle errors\n> from the server when it's set though.\n\nSo I think you're proposing two separate things or there's a typo:\n\n(1) blocking O_DIRECTORY for ->atomic_open::\n(2) blocking O_REGULAR for ->atomic_open::\n\nThe (1) point implies that O_DIRECTORY currently doesn't work correctly\nwith atomic open for all filesystems.\n\nEver since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\nO_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\nand completely broken before that.\n\nFor O_DIRECTORY without O_CREAT the kernel will pass that down through\n->atomic_open:: to the filesystem.\n\nThe worry that I see is that a network filesystem via ->atomic_open::\nsomehow already called open on the server side on something that wasn't\na directory. At that point the damage such as side-effects from device\nopening is already done.\n                                    \nBut I suspect that every filesystem implementing ->atomic_open:: just\ndoes finish_no_open() and punts to the VFS for the actual open. And the\nVFS will catch it in do_open() for it actually opens the file. So the\nonly real worry for O_DIRECTORY I see is that there's an fs that handles\nit wrong.\n\nFor (2) it is problematic as there surely are filesystems with\n->atomic_open:: that do handle the ~O_CREAT case and return with\nFMODE_OPENED. So that'll be problematic if the intention is to not\ntrigger an actual open on a non-regular file such as a\ndevice/socket/fifo etc. before the VFS had a chance to validate what's\ngoing on.\n\nSo I'm not excited about having this 70% working and punting on\n->atomic_open:: waiting for someone to fix this. One option would be to\nbypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\nto racy and pricy lookup + open for now. How problematic would that be?\nIf possible I'd prefer this a lot over merging something that works\nhalf-way.\n\nI guess to make that really work you'd need some protocol extension?\n",
          "reply_to": ""
        }
      ],
      "analysis_source": "llm"
    }
  }
}