{
  "thread_id": "aY-E2Rj2gBrBHJsT@cmpxchg.org",
  "subject": "Re: [PATCH] memcg: consolidate private id refcount get/put helpers",
  "url": "https://lore.kernel.org/all/aY-E2Rj2gBrBHJsT@cmpxchg.org/",
  "dates": {
    "2026-02-13": {
      "report_file": "2026-02-13_ollama_llama3.1-8b.html",
      "developer": "Johannes Weiner",
      "reviews": [
        {
          "author": "Johannes Weiner",
          "summary": "Johannes Weiner approved the patch and gave an Acked-by tag, but no specific technical concerns were raised.",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Acked-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Fri, Feb 13, 2026 at 06:03:32PM +0800, Kairui Song wrote:\n> From: Kairui Song <kasong@tencent.com>\n> \n> We currently have two different sets of helpers for getting or putting\n> the private IDs' refcount for order 0 and large folios. This is\n> redundant. Just use one and always acquire the refcount of the swapout\n> folio size unless it's zero, and put the refcount using the folio size\n> if the charge failed, since the folio size can't change. Then there is\n> no need to update the refcount for tail pages.\n> \n> Same for freeing, then only one pair of get/put helper is needed now.\n> \n> The performance might be slightly better, too: both \"inc unless zero\"\n> and \"add unless zero\" use the same cmpxchg implementation. For large\n> folios, we saved an atomic operation. And for both order 0 and large\n> folios, we saved a branch.\n> \n> Signed-off-by: Kairui Song <kasong@tencent.com>\n\nNice improvement!\n\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\n",
          "reply_to": ""
        },
        {
          "author": "Chen Ridong",
          "summary": "Gave Reviewed-by",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "\n\nOn 2026/2/13 18:03, Kairui Song wrote:\n> From: Kairui Song <kasong@tencent.com>\n> \n> We currently have two different sets of helpers for getting or putting\n> the private IDs' refcount for order 0 and large folios. This is\n> redundant. Just use one and always acquire the refcount of the swapout\n> folio size unless it's zero, and put the refcount using the folio size\n> if the charge failed, since the folio size can't change. Then there is\n> no need to update the refcount for tail pages.\n> \n> Same for freeing, then only one pair of get/put helper is needed now.\n> \n> The performance might be slightly better, too: both \"inc unless zero\"\n> and \"add unless zero\" use the same cmpxchg implementation. For large\n> folios, we saved an atomic operation. And for both order 0 and large\n> folios, we saved a branch.\n> \n> Signed-off-by: Kairui Song <kasong@tencent.com>\n> ---\n>  mm/memcontrol-v1.c |  5 +----\n>  mm/memcontrol-v1.h |  4 ++--\n>  mm/memcontrol.c    | 29 +++++++----------------------\n>  3 files changed, 10 insertions(+), 28 deletions(-)\n> \n> diff --git a/mm/memcontrol-v1.c b/mm/memcontrol-v1.c\n> index 0e3d972fad33..c28a060abc64 100644\n> --- a/mm/memcontrol-v1.c\n> +++ b/mm/memcontrol-v1.c\n> @@ -635,11 +635,8 @@ void memcg1_swapout(struct folio *folio, swp_entry_t entry)\n>  \t * have an ID allocated to it anymore, charge the closest online\n>  \t * ancestor for the swap instead and transfer the memory+swap charge.\n>  \t */\n> -\tswap_memcg = mem_cgroup_private_id_get_online(memcg);\n>  \tnr_entries = folio_nr_pages(folio);\n> -\t/* Get references for the tail pages, too */\n> -\tif (nr_entries > 1)\n> -\t\tmem_cgroup_private_id_get_many(swap_memcg, nr_entries - 1);\n> +\tswap_memcg = mem_cgroup_private_id_get_online(memcg, nr_entries);\n>  \tmod_memcg_state(swap_memcg, MEMCG_SWAP, nr_entries);\n>  \n>  \tswap_cgroup_record(folio, mem_cgroup_private_id(swap_memcg), entry);\n> diff --git a/mm/memcontrol-v1.h b/mm/memcontrol-v1.h\n> index 49933925b4ba..dbbd0e13d4ff 100644\n> --- a/mm/memcontrol-v1.h\n> +++ b/mm/memcontrol-v1.h\n> @@ -28,8 +28,8 @@ unsigned long memcg_events(struct mem_cgroup *memcg, int event);\n>  unsigned long memcg_page_state_output(struct mem_cgroup *memcg, int item);\n>  int memory_stat_show(struct seq_file *m, void *v);\n>  \n> -void mem_cgroup_private_id_get_many(struct mem_cgroup *memcg, unsigned int n);\n> -struct mem_cgroup *mem_cgroup_private_id_get_online(struct mem_cgroup *memcg);\n> +struct mem_cgroup *mem_cgroup_private_id_get_online(struct mem_cgroup *memcg,\n> +\t\t\t\t\t\t    unsigned int n);\n>  \n>  /* Cgroup v1-specific declarations */\n>  #ifdef CONFIG_MEMCG_V1\n> diff --git a/mm/memcontrol.c b/mm/memcontrol.c\n> index 007413a53b45..4425ef51feae 100644\n> --- a/mm/memcontrol.c\n> +++ b/mm/memcontrol.c\n> @@ -3564,13 +3564,7 @@ static void mem_cgroup_private_id_remove(struct mem_cgroup *memcg)\n>  \t}\n>  }\n>  \n> -void __maybe_unused mem_cgroup_private_id_get_many(struct mem_cgroup *memcg,\n> -\t\t\t\t\t   unsigned int n)\n> -{\n> -\trefcount_add(n, &memcg->id.ref);\n> -}\n> -\n> -static void mem_cgroup_private_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n> +static inline void mem_cgroup_private_id_put(struct mem_cgroup *memcg, unsigned int n)\n>  {\n>  \tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n>  \t\tmem_cgroup_private_id_remove(memcg);\n> @@ -3580,14 +3574,9 @@ static void mem_cgroup_private_id_put_many(struct mem_cgroup *memcg, unsigned in\n>  \t}\n>  }\n>  \n> -static inline void mem_cgroup_private_id_put(struct mem_cgroup *memcg)\n> +struct mem_cgroup *mem_cgroup_private_id_get_online(struct mem_cgroup *memcg, unsigned int n)\n>  {\n> -\tmem_cgroup_private_id_put_many(memcg, 1);\n> -}\n> -\n> -struct mem_cgroup *mem_cgroup_private_id_get_online(struct mem_cgroup *memcg)\n> -{\n> -\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n> +\twhile (!refcount_add_not_zero(n, &memcg->id.ref)) {\n>  \t\t/*\n>  \t\t * The root cgroup cannot be destroyed, so it's refcount must\n>  \t\t * always be >= 1.\n> @@ -3888,7 +3877,7 @@ static void mem_cgroup_css_offline(struct cgroup_subsys_state *css)\n>  \n>  \tdrain_all_stock(memcg);\n>  \n> -\tmem_cgroup_private_id_put(memcg);\n> +\tmem_cgroup_private_id_put(memcg, 1);\n>  }\n>  \n>  static void mem_cgroup_css_released(struct cgroup_subsys_state *css)\n> @@ -5170,19 +5159,15 @@ int __mem_cgroup_try_charge_swap(struct folio *folio, swp_entry_t entry)\n>  \t\treturn 0;\n>  \t}\n>  \n> -\tmemcg = mem_cgroup_private_id_get_online(memcg);\n> +\tmemcg = mem_cgroup_private_id_get_online(memcg, nr_pages);\n>  \n>  \tif (!mem_cgroup_is_root(memcg) &&\n>  \t    !page_counter_try_charge(&memcg->swap, nr_pages, &counter)) {\n>  \t\tmemcg_memory_event(memcg, MEMCG_SWAP_MAX);\n>  \t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n> -\t\tmem_cgroup_private_id_put(memcg);\n> +\t\tmem_cgroup_private_id_put(memcg, nr_pages);\n>  \t\treturn -ENOMEM;\n>  \t}\n> -\n> -\t/* Get references for the tail pages, too */\n> -\tif (nr_pages > 1)\n> -\t\tmem_cgroup_private_id_get_many(memcg, nr_pages - 1);\n>  \tmod_memcg_state(memcg, MEMCG_SWAP, nr_pages);\n>  \n>  \tswap_cgroup_record(folio, mem_cgroup_private_id(memcg), entry);\n> @@ -5211,7 +5196,7 @@ void __mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n>  \t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n>  \t\t}\n>  \t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n> -\t\tmem_cgroup_private_id_put_many(memcg, nr_pages);\n> +\t\tmem_cgroup_private_id_put(memcg, nr_pages);\n>  \t}\n>  \trcu_read_unlock();\n>  }\n> \n> ---\n> base-commit: 9fff1ab283e0982c2b8e73f1d2246fd38caf40c8\n> change-id: 20260213-memcg-privid-6ba2773b5ca2\n> \n> Best regards,\n\nReviewed-by: Chen Ridong <chenridong@huaweicloud.com>\n\n-- \nBest regards,\nRidong\n\n",
          "reply_to": ""
        },
        {
          "author": "Shakeel Butt",
          "summary": "Gave Acked-by",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Acked-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Fri, Feb 13, 2026 at 2:03â€¯AM Kairui Song <ryncsn@gmail.com> wrote:\n>\n> From: Kairui Song <kasong@tencent.com>\n>\n> We currently have two different sets of helpers for getting or putting\n> the private IDs' refcount for order 0 and large folios. This is\n> redundant. Just use one and always acquire the refcount of the swapout\n> folio size unless it's zero, and put the refcount using the folio size\n> if the charge failed, since the folio size can't change. Then there is\n> no need to update the refcount for tail pages.\n>\n> Same for freeing, then only one pair of get/put helper is needed now.\n>\n> The performance might be slightly better, too: both \"inc unless zero\"\n> and \"add unless zero\" use the same cmpxchg implementation. For large\n> folios, we saved an atomic operation. And for both order 0 and large\n> folios, we saved a branch.\n>\n> Signed-off-by: Kairui Song <kasong@tencent.com>\n\nAcked-by: Shakeel Butt <shakeel.butt@gmail.com>\n\n",
          "reply_to": ""
        }
      ],
      "analysis_source": "llm"
    }
  }
}