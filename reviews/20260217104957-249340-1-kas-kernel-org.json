{
  "thread_id": "20260217104957.249340-1-kas@kernel.org",
  "subject": "[PATCHv2 0/2] efi: Fix alignenment issues in unaccepted memory code",
  "url": "https://lore.kernel.org/all/20260217104957.249340-1-kas@kernel.org/",
  "dates": {
    "2026-02-19": {
      "report_file": "2026-02-19_ollama_llama3.1-8b.html",
      "developer": "Kiryl Shutsemau",
      "reviews": [
        {
          "author": "Kiryl (Meta) (author)",
          "summary": "The reviewer, Kiryl (Meta), pointed out alignment issues in the original patch and provided two new patches to fix these issues. The first patch fixes the reservation of the unaccepted memory table by calculating its end address first and then aligning it up to ensure the entire range is covered. The second patch aligns the start address down and the size up to the nearest page boundary before performing unit_size alignment checks, ensuring that the guard unit is correctly added when the range effectively ends on a unit boundary.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "The reserve_unaccepted() function incorrectly calculates the size of the\nmemblock reservation for the unaccepted memory table. It aligns the\nsize of the table, but fails to account for cases where the table's\nstarting physical address (efi.unaccepted) is not page-aligned.\n\nIf the table starts at an offset within a page and its end crosses into\na subsequent page that the aligned size does not cover, the end of the\ntable will not be reserved. This can lead to the table being overwritten\nor inaccessible, causing a kernel panic in accept_memory().\n\nThis issue was observed when starting Intel TDX VMs with specific memory\nsizes (e.g., > 64GB).\n\nFix this by calculating the end address first (including the unaligned\nstart) and then aligning it up, ensuring the entire range is covered\nby the reservation.\n\nFixes: 8dbe33956d96 (\"efi/unaccepted: Make sure unaccepted table is mapped\")\nReported-by: Moritz Sanft <ms@edgeless.systems>\nSigned-off-by: Kiryl Shutsemau (Meta) <kas@kernel.org>\n---\n drivers/firmware/efi/efi.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c\nindex 111e87a618e5..56e9d73412fa 100644\n--- a/drivers/firmware/efi/efi.c\n+++ b/drivers/firmware/efi/efi.c\n@@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,\n \n static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)\n {\n-\tphys_addr_t start, size;\n+\tphys_addr_t start, end;\n \n \tstart = PAGE_ALIGN_DOWN(efi.unaccepted);\n-\tsize = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\n+\tend = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted->size);\n \n-\tmemblock_add(start, size);\n-\tmemblock_reserve(start, size);\n+\tmemblock_add(start, end - start);\n+\tmemblock_reserve(start, end - start);\n }\n \n int __init efi_config_parse_tables(const efi_config_table_t *config_tables,\n-- \n2.51.2\n\n\n\n---\n\nThe accept_memory() and range_contains_unaccepted_memory() functions\nemploy a \"guard page\" logic to prevent crashes with load_unaligned_zeropad().\nThis logic extends the range to be accepted (or checked) by one unit_size\nif the end of the range is aligned to a unit_size boundary.\n\nHowever, if the caller passes a range that is not page-aligned, the\n'end' of the range might not be numerically aligned to unit_size, even\nif it covers the last page of a unit. This causes the \"if (!(end % unit_size))\"\ncheck to fail, skipping the necessary extension and leaving the next\nunit unaccepted, which can lead to a kernel panic when accessed by\nload_unaligned_zeropad().\n\nAlign the start address down and the size up to the nearest page\nboundary before performing the unit_size alignment check. This ensures\nthat the guard unit is correctly added when the range effectively ends\non a unit boundary.\n\nSigned-off-by: Kiryl Shutsemau (Meta) <kas@kernel.org>\n---\n drivers/firmware/efi/unaccepted_memory.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\ndiff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c\nindex c2c067eff634..4a8ec8d6a571 100644\n--- a/drivers/firmware/efi/unaccepted_memory.c\n+++ b/drivers/firmware/efi/unaccepted_memory.c\n@@ -35,14 +35,17 @@ void accept_memory(phys_addr_t start, unsigned long size)\n \tstruct efi_unaccepted_memory *unaccepted;\n \tunsigned long range_start, range_end;\n \tstruct accept_range range, *entry;\n-\tphys_addr_t end = start + size;\n \tunsigned long flags;\n+\tphys_addr_t end;\n \tu64 unit_size;\n \n \tunaccepted = efi_get_unaccepted_table();\n \tif (!unaccepted)\n \t\treturn;\n \n+\tend = PAGE_ALIGN(start + size);\n+\tstart = PAGE_ALIGN_DOWN(start);\n+\n \tunit_size = unaccepted->unit_size;\n \n \t/*\n@@ -160,15 +163,18 @@ void accept_memory(phys_addr_t start, unsigned long size)\n bool range_contains_unaccepted_memory(phys_addr_t start, unsigned long size)\n {\n \tstruct efi_unaccepted_memory *unaccepted;\n-\tphys_addr_t end = start + size;\n \tunsigned long flags;\n \tbool ret = false;\n+\tphys_addr_t end;\n \tu64 unit_size;\n \n \tunaccepted = efi_get_unaccepted_table();\n \tif (!unaccepted)\n \t\treturn false;\n \n+\tend = PAGE_ALIGN(start + size);\n+\tstart = PAGE_ALIGN_DOWN(start);\n+\n \tunit_size = unaccepted->unit_size;\n \n \t/*\n-- \n2.51.2\n\n",
          "reply_to": "",
          "message_date": ""
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "This patch series fixes two alignment issues in the EFI unaccepted memory code that can cause kernel panics in Intel TDX environments. The first patch ensures the entire page range covering the unaccepted memory table is reserved, and the second patch aligns memory acceptance requests to a page boundary before performing unit size alignment checks."
    },
    "2026-02-17": {
      "report_file": "2026-02-19_ollama_llama3.1-8b.html",
      "developer": "Kiryl Shutsemau",
      "reviews": [
        {
          "author": "Kiryl (Meta) (author)",
          "summary": "The author addressed a concern about the reserve_unaccepted() function incorrectly calculating the size of the memblock reservation for the unaccepted memory table, and explained that this can lead to kernel panics in accept_memory(). They proposed fixing this by first calculating the end address (including the unaligned start) and then aligning it up. A fix is planned.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a technical issue",
            "proposed a specific fix"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "The reserve_unaccepted() function incorrectly calculates the size of the\nmemblock reservation for the unaccepted memory table. It aligns the\nsize of the table, but fails to account for cases where the table's\nstarting physical address (efi.unaccepted) is not page-aligned.\n\nIf the table starts at an offset within a page and its end crosses into\na subsequent page that the aligned size does not cover, the end of the\ntable will not be reserved. This can lead to the table being overwritten\nor inaccessible, causing a kernel panic in accept_memory().\n\nThis issue was observed when starting Intel TDX VMs with specific memory\nsizes (e.g., > 64GB).\n\nFix this by calculating the end address first (including the unaligned\nstart) and then aligning it up, ensuring the entire range is covered\nby the reservation.\n\nFixes: 8dbe33956d96 (\"efi/unaccepted: Make sure unaccepted table is mapped\")\nReported-by: Moritz Sanft <ms@edgeless.systems>\nSigned-off-by: Kiryl Shutsemau (Meta) <kas@kernel.org>\n---\n drivers/firmware/efi/efi.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c\nindex 111e87a618e5..56e9d73412fa 100644\n--- a/drivers/firmware/efi/efi.c\n+++ b/drivers/firmware/efi/efi.c\n@@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,\n \n static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)\n {\n-\tphys_addr_t start, size;\n+\tphys_addr_t start, end;\n \n \tstart = PAGE_ALIGN_DOWN(efi.unaccepted);\n-\tsize = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\n+\tend = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted->size);\n \n-\tmemblock_add(start, size);\n-\tmemblock_reserve(start, size);\n+\tmemblock_add(start, end - start);\n+\tmemblock_reserve(start, end - start);\n }\n \n int __init efi_config_parse_tables(const efi_config_table_t *config_tables,\n-- \n2.51.2",
          "reply_to": "",
          "message_date": "2026-02-17"
        },
        {
          "author": "Kiryl (Meta) (author)",
          "summary": "The author addressed a concern about the alignment check in accept_memory() and range_contains_unaccepted_memory() functions, explaining that if the caller passes a non-page-aligned range, the 'end' of the range might not be numerically aligned to unit_size. The author proposed aligning the start address down and the size up to the nearest page boundary before performing the unit_size alignment check.",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "The accept_memory() and range_contains_unaccepted_memory() functions\nemploy a \"guard page\" logic to prevent crashes with load_unaligned_zeropad().\nThis logic extends the range to be accepted (or checked) by one unit_size\nif the end of the range is aligned to a unit_size boundary.\n\nHowever, if the caller passes a range that is not page-aligned, the\n'end' of the range might not be numerically aligned to unit_size, even\nif it covers the last page of a unit. This causes the \"if (!(end % unit_size))\"\ncheck to fail, skipping the necessary extension and leaving the next\nunit unaccepted, which can lead to a kernel panic when accessed by\nload_unaligned_zeropad().\n\nAlign the start address down and the size up to the nearest page\nboundary before performing the unit_size alignment check. This ensures\nthat the guard unit is correctly added when the range effectively ends\non a unit boundary.\n\nSigned-off-by: Kiryl Shutsemau (Meta) <kas@kernel.org>\n---\n drivers/firmware/efi/unaccepted_memory.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\ndiff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c\nindex c2c067eff634..4a8ec8d6a571 100644\n--- a/drivers/firmware/efi/unaccepted_memory.c\n+++ b/drivers/firmware/efi/unaccepted_memory.c\n@@ -35,14 +35,17 @@ void accept_memory(phys_addr_t start, unsigned long size)\n \tstruct efi_unaccepted_memory *unaccepted;\n \tunsigned long range_start, range_end;\n \tstruct accept_range range, *entry;\n-\tphys_addr_t end = start + size;\n \tunsigned long flags;\n+\tphys_addr_t end;\n \tu64 unit_size;\n \n \tunaccepted = efi_get_unaccepted_table();\n \tif (!unaccepted)\n \t\treturn;\n \n+\tend = PAGE_ALIGN(start + size);\n+\tstart = PAGE_ALIGN_DOWN(start);\n+\n \tunit_size = unaccepted->unit_size;\n \n \t/*\n@@ -160,15 +163,18 @@ void accept_memory(phys_addr_t start, unsigned long size)\n bool range_contains_unaccepted_memory(phys_addr_t start, unsigned long size)\n {\n \tstruct efi_unaccepted_memory *unaccepted;\n-\tphys_addr_t end = start + size;\n \tunsigned long flags;\n \tbool ret = false;\n+\tphys_addr_t end;\n \tu64 unit_size;\n \n \tunaccepted = efi_get_unaccepted_table();\n \tif (!unaccepted)\n \t\treturn false;\n \n+\tend = PAGE_ALIGN(start + size);\n+\tstart = PAGE_ALIGN_DOWN(start);\n+\n \tunit_size = unaccepted->unit_size;\n \n \t/*\n-- \n2.51.2",
          "reply_to": "",
          "message_date": "2026-02-17"
        },
        {
          "author": "Mike Rapoport",
          "summary": "Gave Acked-by",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Acked-by"
          ],
          "analysis_source": "heuristic",
          "raw_body": "",
          "reply_to": "Kiryl (Meta)",
          "message_date": "2026-02-17"
        },
        {
          "author": "Tom Lendacky",
          "summary": "Gave Reviewed-by",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "heuristic",
          "raw_body": "",
          "reply_to": "Kiryl (Meta)",
          "message_date": "2026-02-17"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch series addresses two issues related to unaligned physical addresses and sizes in EFI unaccepted memory handling, which can cause kernel panics in Intel TDX environments. The patches fix the reservation of the unaccepted memory table itself and ensure that memory acceptance requests are page-aligned before performing unit_size alignment checks, preventing crashes due to missing 'guard page' extensions."
    }
  }
}