{
  "thread_id": "aZjxP2sTavBRGC1l@linux.dev",
  "subject": "Re: [RFC PATCH v2 0/5] mm/swap, memcg: Introduce swap tiers for cgroup based swap control",
  "url": "https://lore.kernel.org/all/aZjxP2sTavBRGC1l@linux.dev/",
  "dates": {
    "2026-02-11": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Shakeel Butt",
      "reviews": [
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the swap_tier structure was simplified by replacing 'end prio' and priority lists with a standard list_head, as requested in v2.\n\nReviewer Chris Li suggested breaking down the patch series into smaller, incremental steps, starting with defining the tiers bits without deletion, and then building upon that in subsequent steps.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledgment of patch changes",
            "requested changes",
            "suggested incremental development"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi Youngjun,\n\nOn Sun, Jan 25, 2026 at 10:53 PM Youngjun Park <youngjun.park@lge.com> wrote:\n\n---\n\nThanks for the patches series.\n\nSorry for the late reply. I have been wanting to reply to it but get\nsuper busy at work.\n\nSome high level feedback for the series. Now that you demonstrated the\nwhole series, let's focus on making small mergiable baby steps. Just\nlike the swap table has different phases. Make each step minimal, each\nstep shows some value. Do the MVP, we can always add more features as\na follow up step.\n\nI suggest the first step is getting the tiers bits defined. Add only,\nno delete.  Get that reviewed and merged, then the next step is to use\nthose tiers.\n\nChris",
          "reply_to": "Youngjun Park",
          "message_date": "2026-02-11"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li suggested replacing per-cpu per-swap-device cluster allocation with a global percpu cluster per tier, citing that the maximum number of tiers is smaller than the maximum number of swap devices and expecting this change to be beneficial.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "One idea is that, instead of using percpu per swap device.\nYou can make the global percpu cluster per tier. Because the max tier\nnumber is smaller than the max number of swap devices. That is likely\na win.\n\nChris",
          "reply_to": "Youngjun Park",
          "message_date": "2026-02-11"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-12": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Shakeel Butt",
      "reviews": [
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the patch does not handle the case where a child cgroup re-enables a tier with '+' that was excluded by its parent, and requested that the effective tier list be limited to the parent's allowed subset.\n\nReviewer Chris Li suggested introducing a CONFIG option to limit the maximum number of swap tiers, recommending a default value of 4.\n\nReviewer Chris Li noted that when modifying a tier, if swap files are moved to a different tier, it could cause issues, and requested further consideration of this scenario.\n\nReviewer Chris Li expressed concern about the complexity of the patch, specifically the need for save and restore operations, and requested a simpler design.\n\nReviewer Chris Li suggested that each tier have its own swap_active_head, so different swap entries on different tiers do not compete for the same resource, and proposed that swapfiles should not be allowed to switch between tiers.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "complexity"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi Yongjun,\n\nOn Sun, Jan 25, 2026 at 10:53 PM Youngjun Park <youngjun.park@lge.com> wrote:\n\n---\n\nWe can have a CONFIG option for the MAX_SWAPTIER. I think the default\nshould be a small number like 4.\n\n---\n\nWhen we add, modify, remove a tier. The simple case is there is no\nswap file under any tiers.\nBut if the modification causes some swap files to jump to different\ntiers. That might be problematic.\n\n---\n\nI really hope we don't have to do the save and restore thing. Is there\nanother design we can simplify this?\n\n---\n\nOne idea is to make each tier have swap_active_head. So different swap\nentry releases on different tiers don't need to be competing on the\nsame swap_active_head.\n\nThat will require the swapfile don't jump to another tiers.\n\nChris",
          "reply_to": "Youngjun Park",
          "message_date": "2026-02-12"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li initially suggested that adding tier names would be beneficial, but after reevaluating the patch series, he took back his suggestion and stated that looking at the whole series is necessary rather than just focusing on the tier name.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "reconsidered opinion",
            "need to look at the whole series"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Just take a quick look at the series. I take that suggestion back.\nThis series is actually not too long. Adding the tiers name alone does\nnot add any real value. I actually need to look at the whole series\nrather than just the tier name alone.\n\nChris",
          "reply_to": "",
          "message_date": "2026-02-12"
        },
        {
          "author": "Nhat Pham",
          "summary": "Reviewer Nhat Pham questioned the consistency of the patch description, pointing out that the '+' operator was removed but its mention in the text seemed unnecessary.\n\nReviewer Nhat Pham questioned the logic of restricting child cgroup's allowed swap tiers to be a subset of their children and ancestors, suggesting an alternative approach as more straightforward.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "questioning inconsistency",
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "This comment seems a bit clunky to me. The \"+\" is removed, as noted\nabove, but then why are we saying \"even if a child re-enables a tier\nwith \"+\"\" here? Am I missing something?\n\n---\n\nBut otherwise, I assume you mean to restrict child's allowed swap\ntiers to be a subset of children and its ancestors? That seems more\nstraightforward to me than the last system :)",
          "reply_to": "Youngjun Park",
          "message_date": "2026-02-12"
        },
        {
          "author": "Shakeel Butt",
          "summary": "Reviewer Shakeel Butt noted that the patch does not handle the case where a swap tier is removed while it still has active swap devices, which could lead to swap devices being left in an inconsistent state.\n\nReviewer Shakeel Butt expressed concerns that adding a memcg interface for swap tier functionality is premature, suggesting exploration of BPF as an alternative approach.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "suggested alternative"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi Youngjun,\n\nOn Mon, Jan 26, 2026 at 03:52:37PM +0900, Youngjun Park wrote:\n\n---\n\nOne of the LPC feedback you missed is to not add memcg interface for\nthis functionality and explore BPF way instead.\n\nWe are normally very conservative to add new interfaces to cgroup.\nHowever I am not even convinced that memcg interface is the right way to\nexpose this functionality. Swap is currently global and the idea to\nlimit or assign specific swap devices to specific cgroups makes sense\nbut that is the decision for the job orchestator or node controller.\nAllowing workloads to pick and choose swap devices do not make sense to\nme.\n\nShakeel",
          "reply_to": "Youngjun Park",
          "message_date": "2026-02-12"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-13": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Shakeel Butt",
      "reviews": [
        {
          "author": "YoungJun Park (author)",
          "summary": "Author addressed Chris Li's feedback about breaking the patch series into smaller, mergeable steps by proposing a modified roadmap to ensure immediate value is demonstrated in Step 1.",
          "sentiment": "positive",
          "sentiment_signals": [
            "agreed",
            "proposed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Hi Chris,\n\nThank you for the direction.\n\nI agree that breaking the series into smaller, mergeable steps is the\nright approach. However, since introducing the definitions alone might\nlack immediate usage, I propose a slightly\nmodified roadmap to ensure Step 1 demonstrates some value.\n\nHere is the plan I have in mind.\n\n1. Swap Tier Definition & Addition\n   - Introduce the concept, grouping logic, and the 'add' interface.\n   - Value: Enables basic exception handling within the swap device\n     itself using tiers.\n\n2. Advanced Control (Delete/Modify)\n   - Implement logic to remove or update tiers.\n   - Value: Enhances the usability and management of the tiers\n     established in Step 1.\n\n3. External Integration (memcg, bpf etc ... )\n   - Apply swap tiers for broader swap control.\n   - Value: Connects swap tiers to other subsystems like memcg.\n\nDoes this roadmap look reasonable to you? I will proceed with preparing\nthe real patch series based on this structure.\n\nBest regards,\nYoungjun",
          "reply_to": "Chris Li",
          "message_date": "2026-02-13"
        },
        {
          "author": "YoungJun Park (author)",
          "summary": "Author acknowledged the need to limit swapfile size by adding a CONFIG option, agreeing to address this concern in the patch.\n\nAuthor addressed Chris Li's feedback about handling mixed operations in the swap tier interface, proposing to restrict it to single operations and considering alternative approaches such as global clone tiers.\n\nAuthor acknowledged that limiting contention to objects within the same tier is beneficial and agreed with the approach, but did not explicitly state if they plan to address this issue in a future patch.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged",
            "agreed",
            "acknowledged a fix is needed",
            "proposed an alternative approach",
            "think"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Sounds good. I will add a CONFIG option for it and ensure it doesn't exceed\nMAX_SWAPFILE.\n\n---\n\nI have given this a lot of thought.\n\nSince the current interface allows mixing add (+), remove (-), and modify\noperations, we must either restore from a saved state or reverse the\nsuccessful individual operations upon failure.\n\nI implemented both approaches and concluded that reversing individual\noperations is error-prone. Also, it could be slow if there are many\noperations.\n\nAnother approach could be using a \"global clone tier\" strategy.\n(Because operation globally synchronized)\n\nTherefore, I would like to propose restricting the interface to handle a\nsingle operation at a time. What do you think?\n\n---\n\nI agree. With the tier structure, we can limit contention to objects within\nthe same tier.\n\nI also think swap_avail_list could be optimized in a similar way in the\nfuture.\n\nYoungjun",
          "reply_to": "Chris Li",
          "message_date": "2026-02-13"
        },
        {
          "author": "YoungJun Park (author)",
          "summary": "Author acknowledges that stripping out the remove/modify parts from the patch is a viable direction, indicating a willingness to revise the patch based on reviewer feedback.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "willingness to revise"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Oops, I replied to your previous email before seeing this one.\n\nStripping out the remove/modify parts is also feasible. Do you agree with\nthat direction?\n\nYoungjun",
          "reply_to": "Chris Li",
          "message_date": "2026-02-13"
        },
        {
          "author": "YoungJun Park (author)",
          "summary": "The author clarified the meaning of '+' in the swap tiers configuration, explaining it switches to an exclusive mode where only that specific tier is used, and changing the model to a subtraction-based one where all tiers are selected by default and users use '-' to exclude specific ones.\n\nAuthor acknowledged Nhat Pham's feedback and agreed to restructure the swapoff path in v2 to drop the per-vswap spinlock before calling try_to_unmap().",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation",
            "acknowledged",
            "agreed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "To clarify, previously, the default state used all tiers. Using \"+\"              \nswitched to \"an exclusive mode\"  where only that specific tier was used.         \n                                                                                 \nI am changing this to a subtraction-based model. By default, all tiers           \nare selected, and users use \"-\" to exclude specific ones.                        \n(Then not \"removed\" but \"changed\" is more proper?)                               \n                                                                                 \nIn this context, I intended \"+\" to be used to restore a tier that was            \npreviously excluded by \"-\".\n\n---\n\nYes, that's right :)\n\nThanks \nYoungjun Park.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-13"
        },
        {
          "author": "YoungJun Park (author)",
          "summary": "Author addressed Shakeel Butt's concern about using the BPF approach for swap control, agreeing it would provide flexibility but expressing concerns about logical contradictions and potential conflicts with cgroup hierarchy semantics. The author suggests implementing a native interface instead of relying on constrained BPF hooks.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a fix is needed",
            "expressed concerns"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Apologies for overlooking the feedback regarding the BPF approach. Thank you\nfor the suggestion.\n\nI agree that using BPF would provide greater flexibility, allowing control not\njust at the memcg level, but also per-process or for complex workloads.\n(As like orchestrator and node controller)\n\nHowever, I am concerned that this level of freedom might introduce logical\ncontradictions, particularly regarding cgroup hierarchy semantics.\n\nFor example, BPF might allow a topology that violates hierarchical constraints\n(a concern that was also touched upon during LPC)\n\n  - Group A (Parent): Assigned to SSD1\n  - Group B (Child of A): Assigned to SSD2\n\nIf Group A has a `memory.swap.max` limit, and Group B swaps out to SSD2, it\ncreates a consistency issue. Group B consumes Group A's swap quota, but it is\nutilizing a device (SSD2) that is distinct from the Parent's assignment. This\ncould lead to situations where the Parent's limit is exhausted by usage on a\ndevice it effectively doesn't \"own\" or shouldn't be using.\n\nOne might suggest restricting BPF to strictly adhere to these hierarchical\nconstraints. However, doing so would effectively eliminate the primary\nadvantage of using BPF\\u2014its flexibility. If we are to enforce standard cgroup\nsemantics anyway, a native interface seems more appropriate than a constrained\nBPF hook.\n\nBeyond this specific example, I suspect that delegating this logic to BPF\nmight introduce other unforeseen edge cases regarding hierarchy enforcement.\nIn my view, the BPF approach seems more like a \"next step.\"\n\nSince you acknowledged that the idea of assigning swap devices to cgroups\n\"makes sense,\" I believe implementing this within the standard, strictly\nconstrained \"cgroup land\" is preferable. \n\nA strict cgroup interface ensures\nthat hierarchy and accounting rules are consistently enforced, avoiding the\npotential conflicts that the unrestricted freedom of BPF might create.\n\nUltimately, I hope this swap tier mechanism can serve as a foundation to be\nleveraged by other subsystems, such as BPF and DAMON. I view this proposal as\nthe necessary first step toward that future.\n\nYoungjun Park",
          "reply_to": "Shakeel Butt",
          "message_date": "2026-02-13"
        },
        {
          "author": "YoungJun Park (author)",
          "summary": "The author acknowledged that existing swapfiles' tier is immutable once assigned and explained how they ensured this invariant by removing tier reference, using operation validation instead of reference counting.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged a technical issue",
            "provided an explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I missed one comment. \n\nThe tier of existing swapfiles is immutable once assigned at swapon.\nI removed tier reference.\nInstead of reference counting, each operation validates the tier\nrange at operation time to guarantee this invariant.\n\n- add:    Does not change existing swapfiles' tier. New tier may\n          split priority range, but existing assignments stay.\n- remove: Rejected with -EBUSY if any swapfile is attached.\n- modify: Rejected if the change would cause any swapfile to\n          move to a different tier.\n\nSo swapfiles never jump between tiers at runtime.\n\nYoungjun Park",
          "reply_to": "Chris Li",
          "message_date": "2026-02-13"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-20": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Shakeel Butt",
      "reviews": [
        {
          "author": "Shakeel Butt",
          "summary": "Reviewer Shakeel Butt requested that further discussion be concluded on the previous version of the patch series before a new version is sent.\n\nReviewer Shakeel Butt expressed concerns about introducing stable interfaces for swap tiers, requesting a BPF approach first and questioning the need for hierarchical control.\n\nReviewer Shakeel Butt noted that while BPF offers more power, its control is limited to administrators who can still make mistakes.\n\nReviewer Shakeel Butt requested additional information about the patch's use-case, specifically asking for details on workload ordering and partitioning of swap devices among sub-workloads.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "lack of technical feedback",
            "requested changes",
            "uncertainty",
            "no clear signal",
            "requested clarification",
            "wanted to brainstorm future use-cases"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Please don't send a new version of the series before concluding the discussion\non the previous one.\n\nOn Fri, Feb 13, 2026 at 12:58:40PM +0900, YoungJun Park wrote:\n\n---\n\nYes it provides the flexibility but that is not the main reason I am pushing for\nit. The reason I want you to first try the BPF approach without introducing any\nstable interfaces. Show how swap tiers will be used and configured in production\nenvironment and then we can talk if a stable interface is needed. I am still not\nconvinced that swap tiers need to be controlled hierarchically and the non-root\nshould be able to control it.\n\n---\n\nYes BPF provides more power but it is controlled by admin and admin can shoot\ntheir foot in multiple ways.\n\n---\n\nNo need to constraint anything.\n\nTaking a step back, can you describe your use-case a bit more and share\nrequirements?\n\nYou have multiple swap devices of different properties and you want to assign\nthose swap devices to different workloads. Now couple of questions:\n\n1. If more than one device is assign to a workload, do you want to have\n   some kind of ordering between them for the worklod or do you want option to\n   have round robin kind of policy?\n\n2. What's the reason to use 'tiers' in the name? Is it similar to memory tiers\n   and you want promotion/demotion among the tiers?\n\n3. If a workload has multiple swap devices assigned, can you describe the\n   scenario where such workloads need to partition/divide given devices to their\n   sub-workloads?\n\nLet's start with these questions. Please note that I want us to not just look at\nthe current use-case but brainstorm more future use-cases and then come up with\nthe solution which is more future proof.\n\nthanks,\nShakeel",
          "reply_to": "YoungJun Park",
          "message_date": "2026-02-20"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li expressed concern that Shakeel Butt hadn't responded to YoungJun Park's previous response, potentially leading to confusion about whether the discussion was concluded.\n\nReviewer Chris Li suggested that instead of addressing the issue directly, a config option could be added to protect the problematic behavior and mark it as experimental, allowing for further testing and feedback.\n\nReviewer Chris Li confirmed that their company uses a different swap device at different cgroup levels, emphasizing the practical need for control at non-root levels.\n\nChris Li noted that the swap device control introduced in this patch is a basic need and generic, similar to zswap.writeback, but not as limited, and suggested that the interface can be improved in future iterations.\n\nChris Li mentioned that he couldn't recall a specific thread on linux-mm mailing list, but offered to share their usage requirement for cgroup swapfile control interface as an alternative solution.\n\nReviewer Chris Li noted that swap tier allocation is dependent on the number of devices within each tier, and suggested using a round-robin approach to distribute swap operations across devices within the same tier.\n\nReviewer Chris Li suggested alternative names for the tier concept, proposing 'swap.device_speed_classes' and acknowledging that the current name is inspired by memory tiers.\n\nReviewer Chris Li noted that their deployment uses multiple swap devices to reduce lock contention and requested consideration for tiering based on job configuration's tolerated swap speed.\n\nReviewer Chris Li expressed a neutral sentiment, suggesting that instead of designing for future-proofing, it's better to start from the current need and make incremental improvements. He used zswap.writeback as an example of a solution that worked for its specific requirement.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "concern",
            "potential confusion",
            "requested changes",
            "suggested alternative solution",
            "acknowledgment of real-world use case",
            "NEEDS_WORK",
            "lack of technical detail",
            "offering alternative solution",
            "suggested alternative names",
            "acknowledged inspiration",
            "consideration_for_tiering",
            "incremental progress is better",
            "starting from the current need is a solid starting point"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "In this case I think it is fine.  You haven't responded to YoungJun's\nlast response in over a week. He might have mistaken that the\ndiscussion concluded.\nConsider it is one of the iterations. It is hard enough to contribute\nto the kernel. Relax.\nPlus, much of the discussion on the mailing list always has differing\nopinions. So, it's hard to determine what is truly concluded.\nDifferent people might have different interitations of the same text.\n\n---\n\nIs that your biggest concern? Many different ways exist to solve that\nproblem. e.g. We can put a config option protecting it and mark it as\nexperimental. This will unblock the development allow experiment. We\ncan have more people to try it out and give feedback.\n\n---\n\nYes, my company uses a different swap device at different cgroup\nlevel. I did ask my coworker to confirm that usage. Control at the non\nroot level is a real need.\n\n---\n\nI think this swap device control is a very basic need. All your\nobjections to swapping control in the group can equally apply to\nzswap.writeback. Unlike zswap.writeback, which only control from the\nzswap behavior. This is a more generic version control swap device\nother than zswap as well. BTW, I raised that concern about\nzswap.writeback was not generic enough as swap control was limited\nwhen zswap was proposed. We did hold back zswap.writeback. The\nconsensers is interface can be improved as later iterations. So here\nwe are.\n\n---\n\nThere is a very long thread on the linux-mm maillist. I'm too lazy to dig it up.\n\nI can share our usage requirement to refresh your memory. We\ninternally use a cgroup swapfile control interface that has not been\nupstreamed. With this we can remove the need of that internal\ninterface and go upstream instead.\n\n---\n\nIt depends on the number of devices in the tiers. Different tiers\nmaintain an order. Within the same tier round robin.\n\n---\n\nI propose the tier name. Guilty. Yes, in was inpired by memory tiers.\nIt just different class of swap speeds. I am not fixed on the name. We\ncan also call it swap.device_speed_classes. You can suggest\nalternatives.\n\nPromotion / demotion is possible in the future. The current state,\nwithout promotion or demotion, already provides value. Our current\ndeployment uses only one class of swap device at a time. However I do\nknow other companies use  more than one class of swap device.\n\n---\n\nIn our deployment, we always use more than one swap device to reduce\nswap device lock contention.\nThe job config can describe the swap speed it can tolerate. Some jobs\ncan tolerate slower speeds, while others cannot.\n\n---\n\nTake zswap.writeback as example. We have a solution that worked for\nthe requirement at that time. Incremental improvement is fine as well.\nUsually, incremental progress is better. At least currently there is a\nreal need to allow different cgroups to select different swap speeds.\nThere is a risk in being too future-proof: we might design things that\npeople in the future don't use as we envisioned. I see that happen too\noften as well.\n\nSo starting from the current need is a solid starting point. It's just\na different design philosophy. Each to their own.\n\nThat is the only usage case I know. YoungJun feel free to add yours\nusage as well.\n\nChris",
          "reply_to": "Shakeel Butt",
          "message_date": "2026-02-20"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-21": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Shakeel Butt",
      "reviews": [
        {
          "author": "YoungJun Park (author)",
          "summary": "Author acknowledges that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agrees to restructure in v2\n\nAuthor acknowledged a concern about committing to a stable interface too early and proposed reducing this risk by adding a build-time config option or marking it as experimental, but also expressed uncertainty about the need for a memcg interface if BPF becomes primary.\n\nAuthor acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), but did not explicitly state a plan for addressing this issue in v2.\n\nAuthor suggests that adding build-time config or runtime constraints would improve predictability of swap tier feature\n\nThe author is addressing Shakeel Butt's concern about the patch's ability to handle complex use cases beyond their own simple use case. The author explains that they initially suggested per-cgroup swap device priorities but later pivoted to the 'swap tier' mechanism proposed by Chris Li, which only handles their specific use case of assigning different swap devices to different workloads (cgroups).\n\nAuthor addressed Shakeel Butt's concern about how swap devices are ordered when they have the same priority within a tier, explaining that round-robin ordering is used in this case.\n\nAuthor acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2, but did not provide a clear resolution signal.\n\nAuthor acknowledged the need to reduce lock contention in swap device allocation, suggesting a possible solution of partitioning devices between parent and child cgroups.\n\nAuthor addressed Shakeel Butt's concern about the patch's long-term maintainability by suggesting that it is premature to design a stable interface for future use cases, and instead proposes guarding the memcg & tier behind a CONFIG option to allow for flexibility in the future.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a fix is needed",
            "agreed to restructure",
            "uncertainty",
            "concerns",
            "acknowledged a concern",
            "did not promise a fix",
            "clarification",
            "explaining",
            "explanation",
            "acknowledged",
            "agreed",
            "possible scenario",
            "acknowledges need for further work",
            "proposes temporary solution"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Understood. Let's continue the discussion. :D\n\nChris has already provided a thorough response, but I would like to\nadd my perspective as well.\n\n---\n\nI understand your concern about committing to a stable interface too\nearly. As Chris suggested, we could reduce this concern by guarding\nthe interface behind a build-time config option or marking it as\nexperimental, which I will also touch on further below.\n\nOn that note, if BPF were to become the primary control mechanism,\nI am not sure a memcg interface would still be needed at all, since\nBPF already provides a high degree of freedom. However, that level\nof freedom is also what concerns me -- BPF-driven swap device\nassignments could subtly conflict with memcg hierarchy semantics in\nways that are hard to predict or debug. A more constrained memcg-based\napproach might actually be safer in that regard.\n\n---\n\nI think this concern is closely tied to your question #3 below about\nconcrete use cases for partitioning devices across sub-workloads.\nI hope my answer there helps clarify this.\n\n---\n\nAs I mentioned above, I think guarding the feature behind a build-time\nconfig or runtime constraints could keep the usage well-defined and\npredictable, while still being useful.\n\n---\n\nOur use case is simple at now. \nWe have two swap devices with different performance\ncharacteristics and want to assign different swap devices to different\nworkloads (cgroups).\n\nFor some background, when I initially proposed this, I suggested allowing\nper-cgroup swap device priorities so that it could also accommodate the\nbroader scenarios you mentioned. However, since even our own use case\ndoes not require reversing swap priorities within a cgroup, we pivoted\nto the \"swap tier\" mechanism that Chris proposed.\n\n---\n\nBoth. If devices are in the same tier with the same priority, round robin.\nIf they are in the same tier with different priorities, or in different\ntiers, ordering applies. The current tier structure should be able to\nsatisfy either preference.\n\n---\n\nThis was originally Chris's idea. I think he explained the rationale\nwell in his reply.\n\n---\n\nOne possible scenario is reducing lock contention by partitioning swap\ndevices between parent and child cgroups.\n\n---\n\nWe have clear production use cases from both us and Chris, and I also\npresented a deployment example in the cover letter.\n\nI think it is hard to design concretely for future use cases at this\npoint. When those needs become clearer, BPF with its flexibility\nwould be a better fit then. I see BPF as a natural extension path\nrather than a starting point.\n\nFor now, guarding the memcg & tier behind a CONFIG option would\nlet us move forward without committing to a stable interface, and\nwe can always pivot to BPF later if needed\n\nThanks,\nYoungJun Park",
          "reply_to": "Shakeel Butt",
          "message_date": "2026-02-21"
        },
        {
          "author": "Shakeel Butt",
          "summary": "Reviewer Shakeel Butt expressed concerns that the patch does not address the primary use-case of controlling/partitioning swap devices among sub-workloads and requested further exploration before adding a stable API.\n\nReviewer Shakeel Butt questioned whether the patch's concept of swap tiers is a new innovation or simply reusing an existing interface, specifically referencing Google's prodkernel team's past work on per-cgroup swapfiles and zswap.\n\nReviewer Shakeel Butt expressed skepticism about the introduction of a new swap tier interface without a clear use case, indicating that it motivates him to push back harder on the patch.\n\nReviewer Shakeel Butt questioned the practicality of hierarchical swap device control, specifically asking for a real-world use case to justify this feature.\n\nReviewer Shakeel Butt noted that having multiple swap devices reduces lock contention, but this does not address hierarchical control of swap devices among sub-workloads.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "concerns",
            "questioning",
            "uncertainty",
            "skepticism",
            "pushback",
            "lacking concrete evidence or justification"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "No, that is secondary because I am not seeing the real use-case of\ncontrolling/partitioning swap devices among sub-workloads. Until that is\nfigured out, adding a stable API is not good.\n\n---\n\nI am assuming you meant Google and particularly Prodkernel team and not\nAndroid or ChromeOS. Google's prodkernel used to have per-cgroup\nswapfiles exposed through memory.swapfiles (if I remember correctly\nSuleiman implemented this along with ghost swapfiles). Later this was\ndeprecated (by Yu Zhao) and global (ghost) swapfiles were being used.\nThe memory.swapfiles interface instead of supporting real swapfiles\nstarted having select options among default, ghost/zswap and real\n(something like that). However such interface was used to just disable\nor enable zswap for a workload and never about hierarchically\ncontrolling the swap devices (Google prodkernel only have zswap). Has\nsomething changed?\n\n---\n\nThis just motivates me to pushback even harder on adding a new interface\nwithout a clear use-case.\n\n---\n\nI already asked above but let me say it again. What's the actual real\nworld use-case to control/allow/disallow swap devices hierarchically?\n\n---\n\nHaving more than one swap devices to reduce lock contention is unrelated\nto hierarchically control swap devices among sub-workloads.",
          "reply_to": "Chris Li",
          "message_date": "2026-02-21"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-22": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Shakeel Butt",
      "reviews": [
        {
          "author": "YoungJun Park (author)",
          "summary": "Author is addressing concerns about the BPF-first approach, specifically questioning its feasibility in an embedded environment and asking for clarification on precedents of BPF prototypes graduating to stable interfaces.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "author is seeking clarification",
            "author is expressing uncertainty"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "....\n\nAfter reading the reply and re-think more of it.\n\nI have a few questions regarding the BPF-first approach you\nsuggested, if you don't mind. Some of them I am re-asking\nbecause I feel they have not been clearly addressed yet.\n\n- We are in an embedded environment where enabling additional\n  kernel compile options is costly. BPF is disabled by\n  default in some of our production configurations. From a\n  trade-off perspective, does it make sense to enable BPF\n  just for swap device control?\n\n- You suggest starting with BPF and discussing a stable\n  interface later. I am genuinely curious, are there actual\n  precedents where a BPF prototype graduated into a stable\n  kernel interface? \n\n- You raised that stable interfaces are hard to remove. Would\n  gating it behind a CONFIG option or marking it experimental\n  be an acceptable compromise?\n\n- You already acknowledged the use-case for assigning\n  different swap devices to different workloads. Your\n  objection is specifically about hierarchical parent-child\n  partitioning. If the interface enforced uniform policy\n  within a subtree, would that be acceptable?\n\n- We already run a modified kernel with internal swap control\n  in production and have real feedback from it. Requiring BPF\n  as a prerequisite to gather production experience seems\n  unnecessary when we are already doing that.\n\nTo be honest, I am having trouble understanding the motivation\nbehind the BPF-first validation approach. If the real point is\nthat BPF enables more flexible swap-out policies than any fixed\ninterface can, that would make much more sense to me. I would\nappreciate it if you could share more on this.\n\nThanks,\nYoungjun Park",
          "reply_to": "Shakeel Butt",
          "message_date": "2026-02-22"
        },
        {
          "author": "Shakeel Butt",
          "summary": "Reviewer noted that the patch does not handle the case where a child cgroup re-enables a tier excluded by its parent, and requested that the effective tier list be limited to the intersection of the parent's allowed subset.\n\nReviewer Shakeel Butt requested additional information about the cgroup hierarchy structure of the reviewer's deployment, specifically asking if they use cgroup v1 or v2 in their production environment.\n\nReviewer Shakeel Butt questioned whether the proposed 'Swap Tiers' concept is identical to existing swap priority behavior and requested clarification on this point.\n\nReviewer Shakeel Butt requested that the patch authors gather all options and their pros/cons before making an informed decision, indicating a need for further discussion.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "lack of technical disagreement",
            "request for clarification",
            "questioning",
            "further discussion"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi YoungJun,\n\nI see you have sent a separate email on BPF specific questions to which I will\nrespond separately, here I will respond to other questions/comments.\n\nOn Sat, Feb 21, 2026 at 11:30:59PM +0900, YoungJun Park wrote:\n\n---\n\nIf you don't mind, can you share a bit more about the cgroup hierarchy structure\nof your deployment. Do you use cgroup v1 or v2 on your production environment?\n\n---\n\nI assume this is the same swap priorities as of today, right? You want similar\npriority behavior within a tier.\n\n---\n\nI think your use-case is very clear. Before committing to any options, I want us\nto brainstorm all options and gather pros/cons and then make an informed\ndecision. Anyways I will respond to your other email (in a day or two).\n\nShakeel",
          "reply_to": "YoungJun Park",
          "message_date": "2026-02-22"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    }
  }
}