<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH v3 1/4] open: new O_REGULAR flag support</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH v3 1/4] open: new O_REGULAR flag support</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/19c990e9bf42cdc9c7b9bef5f4407fce30d35e54.camel@kernel.org/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-18">2026-02-18</a> &bull; <a href="#2026-01-29">2026-01-29</a> &bull; <a href="#2026-01-28">2026-01-28</a> &bull; <a href="#2026-01-27">2026-01-27</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-01-27">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Jeff Layton</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-27">2026-01-27</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer pointed out that the patch is missing handling for -&gt;atomic_open() and suggested adding patches to make it return -EINVAL if O_REGULAR is set. He also provided additional context about SMB2, NFS, and POSIX flags.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; This is useful to write secure programs that want to avoid being tricked
&gt; into opening device nodes with special semantics while thinking they
&gt; operate on regular files.
&gt; 
&gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; will return -ENOTREG.
&gt; 
&gt; When used in combination with O_CREAT, either the regular file is
&gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; file. Otherwise, -ENOTREG is returned.
&gt; 
&gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; is both a directory and a regular file.
&gt; 
&gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; ---
&gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt;  fs/fcntl.c                                 | 2 +-
&gt;  fs/namei.c                                 | 6 ++++++
&gt;  fs/open.c                                  | 4 +++-
&gt;  include/linux/fcntl.h                      | 2 +-
&gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; 
&gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; @@ -127,4 +127,6 @@
&gt;  
&gt;  #define EHWPOISON	139	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		140	/* Not a regular file */
&gt; +
&gt;  #endif
&gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; @@ -34,6 +34,7 @@
&gt;  
&gt;  #define O_PATH		040000000
&gt;  #define __O_TMPFILE	0100000000
&gt; +#define O_REGULAR	0200000000
&gt;  
&gt;  #define F_GETLK		7
&gt;  #define F_SETLK		8
&gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; index c01ed91b1ef4..293c78777254 100644
&gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; @@ -126,6 +126,8 @@
&gt;  
&gt;  #define EHWPOISON	168	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		169	/* Not a regular file */
&gt; +
&gt;  #define EDQUOT		1133	/* Quota exceeded */
&gt;  
&gt;  
&gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; index 8cbc07c1903e..442917484f99 100644
&gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; @@ -124,4 +124,6 @@
&gt;  
&gt;  #define EHWPOISON	257	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		258	/* Not a regular file */
&gt; +
&gt;  #endif
&gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; index 03dee816cb13..0cc3320fe326 100644
&gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; @@ -19,6 +19,7 @@
&gt;  
&gt;  #define O_PATH		020000000
&gt;  #define __O_TMPFILE	040000000
&gt; +#define O_REGULAR	0100000000
&gt;  
&gt;  #define F_GETLK64	8
&gt;  #define F_SETLK64	9
&gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; @@ -117,4 +117,6 @@
&gt;  
&gt;  #define EHWPOISON	135	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		136	/* Not a regular file */
&gt; +
&gt;  #endif
&gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; @@ -37,6 +37,7 @@
&gt;  
&gt;  #define O_PATH		0x1000000
&gt;  #define __O_TMPFILE	0x2000000
&gt; +#define O_REGULAR	0x4000000
&gt;  
&gt;  #define F_GETOWN	5	/*  for sockets. */
&gt;  #define F_SETOWN	6	/*  for sockets. */
&gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; --- a/fs/fcntl.c
&gt; +++ b/fs/fcntl.c
&gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt;  	 * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt;  	 * is defined as O_NONBLOCK on some platforms and not on others.
&gt;  	 */
&gt; -	BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; +	BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt;  		HWEIGHT32(
&gt;  			(VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt;  			__FMODE_EXEC));
&gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; --- a/fs/namei.c
&gt; +++ b/fs/namei.c
&gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt;  		if (unlikely(error))
&gt;  			return error;
&gt;  	}
&gt; +
&gt; +	if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; +		return -ENOTREG;
&gt; +
&gt;  	if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt;  		return -ENOTDIR;
&gt;  
&gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt;  	struct path path;
&gt;  	int error = path_lookupat(nd, flags, &amp;path);
&gt;  	if (!error) {
&gt; +		if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; +			return -ENOTREG;
&gt;  		audit_inode(nd-&gt;name, path.dentry, 0);
&gt;  		error = vfs_open(&amp;path, file);
&gt;  		path_put(&amp;path);
&gt; diff --git a/fs/open.c b/fs/open.c
&gt; index 74c4c1462b3e..82153e21907e 100644
&gt; --- a/fs/open.c
&gt; +++ b/fs/open.c
&gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt;  
&gt;  #define WILL_CREATE(flags)	(flags &amp; (O_CREAT | __O_TMPFILE))
&gt; -#define O_PATH_FLAGS		(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; +#define O_PATH_FLAGS		(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt;  
&gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt;  {
&gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt;  			return -EINVAL;
&gt;  		if (!(acc_mode &amp; MAY_WRITE))
&gt;  			return -EINVAL;
&gt; +	} else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; +		return -EINVAL;
&gt;  	}
&gt;  	if (flags &amp; O_PATH) {
&gt;  		/* O_PATH only permits certain other flags to be set. */
&gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; --- a/include/linux/fcntl.h
&gt; +++ b/include/linux/fcntl.h
&gt; @@ -10,7 +10,7 @@
&gt;  	(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt;  	 O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt;  	 FASYNC	| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; -	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; +	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt;  
&gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt;  #define VALID_RESOLVE_FLAGS \
&gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; --- a/include/uapi/asm-generic/errno.h
&gt; +++ b/include/uapi/asm-generic/errno.h
&gt; @@ -122,4 +122,6 @@
&gt;  
&gt;  #define EHWPOISON	133	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		134	/* Not a regular file */
&gt; +
&gt;  #endif
&gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; index 613475285643..3468b352a575 100644
&gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; @@ -88,6 +88,10 @@
&gt;  #define __O_TMPFILE	020000000
&gt;  #endif
&gt;  
&gt; +#ifndef O_REGULAR
&gt; +#define O_REGULAR	040000000
&gt; +#endif
&gt; +
&gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt;  
&gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; @@ -127,4 +127,6 @@
&gt;  
&gt;  #define EHWPOISON	139	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		140	/* Not a regular file */
&gt; +
&gt;  #endif
&gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; index c01ed91b1ef4..293c78777254 100644
&gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; @@ -126,6 +126,8 @@
&gt;  
&gt;  #define EHWPOISON	168	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		169	/* Not a regular file */
&gt; +
&gt;  #define EDQUOT		1133	/* Quota exceeded */
&gt;  
&gt;  
&gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; index 8cbc07c1903e..442917484f99 100644
&gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; @@ -124,4 +124,6 @@
&gt;  
&gt;  #define EHWPOISON	257	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		258	/* Not a regular file */
&gt; +
&gt;  #endif
&gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; @@ -117,4 +117,6 @@
&gt;  
&gt;  #define EHWPOISON	135	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		136	/* Not a regular file */
&gt; +
&gt;  #endif
&gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; @@ -122,4 +122,6 @@
&gt;  
&gt;  #define EHWPOISON	133	/* Memory page has hardware error */
&gt;  
&gt; +#define ENOTREG		134	/* Not a regular file */
&gt; +
&gt;  #endif

One thing this patch is missing is handling for -&gt;atomic_open(). I
imagine most of the filesystems that provide that op can&#x27;t support
O_REGULAR properly (maybe cifs can? idk). What you probably want to do
is add in some patches that make all of the atomic_open operations in
the kernel return -EINVAL if O_REGULAR is set.

Then, once the basic support is in, you or someone else can go back and
implement support for O_REGULAR where possible.
-- 
Jeff Layton &lt;jlayton@kernel.org&gt;


---

On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; 
&gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; 
&gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; 
&gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; 
&gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; 
&gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; ---
&gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; 
&gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt;        */
&gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt;                       return error;
&gt; &gt; &gt;       }
&gt; &gt; &gt; +
&gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; +
&gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; 
&gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt;       struct path path;
&gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; 
&gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt;  {
&gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt;       }
&gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; 
&gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; 
&gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; +#endif
&gt; &gt; &gt; +
&gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; 
&gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; 
&gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; 
&gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; &gt;  #endif
&gt; &gt; 
&gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; 
&gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; implement support for O_REGULAR where possible.
&gt; 
&gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; fix. I thought open system calls always create regular files, so
&gt; atomic_open probably always creates regular files? Can you please give
&gt; me some more details as to where I need to fix this and what the
&gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; 

atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
present in the dcache. The normal open codepath that you&#x27;re patching
does not get called in this case when -&gt;atomic_open is set for the
filesystem. It&#x27;s mostly used by network filesystems that need to
optimize away the lookup since it&#x27;s wasted round trip, and is often
racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
likely end up ignoring O_REGULAR in that case, which is not what you
want.

What I was suggesting is that, as an interim step, you find all of the
atomic_open operations in the kernel (there are maybe a dozen or so),
and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
you or someone else can then go back and do a proper implementation of
O_REGULAR handling on those filesystems, at least on the ones where
it&#x27;s possible. You will probably also need to similarly patch the
open() routines for those filesystems too. Otherwise you&#x27;ll get
inconsistent behavior vs. when the dentry is in the cache.

One note: I think NFS probably can support O_DIRECTORY, since its OPEN
call only works on files. We&#x27;ll need to change how we handle errors
from the server when it&#x27;s set though.
-- 
Jeff Layton &lt;jlayton@kernel.org&gt;


---

On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; 
&gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; want.
&gt; &gt; 
&gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; 
&gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; from the server when it&#x27;s set though.
&gt; 
&gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; 
&gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; 
&gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; with atomic open for all filesystems.
&gt; 
&gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; and completely broken before that.
&gt; 
&gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; -&gt;atomic_open:: to the filesystem.
&gt; 
&gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; a directory. At that point the damage such as side-effects from device
&gt; opening is already done.
&gt;                           
&gt; 

Exactly. I guess you could send an immediate close, but that&#x27;s not
without side effects.

&gt;           
&gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; it wrong.
&gt; 
&gt; For (2) it is problematic as there surely are filesystems with
&gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; trigger an actual open on a non-regular file such as a
&gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; going on.
&gt; 
&gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; half-way.
&gt; 
&gt; I guess to make that really work you&#x27;d need some protocol extension?

For NFS, I think we&#x27;re OK. The OPEN call on NFSv4 only works for
regular files, so it should be able to handle O_REGULAR. We just need
to rejigger the error handling when it&#x27;s set (just return an error
instead of doing the open of a directory or whatever it is).

The others (at a quick glance):

cifs: I don&#x27;t see a way to specify an O_REGULAR equivalent to the
SMB2_CREATE call and it looks like it can create directories. Maybe
SteveF (cc&#x27;ed) knows if this is possible?

ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case
O_REGULAR can probably be supported similarly to NFS.

fuse: probably ok? Does finish_no_open() in most cases. May depend on
the userland driver though.

gfs2: is ok, it just does finish_no_open() in most cases anyway

vboxsf: does finish_no_open on non-creates, so you could probably just
punt to that if O_REGULAR is set.

So, it&#x27;s probably possible to do this across the board. I&#x27;m not sure
about cifs though.
-- 
Jeff Layton &lt;jlayton@kernel.org&gt;


---

On Thu, 2026-01-29 at 08:12 -0500, Jeff Layton wrote:
&gt; On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; &gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; &gt; want.
&gt; &gt; &gt; 
&gt; &gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; &gt; 
&gt; &gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; &gt; from the server when it&#x27;s set though.
&gt; &gt; 
&gt; &gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; &gt; 
&gt; &gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; &gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; &gt; 
&gt; &gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; &gt; with atomic open for all filesystems.
&gt; &gt; 
&gt; &gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; &gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; &gt; and completely broken before that.
&gt; &gt; 
&gt; &gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; &gt; -&gt;atomic_open:: to the filesystem.
&gt; &gt; 
&gt; &gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; &gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; &gt; a directory. At that point the damage such as side-effects from device
&gt; &gt; opening is already done.
&gt; &gt;                           
&gt; &gt; 
&gt; 
&gt; Exactly. I guess you could send an immediate close, but that&#x27;s not
&gt; without side effects.
&gt; 
&gt; &gt;           
&gt; &gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; &gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; &gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; &gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; &gt; it wrong.
&gt; &gt; 
&gt; &gt; For (2) it is problematic as there surely are filesystems with
&gt; &gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; &gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; &gt; trigger an actual open on a non-regular file such as a
&gt; &gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; &gt; going on.
&gt; &gt; 
&gt; &gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; &gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; &gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; &gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; &gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; &gt; half-way.
&gt; &gt; 
&gt; &gt; I guess to make that really work you&#x27;d need some protocol extension?
&gt; 
&gt; For NFS, I think we&#x27;re OK. The OPEN call on NFSv4 only works for
&gt; regular files, so it should be able to handle O_REGULAR. We just need
&gt; to rejigger the error handling when it&#x27;s set (just return an error
&gt; instead of doing the open of a directory or whatever it is).
&gt; 
&gt; The others (at a quick glance):
&gt; 
&gt; cifs: I don&#x27;t see a way to specify an O_REGULAR equivalent to the
&gt; SMB2_CREATE call and it looks like it can create directories. Maybe
&gt; SteveF (cc&#x27;ed) knows if this is possible?
&gt; 

SMB2 does have this flag:

FILE_NON_DIRECTORY_FILE 0x00000040

If the name of the file being created or opened matches with an
existing directory file, the server MUST fail the request with
STATUS_FILE_IS_A_DIRECTORY. This flag MUST NOT be used with
FILE_DIRECTORY_FILE or the server MUST fail the request with
STATUS_INVALID_PARAMETER.

SMB2 can also present named pipes and printer files. Not sure if there
is a way to exclude those with this.

&gt; ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case
&gt; O_REGULAR can probably be supported similarly to NFS.
&gt; 

Actually I&#x27;m wrong here. That op can open a directory. We&#x27;ll need
someone to look at the MDS code and tell us whether this can be done in
a non-racy way.

&gt; fuse: probably ok? Does finish_no_open() in most cases. May depend on
&gt; the userland driver though.
&gt; 
&gt; gfs2: is ok, it just does finish_no_open() in most cases anyway
&gt; 
&gt; vboxsf: does finish_no_open on non-creates, so you could probably just
&gt; punt to that if O_REGULAR is set.
&gt; 
&gt; So, it&#x27;s probably possible to do this across the board. I&#x27;m not sure
&gt; about cifs though.

-- 
Jeff Layton &lt;jlayton@kernel.org&gt;


---

On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; 
&gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; want.
&gt; &gt; 
&gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; 
&gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; from the server when it&#x27;s set though.
&gt; 
&gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; 

Oops, that was a typo.

&gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; 
&gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; with atomic open for all filesystems.
&gt; 

It looks like NFS at least handles O_DIRECTORY properly. I don&#x27;t have
any reason to believe that O_DIRECTORY handling is broken on the
others.

&gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; and completely broken before that.
&gt; 
&gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; -&gt;atomic_open:: to the filesystem.
&gt; 
&gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; a directory. At that point the damage such as side-effects from device
&gt; opening is already done.
&gt;                                     
&gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; it wrong.
&gt; 
&gt; For (2) it is problematic as there surely are filesystems with
&gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; trigger an actual open on a non-regular file such as a
&gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; going on.
&gt; 
&gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; half-way.
&gt; 
&gt; I guess to make that really work you&#x27;d need some protocol extension?

-- 
Jeff Layton &lt;jlayton@kernel.org&gt;


---

On Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:
&gt; On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; 
&gt; &gt; On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; &gt; &gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; &gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; &gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; &gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; &gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; &gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; &gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; &gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; &gt; &gt; want.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; &gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; &gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; &gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; &gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; &gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; &gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; &gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; &gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; &gt; &gt; from the server when it&#x27;s set though.
&gt; &gt; &gt; 
&gt; &gt; &gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; &gt; &gt; 
&gt; &gt; &gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; &gt; &gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; &gt; &gt; 
&gt; &gt; &gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; &gt; &gt; with atomic open for all filesystems.
&gt; &gt; &gt; 
&gt; &gt; &gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; &gt; &gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; &gt; &gt; and completely broken before that.
&gt; &gt; &gt; 
&gt; &gt; &gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; &gt; &gt; -&gt;atomic_open:: to the filesystem.
&gt; &gt; &gt; 
&gt; &gt; &gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; &gt; &gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; &gt; &gt; a directory. At that point the damage such as side-effects from device
&gt; &gt; &gt; opening is already done.
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; Exactly. I guess you could send an immediate close, but that&#x27;s not
&gt; &gt; without side effects.
&gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; &gt; &gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; &gt; &gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; &gt; &gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; &gt; &gt; it wrong.
&gt; &gt; &gt; 
&gt; &gt; &gt; For (2) it is problematic as there surely are filesystems with
&gt; &gt; &gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; &gt; &gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; &gt; &gt; trigger an actual open on a non-regular file such as a
&gt; &gt; &gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; &gt; &gt; going on.
&gt; &gt; &gt; 
&gt; &gt; &gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; &gt; &gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; &gt; &gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; &gt; &gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; &gt; &gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; &gt; &gt; half-way.
&gt; &gt; &gt; 
&gt; &gt; &gt; I guess to make that really work you&#x27;d need some protocol extension?
&gt; &gt; 
&gt; &gt; For NFS, I think we&#x27;re OK. The OPEN call on NFSv4 only works for
&gt; &gt; regular files, so it should be able to handle O_REGULAR. We just need
&gt; &gt; to rejigger the error handling when it&#x27;s set (just return an error
&gt; &gt; instead of doing the open of a directory or whatever it is).
&gt; &gt; 
&gt; 
&gt; Thank you for the details. Do you remember which codepath this is? Is
&gt; this the inode_operations.atomic_open codepath or file_operations.open
&gt; codepath? I am a bit confused also about where exactly the error
&gt; handling that needs to be done.
&gt; 

I was thinking nfs_atomic_open().

Looking now, I think it might actually work OK without changes. It just
might not be terribly efficient about it.

If the open_context() call returns -EISDIR or similar, then you really
don&#x27;t need to do the call to nfs_lookup() and the like. You can just
return an immediate error when O_REGULAR is set since you know it&#x27;s not
suitable to be opened.

&gt; &gt; The others (at a quick glance):
&gt; &gt; 
&gt; &gt; cifs: I don&#x27;t see a way to specify an O_REGULAR equivalent to the
&gt; &gt; SMB2_CREATE call and it looks like it can create directories. Maybe
&gt; &gt; SteveF (cc&#x27;ed) knows if this is possible?
&gt; &gt; 
&gt; &gt; ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case
&gt; &gt; O_REGULAR can probably be supported similarly to NFS.
&gt; &gt; 
&gt; &gt; fuse: probably ok? Does finish_no_open() in most cases. May depend on
&gt; &gt; the userland driver though.
&gt; &gt; 
&gt; &gt; gfs2: is ok, it just does finish_no_open() in most cases anyway
&gt; &gt; 
&gt; &gt; vboxsf: does finish_no_open on non-creates, so you could probably just
&gt; &gt; punt to that if O_REGULAR is set.
&gt; &gt; 
&gt; 
&gt; These are all inode_operations.atomic_open code paths, right? Because
&gt; you mentioned finish_no_open and I see finish_no_open in the
&gt; atomic_open code paths as opposed to file_operations.open code paths.
&gt; 

Note that this was just a cursory look. Someone will need to do a
deeper dive and test these cases.

I think most will end up working ok, since most fall back to doing a
finish_no_open(). There may be opportunities to optimize some of these
cases though (similarly to how I mentioned with NFS).
-- 
Jeff Layton &lt;jlayton@kernel.org&gt;


---

On Thu, 2026-02-19 at 01:19 +0600, Dorjoy Chowdhury wrote:
&gt; On Thu, Feb 19, 2026 at 1:01 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; 
&gt; &gt; On Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; &gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; &gt; &gt; &gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; &gt; &gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; &gt; &gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; &gt; &gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; &gt; &gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; &gt; &gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; &gt; &gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; &gt; &gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; &gt; &gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; &gt; &gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; &gt; &gt; &gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; &gt; &gt; &gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; &gt; &gt; &gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; &gt; &gt; &gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; &gt; &gt; &gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; &gt; &gt; &gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; &gt; &gt; &gt; &gt; want.
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; &gt; &gt; &gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; &gt; &gt; &gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; &gt; &gt; &gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; &gt; &gt; &gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; &gt; &gt; &gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; &gt; &gt; &gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; &gt; &gt; &gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; &gt; &gt; &gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; &gt; &gt; &gt; &gt; from the server when it&#x27;s set though.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; &gt; &gt; &gt; &gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; &gt; &gt; &gt; &gt; with atomic open for all filesystems.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; &gt; &gt; &gt; &gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; &gt; &gt; &gt; &gt; and completely broken before that.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; &gt; &gt; &gt; &gt; -&gt;atomic_open:: to the filesystem.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; &gt; &gt; &gt; &gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; &gt; &gt; &gt; &gt; a directory. At that point the damage such as side-effects from device
&gt; &gt; &gt; &gt; &gt; opening is already done.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Exactly. I guess you could send an immediate close, but that&#x27;s not
&gt; &gt; &gt; &gt; without side effects.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; &gt; &gt; &gt; &gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; &gt; &gt; &gt; &gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; &gt; &gt; &gt; &gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; &gt; &gt; &gt; &gt; it wrong.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; For (2) it is problematic as there surely are filesystems with
&gt; &gt; &gt; &gt; &gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; &gt; &gt; &gt; &gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; &gt; &gt; &gt; &gt; trigger an actual open on a non-regular file such as a
&gt; &gt; &gt; &gt; &gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; &gt; &gt; &gt; &gt; going on.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; &gt; &gt; &gt; &gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; &gt; &gt; &gt; &gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; &gt; &gt; &gt; &gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; &gt; &gt; &gt; &gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; &gt; &gt; &gt; &gt; half-way.
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; I guess to make that really work you&#x27;d need some protocol extension?
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; For NFS, I think we&#x27;re OK. The OPEN call on NFSv4 only works for
&gt; &gt; &gt; &gt; regular files, so it should be able to handle O_REGULAR. We just need
&gt; &gt; &gt; &gt; to rejigger the error handling when it&#x27;s set (just return an error
&gt; &gt; &gt; &gt; instead of doing the open of a directory or whatever it is).
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; Thank you for the details. Do you remember which codepath this is? Is
&gt; &gt; &gt; this the inode_operations.atomic_open codepath or file_operations.open
&gt; &gt; &gt; codepath? I am a bit confused also about where exactly the error
&gt; &gt; &gt; handling that needs to be done.
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; I was thinking nfs_atomic_open().
&gt; &gt; 
&gt; &gt; Looking now, I think it might actually work OK without changes. It just
&gt; &gt; might not be terribly efficient about it.
&gt; &gt; 
&gt; &gt; If the open_context() call returns -EISDIR or similar, then you really
&gt; &gt; don&#x27;t need to do the call to nfs_lookup() and the like. You can just
&gt; &gt; return an immediate error when O_REGULAR is set since you know it&#x27;s not
&gt; &gt; suitable to be opened.
&gt; &gt; 
&gt; 
&gt; Right. And I guess we don&#x27;t need to worry about O_REGULAR being an
&gt; unknown flag when it gets sent to the server (not only for NFS / but
&gt; others as well)?
&gt; 

You shouldn&#x27;t. We don&#x27;t send POSIX flags in NFSv4 requests. It has its
own set of flags. In the case of NFSv4, O_REGULAR is already implied in
an OPEN call on the wire. OPEN only operates on regular files.

&gt; &gt; &gt; &gt; The others (at a quick glance):
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; cifs: I don&#x27;t see a way to specify an O_REGULAR equivalent to the
&gt; &gt; &gt; &gt; SMB2_CREATE call and it looks like it can create directories. Maybe
&gt; &gt; &gt; &gt; SteveF (cc&#x27;ed) knows if this is possible?
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case
&gt; &gt; &gt; &gt; O_REGULAR can probably be supported similarly to NFS.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; fuse: probably ok? Does finish_no_open() in most cases. May depend on
&gt; &gt; &gt; &gt; the userland driver though.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; gfs2: is ok, it just does finish_no_open() in most cases anyway
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; vboxsf: does finish_no_open on non-creates, so you could probably just
&gt; &gt; &gt; &gt; punt to that if O_REGULAR is set.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; These are all inode_operations.atomic_open code paths, right? Because
&gt; &gt; &gt; you mentioned finish_no_open and I see finish_no_open in the
&gt; &gt; &gt; atomic_open code paths as opposed to file_operations.open code paths.
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; Note that this was just a cursory look. Someone will need to do a
&gt; &gt; deeper dive and test these cases.
&gt; &gt; 
&gt; &gt; I think most will end up working ok, since most fall back to doing a
&gt; &gt; finish_no_open(). There may be opportunities to optimize some of these
&gt; &gt; cases though (similarly to how I mentioned with NFS).
&gt; 
&gt; I can try to look into these and see if I can implement handling for
&gt; O_REGULAR flag for these filesystems in the atomic_open code paths.
&gt; Thanks for the details.
&gt; 
&gt; Will I need to modify the corresponding file_operations.open code
&gt; paths as well along with atomic_open code paths?
&gt; 

Probably not.

The main thing to keep in mind is that -&gt;open is used when we already
have a dentry for the target of the open. -&gt;atomic_open is used when we
don&#x27;t have one yet or the one we have has failed revalidation.

If you have a valid dentry, then you should be able to satisfy the
O_REGULAR check without having to call into -&gt;open at all.
-- 
Jeff Layton &lt;jlayton@kernel.org&gt;
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, additional context</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-28">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Aleksa Sarai</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-28">2026-01-28</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Aleksa Sarai raised concerns about the O_REGULAR flag&#x27;s interaction with O_PATH and legacy open/openat functions, suggesting it may not be suitable for expansion due to potential security issues and compatibility problems.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 2026-01-27, Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt; wrote:
&gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; This is useful to write secure programs that want to avoid being tricked
&gt; into opening device nodes with special semantics while thinking they
&gt; operate on regular files.
&gt; 
&gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; will return -ENOTREG.
&gt; 
&gt; When used in combination with O_CREAT, either the regular file is
&gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; file. Otherwise, -ENOTREG is returned.
&gt; 
&gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; is both a directory and a regular file.

As you mention in your cover letter, this is something that the UAPI
group has asked for in the past[1] and was even discussed at a recent
LPC (maybe LPC 2024?) -- thanks for the patch!

In the next posting of this patchset, I would suggest including this
information in the *commit message* with a link (commit messages end up
in the git history, cover letters are a little harder to search for when
doing &quot;git blame&quot;).

[1]: https://uapi-group.org/kernel-features/#ability-to-only-open-regular-files

&gt;  #define WILL_CREATE(flags)	(flags &amp; (O_CREAT | __O_TMPFILE))
&gt; -#define O_PATH_FLAGS		(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; +#define O_PATH_FLAGS		(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)

It doesn&#x27;t really make sense to use this flag with O_PATH -- O_PATH file
descriptors do not actually open the target inode and so there is no
risk to doing this.

In fact the method of safely opening files while avoiding device inodes
on Linux today is to open an O_PATH, then use fstat(2) to check whether
it is a regular file, and then re-open the file descriptor through
/proc/self/fd/$n. (This is totally race-safe.)

My main reason for pushing back against this it&#x27;s really quite
preferable to avoid expanding the set of O_* flags which work with
O_PATH if they don&#x27;t add much -- O_PATH has really unfortunate behaviour
with ignoring other flags and openat2(2) finally fixed that by blocking
ignored flag combinations.

&gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt;  {
&gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt;  			return -EINVAL;
&gt;  		if (!(acc_mode &amp; MAY_WRITE))
&gt;  			return -EINVAL;
&gt; +	} else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; +		return -EINVAL;
&gt;  	}
&gt;  	if (flags &amp; O_PATH) {
&gt;  		/* O_PATH only permits certain other flags to be set. */
&gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; --- a/include/linux/fcntl.h
&gt; +++ b/include/linux/fcntl.h
&gt; @@ -10,7 +10,7 @@
&gt;  	(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt;  	 O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt;  	 FASYNC	| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; -	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; +	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)

Legacy open(2)/openat(2) do not reject invalid flag arguments, which
means that you cannot trivially add a new security-critical flag to them
for two reasons:

 * You cannot easily rely on them because old kernels will not return
   -EINVAL, meaning you cannot be sure that the flag is supported. You
   can try to test-run it, but the operation needs to be a non-dangerous
   operation to try (and caching this has its own issues, such as with
   programs that apply seccomp filters later).

   To be fair, since you reject O_DIRECTORY|O_REGULAR there is a
   relatively easy way to detect this, but the caveats about problems
   with caching still apply.

 * Old programs might pass garbage bits that have been ignored thus far,
   which means that making them have meaning can break userspace. Given
   the age of open(2) this is a very hard thing to guarantee and is one
   of many reasons I wrote openat2(2) and finally added proper flag
   checking.

   This is something your patch doesn&#x27;t deal with and I don&#x27;t think can
   be done in a satisfactory way (because the behaviour relies on more
   than just the arguments).

For reference, this is why O_TMPFILE includes O_DIRECTORY and requires
an O_ACCMODE with write bits -- this combination will fail on old
kernels, which allows you to rely on it and also guarantees that no
existing older programs passed that flag combination already and
happened to work on older kernels. This kind of trick won&#x27;t work for
O_REGULAR, unfortunately.

In my view, this should be an openat2(2)-only API. In addition, I would
propose that (instead of burning another O_* flag bit for this as a
special-purpose API just for regular files) you could have a mask of
which S_IFMT bits should be rejected as a new field in &quot;struct
open_how&quot;. This would let you reject sockets or device inodes but permit
FIFOs and regular files or directories, for instance. This could even be
done without a new O_* flag at all (the zero-value how-&gt;sfmt_mask would
allow everything and so would work well with extensible structs), but we
could add an O2_* flag anyway.

&gt; +#define ENOTREG		134	/* Not a regular file */
&gt; +

We are probably a little too reticent to add new errnos, but in this
case I think that there should be some description in the commit or
cover letter about why a new errno is needed. ENXIO or
EPROTONOSUPPORT/EPROTOTYPE is what you would typically use (yes, they
aren&#x27;t a _perfect_ match but one of the common occurrences in syscall
design is to read through errno(7) and figure out what errnos kind of
fit what you need to express).

Then to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind
of justify the existence of ENOTREG too. Unfortunately, you won&#x27;t be
able to use ENOTREG if you go with my idea of having mask bits in
open_how... (And what errno should we use then...? Hm.)

-- 
Aleksa Sarai
https://www.cyphar.com/


---

On 2026-01-28, Mateusz Guzik &lt;mjguzik@gmail.com&gt; wrote:
&gt; On Wed, Jan 28, 2026 at 12:23:45AM +0100, Aleksa Sarai wrote:
&gt; &gt; In my view, this should be an openat2(2)-only API.
&gt; 
&gt; fwiw +1 from me, the O_ flag situation is already terrible even without
&gt; the validation woes.
&gt; 
&gt; I find it most unfortunate the openat2 syscall reuses the O_ namespace.
&gt; For my taste it would be best closed for business, with all new flag
&gt; additions using a different space.

We don&#x27;t have any openat2(2)-only O_* flags yet, I agree that new flag
additions (except for very rare cases where you can make them backward
compatible -- such as a hypothetical O_EMPTYPATH) should be O2_* or
OEXT_* or something.

&gt; I can easily see people passing O_WHATEVER to open and openat by blindly
&gt; assuming they are supported just based on the name.

Yeah, if we don&#x27;t do that it&#x27;ll lead to confusion. openat2(2) has
exclusive rights to the 64-bit flag bits so we could start with those
before we need to cross with the O_* flag space.

&gt; that&#x27;s a side mini-rant, too late to do anything here now
&gt; 
&gt; &gt; In addition, I would
&gt; &gt; propose that (instead of burning another O_* flag bit for this as a
&gt; &gt; special-purpose API just for regular files) you could have a mask of
&gt; &gt; which S_IFMT bits should be rejected as a new field in &quot;struct
&gt; &gt; open_how&quot;. This would let you reject sockets or device inodes but permit
&gt; &gt; FIFOs and regular files or directories, for instance. This could even be
&gt; &gt; done without a new O_* flag at all (the zero-value how-&gt;sfmt_mask would
&gt; &gt; allow everything and so would work well with extensible structs), but we
&gt; &gt; could add an O2_* flag anyway.
&gt; 
&gt; I don&#x27;t think this works because the vars have overlapping bits:
&gt;   #define S_IFBLK  0060000
&gt;   #define S_IFDIR  0040000
&gt; 
&gt; So you very much can&#x27;t select what you want off of a bitmask.

Well, you can filter on S_IFCHR if you want to block both block/char
devices, but yeah the overlap is quite unfortunate... (That would also
mean blocking directories would also block S_IFBLK -- I remembered there
was an overlap but I forgot it coincided with S_IFDIR... Damn wacky
APIs.)

&gt; At best the field could be used to select the one type you are fine with.
&gt; 
&gt; If one was to pursue the idea, some other defines with unique bits would
&gt; need to be provided. But even then, semantics should be to only *allow*
&gt; the bits you are fine with and reject the rest.
&gt; 
&gt; But I&#x27;m not at all confident this is worth any effort -- with
&gt; O_DIRECTORY already being there and O_REGULAR proposed, is there a use
&gt; case which wants something else?

There&#x27;s also O_NOFOLLOW in a similar vein.

I can see someone wanting to permit FIFOs, regular files, and
directories being fine but blocking everything else. None of O_REGULAR,
O_DIRECTORY, nor O_NOFOLLOW provide that.

&gt; &gt; &gt; +#define ENOTREG		134	/* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt; 
&gt; [..]
&gt; &gt; Then to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind
&gt; &gt; of justify the existence of ENOTREG too. Unfortunately, you won&#x27;t be
&gt; &gt; able to use ENOTREG if you go with my idea of having mask bits in
&gt; &gt; open_how... (And what errno should we use then...? Hm.)
&gt; &gt; 
&gt; 
&gt; The most useful behavior would indicate what was found (e.g., a pipe).
&gt; 
&gt; The easiest way to do it would create errnos for all types (EISDIR
&gt; already exists for one), but I can&#x27;t seriously propose that.

It might be kinda neat from a potential re-use perspective in other APIs
but yeah it would be quite wasteful to burn 3-5 errnos for this when we
already have ~4 that are logical inverses.

&gt; Going the other way, EBADTYPE or something else reusable would be my
&gt; idea.

I think that would be reasonable and if you word the error message
carefully you can even see it being a fairly generic errno for other
places to use.

-- 
Aleksa Sarai
https://www.cyphar.com/


---

On 2026-01-29, Christian Brauner &lt;brauner@kernel.org&gt; wrote:
&gt; On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:
&gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; operate on regular files.
&gt; &gt; 
&gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; will return -ENOTREG.
&gt; &gt; 
&gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; 
&gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; is both a directory and a regular file.
&gt; &gt; 
&gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; ---
&gt; 
&gt; Yeah, we shouldn&#x27;t add support for this outside of openat2(). We also
&gt; shouldn&#x27;t call this OEXT_* or O2_*. Let&#x27;s just follow the pattern where
&gt; we prefix the flag space with the name of the system call
&gt; OPENAT2_REGULAR.
&gt; 
&gt; There&#x27;s also no real need to make O_DIRECTORY exclusive with
&gt; OPENAT2_REGULAR. Callers could legimitately want to open a directory or
&gt; regular file but not anything else. If someone wants to operate on a
&gt; whole filesystem tree but only wants to interact with regular files and
&gt; directories and ignore devices, sockets, fifos etc it&#x27;s very handy to
&gt; just be able to set both in flags.
&gt; 
&gt; Frankly, this shouldn&#x27;t be a flag at all but we already have O_DIRECTORY
&gt; in there so no need to move this into a new field.

You could even say O_NOFOLLOW is kinda like that too.

In my other mail I proposed a bitmask of S_IFMT to reject opening (which
would let you allow FIFOs and regular files but block devices, etc).
Unfortunately I forgot that S_IFBLK is S_IFCHR|S_IFDIR. This isn&#x27;t fatal
to the idea but it kinda sucks. Grr.

&gt; Add EFTYPE as the errno code. Some of the bsds including macos already
&gt; have that.

-- 
Aleksa Sarai
https://www.cyphar.com/
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, security concerns</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Mateusz Guzik</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-28">2026-01-28</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Mateusz Guzik expressed concerns about the O_REGULAR flag&#x27;s behavior and suggested it may not work as intended due to overlapping bits in the bitmask. He also questioned whether there is a use case for additional flags beyond O_DIRECTORY and O_REGULAR.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Wed, Jan 28, 2026 at 12:23:45AM +0100, Aleksa Sarai wrote:
&gt; In my view, this should be an openat2(2)-only API.

fwiw +1 from me, the O_ flag situation is already terrible even without
the validation woes.

I find it most unfortunate the openat2 syscall reuses the O_ namespace.
For my taste it would be best closed for business, with all new flag
additions using a different space.

I can easily see people passing O_WHATEVER to open and openat by blindly
assuming they are supported just based on the name.

that&#x27;s a side mini-rant, too late to do anything here now

&gt; In addition, I would
&gt; propose that (instead of burning another O_* flag bit for this as a
&gt; special-purpose API just for regular files) you could have a mask of
&gt; which S_IFMT bits should be rejected as a new field in &quot;struct
&gt; open_how&quot;. This would let you reject sockets or device inodes but permit
&gt; FIFOs and regular files or directories, for instance. This could even be
&gt; done without a new O_* flag at all (the zero-value how-&gt;sfmt_mask would
&gt; allow everything and so would work well with extensible structs), but we
&gt; could add an O2_* flag anyway.

I don&#x27;t think this works because the vars have overlapping bits:
  #define S_IFBLK  0060000
  #define S_IFDIR  0040000

So you very much can&#x27;t select what you want off of a bitmask.

At best the field could be used to select the one type you are fine with.

If one was to pursue the idea, some other defines with unique bits would
need to be provided. But even then, semantics should be to only *allow*
the bits you are fine with and reject the rest.

But I&#x27;m not at all confident this is worth any effort -- with
O_DIRECTORY already being there and O_REGULAR proposed, is there a use
case which wants something else?

&gt; 
&gt; &gt; +#define ENOTREG		134	/* Not a regular file */
&gt; &gt; +
&gt; 
[..]
&gt; Then to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind
&gt; of justify the existence of ENOTREG too. Unfortunately, you won&#x27;t be
&gt; able to use ENOTREG if you go with my idea of having mask bits in
&gt; open_how... (And what errno should we use then...? Hm.)
&gt; 

The most useful behavior would indicate what was found (e.g., a pipe).

The easiest way to do it would create errnos for all types (EISDIR
already exists for one), but I can&#x27;t seriously propose that.

Going the other way, EBADTYPE or something else reusable would be my
idea.
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, technical concerns</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-29">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Christian Brauner</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-29">2026-01-29</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer raised concerns about the implementation of O_REGULAR flag support, suggesting it should be done within openat2() and following a consistent naming pattern. They also questioned the need for O_DIRECTORY to be exclusive with OPENAT2_REGULAR.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:
&gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; This is useful to write secure programs that want to avoid being tricked
&gt; into opening device nodes with special semantics while thinking they
&gt; operate on regular files.
&gt; 
&gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; will return -ENOTREG.
&gt; 
&gt; When used in combination with O_CREAT, either the regular file is
&gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; file. Otherwise, -ENOTREG is returned.
&gt; 
&gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; is both a directory and a regular file.
&gt; 
&gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; ---

Yeah, we shouldn&#x27;t add support for this outside of openat2(). We also
shouldn&#x27;t call this OEXT_* or O2_*. Let&#x27;s just follow the pattern where
we prefix the flag space with the name of the system call
OPENAT2_REGULAR.

There&#x27;s also no real need to make O_DIRECTORY exclusive with
OPENAT2_REGULAR. Callers could legimitately want to open a directory or
regular file but not anything else. If someone wants to operate on a
whole filesystem tree but only wants to interact with regular files and
directories and ignore devices, sockets, fifos etc it&#x27;s very handy to
just be able to set both in flags.

Frankly, this shouldn&#x27;t be a flag at all but we already have O_DIRECTORY
in there so no need to move this into a new field.

Add EFTYPE as the errno code. Some of the bsds including macos already
have that.


---

On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; On Wed, Jan 28, 2026 at 5:52\u202fAM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; 
&gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; 
&gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; 
&gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; 
&gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; 
&gt; 
&gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; want.
&gt; 
&gt; What I was suggesting is that, as an interim step, you find all of the
&gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; you or someone else can then go back and do a proper implementation of
&gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; 
&gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; from the server when it&#x27;s set though.

So I think you&#x27;re proposing two separate things or there&#x27;s a typo:

(1) blocking O_DIRECTORY for -&gt;atomic_open::
(2) blocking O_REGULAR for -&gt;atomic_open::

The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
with atomic open for all filesystems.

Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
and completely broken before that.

For O_DIRECTORY without O_CREAT the kernel will pass that down through
-&gt;atomic_open:: to the filesystem.

The worry that I see is that a network filesystem via -&gt;atomic_open::
somehow already called open on the server side on something that wasn&#x27;t
a directory. At that point the damage such as side-effects from device
opening is already done.
                                    
But I suspect that every filesystem implementing -&gt;atomic_open:: just
does finish_no_open() and punts to the VFS for the actual open. And the
VFS will catch it in do_open() for it actually opens the file. So the
only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
it wrong.

For (2) it is problematic as there surely are filesystems with
-&gt;atomic_open:: that do handle the ~O_CREAT case and return with
FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
trigger an actual open on a non-regular file such as a
device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
going on.

So I&#x27;m not excited about having this 70% working and punting on
-&gt;atomic_open:: waiting for someone to fix this. One option would be to
bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
to racy and pricy lookup + open for now. How problematic would that be?
If possible I&#x27;d prefer this a lot over merging something that works
half-way.

I guess to make that really work you&#x27;d need some protocol extension?
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, technical concerns</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-18">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Dorjoy Chowdhury (author)</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Dorjoy Chowdhury (author), raised concerns about the O_REGULAR flag&#x27;s behavior when combined with other flags like O_CREAT and its interaction with directory paths.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">This flag indicates the path should be opened if it&#x27;s a regular file.
This is useful to write secure programs that want to avoid being tricked
into opening device nodes with special semantics while thinking they
operate on regular files.

A corresponding error code ENOTREG has been introduced. For example, if
open is called on path /dev/null with O_REGULAR in the flag param, it
will return -ENOTREG.

When used in combination with O_CREAT, either the regular file is
created, or if the path already exists, it is opened if it&#x27;s a regular
file. Otherwise, -ENOTREG is returned.

-EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
is both a directory and a regular file.

Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
---
 arch/alpha/include/uapi/asm/errno.h        | 2 ++
 arch/alpha/include/uapi/asm/fcntl.h        | 1 +
 arch/mips/include/uapi/asm/errno.h         | 2 ++
 arch/parisc/include/uapi/asm/errno.h       | 2 ++
 arch/parisc/include/uapi/asm/fcntl.h       | 1 +
 arch/sparc/include/uapi/asm/errno.h        | 2 ++
 arch/sparc/include/uapi/asm/fcntl.h        | 1 +
 fs/fcntl.c                                 | 2 +-
 fs/namei.c                                 | 6 ++++++
 fs/open.c                                  | 4 +++-
 include/linux/fcntl.h                      | 2 +-
 include/uapi/asm-generic/errno.h           | 2 ++
 include/uapi/asm-generic/fcntl.h           | 4 ++++
 tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
 tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
 tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
 tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
 tools/include/uapi/asm-generic/errno.h     | 2 ++
 18 files changed, 38 insertions(+), 3 deletions(-)

diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
index 6791f6508632..8bbcaa9024f9 100644
--- a/arch/alpha/include/uapi/asm/errno.h
+++ b/arch/alpha/include/uapi/asm/errno.h
@@ -127,4 +127,6 @@
 
 #define EHWPOISON	139	/* Memory page has hardware error */
 
+#define ENOTREG		140	/* Not a regular file */
+
 #endif
diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
index 50bdc8e8a271..4da5a64c23bd 100644
--- a/arch/alpha/include/uapi/asm/fcntl.h
+++ b/arch/alpha/include/uapi/asm/fcntl.h
@@ -34,6 +34,7 @@
 
 #define O_PATH		040000000
 #define __O_TMPFILE	0100000000
+#define O_REGULAR	0200000000
 
 #define F_GETLK		7
 #define F_SETLK		8
diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
index c01ed91b1ef4..293c78777254 100644
--- a/arch/mips/include/uapi/asm/errno.h
+++ b/arch/mips/include/uapi/asm/errno.h
@@ -126,6 +126,8 @@
 
 #define EHWPOISON	168	/* Memory page has hardware error */
 
+#define ENOTREG		169	/* Not a regular file */
+
 #define EDQUOT		1133	/* Quota exceeded */
 
 
diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
index 8cbc07c1903e..442917484f99 100644
--- a/arch/parisc/include/uapi/asm/errno.h
+++ b/arch/parisc/include/uapi/asm/errno.h
@@ -124,4 +124,6 @@
 
 #define EHWPOISON	257	/* Memory page has hardware error */
 
+#define ENOTREG		258	/* Not a regular file */
+
 #endif
diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
index 03dee816cb13..0cc3320fe326 100644
--- a/arch/parisc/include/uapi/asm/fcntl.h
+++ b/arch/parisc/include/uapi/asm/fcntl.h
@@ -19,6 +19,7 @@
 
 #define O_PATH		020000000
 #define __O_TMPFILE	040000000
+#define O_REGULAR	0100000000
 
 #define F_GETLK64	8
 #define F_SETLK64	9
diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
index 4a41e7835fd5..8dce0bfeab74 100644
--- a/arch/sparc/include/uapi/asm/errno.h
+++ b/arch/sparc/include/uapi/asm/errno.h
@@ -117,4 +117,6 @@
 
 #define EHWPOISON	135	/* Memory page has hardware error */
 
+#define ENOTREG		136	/* Not a regular file */
+
 #endif
diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
index 67dae75e5274..a93d18d2c23e 100644
--- a/arch/sparc/include/uapi/asm/fcntl.h
+++ b/arch/sparc/include/uapi/asm/fcntl.h
@@ -37,6 +37,7 @@
 
 #define O_PATH		0x1000000
 #define __O_TMPFILE	0x2000000
+#define O_REGULAR	0x4000000
 
 #define F_GETOWN	5	/*  for sockets. */
 #define F_SETOWN	6	/*  for sockets. */
diff --git a/fs/fcntl.c b/fs/fcntl.c
index f93dbca08435..62ab4ad2b6f5 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
 	 * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
 	 * is defined as O_NONBLOCK on some platforms and not on others.
 	 */
-	BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
+	BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
 		HWEIGHT32(
 			(VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
 			__FMODE_EXEC));
diff --git a/fs/namei.c b/fs/namei.c
index b28ecb699f32..f5504ae4b03c 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
 		if (unlikely(error))
 			return error;
 	}
+
+	if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
+		return -ENOTREG;
+
 	if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
 		return -ENOTDIR;
 
@@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
 	struct path path;
 	int error = path_lookupat(nd, flags, &amp;path);
 	if (!error) {
+		if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
+			return -ENOTREG;
 		audit_inode(nd-&gt;name, path.dentry, 0);
 		error = vfs_open(&amp;path, file);
 		path_put(&amp;path);
diff --git a/fs/open.c b/fs/open.c
index 74c4c1462b3e..82153e21907e 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
 EXPORT_SYMBOL_GPL(kernel_file_open);
 
 #define WILL_CREATE(flags)	(flags &amp; (O_CREAT | __O_TMPFILE))
-#define O_PATH_FLAGS		(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
+#define O_PATH_FLAGS		(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
 
 inline struct open_how build_open_how(int flags, umode_t mode)
 {
@@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
 			return -EINVAL;
 		if (!(acc_mode &amp; MAY_WRITE))
 			return -EINVAL;
+	} else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
+		return -EINVAL;
 	}
 	if (flags &amp; O_PATH) {
 		/* O_PATH only permits certain other flags to be set. */
diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
index a332e79b3207..4fd07b0e0a17 100644
--- a/include/linux/fcntl.h
+++ b/include/linux/fcntl.h
@@ -10,7 +10,7 @@
 	(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
 	 O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
 	 FASYNC	| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
-	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
+	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
 
 /* List of all valid flags for the how-&gt;resolve argument: */
 #define VALID_RESOLVE_FLAGS \
diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
index 92e7ae493ee3..2216ab9aa32e 100644
--- a/include/uapi/asm-generic/errno.h
+++ b/include/uapi/asm-generic/errno.h
@@ -122,4 +122,6 @@
 
 #define EHWPOISON	133	/* Memory page has hardware error */
 
+#define ENOTREG		134	/* Not a regular file */
+
 #endif
diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
index 613475285643..3468b352a575 100644
--- a/include/uapi/asm-generic/fcntl.h
+++ b/include/uapi/asm-generic/fcntl.h
@@ -88,6 +88,10 @@
 #define __O_TMPFILE	020000000
 #endif
 
+#ifndef O_REGULAR
+#define O_REGULAR	040000000
+#endif
+
 /* a horrid kludge trying to make sure that this will fail on old kernels */
 #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
 
diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
index 6791f6508632..8bbcaa9024f9 100644
--- a/tools/arch/alpha/include/uapi/asm/errno.h
+++ b/tools/arch/alpha/include/uapi/asm/errno.h
@@ -127,4 +127,6 @@
 
 #define EHWPOISON	139	/* Memory page has hardware error */
 
+#define ENOTREG		140	/* Not a regular file */
+
 #endif
diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
index c01ed91b1ef4..293c78777254 100644
--- a/tools/arch/mips/include/uapi/asm/errno.h
+++ b/tools/arch/mips/include/uapi/asm/errno.h
@@ -126,6 +126,8 @@
 
 #define EHWPOISON	168	/* Memory page has hardware error */
 
+#define ENOTREG		169	/* Not a regular file */
+
 #define EDQUOT		1133	/* Quota exceeded */
 
 
diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
index 8cbc07c1903e..442917484f99 100644
--- a/tools/arch/parisc/include/uapi/asm/errno.h
+++ b/tools/arch/parisc/include/uapi/asm/errno.h
@@ -124,4 +124,6 @@
 
 #define EHWPOISON	257	/* Memory page has hardware error */
 
+#define ENOTREG		258	/* Not a regular file */
+
 #endif
diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
index 4a41e7835fd5..8dce0bfeab74 100644
--- a/tools/arch/sparc/include/uapi/asm/errno.h
+++ b/tools/arch/sparc/include/uapi/asm/errno.h
@@ -117,4 +117,6 @@
 
 #define EHWPOISON	135	/* Memory page has hardware error */
 
+#define ENOTREG		136	/* Not a regular file */
+
 #endif
diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
index 92e7ae493ee3..2216ab9aa32e 100644
--- a/tools/include/uapi/asm-generic/errno.h
+++ b/tools/include/uapi/asm-generic/errno.h
@@ -122,4 +122,6 @@
 
 #define EHWPOISON	133	/* Memory page has hardware error */
 
+#define ENOTREG		134	/* Not a regular file */
+
 #endif
-- 
2.52.0



---

Just a happy path test.

Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
---
 .../testing/selftests/openat2/openat2_test.c  | 37 ++++++++++++++++++-
 1 file changed, 36 insertions(+), 1 deletion(-)

diff --git a/tools/testing/selftests/openat2/openat2_test.c b/tools/testing/selftests/openat2/openat2_test.c
index 0e161ef9e9e4..011ebc9af4e5 100644
--- a/tools/testing/selftests/openat2/openat2_test.c
+++ b/tools/testing/selftests/openat2/openat2_test.c
@@ -320,8 +320,42 @@ void test_openat2_flags(void)
 	}
 }
 
+#ifndef O_REGULAR
+#define O_REGULAR 040000000
+#endif
+
+#ifndef ENOTREG
+#define ENOTREG 134
+#endif
+
+void test_openat2_o_regular_flag(void)
+{
+	if (!openat2_supported) {
+		ksft_test_result_skip(&quot;Skipping %s as openat2 is not supported\n&quot;, __func__);
+		return;
+	}
+
+	struct open_how how = {
+		.flags = O_REGULAR | O_RDONLY
+	};
+
+	int fd = sys_openat2(AT_FDCWD, &quot;/dev/null&quot;, &amp;how);
+
+	if (fd == ENOENT) {
+		ksft_test_result_skip(&quot;Skipping %s as there is no /dev/null\n&quot;, __func__);
+		return;
+	}
+
+	if (fd != -ENOTREG) {
+		ksft_test_result_fail(&quot;openat2 should return ENOTREG\n&quot;);
+		return;
+	}
+
+	ksft_test_result_pass(&quot;%s succeeded\n&quot;, __func__);
+}
+
 #define NUM_TESTS (NUM_OPENAT2_STRUCT_VARIATIONS * NUM_OPENAT2_STRUCT_TESTS + \
-		   NUM_OPENAT2_FLAG_TESTS)
+		   NUM_OPENAT2_FLAG_TESTS + 1)
 
 int main(int argc, char **argv)
 {
@@ -330,6 +364,7 @@ int main(int argc, char **argv)
 
 	test_openat2_struct();
 	test_openat2_flags();
+	test_openat2_o_regular_flag();
 
 	if (ksft_get_fail_cnt() + ksft_get_error_cnt() &gt; 0)
 		ksft_exit_fail();
-- 
2.52.0



---

Following the convention in include/uapi/asm-generic/fcntl.h and other
architecture specific arch/*/include/uapi/asm/fcntl.h files.

Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
---
 arch/sparc/include/uapi/asm/fcntl.h | 36 ++++++++++++++---------------
 1 file changed, 18 insertions(+), 18 deletions(-)

diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
index a93d18d2c23e..3c16f1a66a6a 100644
--- a/arch/sparc/include/uapi/asm/fcntl.h
+++ b/arch/sparc/include/uapi/asm/fcntl.h
@@ -2,23 +2,23 @@
 #ifndef _SPARC_FCNTL_H
 #define _SPARC_FCNTL_H
 
-#define O_APPEND	0x0008
-#define FASYNC		0x0040	/* fcntl, for BSD compatibility */
-#define O_CREAT		0x0200	/* not fcntl */
-#define O_TRUNC		0x0400	/* not fcntl */
-#define O_EXCL		0x0800	/* not fcntl */
-#define O_DSYNC		0x2000	/* used to be O_SYNC, see below */
-#define O_NONBLOCK	0x4000
+#define O_APPEND	0000000010
+#define FASYNC		0000000100	/* fcntl, for BSD compatibility */
+#define O_CREAT		0000001000	/* not fcntl */
+#define O_TRUNC		0000002000	/* not fcntl */
+#define O_EXCL		0000004000	/* not fcntl */
+#define O_DSYNC		0000020000	/* used to be O_SYNC, see below */
+#define O_NONBLOCK	0000040000
 #if defined(__sparc__) &amp;&amp; defined(__arch64__)
-#define O_NDELAY	0x0004
+#define O_NDELAY	0000000004
 #else
-#define O_NDELAY	(0x0004 | O_NONBLOCK)
+#define O_NDELAY	(0000000004 | O_NONBLOCK)
 #endif
-#define O_NOCTTY	0x8000	/* not fcntl */
-#define O_LARGEFILE	0x40000
-#define O_DIRECT        0x100000 /* direct disk access hint */
-#define O_NOATIME	0x200000
-#define O_CLOEXEC	0x400000
+#define O_NOCTTY	0000100000	/* not fcntl */
+#define O_LARGEFILE	0001000000
+#define O_DIRECT        0004000000 /* direct disk access hint */
+#define O_NOATIME	0010000000
+#define O_CLOEXEC	0020000000
 /*
  * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using
  * the O_SYNC flag.  We continue to use the existing numerical value
@@ -32,12 +32,12 @@
  *
  * Note: __O_SYNC must never be used directly.
  */
-#define __O_SYNC	0x800000
+#define __O_SYNC	0040000000
 #define O_SYNC		(__O_SYNC|O_DSYNC)
 
-#define O_PATH		0x1000000
-#define __O_TMPFILE	0x2000000
-#define O_REGULAR	0x4000000
+#define O_PATH		0100000000
+#define __O_TMPFILE	0200000000
+#define O_REGULAR	0400000000
 
 #define F_GETOWN	5	/*  for sockets. */
 #define F_SETOWN	6	/*  for sockets. */
-- 
2.52.0



---

Following the convention in include/uapi/asm-generic/fcntl.h and other
architecture specific arch/*/include/uapi/asm/fcntl.h files.

Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
---
 arch/mips/include/uapi/asm/fcntl.h | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/arch/mips/include/uapi/asm/fcntl.h b/arch/mips/include/uapi/asm/fcntl.h
index 0369a38e3d4f..6aa3f49df17e 100644
--- a/arch/mips/include/uapi/asm/fcntl.h
+++ b/arch/mips/include/uapi/asm/fcntl.h
@@ -11,15 +11,15 @@
 
 #include &lt;asm/sgidefs.h&gt;
 
-#define O_APPEND	0x0008
-#define O_DSYNC		0x0010	/* used to be O_SYNC, see below */
-#define O_NONBLOCK	0x0080
-#define O_CREAT		0x0100	/* not fcntl */
-#define O_TRUNC		0x0200	/* not fcntl */
-#define O_EXCL		0x0400	/* not fcntl */
-#define O_NOCTTY	0x0800	/* not fcntl */
-#define FASYNC		0x1000	/* fcntl, for BSD compatibility */
-#define O_LARGEFILE	0x2000	/* allow large file opens */
+#define O_APPEND	0000010
+#define O_DSYNC		0000020	/* used to be O_SYNC, see below */
+#define O_NONBLOCK	0000200
+#define O_CREAT		0000400	/* not fcntl */
+#define O_TRUNC		0001000	/* not fcntl */
+#define O_EXCL		0002000	/* not fcntl */
+#define O_NOCTTY	0004000	/* not fcntl */
+#define FASYNC		0010000	/* fcntl, for BSD compatibility */
+#define O_LARGEFILE	0020000	/* allow large file opens */
 /*
  * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using
  * the O_SYNC flag.  We continue to use the existing numerical value
@@ -33,9 +33,9 @@
  *
  * Note: __O_SYNC must never be used directly.
  */
-#define __O_SYNC	0x4000
+#define __O_SYNC	0040000
 #define O_SYNC		(__O_SYNC|O_DSYNC)
-#define O_DIRECT	0x8000	/* direct disk access hint */
+#define O_DIRECT	0100000	/* direct disk access hint */
 
 #define F_GETLK		14
 #define F_SETLK		6
-- 
2.52.0



---

On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt;
&gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; operate on regular files.
&gt; &gt;
&gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; will return -ENOTREG.
&gt; &gt;
&gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt;
&gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; is both a directory and a regular file.
&gt; &gt;
&gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; ---
&gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt;
&gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt;
&gt; &gt;  #define O_PATH               040000000
&gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt;
&gt; &gt;  #define F_GETLK              7
&gt; &gt;  #define F_SETLK              8
&gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt;
&gt; &gt;
&gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt;
&gt; &gt;  #define O_PATH               020000000
&gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt;
&gt; &gt;  #define F_GETLK64    8
&gt; &gt;  #define F_SETLK64    9
&gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt;
&gt; &gt;  #define O_PATH               0x1000000
&gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt;
&gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; --- a/fs/fcntl.c
&gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt;        */
&gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt;               HWEIGHT32(
&gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt;                       __FMODE_EXEC));
&gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; --- a/fs/namei.c
&gt; &gt; +++ b/fs/namei.c
&gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt;               if (unlikely(error))
&gt; &gt;                       return error;
&gt; &gt;       }
&gt; &gt; +
&gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; +             return -ENOTREG;
&gt; &gt; +
&gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt;               return -ENOTDIR;
&gt; &gt;
&gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt;       struct path path;
&gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt;       if (!error) {
&gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; +                     return -ENOTREG;
&gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt;               path_put(&amp;path);
&gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; --- a/fs/open.c
&gt; &gt; +++ b/fs/open.c
&gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt;
&gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt;
&gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt;  {
&gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt;                       return -EINVAL;
&gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt;                       return -EINVAL;
&gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; +             return -EINVAL;
&gt; &gt;       }
&gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt;
&gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt;  #endif
&gt; &gt;
&gt; &gt; +#ifndef O_REGULAR
&gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; +#endif
&gt; &gt; +
&gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt;
&gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt;
&gt; &gt;
&gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt;
&gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt;
&gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; +
&gt; &gt;  #endif
&gt;
&gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; is add in some patches that make all of the atomic_open operations in
&gt; the kernel return -EINVAL if O_REGULAR is set.
&gt;
&gt; Then, once the basic support is in, you or someone else can go back and
&gt; implement support for O_REGULAR where possible.

Thank you for the feedback. I don&#x27;t quite understand what I need to
fix. I thought open system calls always create regular files, so
atomic_open probably always creates regular files? Can you please give
me some more details as to where I need to fix this and what the
actual bug here is that is related to atomic_open?  I think I had done
some normal testing and when using O_CREAT | O_REGULAR, if the file
doesn&#x27;t exist, the file gets created and the file that gets created is
a regular file, so it probably makes sense? Or should the behavior be
that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
is opened if regular, otherwise -ENOTREG is returned?

Regards,
Dorjoy


---

On Wed, Jan 28, 2026 at 9:51 PM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt;
&gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt;
&gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt;
&gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt;
&gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt;
&gt;
&gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; want.
&gt;
&gt; What I was suggesting is that, as an interim step, you find all of the
&gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,

Sorry, I am just trying to fully understand this. Do you mean to
return -EINVAL from all atomic_open implementations in the kernel if
both O_REGULAR and O_DIRECTORY are set (or just only if O_REGULAR is
set, we need to return -EINVAL)? I am already returning -EINVAL when
both these are set from the build_open_flags function, so that should
already handle the cases, right? I think after atomic_open get called,
all code paths eventually go through the do_open function where I have
this check &quot;if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
return -ENOTREG&quot;. This is right before if ((nd-&gt;flags &amp;
LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry)) return -ENOTDIR;
which I had initially followed. So should I just return -EINVAL from
the atomic_open functions too if both O_REGULAR and O_DIRECTORY are
set? Sorry if I am misunderstanding this.

Regards,
Dorjoy


---

On Wed, Jan 28, 2026 at 1:12 PM Mateusz Guzik &lt;mjguzik@gmail.com&gt; wrote:
&gt;
&gt; On Wed, Jan 28, 2026 at 12:23:45AM +0100, Aleksa Sarai wrote:
&gt; &gt; In my view, this should be an openat2(2)-only API.
&gt;
&gt; fwiw +1 from me, the O_ flag situation is already terrible even without
&gt; the validation woes.
&gt;
&gt; I find it most unfortunate the openat2 syscall reuses the O_ namespace.
&gt; For my taste it would be best closed for business, with all new flag
&gt; additions using a different space.
&gt;
&gt; I can easily see people passing O_WHATEVER to open and openat by blindly
&gt; assuming they are supported just based on the name.
&gt;
&gt; that&#x27;s a side mini-rant, too late to do anything here now
&gt;
&gt; &gt; In addition, I would
&gt; &gt; propose that (instead of burning another O_* flag bit for this as a
&gt; &gt; special-purpose API just for regular files) you could have a mask of
&gt; &gt; which S_IFMT bits should be rejected as a new field in &quot;struct
&gt; &gt; open_how&quot;. This would let you reject sockets or device inodes but permit
&gt; &gt; FIFOs and regular files or directories, for instance. This could even be
&gt; &gt; done without a new O_* flag at all (the zero-value how-&gt;sfmt_mask would
&gt; &gt; allow everything and so would work well with extensible structs), but we
&gt; &gt; could add an O2_* flag anyway.
&gt;
&gt; I don&#x27;t think this works because the vars have overlapping bits:
&gt;   #define S_IFBLK  0060000
&gt;   #define S_IFDIR  0040000
&gt;
&gt; So you very much can&#x27;t select what you want off of a bitmask.
&gt;
&gt; At best the field could be used to select the one type you are fine with.
&gt;
&gt; If one was to pursue the idea, some other defines with unique bits would
&gt; need to be provided. But even then, semantics should be to only *allow*
&gt; the bits you are fine with and reject the rest.
&gt;
&gt; But I&#x27;m not at all confident this is worth any effort -- with
&gt; O_DIRECTORY already being there and O_REGULAR proposed, is there a use
&gt; case which wants something else?
&gt;

Good discussion. So should I just rename the O_REGULAR to O2_REGULAR
and create a VALID_OPENAT2_FLAGS and no need to do how-&gt;sfmt_mask
stuff?

&gt; &gt;
&gt; &gt; &gt; +#define ENOTREG            134     /* Not a regular file */
&gt; &gt; &gt; +
&gt; &gt;
&gt; [..]
&gt; &gt; Then to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind
&gt; &gt; of justify the existence of ENOTREG too. Unfortunately, you won&#x27;t be
&gt; &gt; able to use ENOTREG if you go with my idea of having mask bits in
&gt; &gt; open_how... (And what errno should we use then...? Hm.)
&gt; &gt;
&gt;
&gt; The most useful behavior would indicate what was found (e.g., a pipe).
&gt;
&gt; The easiest way to do it would create errnos for all types (EISDIR
&gt; already exists for one), but I can&#x27;t seriously propose that.
&gt;
&gt; Going the other way, EBADTYPE or something else reusable would be my
&gt; idea.

Good point. Maybe ENOTREG is acceptable too?

Regards,
Dorjoy


---

On Thu, Jan 29, 2026 at 4:49 PM Christian Brauner &lt;brauner@kernel.org&gt; wrote:
&gt;
&gt; On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:
&gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; operate on regular files.
&gt; &gt;
&gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; will return -ENOTREG.
&gt; &gt;
&gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt;
&gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; is both a directory and a regular file.
&gt; &gt;
&gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; ---
&gt;
&gt; Yeah, we shouldn&#x27;t add support for this outside of openat2(). We also
&gt; shouldn&#x27;t call this OEXT_* or O2_*. Let&#x27;s just follow the pattern where
&gt; we prefix the flag space with the name of the system call
&gt; OPENAT2_REGULAR.
&gt;

Thanks for the feedback. I agree that OPENAT2_REGULAR is better than
the other OEXT_*/O2_* options. Right now in the patch, the O_REGULAR
took the next slot in all the fcntl files. Should OPENAT2_REGULAR be a
bit outside of the 32bits? That way it won&#x27;t take any of the regular
O_* bits and we would only need to define it in
include/uapi/asm-generic/fcntl.h file and not need it in
arch/*/fcntl.h files. What do you think?

&gt; There&#x27;s also no real need to make O_DIRECTORY exclusive with
&gt; OPENAT2_REGULAR. Callers could legimitately want to open a directory or
&gt; regular file but not anything else. If someone wants to operate on a
&gt; whole filesystem tree but only wants to interact with regular files and
&gt; directories and ignore devices, sockets, fifos etc it&#x27;s very handy to
&gt; just be able to set both in flags.
&gt;
&gt; Frankly, this shouldn&#x27;t be a flag at all but we already have O_DIRECTORY
&gt; in there so no need to move this into a new field.
&gt;
&gt; Add EFTYPE as the errno code. Some of the bsds including macos already
&gt; have that.

Great suggestion. Will fixup in v4 submission.

Regards,
Dorjoy


---

On Thu, Jan 29, 2026 at 11:03 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt;
&gt; On 2026-01-29, Christian Brauner &lt;brauner@kernel.org&gt; wrote:
&gt; &gt; On Tue, Jan 27, 2026 at 11:58:17PM +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt;
&gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt;
&gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt;
&gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt;
&gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; ---
&gt; &gt;
&gt; &gt; Yeah, we shouldn&#x27;t add support for this outside of openat2(). We also
&gt; &gt; shouldn&#x27;t call this OEXT_* or O2_*. Let&#x27;s just follow the pattern where
&gt; &gt; we prefix the flag space with the name of the system call
&gt; &gt; OPENAT2_REGULAR.
&gt; &gt;
&gt; &gt; There&#x27;s also no real need to make O_DIRECTORY exclusive with
&gt; &gt; OPENAT2_REGULAR. Callers could legimitately want to open a directory or
&gt; &gt; regular file but not anything else. If someone wants to operate on a
&gt; &gt; whole filesystem tree but only wants to interact with regular files and
&gt; &gt; directories and ignore devices, sockets, fifos etc it&#x27;s very handy to
&gt; &gt; just be able to set both in flags.
&gt; &gt;
&gt; &gt; Frankly, this shouldn&#x27;t be a flag at all but we already have O_DIRECTORY
&gt; &gt; in there so no need to move this into a new field.
&gt;
&gt; You could even say O_NOFOLLOW is kinda like that too.
&gt;
&gt; In my other mail I proposed a bitmask of S_IFMT to reject opening (which
&gt; would let you allow FIFOs and regular files but block devices, etc).
&gt; Unfortunately I forgot that S_IFBLK is S_IFCHR|S_IFDIR. This isn&#x27;t fatal
&gt; to the idea but it kinda sucks. Grr.
&gt;

It is a good suggestion. I guess we can still introduce a new
how-&gt;sfmt_allow field and have new bits (instead of keeping in sync
with S_IF* ones) that allow types and just start with regular file
allow bit for now, right? But I guess it would be cumbersome for users
as an api to use different bits?

Regards,
Dorjoy


---

On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt;
&gt; On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; &gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; &gt; want.
&gt; &gt; &gt;
&gt; &gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; &gt;
&gt; &gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; &gt; from the server when it&#x27;s set though.
&gt; &gt;
&gt; &gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; &gt;
&gt; &gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; &gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; &gt;
&gt; &gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; &gt; with atomic open for all filesystems.
&gt; &gt;
&gt; &gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; &gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; &gt; and completely broken before that.
&gt; &gt;
&gt; &gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; &gt; -&gt;atomic_open:: to the filesystem.
&gt; &gt;
&gt; &gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; &gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; &gt; a directory. At that point the damage such as side-effects from device
&gt; &gt; opening is already done.
&gt; &gt;
&gt; &gt;
&gt;
&gt; Exactly. I guess you could send an immediate close, but that&#x27;s not
&gt; without side effects.
&gt;
&gt; &gt;
&gt; &gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; &gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; &gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; &gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; &gt; it wrong.
&gt; &gt;
&gt; &gt; For (2) it is problematic as there surely are filesystems with
&gt; &gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; &gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; &gt; trigger an actual open on a non-regular file such as a
&gt; &gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; &gt; going on.
&gt; &gt;
&gt; &gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; &gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; &gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; &gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; &gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; &gt; half-way.
&gt; &gt;
&gt; &gt; I guess to make that really work you&#x27;d need some protocol extension?
&gt;
&gt; For NFS, I think we&#x27;re OK. The OPEN call on NFSv4 only works for
&gt; regular files, so it should be able to handle O_REGULAR. We just need
&gt; to rejigger the error handling when it&#x27;s set (just return an error
&gt; instead of doing the open of a directory or whatever it is).
&gt;

Thank you for the details. Do you remember which codepath this is? Is
this the inode_operations.atomic_open codepath or file_operations.open
codepath? I am a bit confused also about where exactly the error
handling that needs to be done.

&gt; The others (at a quick glance):
&gt;
&gt; cifs: I don&#x27;t see a way to specify an O_REGULAR equivalent to the
&gt; SMB2_CREATE call and it looks like it can create directories. Maybe
&gt; SteveF (cc&#x27;ed) knows if this is possible?
&gt;
&gt; ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case
&gt; O_REGULAR can probably be supported similarly to NFS.
&gt;
&gt; fuse: probably ok? Does finish_no_open() in most cases. May depend on
&gt; the userland driver though.
&gt;
&gt; gfs2: is ok, it just does finish_no_open() in most cases anyway
&gt;
&gt; vboxsf: does finish_no_open on non-creates, so you could probably just
&gt; punt to that if O_REGULAR is set.
&gt;

These are all inode_operations.atomic_open code paths, right? Because
you mentioned finish_no_open and I see finish_no_open in the
atomic_open code paths as opposed to file_operations.open code paths.

Regards,
Dorjoy


---

On Thu, Feb 19, 2026 at 1:01 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt;
&gt; On Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; &gt; &gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; &gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; &gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; &gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; &gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; &gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; &gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; &gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; &gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; &gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; &gt; &gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; &gt; &gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; &gt; &gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; &gt; &gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; &gt; &gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; &gt; &gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; &gt; &gt; &gt; want.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; &gt; &gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; &gt; &gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; &gt; &gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; &gt; &gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; &gt; &gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; &gt; &gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; &gt; &gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; &gt; &gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; &gt; &gt; &gt; from the server when it&#x27;s set though.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; &gt; &gt; &gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; &gt; &gt; &gt; with atomic open for all filesystems.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; &gt; &gt; &gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; &gt; &gt; &gt; and completely broken before that.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; &gt; &gt; &gt; -&gt;atomic_open:: to the filesystem.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; &gt; &gt; &gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; &gt; &gt; &gt; a directory. At that point the damage such as side-effects from device
&gt; &gt; &gt; &gt; opening is already done.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Exactly. I guess you could send an immediate close, but that&#x27;s not
&gt; &gt; &gt; without side effects.
&gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; &gt; &gt; &gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; &gt; &gt; &gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; &gt; &gt; &gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; &gt; &gt; &gt; it wrong.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; For (2) it is problematic as there surely are filesystems with
&gt; &gt; &gt; &gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; &gt; &gt; &gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; &gt; &gt; &gt; trigger an actual open on a non-regular file such as a
&gt; &gt; &gt; &gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; &gt; &gt; &gt; going on.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; &gt; &gt; &gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; &gt; &gt; &gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; &gt; &gt; &gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; &gt; &gt; &gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; &gt; &gt; &gt; half-way.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; I guess to make that really work you&#x27;d need some protocol extension?
&gt; &gt; &gt;
&gt; &gt; &gt; For NFS, I think we&#x27;re OK. The OPEN call on NFSv4 only works for
&gt; &gt; &gt; regular files, so it should be able to handle O_REGULAR. We just need
&gt; &gt; &gt; to rejigger the error handling when it&#x27;s set (just return an error
&gt; &gt; &gt; instead of doing the open of a directory or whatever it is).
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; Thank you for the details. Do you remember which codepath this is? Is
&gt; &gt; this the inode_operations.atomic_open codepath or file_operations.open
&gt; &gt; codepath? I am a bit confused also about where exactly the error
&gt; &gt; handling that needs to be done.
&gt; &gt;
&gt;
&gt; I was thinking nfs_atomic_open().
&gt;
&gt; Looking now, I think it might actually work OK without changes. It just
&gt; might not be terribly efficient about it.
&gt;
&gt; If the open_context() call returns -EISDIR or similar, then you really
&gt; don&#x27;t need to do the call to nfs_lookup() and the like. You can just
&gt; return an immediate error when O_REGULAR is set since you know it&#x27;s not
&gt; suitable to be opened.
&gt;

Right. And I guess we don&#x27;t need to worry about O_REGULAR being an
unknown flag when it gets sent to the server (not only for NFS / but
others as well)?

&gt; &gt; &gt; The others (at a quick glance):
&gt; &gt; &gt;
&gt; &gt; &gt; cifs: I don&#x27;t see a way to specify an O_REGULAR equivalent to the
&gt; &gt; &gt; SMB2_CREATE call and it looks like it can create directories. Maybe
&gt; &gt; &gt; SteveF (cc&#x27;ed) knows if this is possible?
&gt; &gt; &gt;
&gt; &gt; &gt; ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case
&gt; &gt; &gt; O_REGULAR can probably be supported similarly to NFS.
&gt; &gt; &gt;
&gt; &gt; &gt; fuse: probably ok? Does finish_no_open() in most cases. May depend on
&gt; &gt; &gt; the userland driver though.
&gt; &gt; &gt;
&gt; &gt; &gt; gfs2: is ok, it just does finish_no_open() in most cases anyway
&gt; &gt; &gt;
&gt; &gt; &gt; vboxsf: does finish_no_open on non-creates, so you could probably just
&gt; &gt; &gt; punt to that if O_REGULAR is set.
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; These are all inode_operations.atomic_open code paths, right? Because
&gt; &gt; you mentioned finish_no_open and I see finish_no_open in the
&gt; &gt; atomic_open code paths as opposed to file_operations.open code paths.
&gt; &gt;
&gt;
&gt; Note that this was just a cursory look. Someone will need to do a
&gt; deeper dive and test these cases.
&gt;
&gt; I think most will end up working ok, since most fall back to doing a
&gt; finish_no_open(). There may be opportunities to optimize some of these
&gt; cases though (similarly to how I mentioned with NFS).

I can try to look into these and see if I can implement handling for
O_REGULAR flag for these filesystems in the atomic_open code paths.
Thanks for the details.

Will I need to modify the corresponding file_operations.open code
paths as well along with atomic_open code paths?

Regards,
Dorjoy


---

On Thu, Feb 19, 2026 at 1:32 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt;
&gt; On Thu, 2026-02-19 at 01:19 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; On Thu, Feb 19, 2026 at 1:01 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Thu, 2026-02-19 at 00:26 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; On Thu, Jan 29, 2026 at 7:12 PM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; On Thu, 2026-01-29 at 13:33 +0100, Christian Brauner wrote:
&gt; &gt; &gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 10:51:07AM -0500, Jeff Layton wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Wed, 2026-01-28 at 21:36 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On Wed, Jan 28, 2026 at 5:52 AM Jeff Layton &lt;jlayton@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On Tue, 2026-01-27 at 23:58 +0600, Dorjoy Chowdhury wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; This flag indicates the path should be opened if it&#x27;s a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; This is useful to write secure programs that want to avoid being tricked
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; into opening device nodes with special semantics while thinking they
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; operate on regular files.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; A corresponding error code ENOTREG has been introduced. For example, if
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; open is called on path /dev/null with O_REGULAR in the flag param, it
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; will return -ENOTREG.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; When used in combination with O_CREAT, either the regular file is
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; created, or if the path already exists, it is opened if it&#x27;s a regular
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; file. Otherwise, -ENOTREG is returned.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; part of O_TMPFILE) because it doesn&#x27;t make sense to open a path that
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; is both a directory and a regular file.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Dorjoy Chowdhury &lt;dorjoychy111@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/alpha/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/mips/include/uapi/asm/errno.h         | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/errno.h       | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/parisc/include/uapi/asm/fcntl.h       | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/errno.h        | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  arch/sparc/include/uapi/asm/fcntl.h        | 1 +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/fcntl.c                                 | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/namei.c                                 | 6 ++++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  fs/open.c                                  | 4 +++-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/linux/fcntl.h                      | 2 +-
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/errno.h           | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  include/uapi/asm-generic/fcntl.h           | 4 ++++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/mips/include/uapi/asm/errno.h   | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/parisc/include/uapi/asm/errno.h | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  tools/include/uapi/asm-generic/errno.h     | 2 ++
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  18 files changed, 38 insertions(+), 3 deletions(-)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 50bdc8e8a271..4da5a64c23bd 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/alpha/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -34,6 +34,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0200000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK              7
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK              8
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 03dee816cb13..0cc3320fe326 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/parisc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -19,6 +19,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0100000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETLK64    8
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETLK64    9
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 67dae75e5274..a93d18d2c23e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/arch/sparc/include/uapi/asm/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -37,6 +37,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_PATH               0x1000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  0x2000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    0x4000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_GETOWN     5       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define F_SETOWN     6       /*  for sockets. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index f93dbca08435..62ab4ad2b6f5 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -     BUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               HWEIGHT32(
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       __FMODE_EXEC));
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index b28ecb699f32..f5504ae4b03c 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (unlikely(error))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return error;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     if ((open_flag &amp; O_REGULAR) &amp;&amp; !d_is_reg(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               return -ENOTDIR;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       struct path path;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       int error = path_lookupat(nd, flags, &amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (!error) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             if ((file-&gt;f_flags &amp; O_REGULAR) &amp;&amp; !d_is_reg(path.dentry))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +                     return -ENOTREG;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               audit_inode(nd-&gt;name, path.dentry, 0);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               error = vfs_open(&amp;path, file);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               path_put(&amp;path);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 74c4c1462b3e..82153e21907e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/open.c
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  EXPORT_SYMBOL_GPL(kernel_file_open);
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define WILL_CREATE(flags)   (flags &amp; (O_CREAT | __O_TMPFILE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_PATH_FLAGS         (O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  inline struct open_how build_open_how(int flags, umode_t mode)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               if (!(acc_mode &amp; MAY_WRITE))
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                       return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +     } else if ((flags &amp; O_DIRECTORY) &amp;&amp; (flags &amp; O_REGULAR)) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +             return -EINVAL;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       }
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       if (flags &amp; O_PATH) {
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;               /* O_PATH only permits certain other flags to be set. */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index a332e79b3207..4fd07b0e0a17 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;        FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; -      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +      O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* List of all valid flags for the how-&gt;resolve argument: */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define VALID_RESOLVE_FLAGS \
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 613475285643..3468b352a575 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -88,6 +88,10 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define __O_TMPFILE  020000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#ifndef O_REGULAR
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define O_REGULAR    040000000
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  /* a horrid kludge trying to make sure that this will fail on old kernels */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 6791f6508632..8bbcaa9024f9 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/alpha/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -127,4 +127,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    139     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              140     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index c01ed91b1ef4..293c78777254 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/mips/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -126,6 +126,8 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    168     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              169     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EDQUOT               1133    /* Quota exceeded */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 8cbc07c1903e..442917484f99 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/parisc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -124,4 +124,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    257     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              258     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 4a41e7835fd5..8dce0bfeab74 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/arch/sparc/include/uapi/asm/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -117,4 +117,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    135     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              136     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; diff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; index 92e7ae493ee3..2216ab9aa32e 100644
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; --- a/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +++ b/tools/include/uapi/asm-generic/errno.h
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -122,4 +122,6 @@
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #define EHWPOISON    133     /* Memory page has hardware error */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +#define ENOTREG              134     /* Not a regular file */
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  #endif
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; One thing this patch is missing is handling for -&gt;atomic_open(). I
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; imagine most of the filesystems that provide that op can&#x27;t support
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; O_REGULAR properly (maybe cifs can? idk). What you probably want to do
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; is add in some patches that make all of the atomic_open operations in
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; the kernel return -EINVAL if O_REGULAR is set.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Then, once the basic support is in, you or someone else can go back and
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; implement support for O_REGULAR where possible.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Thank you for the feedback. I don&#x27;t quite understand what I need to
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; fix. I thought open system calls always create regular files, so
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; atomic_open probably always creates regular files? Can you please give
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; me some more details as to where I need to fix this and what the
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; actual bug here is that is related to atomic_open?  I think I had done
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; some normal testing and when using O_CREAT | O_REGULAR, if the file
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; doesn&#x27;t exist, the file gets created and the file that gets created is
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; a regular file, so it probably makes sense? Or should the behavior be
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; that if file doesn&#x27;t exist, -EINVAL is returned and if file exists it
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; is opened if regular, otherwise -ENOTREG is returned?
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; atomic_open() is a combination lookup+open for when the dentry isn&#x27;t
&gt; &gt; &gt; &gt; &gt; &gt; &gt; present in the dcache. The normal open codepath that you&#x27;re patching
&gt; &gt; &gt; &gt; &gt; &gt; &gt; does not get called in this case when -&gt;atomic_open is set for the
&gt; &gt; &gt; &gt; &gt; &gt; &gt; filesystem. It&#x27;s mostly used by network filesystems that need to
&gt; &gt; &gt; &gt; &gt; &gt; &gt; optimize away the lookup since it&#x27;s wasted round trip, and is often
&gt; &gt; &gt; &gt; &gt; &gt; &gt; racy anyway. Your patchset doesn&#x27;t address those filesystems. They will
&gt; &gt; &gt; &gt; &gt; &gt; &gt; likely end up ignoring O_REGULAR in that case, which is not what you
&gt; &gt; &gt; &gt; &gt; &gt; &gt; want.
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; What I was suggesting is that, as an interim step, you find all of the
&gt; &gt; &gt; &gt; &gt; &gt; &gt; atomic_open operations in the kernel (there are maybe a dozen or so),
&gt; &gt; &gt; &gt; &gt; &gt; &gt; and just make them return -EINVAL if someone sets O_DIRECTORY. Later,
&gt; &gt; &gt; &gt; &gt; &gt; &gt; you or someone else can then go back and do a proper implementation of
&gt; &gt; &gt; &gt; &gt; &gt; &gt; O_REGULAR handling on those filesystems, at least on the ones where
&gt; &gt; &gt; &gt; &gt; &gt; &gt; it&#x27;s possible. You will probably also need to similarly patch the
&gt; &gt; &gt; &gt; &gt; &gt; &gt; open() routines for those filesystems too. Otherwise you&#x27;ll get
&gt; &gt; &gt; &gt; &gt; &gt; &gt; inconsistent behavior vs. when the dentry is in the cache.
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; One note: I think NFS probably can support O_DIRECTORY, since its OPEN
&gt; &gt; &gt; &gt; &gt; &gt; &gt; call only works on files. We&#x27;ll need to change how we handle errors
&gt; &gt; &gt; &gt; &gt; &gt; &gt; from the server when it&#x27;s set though.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; So I think you&#x27;re proposing two separate things or there&#x27;s a typo:
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; (1) blocking O_DIRECTORY for -&gt;atomic_open::
&gt; &gt; &gt; &gt; &gt; &gt; (2) blocking O_REGULAR for -&gt;atomic_open::
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; The (1) point implies that O_DIRECTORY currently doesn&#x27;t work correctly
&gt; &gt; &gt; &gt; &gt; &gt; with atomic open for all filesystems.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Ever since 43b450632676 (&quot;open: return EINVAL for O_DIRECTORY |
&gt; &gt; &gt; &gt; &gt; &gt; O_CREAT&quot;) O_DIRECTORY with O_CREAT is blocked. It was accidently allowed
&gt; &gt; &gt; &gt; &gt; &gt; and completely broken before that.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; For O_DIRECTORY without O_CREAT the kernel will pass that down through
&gt; &gt; &gt; &gt; &gt; &gt; -&gt;atomic_open:: to the filesystem.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; The worry that I see is that a network filesystem via -&gt;atomic_open::
&gt; &gt; &gt; &gt; &gt; &gt; somehow already called open on the server side on something that wasn&#x27;t
&gt; &gt; &gt; &gt; &gt; &gt; a directory. At that point the damage such as side-effects from device
&gt; &gt; &gt; &gt; &gt; &gt; opening is already done.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Exactly. I guess you could send an immediate close, but that&#x27;s not
&gt; &gt; &gt; &gt; &gt; without side effects.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; But I suspect that every filesystem implementing -&gt;atomic_open:: just
&gt; &gt; &gt; &gt; &gt; &gt; does finish_no_open() and punts to the VFS for the actual open. And the
&gt; &gt; &gt; &gt; &gt; &gt; VFS will catch it in do_open() for it actually opens the file. So the
&gt; &gt; &gt; &gt; &gt; &gt; only real worry for O_DIRECTORY I see is that there&#x27;s an fs that handles
&gt; &gt; &gt; &gt; &gt; &gt; it wrong.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; For (2) it is problematic as there surely are filesystems with
&gt; &gt; &gt; &gt; &gt; &gt; -&gt;atomic_open:: that do handle the ~O_CREAT case and return with
&gt; &gt; &gt; &gt; &gt; &gt; FMODE_OPENED. So that&#x27;ll be problematic if the intention is to not
&gt; &gt; &gt; &gt; &gt; &gt; trigger an actual open on a non-regular file such as a
&gt; &gt; &gt; &gt; &gt; &gt; device/socket/fifo etc. before the VFS had a chance to validate what&#x27;s
&gt; &gt; &gt; &gt; &gt; &gt; going on.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; So I&#x27;m not excited about having this 70% working and punting on
&gt; &gt; &gt; &gt; &gt; &gt; -&gt;atomic_open:: waiting for someone to fix this. One option would be to
&gt; &gt; &gt; &gt; &gt; &gt; bypass -&gt;atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback
&gt; &gt; &gt; &gt; &gt; &gt; to racy and pricy lookup + open for now. How problematic would that be?
&gt; &gt; &gt; &gt; &gt; &gt; If possible I&#x27;d prefer this a lot over merging something that works
&gt; &gt; &gt; &gt; &gt; &gt; half-way.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; I guess to make that really work you&#x27;d need some protocol extension?
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; For NFS, I think we&#x27;re OK. The OPEN call on NFSv4 only works for
&gt; &gt; &gt; &gt; &gt; regular files, so it should be able to handle O_REGULAR. We just need
&gt; &gt; &gt; &gt; &gt; to rejigger the error handling when it&#x27;s set (just return an error
&gt; &gt; &gt; &gt; &gt; instead of doing the open of a directory or whatever it is).
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thank you for the details. Do you remember which codepath this is? Is
&gt; &gt; &gt; &gt; this the inode_operations.atomic_open codepath or file_operations.open
&gt; &gt; &gt; &gt; codepath? I am a bit confused also about where exactly the error
&gt; &gt; &gt; &gt; handling that needs to be done.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; I was thinking nfs_atomic_open().
&gt; &gt; &gt;
&gt; &gt; &gt; Looking now, I think it might actually work OK without changes. It just
&gt; &gt; &gt; might not be terribly efficient about it.
&gt; &gt; &gt;
&gt; &gt; &gt; If the open_context() call returns -EISDIR or similar, then you really
&gt; &gt; &gt; don&#x27;t need to do the call to nfs_lookup() and the like. You can just
&gt; &gt; &gt; return an immediate error when O_REGULAR is set since you know it&#x27;s not
&gt; &gt; &gt; suitable to be opened.
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; Right. And I guess we don&#x27;t need to worry about O_REGULAR being an
&gt; &gt; unknown flag when it gets sent to the server (not only for NFS / but
&gt; &gt; others as well)?
&gt; &gt;
&gt;
&gt; You shouldn&#x27;t. We don&#x27;t send POSIX flags in NFSv4 requests. It has its
&gt; own set of flags. In the case of NFSv4, O_REGULAR is already implied in
&gt; an OPEN call on the wire. OPEN only operates on regular files.
&gt;

Alright. Thanks for the details again!

&gt; &gt; &gt; &gt; &gt; The others (at a quick glance):
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; cifs: I don&#x27;t see a way to specify an O_REGULAR equivalent to the
&gt; &gt; &gt; &gt; &gt; SMB2_CREATE call and it looks like it can create directories. Maybe
&gt; &gt; &gt; &gt; &gt; SteveF (cc&#x27;ed) knows if this is possible?
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; ceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case
&gt; &gt; &gt; &gt; &gt; O_REGULAR can probably be supported similarly to NFS.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; fuse: probably ok? Does finish_no_open() in most cases. May depend on
&gt; &gt; &gt; &gt; &gt; the userland driver though.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; gfs2: is ok, it just does finish_no_open() in most cases anyway
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; vboxsf: does finish_no_open on non-creates, so you could probably just
&gt; &gt; &gt; &gt; &gt; punt to that if O_REGULAR is set.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; These are all inode_operations.atomic_open code paths, right? Because
&gt; &gt; &gt; &gt; you mentioned finish_no_open and I see finish_no_open in the
&gt; &gt; &gt; &gt; atomic_open code paths as opposed to file_operations.open code paths.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Note that this was just a cursory look. Someone will need to do a
&gt; &gt; &gt; deeper dive and test these cases.
&gt; &gt; &gt;
&gt; &gt; &gt; I think most will end up working ok, since most fall back to doing a
&gt; &gt; &gt; finish_no_open(). There may be opportunities to optimize some of these
&gt; &gt; &gt; cases though (similarly to how I mentioned with NFS).
&gt; &gt;
&gt; &gt; I can try to look into these and see if I can implement handling for
&gt; &gt; O_REGULAR flag for these filesystems in the atomic_open code paths.
&gt; &gt; Thanks for the details.
&gt; &gt;
&gt; &gt; Will I need to modify the corresponding file_operations.open code
&gt; &gt; paths as well along with atomic_open code paths?
&gt; &gt;
&gt;
&gt; Probably not.
&gt;
&gt; The main thing to keep in mind is that -&gt;open is used when we already
&gt; have a dentry for the target of the open. -&gt;atomic_open is used when we
&gt; don&#x27;t have one yet or the one we have has failed revalidation.
&gt;
&gt; If you have a valid dentry, then you should be able to satisfy the
&gt; O_REGULAR check without having to call into -&gt;open at all.

Understood. Thanks!

Regards,
Dorjoy

</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, concerns about flag behavior</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>