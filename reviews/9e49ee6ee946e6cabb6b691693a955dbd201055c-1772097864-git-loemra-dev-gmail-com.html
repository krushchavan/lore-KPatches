<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: [PATCH v4 2/3] btrfs: inhibit extent buffer writeback to prevent COW amplification</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }
        .reply-to-label {
            font-size: 0.8em;
            color: #999;
            font-style: italic;
            margin-top: 3px;
        }
        .lore-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 0.82em;
            color: #0366d6;
            text-decoration: none;
            font-weight: 500;
            white-space: nowrap;
        }
        .lore-link:hover { text-decoration: underline; color: #0056b3; }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../index.html">&larr; Back to reports</a></div>
    <h1>[PATCH v4 2/3] btrfs: inhibit extent buffer writeback to prevent COW amplification</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/9e49ee6ee946e6cabb6b691693a955dbd201055c.1772097864.git.loemra.dev@gmail.com/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-26">2026-02-26</a></div>
    <div class="patch-summary-block"><div class="patch-summary-label">Patch summary</div><div class="patch-summary-text">This patch adds a new tracepoint to the Btrfs file system, specifically for tracking search slot restarts during btrfs_search_slot() operations. The tracepoint records the root, tree level, and reason for each restart, enabling more detailed analysis of COW amplification under memory pressure.</div></div>
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-26">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Filipe Manana</span>
<a class="date-chip" href="../2026-02-26_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-26">2026-02-26</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Provided a Reviewed-by tag, indicating they have reviewed the code and found it acceptable for inclusion in the kernel.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Thu, Feb 26, 2026 at 9:58 AM Leo Martins &lt;loemra.dev@gmail.com&gt; wrote:
&gt;
&gt; Inhibit writeback on COW&#x27;d extent buffers for the lifetime of the
&gt; transaction handle, preventing background writeback from setting
&gt; BTRFS_HEADER_FLAG_WRITTEN and causing unnecessary re-COW.
&gt;
&gt; COW amplification occurs when background writeback flushes an extent
&gt; buffer that a transaction handle is still actively modifying. When
&gt; lock_extent_buffer_for_io() transitions a buffer from dirty to
&gt; writeback, it sets BTRFS_HEADER_FLAG_WRITTEN, marking the block as
&gt; having been persisted to disk at its current bytenr. Once WRITTEN is
&gt; set, should_cow_block() must either COW the block again or overwrite
&gt; it in place, both of which are unnecessary overhead when the buffer
&gt; is still being modified by the same handle that allocated it. By
&gt; inhibiting background writeback on actively-used buffers, WRITTEN is
&gt; never set while a transaction handle holds a reference to the buffer,
&gt; avoiding this overhead entirely.
&gt;
&gt; Add an atomic_t writeback_inhibitors counter to struct extent_buffer,
&gt; which fits in an existing 6-byte hole without increasing struct size.
&gt; When a buffer is COW&#x27;d in btrfs_force_cow_block(), call
&gt; btrfs_inhibit_eb_writeback() to store the eb in the transaction
&gt; handle&#x27;s writeback_inhibited_ebs xarray (keyed by eb-&gt;start), take a
&gt; reference, and increment writeback_inhibitors. The function handles
&gt; dedup (same eb inhibited twice by the same handle) and replacement
&gt; (different eb at the same logical address). Allocation failure is
&gt; graceful: the buffer simply falls back to the pre-existing behavior
&gt; where it may be written back and re-COW&#x27;d.
&gt;
&gt; Also inhibit writeback in should_cow_block() when COW is skipped,
&gt; so that every transaction handle that reuses an already-COW&#x27;d buffer
&gt; also inhibits its writeback. Without this, if handle A COWs a block
&gt; and inhibits it, and handle B later reuses the same block without
&gt; inhibiting, handle A&#x27;s uninhibit on end_transaction leaves the buffer
&gt; unprotected while handle B is still using it. This ensures all handles
&gt; that access a COW&#x27;d buffer contribute to the inhibitor count, and the
&gt; buffer remains protected until the last handle releases it.
&gt;
&gt; In lock_extent_buffer_for_io(), when writeback_inhibitors is non-zero
&gt; and the writeback mode is WB_SYNC_NONE, skip the buffer. WB_SYNC_NONE
&gt; is used by the VM flusher threads for background and periodic
&gt; writeback, which are the only paths that cause COW amplification by
&gt; opportunistically writing out dirty extent buffers mid-transaction.
&gt; Skipping these is safe because the buffers remain dirty in the page
&gt; cache and will be written out at transaction commit time.
&gt;
&gt; WB_SYNC_ALL must always proceed regardless of writeback_inhibitors.
&gt; This is required for correctness in the fsync path: btrfs_sync_log()
&gt; writes log tree blocks via filemap_fdatawrite_range() (WB_SYNC_ALL)
&gt; while the transaction handle that inhibited those same blocks is still
&gt; active. Without the WB_SYNC_ALL bypass, those inhibited log tree
&gt; blocks would be silently skipped, resulting in an incomplete log on
&gt; disk and corruption on replay. btrfs_write_and_wait_transaction()
&gt; also uses WB_SYNC_ALL via filemap_fdatawrite_range(); for that path,
&gt; inhibitors are already cleared beforehand, but the bypass ensures
&gt; correctness regardless.
&gt;
&gt; Uninhibit in __btrfs_end_transaction() before atomic_dec(num_writers)
&gt; to prevent a race where the committer proceeds while buffers are still
&gt; inhibited. Also uninhibit in btrfs_commit_transaction() before writing
&gt; and in cleanup_transaction() for the error path.
&gt;
&gt; Signed-off-by: Leo Martins &lt;loemra.dev@gmail.com&gt;
&gt; ---
&gt;  fs/btrfs/ctree.c       |  9 ++++++
&gt;  fs/btrfs/extent_io.c   | 63 +++++++++++++++++++++++++++++++++++++++++-
&gt;  fs/btrfs/extent_io.h   |  6 ++++
&gt;  fs/btrfs/transaction.c | 19 +++++++++++++
&gt;  fs/btrfs/transaction.h |  3 ++
&gt;  5 files changed, 99 insertions(+), 1 deletion(-)
&gt;
&gt; diff --git a/fs/btrfs/ctree.c b/fs/btrfs/ctree.c
&gt; index ea7cfc3a9e89..46a715c95bc8 100644
&gt; --- a/fs/btrfs/ctree.c
&gt; +++ b/fs/btrfs/ctree.c
&gt; @@ -21,6 +21,7 @@
&gt;  #include &quot;fs.h&quot;
&gt;  #include &quot;accessors.h&quot;
&gt;  #include &quot;extent-tree.h&quot;
&gt; +#include &quot;extent_io.h&quot;
&gt;  #include &quot;relocation.h&quot;
&gt;  #include &quot;file-item.h&quot;
&gt;
&gt; @@ -590,6 +591,10 @@ int btrfs_force_cow_block(struct btrfs_trans_handle *trans,
&gt;                 btrfs_tree_unlock(buf);
&gt;         free_extent_buffer_stale(buf);
&gt;         btrfs_mark_buffer_dirty(trans, cow);
&gt; +
&gt; +       /* Inhibit writeback on the COW&#x27;d buffer for this transaction handle. */
&gt; +       btrfs_inhibit_eb_writeback(trans, cow);

Btw, that comment is redundant. It&#x27;s clear what we are doing, since
the function&#x27;s name is clear about what it does and the eb is named
&quot;cow&quot;.
Usually we add comments for things that are not obvious.

&gt; +
&gt;         *cow_ret = cow;
&gt;         return 0;
&gt;
&gt; @@ -617,6 +622,9 @@ int btrfs_force_cow_block(struct btrfs_trans_handle *trans,
&gt;   * When returning false for a WRITTEN buffer allocated in the current
&gt;   * transaction, re-dirties the buffer for in-place overwrite instead
&gt;   * of requesting a new COW.
&gt; + *
&gt; + * When returning false, inhibits background writeback on the buffer
&gt; + * for the lifetime of the transaction handle.
&gt;   */
&gt;  static inline bool should_cow_block(struct btrfs_trans_handle *trans,
&gt;                                     const struct btrfs_root *root,
&gt; @@ -684,6 +692,7 @@ static inline bool should_cow_block(struct btrfs_trans_handle *trans,
&gt;                 btrfs_mark_buffer_dirty(trans, buf);
&gt;         }
&gt;
&gt; +       btrfs_inhibit_eb_writeback(trans, buf);
&gt;         return false;
&gt;  }
&gt;
&gt; diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
&gt; index ff1fc699a6ca..e04e42a81978 100644
&gt; --- a/fs/btrfs/extent_io.c
&gt; +++ b/fs/btrfs/extent_io.c
&gt; @@ -1940,7 +1940,9 @@ static noinline_for_stack bool lock_extent_buffer_for_io(struct extent_buffer *e
&gt;          * of time.
&gt;          */
&gt;         spin_lock(&amp;eb-&gt;refs_lock);
&gt; -       if (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &amp;eb-&gt;bflags)) {
&gt; +       if ((wbc-&gt;sync_mode == WB_SYNC_ALL ||
&gt; +            atomic_read(&amp;eb-&gt;writeback_inhibitors) == 0) &amp;&amp;
&gt; +           test_and_clear_bit(EXTENT_BUFFER_DIRTY, &amp;eb-&gt;bflags)) {
&gt;                 XA_STATE(xas, &amp;fs_info-&gt;buffer_tree, eb-&gt;start &gt;&gt; fs_info-&gt;nodesize_bits);
&gt;                 unsigned long flags;
&gt;
&gt; @@ -2999,6 +3001,64 @@ static inline void btrfs_release_extent_buffer(struct extent_buffer *eb)
&gt;         kmem_cache_free(extent_buffer_cache, eb);
&gt;  }
&gt;
&gt; +/*
&gt; + * btrfs_inhibit_eb_writeback - Inhibit writeback on buffer during transaction.
&gt; + * @trans: transaction handle that will own the inhibitor
&gt; + * @eb: extent buffer to inhibit writeback on
&gt; + *
&gt; + * Attempts to track this extent buffer in the transaction&#x27;s inhibited set.
&gt; + * If memory allocation fails, the buffer is simply not tracked. It may
&gt; + * be written back and need re-COW, which is the original behavior.
&gt; + * This is acceptable since inhibiting writeback is an optimization.
&gt; + */
&gt; +void btrfs_inhibit_eb_writeback(struct btrfs_trans_handle *trans,
&gt; +                               struct extent_buffer *eb)
&gt; +{
&gt; +       unsigned long index = eb-&gt;start &gt;&gt; trans-&gt;fs_info-&gt;nodesize_bits;
&gt; +       void *old;
&gt; +
&gt; +       /* Check if already inhibited by this handle. */
&gt; +       old = xa_load(&amp;trans-&gt;writeback_inhibited_ebs, index);
&gt; +       if (old == eb)
&gt; +               return;
&gt; +
&gt; +       /* Take reference for the xarray entry. */
&gt; +       refcount_inc(&amp;eb-&gt;refs);
&gt; +
&gt; +       old = xa_store(&amp;trans-&gt;writeback_inhibited_ebs, index, eb, GFP_NOFS);
&gt; +       if (xa_is_err(old)) {
&gt; +               /* Allocation failed, just skip inhibiting this buffer. */
&gt; +               free_extent_buffer(eb);
&gt; +               return;
&gt; +       }
&gt; +
&gt; +       /* Handle replacement of different eb at same index. */
&gt; +       if (old &amp;&amp; old != eb) {
&gt; +               struct extent_buffer *old_eb = old;
&gt; +
&gt; +               atomic_dec(&amp;old_eb-&gt;writeback_inhibitors);
&gt; +               free_extent_buffer(old_eb);
&gt; +       }
&gt; +
&gt; +       atomic_inc(&amp;eb-&gt;writeback_inhibitors);

Btw, at the top of this function we should assert the eb is locked.

Otherwise,

Reviewed-by: Filipe Manana &lt;fdmanana@suse.com&gt;

Thanks.

&gt; +}
&gt; +
&gt; +/*
&gt; + * btrfs_uninhibit_all_eb_writeback - Uninhibit writeback on all buffers.
&gt; + * @trans: transaction handle to clean up
&gt; + */
&gt; +void btrfs_uninhibit_all_eb_writeback(struct btrfs_trans_handle *trans)
&gt; +{
&gt; +       struct extent_buffer *eb;
&gt; +       unsigned long index;
&gt; +
&gt; +       xa_for_each(&amp;trans-&gt;writeback_inhibited_ebs, index, eb) {
&gt; +               atomic_dec(&amp;eb-&gt;writeback_inhibitors);
&gt; +               free_extent_buffer(eb);
&gt; +       }
&gt; +       xa_destroy(&amp;trans-&gt;writeback_inhibited_ebs);
&gt; +}
&gt; +
&gt;  static struct extent_buffer *__alloc_extent_buffer(struct btrfs_fs_info *fs_info,
&gt;                                                    u64 start)
&gt;  {
&gt; @@ -3009,6 +3069,7 @@ static struct extent_buffer *__alloc_extent_buffer(struct btrfs_fs_info *fs_info
&gt;         eb-&gt;len = fs_info-&gt;nodesize;
&gt;         eb-&gt;fs_info = fs_info;
&gt;         init_rwsem(&amp;eb-&gt;lock);
&gt; +       atomic_set(&amp;eb-&gt;writeback_inhibitors, 0);
&gt;
&gt;         btrfs_leak_debug_add_eb(eb);
&gt;
&gt; diff --git a/fs/btrfs/extent_io.h b/fs/btrfs/extent_io.h
&gt; index 73571d5d3d5a..fb68fbd4866c 100644
&gt; --- a/fs/btrfs/extent_io.h
&gt; +++ b/fs/btrfs/extent_io.h
&gt; @@ -102,6 +102,8 @@ struct extent_buffer {
&gt;         /* &gt;= 0 if eb belongs to a log tree, -1 otherwise */
&gt;         s8 log_index;
&gt;         u8 folio_shift;
&gt; +       /* Inhibits WB_SYNC_NONE writeback when &gt; 0. */
&gt; +       atomic_t writeback_inhibitors;
&gt;         struct rcu_head rcu_head;
&gt;
&gt;         struct rw_semaphore lock;
&gt; @@ -381,4 +383,8 @@ void btrfs_extent_buffer_leak_debug_check(struct btrfs_fs_info *fs_info);
&gt;  #define btrfs_extent_buffer_leak_debug_check(fs_info)  do {} while (0)
&gt;  #endif
&gt;
&gt; +void btrfs_inhibit_eb_writeback(struct btrfs_trans_handle *trans,
&gt; +                              struct extent_buffer *eb);
&gt; +void btrfs_uninhibit_all_eb_writeback(struct btrfs_trans_handle *trans);
&gt; +
&gt;  #endif
&gt; diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c
&gt; index f4cc9e1a1b93..a9a22629b49d 100644
&gt; --- a/fs/btrfs/transaction.c
&gt; +++ b/fs/btrfs/transaction.c
&gt; @@ -15,6 +15,7 @@
&gt;  #include &quot;misc.h&quot;
&gt;  #include &quot;ctree.h&quot;
&gt;  #include &quot;disk-io.h&quot;
&gt; +#include &quot;extent_io.h&quot;
&gt;  #include &quot;transaction.h&quot;
&gt;  #include &quot;locking.h&quot;
&gt;  #include &quot;tree-log.h&quot;
&gt; @@ -688,6 +689,8 @@ start_transaction(struct btrfs_root *root, unsigned int num_items,
&gt;                 goto alloc_fail;
&gt;         }
&gt;
&gt; +       xa_init(&amp;h-&gt;writeback_inhibited_ebs);
&gt; +
&gt;         /*
&gt;          * If we are JOIN_NOLOCK we&#x27;re already committing a transaction and
&gt;          * waiting on this guy, so we don&#x27;t need to do the sb_start_intwrite
&gt; @@ -1083,6 +1086,13 @@ static int __btrfs_end_transaction(struct btrfs_trans_handle *trans,
&gt;         if (trans-&gt;type &amp; __TRANS_FREEZABLE)
&gt;                 sb_end_intwrite(info-&gt;sb);
&gt;
&gt; +       /*
&gt; +        * Uninhibit extent buffer writeback before decrementing num_writers,
&gt; +        * since the decrement wakes the committing thread which needs all
&gt; +        * buffers uninhibited to write them to disk.
&gt; +        */
&gt; +       btrfs_uninhibit_all_eb_writeback(trans);
&gt; +
&gt;         WARN_ON(cur_trans != info-&gt;running_transaction);
&gt;         WARN_ON(atomic_read(&amp;cur_trans-&gt;num_writers) &lt; 1);
&gt;         atomic_dec(&amp;cur_trans-&gt;num_writers);
&gt; @@ -2110,6 +2120,7 @@ static void cleanup_transaction(struct btrfs_trans_handle *trans, int err)
&gt;         if (!test_bit(BTRFS_FS_RELOC_RUNNING, &amp;fs_info-&gt;flags))
&gt;                 btrfs_scrub_cancel(fs_info);
&gt;
&gt; +       btrfs_uninhibit_all_eb_writeback(trans);
&gt;         kmem_cache_free(btrfs_trans_handle_cachep, trans);
&gt;  }
&gt;
&gt; @@ -2556,6 +2567,14 @@ int btrfs_commit_transaction(struct btrfs_trans_handle *trans)
&gt;             fs_info-&gt;cleaner_kthread)
&gt;                 wake_up_process(fs_info-&gt;cleaner_kthread);
&gt;
&gt; +       /*
&gt; +        * Uninhibit writeback on all extent buffers inhibited during this
&gt; +        * transaction before writing them to disk. Inhibiting prevented
&gt; +        * writeback while the transaction was building, but now we need
&gt; +        * them written.
&gt; +        */
&gt; +       btrfs_uninhibit_all_eb_writeback(trans);
&gt; +
&gt;         ret = btrfs_write_and_wait_transaction(trans);
&gt;         if (unlikely(ret)) {
&gt;                 btrfs_err(fs_info, &quot;error while writing out transaction: %d&quot;, ret);
&gt; diff --git a/fs/btrfs/transaction.h b/fs/btrfs/transaction.h
&gt; index 18ef069197e5..7d70fe486758 100644
&gt; --- a/fs/btrfs/transaction.h
&gt; +++ b/fs/btrfs/transaction.h
&gt; @@ -12,6 +12,7 @@
&gt;  #include &lt;linux/time64.h&gt;
&gt;  #include &lt;linux/mutex.h&gt;
&gt;  #include &lt;linux/wait.h&gt;
&gt; +#include &lt;linux/xarray.h&gt;
&gt;  #include &quot;btrfs_inode.h&quot;
&gt;  #include &quot;delayed-ref.h&quot;
&gt;
&gt; @@ -162,6 +163,8 @@ struct btrfs_trans_handle {
&gt;         struct btrfs_fs_info *fs_info;
&gt;         struct list_head new_bgs;
&gt;         struct btrfs_block_rsv delayed_rsv;
&gt; +       /* Extent buffers with writeback inhibited by this handle. */
&gt; +       struct xarray writeback_inhibited_ebs;
&gt;  };
&gt;
&gt;  /*
&gt; --
&gt; 2.47.3
&gt;
&gt;
</pre>
</details>
<div class="review-comment-signals">Signals: LGTM</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>