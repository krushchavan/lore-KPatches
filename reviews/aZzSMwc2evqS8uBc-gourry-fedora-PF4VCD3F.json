{
  "thread_id": "aZzSMwc2evqS8uBc@gourry-fedora-PF4VCD3F",
  "subject": "Re: [PATCH v3 2/2] cxl: Fix race of nvdimm_bus object when creating nvdimm objects",
  "url": "https://lore.kernel.org/all/aZzSMwc2evqS8uBc@gourry-fedora-PF4VCD3F/",
  "dates": {
    "2026-02-13": {
      "report_file": "2026-02-23_ollama_llama3.1-8b.html",
      "developer": "Gregory Price",
      "reviews": [
        {
          "author": "Dave Jiang (author)",
          "summary": "The author is addressing a concern about the race condition in nvdimm_bus object creation by moving the symbol devm_cxl_add_nvdimm_bridge() to cxl_pmem.c, making it exportable and dependent on cxl_pmem kernel module. This change does not introduce any functional changes besides code movement.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no clear resolution signal",
            "acknowledges the race condition"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Moving the symbol devm_cxl_add_nvdimm_bridge() to\ndrivers/cxl/cxl_pmem.c, so that cxl_pmem can export a symbol that gives\ncxl_acpi a depedency on cxl_pmem kernel module. This is a prepatory patch\nto resolve the issue of a race for nvdimm_bus object that is created\nduring cxl_acpi_probe().\n\nNo functional changes besides moving code.\n\nSuggested-by: Dan Williams <dan.j.williams@intel.com>\nSigned-off-by: Dave Jiang <dave.jiang@intel.com>\n---\nv3:\n- Just move the symbol with a wrapper function. (Dan)\n---\n drivers/cxl/core/pmem.c | 13 +++----------\n drivers/cxl/cxl.h       |  2 ++\n drivers/cxl/pmem.c      | 14 ++++++++++++++\n 3 files changed, 19 insertions(+), 10 deletions(-)\n\ndiff --git a/drivers/cxl/core/pmem.c b/drivers/cxl/core/pmem.c\nindex e7b1e6fa0ea0..7c78344acc6d 100644\n--- a/drivers/cxl/core/pmem.c\n+++ b/drivers/cxl/core/pmem.c\n@@ -115,15 +115,8 @@ static void unregister_nvb(void *_cxl_nvb)\n \tdevice_unregister(&cxl_nvb->dev);\n }\n \n-/**\n- * devm_cxl_add_nvdimm_bridge() - add the root of a LIBNVDIMM topology\n- * @host: platform firmware root device\n- * @port: CXL port at the root of a CXL topology\n- *\n- * Return: bridge device that can host cxl_nvdimm objects\n- */\n-struct cxl_nvdimm_bridge *devm_cxl_add_nvdimm_bridge(struct device *host,\n-\t\t\t\t\t\t     struct cxl_port *port)\n+struct cxl_nvdimm_bridge *__devm_cxl_add_nvdimm_bridge(struct device *host,\n+\t\t\t\t\t\t       struct cxl_port *port)\n {\n \tstruct cxl_nvdimm_bridge *cxl_nvb;\n \tstruct device *dev;\n@@ -155,7 +148,7 @@ struct cxl_nvdimm_bridge *devm_cxl_add_nvdimm_bridge(struct device *host,\n \tput_device(dev);\n \treturn ERR_PTR(rc);\n }\n-EXPORT_SYMBOL_NS_GPL(devm_cxl_add_nvdimm_bridge, \"CXL\");\n+EXPORT_SYMBOL_FOR_MODULES(__devm_cxl_add_nvdimm_bridge, \"cxl_pmem\");\n \n static void cxl_nvdimm_release(struct device *dev)\n {\ndiff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h\nindex 04c673e7cdb0..f5850800f400 100644\n--- a/drivers/cxl/cxl.h\n+++ b/drivers/cxl/cxl.h\n@@ -920,6 +920,8 @@ void cxl_driver_unregister(struct cxl_driver *cxl_drv);\n struct cxl_nvdimm_bridge *to_cxl_nvdimm_bridge(struct device *dev);\n struct cxl_nvdimm_bridge *devm_cxl_add_nvdimm_bridge(struct device *host,\n \t\t\t\t\t\t     struct cxl_port *port);\n+struct cxl_nvdimm_bridge *__devm_cxl_add_nvdimm_bridge(struct device *host,\n+\t\t\t\t\t\t       struct cxl_port *port);\n struct cxl_nvdimm *to_cxl_nvdimm(struct device *dev);\n bool is_cxl_nvdimm(struct device *dev);\n int devm_cxl_add_nvdimm(struct device *host, struct cxl_port *port,\ndiff --git a/drivers/cxl/pmem.c b/drivers/cxl/pmem.c\nindex e197883690ef..714beaf1704b 100644\n--- a/drivers/cxl/pmem.c\n+++ b/drivers/cxl/pmem.c\n@@ -13,6 +13,20 @@\n \n static __read_mostly DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);\n \n+/**\n+ * __devm_cxl_add_nvdimm_bridge() - add the root of a LIBNVDIMM topology\n+ * @host: platform firmware root device\n+ * @port: CXL port at the root of a CXL topology\n+ *\n+ * Return: bridge device that can host cxl_nvdimm objects\n+ */\n+struct cxl_nvdimm_bridge *devm_cxl_add_nvdimm_bridge(struct device *host,\n+\t\t\t\t\t\t     struct cxl_port *port)\n+{\n+\treturn __devm_cxl_add_nvdimm_bridge(host, port);\n+}\n+EXPORT_SYMBOL_NS_GPL(devm_cxl_add_nvdimm_bridge, \"CXL\");\n+\n static void clear_exclusive(void *mds)\n {\n \tclear_exclusive_cxl_commands(mds, exclusive_cmds);\n-- \n2.53.0",
          "reply_to": "",
          "message_date": "2026-02-13"
        },
        {
          "author": "Dave Jiang (author)",
          "summary": "The author is addressing a concern about the cxl_nvdimm_bridge_failed_attach() function not being called when the nvdimm_bus object is missing, causing a NULL pointer dereference in __nd_device_register(). The author agrees that this is a problem and explains how they plan to fix it by adding a check in devm_cxl_add_nvdimm() to ensure that the cxl_nvb driver is attached before checking if the nvdimm_bus object is valid. They also mention that they will set an invalidated flag for cxl_nvdimm when the nvdimm_bus is released.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledges a fix is needed",
            "explains how to fix it"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Found issue during running of cxl-translate.sh unit test. Adding a 3s\nsleep right before the test seems to make the issue reproduce fairly\nconsistently. The cxl_translate module has dependency on cxl_acpi and\ncauses orphaned nvdimm objects to reprobe after cxl_acpi is removed.\nThe nvdimm_bus object is registered by the cxl_nvb object when\ncxl_acpi_probe() is called. With the nvdimm_bus object missing,\n__nd_device_register() will trigger NULL pointer dereference when\naccessing the dev->parent that points to &nvdimm_bus->dev.\n\n[  192.884510] BUG: kernel NULL pointer dereference, address: 000000000000006c\n[  192.895383] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS edk2-20250812-19.fc42 08/12/2025\n[  192.897721] Workqueue: cxl_port cxl_bus_rescan_queue [cxl_core]\n[  192.899459] RIP: 0010:kobject_get+0xc/0x90\n[  192.924871] Call Trace:\n[  192.925959]  <TASK>\n[  192.926976]  ? pm_runtime_init+0xb9/0xe0\n[  192.929712]  __nd_device_register.part.0+0x4d/0xc0 [libnvdimm]\n[  192.933314]  __nvdimm_create+0x206/0x290 [libnvdimm]\n[  192.936662]  cxl_nvdimm_probe+0x119/0x1d0 [cxl_pmem]\n[  192.940245]  cxl_bus_probe+0x1a/0x60 [cxl_core]\n[  192.943349]  really_probe+0xde/0x380\n\nThis patch also relies on the previous change where\ndevm_cxl_add_nvdimm_bridge() is called from drivers/cxl/pmem.c instead\nof drivers/cxl/core.c to ensure the dependency of cxl_acpi on cxl_pmem.\n\n1. Set probe_type of cxl_nvb to PROBE_FORCE_SYNCHRONOUS to ensure the\n   driver is probed synchronously when add_device() is called.\n2. Add a check in __devm_cxl_add_nvdimm_bridge() to ensure that the\n   cxl_nvb driver is attached during cxl_acpi_probe().\n3. Take the cxl_root uport_dev lock and the cxl_nvb->dev lock in\n   devm_cxl_add_nvdimm() before checking nvdimm_bus is valid.\n4. Set cxl_nvdimm flag to CXL_NVD_F_INVALIDATED so cxl_nvdimm_probe()\n   will exit with -EBUSY.\n\nThe removal of cxl_nvdimm devices should prevent any orphaned devices\nfrom probing once the nvdimm_bus is gone.\n\nFixes: 21083f51521f (\"cxl/pmem: Register 'pmem' / cxl_nvdimm devices\")\nSigned-off-by: Dave Jiang <dave.jiang@intel.com>\n\n---\nv3:\n- squash patch 2 and 3 (Dan)\n- Remove nvdimm_bus check from cxl_nvdimm driver (Dan)\n- Set an invalidated flag for cxl_nvdimm when nvdimm_bus is released. (Dan)\n- Create a helper to see if driver is attached. (Dan)\n---\n drivers/cxl/core/pmem.c | 27 +++++++++++++++++++++++++++\n drivers/cxl/cxl.h       |  5 +++++\n drivers/cxl/pmem.c      |  8 +++++++-\n 3 files changed, 39 insertions(+), 1 deletion(-)\n\ndiff --git a/drivers/cxl/core/pmem.c b/drivers/cxl/core/pmem.c\nindex 7c78344acc6d..375948ec5fed 100644\n--- a/drivers/cxl/core/pmem.c\n+++ b/drivers/cxl/core/pmem.c\n@@ -115,6 +115,15 @@ static void unregister_nvb(void *_cxl_nvb)\n \tdevice_unregister(&cxl_nvb->dev);\n }\n \n+static bool cxl_nvdimm_bridge_failed_attach(struct cxl_nvdimm_bridge *cxl_nvb)\n+{\n+\tstruct device *dev = &cxl_nvb->dev;\n+\n+\tguard(device)(dev);\n+\t/* If the device has no driver, then it failed to attach. */\n+\treturn dev->driver == NULL;\n+}\n+\n struct cxl_nvdimm_bridge *__devm_cxl_add_nvdimm_bridge(struct device *host,\n \t\t\t\t\t\t       struct cxl_port *port)\n {\n@@ -138,6 +147,11 @@ struct cxl_nvdimm_bridge *__devm_cxl_add_nvdimm_bridge(struct device *host,\n \tif (rc)\n \t\tgoto err;\n \n+\tif (cxl_nvdimm_bridge_failed_attach(cxl_nvb)) {\n+\t\tunregister_nvb(cxl_nvb);\n+\t\treturn ERR_PTR(-ENODEV);\n+\t}\n+\n \trc = devm_add_action_or_reset(host, unregister_nvb, cxl_nvb);\n \tif (rc)\n \t\treturn ERR_PTR(rc);\n@@ -248,6 +262,19 @@ int devm_cxl_add_nvdimm(struct device *host, struct cxl_port *port,\n \tif (!cxl_nvb)\n \t\treturn -ENODEV;\n \n+\t/*\n+\t * Take the uport_dev lock to guard against race of nvdimm_bus object.\n+\t * cxl_acpi_probe() registers the nvdimm_bus and is done under the\n+\t * root port uport_dev lock.\n+\t *\n+\t * Take the cxl_nvb device lock to ensure that cxl_nvb driver is in a\n+\t * consistent state. And the driver registers nvdimm_bus.\n+\t */\n+\tguard(device)(cxl_nvb->port->uport_dev);\n+\tguard(device)(&cxl_nvb->dev);\n+\tif (!cxl_nvb->nvdimm_bus)\n+\t\treturn -ENODEV;\n+\n \tcxl_nvd = cxl_nvdimm_alloc(cxl_nvb, cxlmd);\n \tif (IS_ERR(cxl_nvd)) {\n \t\trc = PTR_ERR(cxl_nvd);\ndiff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h\nindex f5850800f400..9b947286eb9b 100644\n--- a/drivers/cxl/cxl.h\n+++ b/drivers/cxl/cxl.h\n@@ -574,11 +574,16 @@ struct cxl_nvdimm_bridge {\n \n #define CXL_DEV_ID_LEN 19\n \n+enum {\n+\tCXL_NVD_F_INVALIDATED = 0,\n+};\n+\n struct cxl_nvdimm {\n \tstruct device dev;\n \tstruct cxl_memdev *cxlmd;\n \tu8 dev_id[CXL_DEV_ID_LEN]; /* for nvdimm, string of 'serial' */\n \tu64 dirty_shutdowns;\n+\tunsigned long flags;\n };\n \n struct cxl_pmem_region_mapping {\ndiff --git a/drivers/cxl/pmem.c b/drivers/cxl/pmem.c\nindex 714beaf1704b..61f7a0b352aa 100644\n--- a/drivers/cxl/pmem.c\n+++ b/drivers/cxl/pmem.c\n@@ -143,6 +143,9 @@ static int cxl_nvdimm_probe(struct device *dev)\n \tstruct nvdimm *nvdimm;\n \tint rc;\n \n+\tif (test_bit(CXL_NVD_F_INVALIDATED, &cxl_nvd->flags))\n+\t\treturn -EBUSY;\n+\n \tset_exclusive_cxl_commands(mds, exclusive_cmds);\n \trc = devm_add_action_or_reset(dev, clear_exclusive, mds);\n \tif (rc)\n@@ -323,8 +326,10 @@ static int detach_nvdimm(struct device *dev, void *data)\n \tscoped_guard(device, dev) {\n \t\tif (dev->driver) {\n \t\t\tcxl_nvd = to_cxl_nvdimm(dev);\n-\t\t\tif (cxl_nvd->cxlmd && cxl_nvd->cxlmd->cxl_nvb == data)\n+\t\t\tif (cxl_nvd->cxlmd && cxl_nvd->cxlmd->cxl_nvb == data) {\n \t\t\t\trelease = true;\n+\t\t\t\tset_bit(CXL_NVD_F_INVALIDATED, &cxl_nvd->flags);\n+\t\t\t}\n \t\t}\n \t}\n \tif (release)\n@@ -367,6 +372,7 @@ static struct cxl_driver cxl_nvdimm_bridge_driver = {\n \t.probe = cxl_nvdimm_bridge_probe,\n \t.id = CXL_DEVICE_NVDIMM_BRIDGE,\n \t.drv = {\n+\t\t.probe_type = PROBE_FORCE_SYNCHRONOUS,\n \t\t.suppress_bind_attrs = true,\n \t},\n };\n-- \n2.53.0",
          "reply_to": "",
          "message_date": "2026-02-13"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-23": {
      "report_file": "2026-02-23_ollama_llama3.1-8b.html",
      "developer": "Gregory Price",
      "reviews": [
        {
          "author": "Gregory Price",
          "summary": "Reviewer noted that the cxl_nvb reference is leaked due to a missing check for nvdimm_bus existence, and suggested adding a conditional statement to handle this case",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "leaks reference",
            "missing check"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I think this leaks the reference on cxl_nvb taken by \n\n\tdevm_cxl_add_nvdimm()\n\t\tdevice_find_child()\n\nMaybe:\n     if (!cxl_nvb->nvdimm_bus) {\n             rc = -ENODEV;\n             goto err_alloc;\n     }\n\n\nReported-by: kreview-0811365\n\n~Gregory",
          "reply_to": "Dave Jiang",
          "message_date": "2026-02-23"
        },
        {
          "author": "Dave Jiang (author)",
          "summary": "Author acknowledged a concern about the race condition in nvdimm_bus object creation and explained that the patch already addresses this issue by introducing a flag to invalidate cxl_nvdimm when releasing nvdimm_bus.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged a concern",
            "patch already addresses"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Applied to cxl/fixes\n16fb82cadd63 cxl: Fix race of nvdimm_bus object when creating nvdimm objects\ne7e222ad73d9 cxl: Move devm_cxl_add_nvdimm_bridge() to cxl_pmem.ko",
          "reply_to": "",
          "message_date": "2026-02-23"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    }
  }
}