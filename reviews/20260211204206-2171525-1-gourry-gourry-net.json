{
  "thread_id": "20260211204206.2171525-1-gourry@gourry.net",
  "subject": "[PATCH v3 0/3] pull region-specific logic into new files",
  "url": "https://lore.kernel.org/all/20260211204206.2171525-1-gourry@gourry.net/",
  "dates": {
    "2026-02-20": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Gregory Price",
      "reviews": [
        {
          "author": "Gregory Price (author)",
          "summary": "The reviewer approved the patch and provided Reviewed-by tags, but did not raise any technical concerns or objections.",
          "sentiment": "positive",
          "sentiment_signals": [
            "Reviewed-by"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "core/region.c is overloaded with per-region control logic (pmem, dax).\nMove pmem region logic from region.c into region_pmem.c to make it\nclear that this code only applies to pmem regions.\n\nNo functional changes.\n\nReviewed-by: Dave Jiang <dave.jiang@intel.com>\nReviewed-by: Fabio M. De Francesco <fabio.m.de.francesco@linux.intel.com>\nSigned-off-by: Gregory Price <gourry@gourry.net>\n---\n drivers/cxl/core/Makefile      |   1 +\n drivers/cxl/core/core.h        |   1 +\n drivers/cxl/core/region.c      | 184 --------------------------------\n drivers/cxl/core/region_pmem.c | 189 +++++++++++++++++++++++++++++++++\n 4 files changed, 191 insertions(+), 184 deletions(-)\n create mode 100644 drivers/cxl/core/region_pmem.c\n\ndiff --git a/drivers/cxl/core/Makefile b/drivers/cxl/core/Makefile\nindex a639a9499972..d1484a0e5eb4 100644\n--- a/drivers/cxl/core/Makefile\n+++ b/drivers/cxl/core/Makefile\n@@ -16,6 +16,7 @@ cxl_core-y += pmu.o\n cxl_core-y += cdat.o\n cxl_core-$(CONFIG_TRACING) += trace.o\n cxl_core-$(CONFIG_CXL_REGION) += region.o\n+cxl_core-$(CONFIG_CXL_REGION) += region_pmem.o\n cxl_core-$(CONFIG_CXL_MCE) += mce.o\n cxl_core-$(CONFIG_CXL_FEATURES) += features.o\n cxl_core-$(CONFIG_CXL_EDAC_MEM_FEATURES) += edac.o\ndiff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h\nindex 007b8aff0238..ced65a779a09 100644\n--- a/drivers/cxl/core/core.h\n+++ b/drivers/cxl/core/core.h\n@@ -50,6 +50,7 @@ int cxl_get_poison_by_endpoint(struct cxl_port *port);\n struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa);\n u64 cxl_dpa_to_hpa(struct cxl_region *cxlr, const struct cxl_memdev *cxlmd,\n \t\t   u64 dpa);\n+int devm_cxl_add_pmem_region(struct cxl_region *cxlr);\n \n #else\n static inline u64 cxl_dpa_to_hpa(struct cxl_region *cxlr,\ndiff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c\nindex bd4c4a4a27da..1c322318d70e 100644\n--- a/drivers/cxl/core/region.c\n+++ b/drivers/cxl/core/region.c\n@@ -2757,46 +2757,6 @@ static ssize_t delete_region_store(struct device *dev,\n }\n DEVICE_ATTR_WO(delete_region);\n \n-static void cxl_pmem_region_release(struct device *dev)\n-{\n-\tstruct cxl_pmem_region *cxlr_pmem = to_cxl_pmem_region(dev);\n-\tint i;\n-\n-\tfor (i = 0; i < cxlr_pmem->nr_mappings; i++) {\n-\t\tstruct cxl_memdev *cxlmd = cxlr_pmem->mapping[i].cxlmd;\n-\n-\t\tput_device(&cxlmd->dev);\n-\t}\n-\n-\tkfree(cxlr_pmem);\n-}\n-\n-static const struct attribute_group *cxl_pmem_region_attribute_groups[] = {\n-\t&cxl_base_attribute_group,\n-\tNULL,\n-};\n-\n-const struct device_type cxl_pmem_region_type = {\n-\t.name = \"cxl_pmem_region\",\n-\t.release = cxl_pmem_region_release,\n-\t.groups = cxl_pmem_region_attribute_groups,\n-};\n-\n-bool is_cxl_pmem_region(struct device *dev)\n-{\n-\treturn dev->type == &cxl_pmem_region_type;\n-}\n-EXPORT_SYMBOL_NS_GPL(is_cxl_pmem_region, \"CXL\");\n-\n-struct cxl_pmem_region *to_cxl_pmem_region(struct device *dev)\n-{\n-\tif (dev_WARN_ONCE(dev, !is_cxl_pmem_region(dev),\n-\t\t\t  \"not a cxl_pmem_region device\\n\"))\n-\t\treturn NULL;\n-\treturn container_of(dev, struct cxl_pmem_region, dev);\n-}\n-EXPORT_SYMBOL_NS_GPL(to_cxl_pmem_region, \"CXL\");\n-\n struct cxl_poison_context {\n \tstruct cxl_port *port;\n \tint part;\n@@ -3432,64 +3392,6 @@ static int region_offset_to_dpa_result(struct cxl_region *cxlr, u64 offset,\n \treturn -ENXIO;\n }\n \n-static struct lock_class_key cxl_pmem_region_key;\n-\n-static int cxl_pmem_region_alloc(struct cxl_region *cxlr)\n-{\n-\tstruct cxl_region_params *p = &cxlr->params;\n-\tstruct cxl_nvdimm_bridge *cxl_nvb;\n-\tstruct device *dev;\n-\tint i;\n-\n-\tguard(rwsem_read)(&cxl_rwsem.region);\n-\tif (p->state != CXL_CONFIG_COMMIT)\n-\t\treturn -ENXIO;\n-\n-\tstruct cxl_pmem_region *cxlr_pmem __free(kfree) =\n-\t\tkzalloc(struct_size(cxlr_pmem, mapping, p->nr_targets), GFP_KERNEL);\n-\tif (!cxlr_pmem)\n-\t\treturn -ENOMEM;\n-\n-\tcxlr_pmem->hpa_range.start = p->res->start;\n-\tcxlr_pmem->hpa_range.end = p->res->end;\n-\n-\t/* Snapshot the region configuration underneath the cxl_rwsem.region */\n-\tcxlr_pmem->nr_mappings = p->nr_targets;\n-\tfor (i = 0; i < p->nr_targets; i++) {\n-\t\tstruct cxl_endpoint_decoder *cxled = p->targets[i];\n-\t\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n-\t\tstruct cxl_pmem_region_mapping *m = &cxlr_pmem->mapping[i];\n-\n-\t\t/*\n-\t\t * Regions never span CXL root devices, so by definition the\n-\t\t * bridge for one device is the same for all.\n-\t\t */\n-\t\tif (i == 0) {\n-\t\t\tcxl_nvb = cxl_find_nvdimm_bridge(cxlmd->endpoint);\n-\t\t\tif (!cxl_nvb)\n-\t\t\t\treturn -ENODEV;\n-\t\t\tcxlr->cxl_nvb = cxl_nvb;\n-\t\t}\n-\t\tm->cxlmd = cxlmd;\n-\t\tget_device(&cxlmd->dev);\n-\t\tm->start = cxled->dpa_res->start;\n-\t\tm->size = resource_size(cxled->dpa_res);\n-\t\tm->position = i;\n-\t}\n-\n-\tdev = &cxlr_pmem->dev;\n-\tdevice_initialize(dev);\n-\tlockdep_set_class(&dev->mutex, &cxl_pmem_region_key);\n-\tdevice_set_pm_not_required(dev);\n-\tdev->parent = &cxlr->dev;\n-\tdev->bus = &cxl_bus_type;\n-\tdev->type = &cxl_pmem_region_type;\n-\tcxlr_pmem->cxlr = cxlr;\n-\tcxlr->cxlr_pmem = no_free_ptr(cxlr_pmem);\n-\n-\treturn 0;\n-}\n-\n static void cxl_dax_region_release(struct device *dev)\n {\n \tstruct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);\n@@ -3553,92 +3455,6 @@ static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)\n \treturn cxlr_dax;\n }\n \n-static void cxlr_pmem_unregister(void *_cxlr_pmem)\n-{\n-\tstruct cxl_pmem_region *cxlr_pmem = _cxlr_pmem;\n-\tstruct cxl_region *cxlr = cxlr_pmem->cxlr;\n-\tstruct cxl_nvdimm_bridge *cxl_nvb = cxlr->cxl_nvb;\n-\n-\t/*\n-\t * Either the bridge is in ->remove() context under the device_lock(),\n-\t * or cxlr_release_nvdimm() is cancelling the bridge's release action\n-\t * for @cxlr_pmem and doing it itself (while manually holding the bridge\n-\t * lock).\n-\t */\n-\tdevice_lock_assert(&cxl_nvb->dev);\n-\tcxlr->cxlr_pmem = NULL;\n-\tcxlr_pmem->cxlr = NULL;\n-\tdevice_unregister(&cxlr_pmem->dev);\n-}\n-\n-static void cxlr_release_nvdimm(void *_cxlr)\n-{\n-\tstruct cxl_region *cxlr = _cxlr;\n-\tstruct cxl_nvdimm_bridge *cxl_nvb = cxlr->cxl_nvb;\n-\n-\tscoped_guard(device, &cxl_nvb->dev) {\n-\t\tif (cxlr->cxlr_pmem)\n-\t\t\tdevm_release_action(&cxl_nvb->dev, cxlr_pmem_unregister,\n-\t\t\t\t\t    cxlr->cxlr_pmem);\n-\t}\n-\tcxlr->cxl_nvb = NULL;\n-\tput_device(&cxl_nvb->dev);\n-}\n-\n-/**\n- * devm_cxl_add_pmem_region() - add a cxl_region-to-nd_region bridge\n- * @cxlr: parent CXL region for this pmem region bridge device\n- *\n- * Return: 0 on success negative error code on failure.\n- */\n-static int devm_cxl_add_pmem_region(struct cxl_region *cxlr)\n-{\n-\tstruct cxl_pmem_region *cxlr_pmem;\n-\tstruct cxl_nvdimm_bridge *cxl_nvb;\n-\tstruct device *dev;\n-\tint rc;\n-\n-\trc = cxl_pmem_region_alloc(cxlr);\n-\tif (rc)\n-\t\treturn rc;\n-\tcxlr_pmem = cxlr->cxlr_pmem;\n-\tcxl_nvb = cxlr->cxl_nvb;\n-\n-\tdev = &cxlr_pmem->dev;\n-\trc = dev_set_name(dev, \"pmem_region%d\", cxlr->id);\n-\tif (rc)\n-\t\tgoto err;\n-\n-\trc = device_add(dev);\n-\tif (rc)\n-\t\tgoto err;\n-\n-\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(dev->parent),\n-\t\tdev_name(dev));\n-\n-\tscoped_guard(device, &cxl_nvb->dev) {\n-\t\tif (cxl_nvb->dev.driver)\n-\t\t\trc = devm_add_action_or_reset(&cxl_nvb->dev,\n-\t\t\t\t\t\t      cxlr_pmem_unregister,\n-\t\t\t\t\t\t      cxlr_pmem);\n-\t\telse\n-\t\t\trc = -ENXIO;\n-\t}\n-\n-\tif (rc)\n-\t\tgoto err_bridge;\n-\n-\t/* @cxlr carries a reference on @cxl_nvb until cxlr_release_nvdimm */\n-\treturn devm_add_action_or_reset(&cxlr->dev, cxlr_release_nvdimm, cxlr);\n-\n-err:\n-\tput_device(dev);\n-err_bridge:\n-\tput_device(&cxl_nvb->dev);\n-\tcxlr->cxl_nvb = NULL;\n-\treturn rc;\n-}\n-\n static void cxlr_dax_unregister(void *_cxlr_dax)\n {\n \tstruct cxl_dax_region *cxlr_dax = _cxlr_dax;\ndiff --git a/drivers/cxl/core/region_pmem.c b/drivers/cxl/core/region_pmem.c\nnew file mode 100644\nindex 000000000000..f800407566d3\n--- /dev/null\n+++ b/drivers/cxl/core/region_pmem.c\n@@ -0,0 +1,189 @@\n+// SPDX-License-Identifier: GPL-2.0-only\n+/* Copyright(c) 2022 Intel Corporation. All rights reserved. */\n+#include <linux/device.h>\n+#include <linux/slab.h>\n+#include <cxlmem.h>\n+#include <cxl.h>\n+#include \"core.h\"\n+\n+static void cxl_pmem_region_release(struct device *dev)\n+{\n+\tstruct cxl_pmem_region *cxlr_pmem = to_cxl_pmem_region(dev);\n+\tint i;\n+\n+\tfor (i = 0; i < cxlr_pmem->nr_mappings; i++) {\n+\t\tstruct cxl_memdev *cxlmd = cxlr_pmem->mapping[i].cxlmd;\n+\n+\t\tput_device(&cxlmd->dev);\n+\t}\n+\n+\tkfree(cxlr_pmem);\n+}\n+\n+static const struct attribute_group *cxl_pmem_region_attribute_groups[] = {\n+\t&cxl_base_attribute_group,\n+\tNULL\n+};\n+\n+const struct device_type cxl_pmem_region_type = {\n+\t.name = \"cxl_pmem_region\",\n+\t.release = cxl_pmem_region_release,\n+\t.groups = cxl_pmem_region_attribute_groups,\n+};\n+bool is_cxl_pmem_region(struct device *dev)\n+{\n+\treturn dev->type == &cxl_pmem_region_type;\n+}\n+EXPORT_SYMBOL_NS_GPL(is_cxl_pmem_region, \"CXL\");\n+\n+struct cxl_pmem_region *to_cxl_pmem_region(struct device *dev)\n+{\n+\tif (dev_WARN_ONCE(dev, !is_cxl_pmem_region(dev),\n+\t\t\t\t\"not a cxl_pmem_region device\\n\"))\n+\t\treturn NULL;\n+\treturn container_of(dev, struct cxl_pmem_region, dev);\n+}\n+EXPORT_SYMBOL_NS_GPL(to_cxl_pmem_region, \"CXL\");\n+static struct lock_class_key cxl_pmem_region_key;\n+\n+static int cxl_pmem_region_alloc(struct cxl_region *cxlr)\n+{\n+\tstruct cxl_region_params *p = &cxlr->params;\n+\tstruct cxl_nvdimm_bridge *cxl_nvb;\n+\tstruct device *dev;\n+\tint i;\n+\n+\tguard(rwsem_read)(&cxl_rwsem.region);\n+\tif (p->state != CXL_CONFIG_COMMIT)\n+\t\treturn -ENXIO;\n+\n+\tstruct cxl_pmem_region *cxlr_pmem __free(kfree) =\n+\t\tkzalloc(struct_size(cxlr_pmem, mapping, p->nr_targets), GFP_KERNEL);\n+\tif (!cxlr_pmem)\n+\t\treturn -ENOMEM;\n+\n+\tcxlr_pmem->hpa_range.start = p->res->start;\n+\tcxlr_pmem->hpa_range.end = p->res->end;\n+\n+\t/* Snapshot the region configuration underneath the cxl_rwsem.region */\n+\tcxlr_pmem->nr_mappings = p->nr_targets;\n+\tfor (i = 0; i < p->nr_targets; i++) {\n+\t\tstruct cxl_endpoint_decoder *cxled = p->targets[i];\n+\t\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n+\t\tstruct cxl_pmem_region_mapping *m = &cxlr_pmem->mapping[i];\n+\n+\t\t/*\n+\t\t * Regions never span CXL root devices, so by definition the\n+\t\t * bridge for one device is the same for all.\n+\t\t */\n+\t\tif (i == 0) {\n+\t\t\tcxl_nvb = cxl_find_nvdimm_bridge(cxlmd->endpoint);\n+\t\t\tif (!cxl_nvb)\n+\t\t\t\treturn -ENODEV;\n+\t\t\tcxlr->cxl_nvb = cxl_nvb;\n+\t\t}\n+\t\tm->cxlmd = cxlmd;\n+\t\tget_device(&cxlmd->dev);\n+\t\tm->start = cxled->dpa_res->start;\n+\t\tm->size = resource_size(cxled->dpa_res);\n+\t\tm->position = i;\n+\t}\n+\n+\tdev = &cxlr_pmem->dev;\n+\tdevice_initialize(dev);\n+\tlockdep_set_class(&dev->mutex, &cxl_pmem_region_key);\n+\tdevice_set_pm_not_required(dev);\n+\tdev->parent = &cxlr->dev;\n+\tdev->bus = &cxl_bus_type;\n+\tdev->type = &cxl_pmem_region_type;\n+\tcxlr_pmem->cxlr = cxlr;\n+\tcxlr->cxlr_pmem = no_free_ptr(cxlr_pmem);\n+\n+\treturn 0;\n+}\n+\n+static void cxlr_pmem_unregister(void *_cxlr_pmem)\n+{\n+\tstruct cxl_pmem_region *cxlr_pmem = _cxlr_pmem;\n+\tstruct cxl_region *cxlr = cxlr_pmem->cxlr;\n+\tstruct cxl_nvdimm_bridge *cxl_nvb = cxlr->cxl_nvb;\n+\n+\t/*\n+\t * Either the bridge is in ->remove() context under the device_lock(),\n+\t * or cxlr_release_nvdimm() is cancelling the bridge's release action\n+\t * for @cxlr_pmem and doing it itself (while manually holding the bridge\n+\t * lock).\n+\t */\n+\tdevice_lock_assert(&cxl_nvb->dev);\n+\tcxlr->cxlr_pmem = NULL;\n+\tcxlr_pmem->cxlr = NULL;\n+\tdevice_unregister(&cxlr_pmem->dev);\n+}\n+\n+static void cxlr_release_nvdimm(void *_cxlr)\n+{\n+\tstruct cxl_region *cxlr = _cxlr;\n+\tstruct cxl_nvdimm_bridge *cxl_nvb = cxlr->cxl_nvb;\n+\n+\tscoped_guard(device, &cxl_nvb->dev) {\n+\t\tif (cxlr->cxlr_pmem)\n+\t\t\tdevm_release_action(&cxl_nvb->dev, cxlr_pmem_unregister,\n+\t\t\t\t\tcxlr->cxlr_pmem);\n+\t}\n+\tcxlr->cxl_nvb = NULL;\n+\tput_device(&cxl_nvb->dev);\n+}\n+\n+/**\n+ * devm_cxl_add_pmem_region() - add a cxl_region-to-nd_region bridge\n+ * @cxlr: parent CXL region for this pmem region bridge device\n+ *\n+ * Return: 0 on success negative error code on failure.\n+ */\n+int devm_cxl_add_pmem_region(struct cxl_region *cxlr)\n+{\n+\tstruct cxl_pmem_region *cxlr_pmem;\n+\tstruct cxl_nvdimm_bridge *cxl_nvb;\n+\tstruct device *dev;\n+\tint rc;\n+\n+\trc = cxl_pmem_region_alloc(cxlr);\n+\tif (rc)\n+\t\treturn rc;\n+\tcxlr_pmem = cxlr->cxlr_pmem;\n+\tcxl_nvb = cxlr->cxl_nvb;\n+\n+\tdev = &cxlr_pmem->dev;\n+\trc = dev_set_name(dev, \"pmem_region%d\", cxlr->id);\n+\tif (rc)\n+\t\tgoto err;\n+\n+\trc = device_add(dev);\n+\tif (rc)\n+\t\tgoto err;\n+\n+\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(dev->parent),\n+\t\t\tdev_name(dev));\n+\n+\tscoped_guard(device, &cxl_nvb->dev) {\n+\t\tif (cxl_nvb->dev.driver)\n+\t\t\trc = devm_add_action_or_reset(&cxl_nvb->dev,\n+\t\t\t\t\tcxlr_pmem_unregister,\n+\t\t\t\t\tcxlr_pmem);\n+\t\telse\n+\t\t\trc = -ENXIO;\n+\t}\n+\n+\tif (rc)\n+\t\tgoto err_bridge;\n+\n+\t/* @cxlr carries a reference on @cxl_nvb until cxlr_release_nvdimm */\n+\treturn devm_add_action_or_reset(&cxlr->dev, cxlr_release_nvdimm, cxlr);\n+\n+err:\n+\tput_device(dev);\n+err_bridge:\n+\tput_device(&cxl_nvb->dev);\n+\tcxlr->cxl_nvb = NULL;\n+\treturn rc;\n+}\n-- \n2.47.3\n\n\n\n---\n\ncore/region.c is overloaded with per-region control logic (pmem, dax).\nMove CXL DAX region device logic from region.c into region_dax.c.\n\nNo functional changes.\n\nReviewed-by: Dave Jiang <dave.jiang@intel.com>\nReviewed-by: Fabio M. De Francesco <fabio.m.de.francesco@linux.intel.com>\nAcked-by: Davidlohr Bueso <dave@stgolabs.net>\nSigned-off-by: Gregory Price <gourry@gourry.net>\n---\n drivers/cxl/core/Makefile     |   1 +\n drivers/cxl/core/core.h       |   1 +\n drivers/cxl/core/region.c     |  99 ------------------------------\n drivers/cxl/core/region_dax.c | 109 ++++++++++++++++++++++++++++++++++\n 4 files changed, 111 insertions(+), 99 deletions(-)\n create mode 100644 drivers/cxl/core/region_dax.c\n\ndiff --git a/drivers/cxl/core/Makefile b/drivers/cxl/core/Makefile\nindex d1484a0e5eb4..d3ec8aea64c5 100644\n--- a/drivers/cxl/core/Makefile\n+++ b/drivers/cxl/core/Makefile\n@@ -16,6 +16,7 @@ cxl_core-y += pmu.o\n cxl_core-y += cdat.o\n cxl_core-$(CONFIG_TRACING) += trace.o\n cxl_core-$(CONFIG_CXL_REGION) += region.o\n+cxl_core-$(CONFIG_CXL_REGION) += region_dax.o\n cxl_core-$(CONFIG_CXL_REGION) += region_pmem.o\n cxl_core-$(CONFIG_CXL_MCE) += mce.o\n cxl_core-$(CONFIG_CXL_FEATURES) += features.o\ndiff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h\nindex ced65a779a09..a89e0d6d9e7b 100644\n--- a/drivers/cxl/core/core.h\n+++ b/drivers/cxl/core/core.h\n@@ -50,6 +50,7 @@ int cxl_get_poison_by_endpoint(struct cxl_port *port);\n struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa);\n u64 cxl_dpa_to_hpa(struct cxl_region *cxlr, const struct cxl_memdev *cxlmd,\n \t\t   u64 dpa);\n+int devm_cxl_add_dax_region(struct cxl_region *cxlr);\n int devm_cxl_add_pmem_region(struct cxl_region *cxlr);\n \n #else\ndiff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c\nindex 1c322318d70e..0c37caa60f2a 100644\n--- a/drivers/cxl/core/region.c\n+++ b/drivers/cxl/core/region.c\n@@ -3392,105 +3392,6 @@ static int region_offset_to_dpa_result(struct cxl_region *cxlr, u64 offset,\n \treturn -ENXIO;\n }\n \n-static void cxl_dax_region_release(struct device *dev)\n-{\n-\tstruct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);\n-\n-\tkfree(cxlr_dax);\n-}\n-\n-static const struct attribute_group *cxl_dax_region_attribute_groups[] = {\n-\t&cxl_base_attribute_group,\n-\tNULL,\n-};\n-\n-const struct device_type cxl_dax_region_type = {\n-\t.name = \"cxl_dax_region\",\n-\t.release = cxl_dax_region_release,\n-\t.groups = cxl_dax_region_attribute_groups,\n-};\n-\n-static bool is_cxl_dax_region(struct device *dev)\n-{\n-\treturn dev->type == &cxl_dax_region_type;\n-}\n-\n-struct cxl_dax_region *to_cxl_dax_region(struct device *dev)\n-{\n-\tif (dev_WARN_ONCE(dev, !is_cxl_dax_region(dev),\n-\t\t\t  \"not a cxl_dax_region device\\n\"))\n-\t\treturn NULL;\n-\treturn container_of(dev, struct cxl_dax_region, dev);\n-}\n-EXPORT_SYMBOL_NS_GPL(to_cxl_dax_region, \"CXL\");\n-\n-static struct lock_class_key cxl_dax_region_key;\n-\n-static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)\n-{\n-\tstruct cxl_region_params *p = &cxlr->params;\n-\tstruct cxl_dax_region *cxlr_dax;\n-\tstruct device *dev;\n-\n-\tguard(rwsem_read)(&cxl_rwsem.region);\n-\tif (p->state != CXL_CONFIG_COMMIT)\n-\t\treturn ERR_PTR(-ENXIO);\n-\n-\tcxlr_dax = kzalloc(sizeof(*cxlr_dax), GFP_KERNEL);\n-\tif (!cxlr_dax)\n-\t\treturn ERR_PTR(-ENOMEM);\n-\n-\tcxlr_dax->hpa_range.start = p->res->start;\n-\tcxlr_dax->hpa_range.end = p->res->end;\n-\n-\tdev = &cxlr_dax->dev;\n-\tcxlr_dax->cxlr = cxlr;\n-\tdevice_initialize(dev);\n-\tlockdep_set_class(&dev->mutex, &cxl_dax_region_key);\n-\tdevice_set_pm_not_required(dev);\n-\tdev->parent = &cxlr->dev;\n-\tdev->bus = &cxl_bus_type;\n-\tdev->type = &cxl_dax_region_type;\n-\n-\treturn cxlr_dax;\n-}\n-\n-static void cxlr_dax_unregister(void *_cxlr_dax)\n-{\n-\tstruct cxl_dax_region *cxlr_dax = _cxlr_dax;\n-\n-\tdevice_unregister(&cxlr_dax->dev);\n-}\n-\n-static int devm_cxl_add_dax_region(struct cxl_region *cxlr)\n-{\n-\tstruct cxl_dax_region *cxlr_dax;\n-\tstruct device *dev;\n-\tint rc;\n-\n-\tcxlr_dax = cxl_dax_region_alloc(cxlr);\n-\tif (IS_ERR(cxlr_dax))\n-\t\treturn PTR_ERR(cxlr_dax);\n-\n-\tdev = &cxlr_dax->dev;\n-\trc = dev_set_name(dev, \"dax_region%d\", cxlr->id);\n-\tif (rc)\n-\t\tgoto err;\n-\n-\trc = device_add(dev);\n-\tif (rc)\n-\t\tgoto err;\n-\n-\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(dev->parent),\n-\t\tdev_name(dev));\n-\n-\treturn devm_add_action_or_reset(&cxlr->dev, cxlr_dax_unregister,\n-\t\t\t\t\tcxlr_dax);\n-err:\n-\tput_device(dev);\n-\treturn rc;\n-}\n-\n static int match_root_decoder(struct device *dev, const void *data)\n {\n \tconst struct range *r1, *r2 = data;\ndiff --git a/drivers/cxl/core/region_dax.c b/drivers/cxl/core/region_dax.c\nnew file mode 100644\nindex 000000000000..c8dd2bd1d9b9\n--- /dev/null\n+++ b/drivers/cxl/core/region_dax.c\n@@ -0,0 +1,109 @@\n+// SPDX-License-Identifier: GPL-2.0-only\n+/*\n+ * Copyright(c) 2022 Intel Corporation. All rights reserved.\n+ * Copyright(c) 2026 Meta Technologies Inc. All rights reserved.\n+ */\n+#include <linux/device.h>\n+#include <linux/slab.h>\n+#include <cxlmem.h>\n+#include <cxl.h>\n+#include \"core.h\"\n+\n+static void cxl_dax_region_release(struct device *dev)\n+{\n+\tstruct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);\n+\n+\tkfree(cxlr_dax);\n+}\n+\n+static const struct attribute_group *cxl_dax_region_attribute_groups[] = {\n+\t&cxl_base_attribute_group,\n+\tNULL\n+};\n+\n+const struct device_type cxl_dax_region_type = {\n+\t.name = \"cxl_dax_region\",\n+\t.release = cxl_dax_region_release,\n+\t.groups = cxl_dax_region_attribute_groups,\n+};\n+\n+static bool is_cxl_dax_region(struct device *dev)\n+{\n+\treturn dev->type == &cxl_dax_region_type;\n+}\n+\n+struct cxl_dax_region *to_cxl_dax_region(struct device *dev)\n+{\n+\tif (dev_WARN_ONCE(dev, !is_cxl_dax_region(dev),\n+\t\t\t  \"not a cxl_dax_region device\\n\"))\n+\t\treturn NULL;\n+\treturn container_of(dev, struct cxl_dax_region, dev);\n+}\n+EXPORT_SYMBOL_NS_GPL(to_cxl_dax_region, \"CXL\");\n+\n+static struct lock_class_key cxl_dax_region_key;\n+\n+static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)\n+{\n+\tstruct cxl_region_params *p = &cxlr->params;\n+\tstruct cxl_dax_region *cxlr_dax;\n+\tstruct device *dev;\n+\n+\tguard(rwsem_read)(&cxl_rwsem.region);\n+\tif (p->state != CXL_CONFIG_COMMIT)\n+\t\treturn ERR_PTR(-ENXIO);\n+\n+\tcxlr_dax = kzalloc(sizeof(*cxlr_dax), GFP_KERNEL);\n+\tif (!cxlr_dax)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\tcxlr_dax->hpa_range.start = p->res->start;\n+\tcxlr_dax->hpa_range.end = p->res->end;\n+\n+\tdev = &cxlr_dax->dev;\n+\tcxlr_dax->cxlr = cxlr;\n+\tdevice_initialize(dev);\n+\tlockdep_set_class(&dev->mutex, &cxl_dax_region_key);\n+\tdevice_set_pm_not_required(dev);\n+\tdev->parent = &cxlr->dev;\n+\tdev->bus = &cxl_bus_type;\n+\tdev->type = &cxl_dax_region_type;\n+\n+\treturn cxlr_dax;\n+}\n+\n+static void cxlr_dax_unregister(void *_cxlr_dax)\n+{\n+\tstruct cxl_dax_region *cxlr_dax = _cxlr_dax;\n+\n+\tdevice_unregister(&cxlr_dax->dev);\n+}\n+\n+int devm_cxl_add_dax_region(struct cxl_region *cxlr)\n+{\n+\tstruct cxl_dax_region *cxlr_dax;\n+\tstruct device *dev;\n+\tint rc;\n+\n+\tcxlr_dax = cxl_dax_region_alloc(cxlr);\n+\tif (IS_ERR(cxlr_dax))\n+\t\treturn PTR_ERR(cxlr_dax);\n+\n+\tdev = &cxlr_dax->dev;\n+\trc = dev_set_name(dev, \"dax_region%d\", cxlr->id);\n+\tif (rc)\n+\t\tgoto err;\n+\n+\trc = device_add(dev);\n+\tif (rc)\n+\t\tgoto err;\n+\n+\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(dev->parent),\n+\t\tdev_name(dev));\n+\n+\treturn devm_add_action_or_reset(&cxlr->dev, cxlr_dax_unregister,\n+\t\t\t\t\tcxlr_dax);\n+err:\n+\tput_device(dev);\n+\treturn rc;\n+}\n-- \n2.47.3\n\n\n\n---\n\nCleanup the gotos in the function.\n\nNo functional change intended.\n\nSigned-off-by: Gregory Price <gourry@gourry.net>\n---\n drivers/cxl/core/region_dax.c | 21 ++++++++-------------\n drivers/cxl/cxl.h             |  1 +\n 2 files changed, 9 insertions(+), 13 deletions(-)\n\ndiff --git a/drivers/cxl/core/region_dax.c b/drivers/cxl/core/region_dax.c\nindex c8dd2bd1d9b9..49907c6c7620 100644\n--- a/drivers/cxl/core/region_dax.c\n+++ b/drivers/cxl/core/region_dax.c\n@@ -81,29 +81,24 @@ static void cxlr_dax_unregister(void *_cxlr_dax)\n \n int devm_cxl_add_dax_region(struct cxl_region *cxlr)\n {\n-\tstruct cxl_dax_region *cxlr_dax;\n-\tstruct device *dev;\n+\tstruct cxl_dax_region *cxlr_dax __free(put_cxl_dax_region) = NULL;\n \tint rc;\n \n \tcxlr_dax = cxl_dax_region_alloc(cxlr);\n \tif (IS_ERR(cxlr_dax))\n \t\treturn PTR_ERR(cxlr_dax);\n \n-\tdev = &cxlr_dax->dev;\n-\trc = dev_set_name(dev, \"dax_region%d\", cxlr->id);\n+\trc = dev_set_name(&cxlr_dax->dev, \"dax_region%d\", cxlr->id);\n \tif (rc)\n-\t\tgoto err;\n+\t\treturn rc;\n \n-\trc = device_add(dev);\n+\trc = device_add(&cxlr_dax->dev);\n \tif (rc)\n-\t\tgoto err;\n+\t\treturn rc;\n \n-\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(dev->parent),\n-\t\tdev_name(dev));\n+\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(cxlr_dax->dev.parent),\n+\t\tdev_name(&cxlr_dax->dev));\n \n \treturn devm_add_action_or_reset(&cxlr->dev, cxlr_dax_unregister,\n-\t\t\t\t\tcxlr_dax);\n-err:\n-\tput_device(dev);\n-\treturn rc;\n+\t\t\t\t\tno_free_ptr(cxlr_dax));\n }\ndiff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h\nindex 04c673e7cdb0..0b59008ea45a 100644\n--- a/drivers/cxl/cxl.h\n+++ b/drivers/cxl/cxl.h\n@@ -803,6 +803,7 @@ DEFINE_FREE(put_cxl_root, struct cxl_root *, if (_T) put_device(&_T->port.dev))\n DEFINE_FREE(put_cxl_port, struct cxl_port *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->dev))\n DEFINE_FREE(put_cxl_root_decoder, struct cxl_root_decoder *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->cxlsd.cxld.dev))\n DEFINE_FREE(put_cxl_region, struct cxl_region *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->dev))\n+DEFINE_FREE(put_cxl_dax_region, struct cxl_dax_region *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->dev))\n \n int devm_cxl_enumerate_ports(struct cxl_memdev *cxlmd);\n void cxl_bus_rescan(void);\n-- \n2.47.3\n\n",
          "reply_to": ""
        },
        {
          "author": "Dave Jiang",
          "summary": "Dave Jiang suggested keeping a local variable in the patch's last change to minimize potential issues and preserve code readability.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "\n\nOn 2/11/26 1:42 PM, Gregory Price wrote:\n> Cleanup the gotos in the function.\n> \n> No functional change intended.\n> \n> Signed-off-by: Gregory Price <gourry@gourry.net>\n> ---\n>  drivers/cxl/core/region_dax.c | 21 ++++++++-------------\n>  drivers/cxl/cxl.h             |  1 +\n>  2 files changed, 9 insertions(+), 13 deletions(-)\n> \n> diff --git a/drivers/cxl/core/region_dax.c b/drivers/cxl/core/region_dax.c\n> index c8dd2bd1d9b9..49907c6c7620 100644\n> --- a/drivers/cxl/core/region_dax.c\n> +++ b/drivers/cxl/core/region_dax.c\n> @@ -81,29 +81,24 @@ static void cxlr_dax_unregister(void *_cxlr_dax)\n>  \n>  int devm_cxl_add_dax_region(struct cxl_region *cxlr)\n>  {\n> -\tstruct cxl_dax_region *cxlr_dax;\n> -\tstruct device *dev;\n> +\tstruct cxl_dax_region *cxlr_dax __free(put_cxl_dax_region) = NULL;\n>  \tint rc;\n>  \n>  \tcxlr_dax = cxl_dax_region_alloc(cxlr);\n\nThe typical __cleanup() pattern is to move the variable declaration here in order to minimize unintended issues between declare and check.\n\n>  \tif (IS_ERR(cxlr_dax))\n>  \t\treturn PTR_ERR(cxlr_dax);\n>  \n> -\tdev = &cxlr_dax->dev;\n\nGiven that this local var is used multiple times, maybe we should keep it?\n\nDJ\n\n> -\trc = dev_set_name(dev, \"dax_region%d\", cxlr->id);\n> +\trc = dev_set_name(&cxlr_dax->dev, \"dax_region%d\", cxlr->id);\n>  \tif (rc)\n> -\t\tgoto err;\n> +\t\treturn rc;\n>  \n> -\trc = device_add(dev);\n> +\trc = device_add(&cxlr_dax->dev);\n>  \tif (rc)\n> -\t\tgoto err;\n> +\t\treturn rc;\n>  \n> -\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(dev->parent),\n> -\t\tdev_name(dev));\n> +\tdev_dbg(&cxlr->dev, \"%s: register %s\\n\", dev_name(cxlr_dax->dev.parent),\n> +\t\tdev_name(&cxlr_dax->dev));\n>  \n>  \treturn devm_add_action_or_reset(&cxlr->dev, cxlr_dax_unregister,\n> -\t\t\t\t\tcxlr_dax);\n> -err:\n> -\tput_device(dev);\n> -\treturn rc;\n> +\t\t\t\t\tno_free_ptr(cxlr_dax));\n>  }\n> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h\n> index 04c673e7cdb0..0b59008ea45a 100644\n> --- a/drivers/cxl/cxl.h\n> +++ b/drivers/cxl/cxl.h\n> @@ -803,6 +803,7 @@ DEFINE_FREE(put_cxl_root, struct cxl_root *, if (_T) put_device(&_T->port.dev))\n>  DEFINE_FREE(put_cxl_port, struct cxl_port *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->dev))\n>  DEFINE_FREE(put_cxl_root_decoder, struct cxl_root_decoder *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->cxlsd.cxld.dev))\n>  DEFINE_FREE(put_cxl_region, struct cxl_region *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->dev))\n> +DEFINE_FREE(put_cxl_dax_region, struct cxl_dax_region *, if (!IS_ERR_OR_NULL(_T)) put_device(&_T->dev))\n>  \n>  int devm_cxl_enumerate_ports(struct cxl_memdev *cxlmd);\n>  void cxl_bus_rescan(void);\n\n",
          "reply_to": "Gregory Price"
        },
        {
          "author": "Gregory Price (author)",
          "summary": "Reviewer Gregory Price approved the patch but requested some minor cleanup and a re-spin.",
          "sentiment": "positive",
          "sentiment_signals": [
            "NEEDS_WORK"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Tue, Feb 17, 2026 at 04:55:13PM -0700, Dave Jiang wrote:\n> \n> \n> On 2/11/26 1:42 PM, Gregory Price wrote:\n> > Cleanup the gotos in the function.\n> > \n> > No functional change intended.\n> > \n> > Signed-off-by: Gregory Price <gourry@gourry.net>\n> > ---\n> >  drivers/cxl/core/region_dax.c | 21 ++++++++-------------\n> >  drivers/cxl/cxl.h             |  1 +\n> >  2 files changed, 9 insertions(+), 13 deletions(-)\n> > \n> > diff --git a/drivers/cxl/core/region_dax.c b/drivers/cxl/core/region_dax.c\n> > index c8dd2bd1d9b9..49907c6c7620 100644\n> > --- a/drivers/cxl/core/region_dax.c\n> > +++ b/drivers/cxl/core/region_dax.c\n> > @@ -81,29 +81,24 @@ static void cxlr_dax_unregister(void *_cxlr_dax)\n> >  \n> >  int devm_cxl_add_dax_region(struct cxl_region *cxlr)\n> >  {\n> > -\tstruct cxl_dax_region *cxlr_dax;\n> > -\tstruct device *dev;\n> > +\tstruct cxl_dax_region *cxlr_dax __free(put_cxl_dax_region) = NULL;\n> >  \tint rc;\n> >  \n> >  \tcxlr_dax = cxl_dax_region_alloc(cxlr);\n> \n> The typical __cleanup() pattern is to move the variable declaration here in order to minimize unintended issues between declare and check.\n>\n\nAh, relatively new pattern for me, i'll clean it up\n\n> >  \tif (IS_ERR(cxlr_dax))\n> >  \t\treturn PTR_ERR(cxlr_dax);\n> >  \n> > -\tdev = &cxlr_dax->dev;\n> \n> Given that this local var is used multiple times, maybe we should keep it?\n> \n\nFair, will re-spin claned up\n\n~Gregory\n\n",
          "reply_to": "Dave Jiang"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch refactors the cxl_region management code in region.c to separate logic for pmem and dax regions into new files, improving organization and reducing development conflicts."
    }
  }
}