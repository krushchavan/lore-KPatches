{
  "thread_id": "20260220210539.989603-1-nphamcs@gmail.com",
  "subject": "[PATCH] vswap: fix poor batching behavior of vswap free path",
  "url": "https://lore.kernel.org/all/20260220210539.989603-1-nphamcs@gmail.com/",
  "dates": {
    "2026-02-08": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Nhat Pham (author)",
          "summary": "Author addressed a concern about the organization of swap API functions in include/linux/swap.h, agreeing to group them into lifecycle, cache, and physical allocator categories as part of a clean-up patch with no functional changes intended.",
          "sentiment": "positive",
          "sentiment_signals": [
            "clean-up",
            "no-functional-change"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "In the swap header file (include/linux/swap.h), group the swap API into\nthe following categories:\n\n1. Lifecycle swap functions (i.e the function that changes the reference\n   count of the swap entry).\n\n2. Swap cache API.\n\n3. Physical swapfile allocator and swap device API.\n\nAlso remove extern in the functions that are rearranged.\n\nThis is purely a clean up. No functional change intended.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h | 53 +++++++++++++++++++++++---------------------\n 1 file changed, 28 insertions(+), 25 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex 38ca3df687160..aa29d8ac542d1 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -423,20 +423,34 @@ extern void __meminit kswapd_stop(int nid);\n \n #ifdef CONFIG_SWAP\n \n-int add_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n-\t\tunsigned long nr_pages, sector_t start_block);\n-int generic_swapfile_activate(struct swap_info_struct *, struct file *,\n-\t\tsector_t *);\n-\n+/* Lifecycle swap API (mm/swapfile.c) */\n+int folio_alloc_swap(struct folio *folio);\n+bool folio_free_swap(struct folio *folio);\n+void put_swap_folio(struct folio *folio, swp_entry_t entry);\n+void swap_shmem_alloc(swp_entry_t, int);\n+int swap_duplicate(swp_entry_t);\n+int swapcache_prepare(swp_entry_t entry, int nr);\n+void swap_free_nr(swp_entry_t entry, int nr_pages);\n+void free_swap_and_cache_nr(swp_entry_t entry, int nr);\n+int __swap_count(swp_entry_t entry);\n+bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry);\n+int swp_swapcount(swp_entry_t entry);\n+\n+/* Swap cache API (mm/swap_state.c) */\n static inline unsigned long total_swapcache_pages(void)\n {\n \treturn global_node_page_state(NR_SWAPCACHE);\n }\n-\n-void free_swap_cache(struct folio *folio);\n void free_folio_and_swap_cache(struct folio *folio);\n void free_pages_and_swap_cache(struct encoded_page **, int);\n-/* linux/mm/swapfile.c */\n+void free_swap_cache(struct folio *folio);\n+\n+/* Physical swap allocator and swap device API (mm/swapfile.c) */\n+int add_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n+\t\tunsigned long nr_pages, sector_t start_block);\n+int generic_swapfile_activate(struct swap_info_struct *, struct file *,\n+\t\tsector_t *);\n+\n extern atomic_long_t nr_swap_pages;\n extern long total_swap_pages;\n extern atomic_t nr_rotate_swap;\n@@ -452,26 +466,15 @@ static inline long get_nr_swap_pages(void)\n \treturn atomic_long_read(&nr_swap_pages);\n }\n \n-extern void si_swapinfo(struct sysinfo *);\n-int folio_alloc_swap(struct folio *folio);\n-bool folio_free_swap(struct folio *folio);\n-void put_swap_folio(struct folio *folio, swp_entry_t entry);\n-extern swp_entry_t get_swap_page_of_type(int);\n-extern int add_swap_count_continuation(swp_entry_t, gfp_t);\n-extern void swap_shmem_alloc(swp_entry_t, int);\n-extern int swap_duplicate(swp_entry_t);\n-extern int swapcache_prepare(swp_entry_t entry, int nr);\n-extern void swap_free_nr(swp_entry_t entry, int nr_pages);\n-extern void free_swap_and_cache_nr(swp_entry_t entry, int nr);\n+void si_swapinfo(struct sysinfo *);\n+swp_entry_t get_swap_page_of_type(int);\n+int add_swap_count_continuation(swp_entry_t, gfp_t);\n int swap_type_of(dev_t device, sector_t offset);\n int find_first_swap(dev_t *device);\n-extern unsigned int count_swap_pages(int, int);\n-extern sector_t swapdev_block(int, pgoff_t);\n-extern int __swap_count(swp_entry_t entry);\n-extern bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry);\n-extern int swp_swapcount(swp_entry_t entry);\n+unsigned int count_swap_pages(int, int);\n+sector_t swapdev_block(int, pgoff_t);\n struct backing_dev_info;\n-extern struct swap_info_struct *get_swap_device(swp_entry_t entry);\n+struct swap_info_struct *get_swap_device(swp_entry_t entry);\n sector_t swap_folio_sector(struct folio *folio);\n \n static inline void put_swap_device(struct swap_info_struct *si)\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2, and provided a generic API to abstract away the swapoff locking out behavior.",
          "sentiment": "positive",
          "sentiment_signals": [
            "agreed",
            "provided"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Currently, we get a reference to the backing swap device in order to\nprevent swapoff from freeing the metadata of a swap entry. This does not\nmake sense in the new virtual swap design, especially after the swap\nbackends are decoupled - a swap entry might not have any backing swap\ndevice at all, and its backend might change at any time during its\nlifetime.\n\nIn preparation for this, abstract away the swapoff locking out behavior\ninto a generic API.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h | 17 +++++++++++++++++\n mm/memory.c          | 13 +++++++------\n mm/mincore.c         | 15 +++------------\n mm/shmem.c           | 12 ++++++------\n mm/swap_state.c      | 14 +++++++-------\n mm/userfaultfd.c     | 15 +++++++++------\n mm/zswap.c           |  5 ++---\n 7 files changed, 51 insertions(+), 40 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex aa29d8ac542d1..3da637b218baf 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -659,5 +659,22 @@ static inline bool mem_cgroup_swap_full(struct folio *folio)\n }\n #endif\n \n+static inline bool tryget_swap_entry(swp_entry_t entry,\n+\t\t\t\tstruct swap_info_struct **sip)\n+{\n+\tstruct swap_info_struct *si = get_swap_device(entry);\n+\n+\tif (sip)\n+\t\t*sip = si;\n+\n+\treturn si;\n+}\n+\n+static inline void put_swap_entry(swp_entry_t entry,\n+\t\t\t\tstruct swap_info_struct *si)\n+{\n+\tput_swap_device(si);\n+}\n+\n #endif /* __KERNEL__*/\n #endif /* _LINUX_SWAP_H */\ndiff --git a/mm/memory.c b/mm/memory.c\nindex da360a6eb8a48..90031f833f52e 100644\n--- a/mm/memory.c\n+++ b/mm/memory.c\n@@ -4630,6 +4630,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \tstruct swap_info_struct *si = NULL;\n \trmap_t rmap_flags = RMAP_NONE;\n \tbool need_clear_cache = false;\n+\tbool swapoff_locked = false;\n \tbool exclusive = false;\n \tsoftleaf_t entry;\n \tpte_t pte;\n@@ -4698,8 +4699,8 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t}\n \n \t/* Prevent swapoff from happening to us. */\n-\tsi = get_swap_device(entry);\n-\tif (unlikely(!si))\n+\tswapoff_locked = tryget_swap_entry(entry, &si);\n+\tif (unlikely(!swapoff_locked))\n \t\tgoto out;\n \n \tfolio = swap_cache_get_folio(entry);\n@@ -5047,8 +5048,8 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\tif (waitqueue_active(&swapcache_wq))\n \t\t\twake_up(&swapcache_wq);\n \t}\n-\tif (si)\n-\t\tput_swap_device(si);\n+\tif (swapoff_locked)\n+\t\tput_swap_entry(entry, si);\n \treturn ret;\n out_nomap:\n \tif (vmf->pte)\n@@ -5066,8 +5067,8 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\tif (waitqueue_active(&swapcache_wq))\n \t\t\twake_up(&swapcache_wq);\n \t}\n-\tif (si)\n-\t\tput_swap_device(si);\n+\tif (swapoff_locked)\n+\t\tput_swap_entry(entry, si);\n \treturn ret;\n }\n \ndiff --git a/mm/mincore.c b/mm/mincore.c\nindex e5d13eea92347..f3eb771249d67 100644\n--- a/mm/mincore.c\n+++ b/mm/mincore.c\n@@ -77,19 +77,10 @@ static unsigned char mincore_swap(swp_entry_t entry, bool shmem)\n \tif (!softleaf_is_swap(entry))\n \t\treturn !shmem;\n \n-\t/*\n-\t * Shmem mapping lookup is lockless, so we need to grab the swap\n-\t * device. mincore page table walk locks the PTL, and the swap\n-\t * device is stable, avoid touching the si for better performance.\n-\t */\n-\tif (shmem) {\n-\t\tsi = get_swap_device(entry);\n-\t\tif (!si)\n-\t\t\treturn 0;\n-\t}\n+\tif (!tryget_swap_entry(entry, &si))\n+\t\treturn 0;\n \tfolio = swap_cache_get_folio(entry);\n-\tif (shmem)\n-\t\tput_swap_device(si);\n+\tput_swap_entry(entry, si);\n \t/* The swap cache space contains either folio, shadow or NULL */\n \tif (folio && !xa_is_value(folio)) {\n \t\tpresent = folio_test_uptodate(folio);\ndiff --git a/mm/shmem.c b/mm/shmem.c\nindex 1db97ef2d14eb..b40be22fa5f09 100644\n--- a/mm/shmem.c\n+++ b/mm/shmem.c\n@@ -2307,7 +2307,7 @@ static int shmem_swapin_folio(struct inode *inode, pgoff_t index,\n \tsoftleaf_t index_entry;\n \tstruct swap_info_struct *si;\n \tstruct folio *folio = NULL;\n-\tbool skip_swapcache = false;\n+\tbool swapoff_locked, skip_swapcache = false;\n \tint error, nr_pages, order;\n \tpgoff_t offset;\n \n@@ -2319,16 +2319,16 @@ static int shmem_swapin_folio(struct inode *inode, pgoff_t index,\n \tif (softleaf_is_poison_marker(index_entry))\n \t\treturn -EIO;\n \n-\tsi = get_swap_device(index_entry);\n+\tswapoff_locked = tryget_swap_entry(index_entry, &si);\n \torder = shmem_confirm_swap(mapping, index, index_entry);\n-\tif (unlikely(!si)) {\n+\tif (unlikely(!swapoff_locked)) {\n \t\tif (order < 0)\n \t\t\treturn -EEXIST;\n \t\telse\n \t\t\treturn -EINVAL;\n \t}\n \tif (unlikely(order < 0)) {\n-\t\tput_swap_device(si);\n+\t\tput_swap_entry(index_entry, si);\n \t\treturn -EEXIST;\n \t}\n \n@@ -2448,7 +2448,7 @@ static int shmem_swapin_folio(struct inode *inode, pgoff_t index,\n \t}\n \tfolio_mark_dirty(folio);\n \tswap_free_nr(swap, nr_pages);\n-\tput_swap_device(si);\n+\tput_swap_entry(swap, si);\n \n \t*foliop = folio;\n \treturn 0;\n@@ -2466,7 +2466,7 @@ static int shmem_swapin_folio(struct inode *inode, pgoff_t index,\n \t\tswapcache_clear(si, folio->swap, folio_nr_pages(folio));\n \tif (folio)\n \t\tfolio_put(folio);\n-\tput_swap_device(si);\n+\tput_swap_entry(swap, si);\n \n \treturn error;\n }\ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex 34c9d9b243a74..bece18eb540fa 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -538,8 +538,7 @@ struct folio *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \tpgoff_t ilx;\n \tstruct folio *folio;\n \n-\tsi = get_swap_device(entry);\n-\tif (!si)\n+\tif (!tryget_swap_entry(entry, &si))\n \t\treturn NULL;\n \n \tmpol = get_vma_policy(vma, addr, 0, &ilx);\n@@ -550,7 +549,7 @@ struct folio *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \tif (page_allocated)\n \t\tswap_read_folio(folio, plug);\n \n-\tput_swap_device(si);\n+\tput_swap_entry(entry, si);\n \treturn folio;\n }\n \n@@ -763,6 +762,7 @@ static struct folio *swap_vma_readahead(swp_entry_t targ_entry, gfp_t gfp_mask,\n \tfor (addr = start; addr < end; ilx++, addr += PAGE_SIZE) {\n \t\tstruct swap_info_struct *si = NULL;\n \t\tsoftleaf_t entry;\n+\t\tbool swapoff_locked = false;\n \n \t\tif (!pte++) {\n \t\t\tpte = pte_offset_map(vmf->pmd, addr);\n@@ -781,14 +781,14 @@ static struct folio *swap_vma_readahead(swp_entry_t targ_entry, gfp_t gfp_mask,\n \t\t * holding a reference to, try to grab a reference, or skip.\n \t\t */\n \t\tif (swp_type(entry) != swp_type(targ_entry)) {\n-\t\t\tsi = get_swap_device(entry);\n-\t\t\tif (!si)\n+\t\t\tswapoff_locked = tryget_swap_entry(entry, &si);\n+\t\t\tif (!swapoff_locked)\n \t\t\t\tcontinue;\n \t\t}\n \t\tfolio = __read_swap_cache_async(entry, gfp_mask, mpol, ilx,\n \t\t\t\t\t\t&page_allocated, false);\n-\t\tif (si)\n-\t\t\tput_swap_device(si);\n+\t\tif (swapoff_locked)\n+\t\t\tput_swap_entry(entry, si);\n \t\tif (!folio)\n \t\t\tcontinue;\n \t\tif (page_allocated) {\ndiff --git a/mm/userfaultfd.c b/mm/userfaultfd.c\nindex e6dfd5f28acd7..25f89eba0438c 100644\n--- a/mm/userfaultfd.c\n+++ b/mm/userfaultfd.c\n@@ -1262,9 +1262,11 @@ static long move_pages_ptes(struct mm_struct *mm, pmd_t *dst_pmd, pmd_t *src_pmd\n \tpte_t *dst_pte = NULL;\n \tpmd_t dummy_pmdval;\n \tpmd_t dst_pmdval;\n+\tsoftleaf_t entry;\n \tstruct folio *src_folio = NULL;\n \tstruct mmu_notifier_range range;\n \tlong ret = 0;\n+\tbool swapoff_locked = false;\n \n \tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, mm,\n \t\t\t\tsrc_addr, src_addr + len);\n@@ -1429,7 +1431,7 @@ static long move_pages_ptes(struct mm_struct *mm, pmd_t *dst_pmd, pmd_t *src_pmd\n \t\t\t\t\tlen);\n \t} else { /* !pte_present() */\n \t\tstruct folio *folio = NULL;\n-\t\tconst softleaf_t entry = softleaf_from_pte(orig_src_pte);\n+\t\tentry = softleaf_from_pte(orig_src_pte);\n \n \t\tif (softleaf_is_migration(entry)) {\n \t\t\tpte_unmap(src_pte);\n@@ -1449,8 +1451,8 @@ static long move_pages_ptes(struct mm_struct *mm, pmd_t *dst_pmd, pmd_t *src_pmd\n \t\t\tgoto out;\n \t\t}\n \n-\t\tsi = get_swap_device(entry);\n-\t\tif (unlikely(!si)) {\n+\t\tswapoff_locked = tryget_swap_entry(entry, &si);\n+\t\tif (unlikely(!swapoff_locked)) {\n \t\t\tret = -EAGAIN;\n \t\t\tgoto out;\n \t\t}\n@@ -1480,8 +1482,9 @@ static long move_pages_ptes(struct mm_struct *mm, pmd_t *dst_pmd, pmd_t *src_pmd\n \t\t\t\tpte_unmap(src_pte);\n \t\t\t\tpte_unmap(dst_pte);\n \t\t\t\tsrc_pte = dst_pte = NULL;\n-\t\t\t\tput_swap_device(si);\n+\t\t\t\tput_swap_entry(entry, si);\n \t\t\t\tsi = NULL;\n+\t\t\t\tswapoff_locked = false;\n \t\t\t\t/* now we can block and wait */\n \t\t\t\tfolio_lock(src_folio);\n \t\t\t\tgoto retry;\n@@ -1507,8 +1510,8 @@ static long move_pages_ptes(struct mm_struct *mm, pmd_t *dst_pmd, pmd_t *src_pmd\n \tif (dst_pte)\n \t\tpte_unmap(dst_pte);\n \tmmu_notifier_invalidate_range_end(&range);\n-\tif (si)\n-\t\tput_swap_device(si);\n+\tif (swapoff_locked)\n+\t\tput_swap_entry(entry, si);\n \n \treturn ret;\n }\ndiff --git a/mm/zswap.c b/mm/zswap.c\nindex ac9b7a60736bc..315e4d0d08311 100644\n--- a/mm/zswap.c\n+++ b/mm/zswap.c\n@@ -1009,14 +1009,13 @@ static int zswap_writeback_entry(struct zswap_entry *entry,\n \tint ret = 0;\n \n \t/* try to allocate swap cache folio */\n-\tsi = get_swap_device(swpentry);\n-\tif (!si)\n+\tif (!tryget_swap_entry(swpentry, &si))\n \t\treturn -EEXIST;\n \n \tmpol = get_task_policy(current);\n \tfolio = __read_swap_cache_async(swpentry, GFP_KERNEL, mpol,\n \t\t\tNO_INTERLEAVE_INDEX, &folio_was_allocated, true);\n-\tput_swap_device(si);\n+\tput_swap_entry(swpentry, si);\n \tif (!folio)\n \t\treturn -ENOMEM;\n \n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that the vswap free path needs to be restructured to improve batching behavior and agreed to make changes in a future version of the patch.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged",
            "agreed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Add new helper functions to abstract away zswap entry operations, in\norder to facilitate re-implementing these functions when swap is\nvirtualized.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n mm/zswap.c | 59 ++++++++++++++++++++++++++++++++++++------------------\n 1 file changed, 40 insertions(+), 19 deletions(-)\n\ndiff --git a/mm/zswap.c b/mm/zswap.c\nindex 315e4d0d08311..a5a3f068bd1a6 100644\n--- a/mm/zswap.c\n+++ b/mm/zswap.c\n@@ -234,6 +234,38 @@ static inline struct xarray *swap_zswap_tree(swp_entry_t swp)",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the batching behavior of vswap free path, acknowledged that the current implementation is inefficient and agreed to restructure in v2.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged inefficiency",
            "agreed to restructure"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "}\n \n+static inline void *zswap_entry_store(swp_entry_t swpentry,\n+\t\tstruct zswap_entry *entry)\n+{\n+\tstruct xarray *tree = swap_zswap_tree(swpentry);\n+\tpgoff_t offset = swp_offset(swpentry);\n+\n+\treturn xa_store(tree, offset, entry, GFP_KERNEL);\n+}\n+\n+static inline void *zswap_entry_load(swp_entry_t swpentry)\n+{\n+\tstruct xarray *tree = swap_zswap_tree(swpentry);\n+\tpgoff_t offset = swp_offset(swpentry);\n+\n+\treturn xa_load(tree, offset);\n+}\n+\n+static inline void *zswap_entry_erase(swp_entry_t swpentry)\n+{\n+\tstruct xarray *tree = swap_zswap_tree(swpentry);\n+\tpgoff_t offset = swp_offset(swpentry);\n+\n+\treturn xa_erase(tree, offset);\n+}\n+\n+static inline bool zswap_empty(swp_entry_t swpentry)\n+{\n+\tstruct xarray *tree = swap_zswap_tree(swpentry);\n+\n+\treturn xa_empty(tree);\n+}\n+\n #define zswap_pool_debug(msg, p)\t\t\t\\\n \tpr_debug(\"%s pool %s\\n\", msg, (p)->tfm_name)\n \n@@ -1000,8 +1032,6 @@ static bool zswap_decompress(struct zswap_entry *entry, struct folio *folio)\n static int zswap_writeback_entry(struct zswap_entry *entry,\n \t\t\t\t swp_entry_t swpentry)\n {\n-\tstruct xarray *tree;\n-\tpgoff_t offset = swp_offset(swpentry);\n \tstruct folio *folio;\n \tstruct mempolicy *mpol;\n \tbool folio_was_allocated;\n@@ -1040,8 +1070,7 @@ static int zswap_writeback_entry(struct zswap_entry *entry,\n \t * old compressed data. Only when this is successful can the entry\n \t * be dereferenced.\n \t */\n-\ttree = swap_zswap_tree(swpentry);\n-\tif (entry != xa_load(tree, offset)) {\n+\tif (entry != zswap_entry_load(swpentry)) {\n \t\tret = -ENOMEM;\n \t\tgoto out;\n \t}\n@@ -1051,7 +1080,7 @@ static int zswap_writeback_entry(struct zswap_entry *entry,\n \t\tgoto out;\n \t}\n \n-\txa_erase(tree, offset);\n+\tzswap_entry_erase(swpentry);\n \n \tcount_vm_event(ZSWPWB);\n \tif (entry->objcg)\n@@ -1427,9 +1456,7 @@ static bool zswap_store_page(struct page *page,\n \tif (!zswap_compress(page, entry, pool))\n \t\tgoto compress_failed;\n \n-\told = xa_store(swap_zswap_tree(page_swpentry),\n-\t\t       swp_offset(page_swpentry),\n-\t\t       entry, GFP_KERNEL);\n+\told = zswap_entry_store(page_swpentry, entry);\n \tif (xa_is_err(old)) {\n \t\tint err = xa_err(old);\n \n@@ -1563,11 +1590,9 @@ bool zswap_store(struct folio *folio)\n \t\tunsigned type = swp_type(swp);\n \t\tpgoff_t offset = swp_offset(swp);\n \t\tstruct zswap_entry *entry;\n-\t\tstruct xarray *tree;\n \n \t\tfor (index = 0; index < nr_pages; ++index) {\n-\t\t\ttree = swap_zswap_tree(swp_entry(type, offset + index));\n-\t\t\tentry = xa_erase(tree, offset + index);\n+\t\t\tentry = zswap_entry_erase(swp_entry(type, offset + index));\n \t\t\tif (entry)\n \t\t\t\tzswap_entry_free(entry);\n \t\t}\n@@ -1599,9 +1624,7 @@ bool zswap_store(struct folio *folio)\n int zswap_load(struct folio *folio)\n {\n \tswp_entry_t swp = folio->swap;\n-\tpgoff_t offset = swp_offset(swp);\n \tbool swapcache = folio_test_swapcache(folio);\n-\tstruct xarray *tree = swap_zswap_tree(swp);\n \tstruct zswap_entry *entry;\n \n \tVM_WARN_ON_ONCE(!folio_test_locked(folio));\n@@ -1619,7 +1642,7 @@ int zswap_load(struct folio *folio)\n \t\treturn -EINVAL;\n \t}\n \n-\tentry = xa_load(tree, offset);\n+\tentry = zswap_entry_load(swp);\n \tif (!entry)\n \t\treturn -ENOENT;\n \n@@ -1648,7 +1671,7 @@ int zswap_load(struct folio *folio)\n \t */\n \tif (swapcache) {\n \t\tfolio_mark_dirty(folio);\n-\t\txa_erase(tree, offset);\n+\t\tzswap_entry_erase(swp);\n \t\tzswap_entry_free(entry);\n \t}\n \n@@ -1658,14 +1681,12 @@ int zswap_load(struct folio *folio)\n \n void zswap_invalidate(swp_entry_t swp)\n {\n-\tpgoff_t offset = swp_offset(swp);\n-\tstruct xarray *tree = swap_zswap_tree(swp);\n \tstruct zswap_entry *entry;\n \n-\tif (xa_empty(tree))\n+\tif (zswap_empty(swp))\n \t\treturn;\n \n-\tentry = xa_erase(tree, offset);\n+\tentry = zswap_entry_erase(swp);\n \tif (entry)\n \t\tzswap_entry_free(entry);\n }\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author is addressing a concern about the swapoff path needing to drop the per-vswap spinlock before calling try_to_unmap(). The author agrees that this is necessary and will restructure in v2.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledges fix needed",
            "agrees with approach"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Userfaultfd checks whether a swap entry is in swapcache. This is\ncurrently done by directly looking at the swapfile's swap map - however,\nthe swap cached state will soon be managed at the virtual swap layer.\nAbstract away this function.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h |  6 ++++++\n mm/swapfile.c        | 15 +++++++++++++++\n mm/userfaultfd.c     |  3 +--\n 3 files changed, 22 insertions(+), 2 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex 3da637b218baf..f91a442ac0e82 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -435,6 +435,7 @@ void free_swap_and_cache_nr(swp_entry_t entry, int nr);\n int __swap_count(swp_entry_t entry);\n bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry);\n int swp_swapcount(swp_entry_t entry);\n+bool is_swap_cached(swp_entry_t entry);\n \n /* Swap cache API (mm/swap_state.c) */\n static inline unsigned long total_swapcache_pages(void)\n@@ -554,6 +555,11 @@ static inline int swp_swapcount(swp_entry_t entry)\n \treturn 0;\n }\n \n+static inline bool is_swap_cached(swp_entry_t entry)\n+{\n+\treturn false;\n+}\n+\n static inline int folio_alloc_swap(struct folio *folio)\n {\n \treturn -EINVAL;\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex cacfafa9a540d..3c89dedbd5718 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -194,6 +194,21 @@ static bool swap_only_has_cache(struct swap_info_struct *si,\n \treturn true;\n }\n \n+/**\n+ * is_swap_cached - check if the swap entry is cached\n+ * @entry: swap entry to check\n+ *\n+ * Check swap_map directly to minimize overhead, READ_ONCE is sufficient.\n+ *\n+ * Returns true if the swap entry is cached, false otherwise.\n+ */\n+bool is_swap_cached(swp_entry_t entry)\n+{\n+\tstruct swap_info_struct *si = __swap_entry_to_info(entry);\n+\n+\treturn READ_ONCE(si->swap_map[swp_offset(entry)]) & SWAP_HAS_CACHE;\n+}\n+\n static bool swap_is_last_map(struct swap_info_struct *si,\n \t\tunsigned long offset, int nr_pages, bool *has_cache)\n {\ndiff --git a/mm/userfaultfd.c b/mm/userfaultfd.c\nindex 25f89eba0438c..98be764fb3ecd 100644\n--- a/mm/userfaultfd.c\n+++ b/mm/userfaultfd.c\n@@ -1190,7 +1190,6 @@ static int move_swap_pte(struct mm_struct *mm, struct vm_area_struct *dst_vma,\n \t\t * Check if the swap entry is cached after acquiring the src_pte\n \t\t * lock. Otherwise, we might miss a newly loaded swap cache folio.\n \t\t *\n-\t\t * Check swap_map directly to minimize overhead, READ_ONCE is sufficient.\n \t\t * We are trying to catch newly added swap cache, the only possible case is\n \t\t * when a folio is swapped in and out again staying in swap cache, using the\n \t\t * same entry before the PTE check above. The PTL is acquired and released\n@@ -1200,7 +1199,7 @@ static int move_swap_pte(struct mm_struct *mm, struct vm_area_struct *dst_vma,\n \t\t * cache, or during the tiny synchronization window between swap cache and\n \t\t * swap_map, but it will be gone very quickly, worst result is retry jitters.\n \t\t */\n-\t\tif (READ_ONCE(si->swap_map[swp_offset(entry)]) & SWAP_HAS_CACHE) {\n+\t\tif (is_swap_cached(entry)) {\n \t\t\tdouble_pt_unlock(dst_ptl, src_ptl);\n \t\t\treturn -EAGAIN;\n \t\t}\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author addressed a concern about the swapoff path needing to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2, but this patch is unrelated and only sets up virtual swap debugfs directory.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no behavioral change intended",
            "unrelated patch"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "In prepration for the implementation of swap virtualization, add new\nscaffolds for the new code: a new mm/vswap.c source file, which\ncurrently only holds the logic to set up the (for now, empty) vswap\ndebugfs directory. Hook this up in the swap setup step in\nmm/swap_state.c, and set up vswap compilation in the Makefile.\n\nOther than the debugfs directory, no behavioral change intended.\n\nFinally, make Johannes a swap reviewer, given that he has contributed\nmajorly to the developments of virtual swap.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n MAINTAINERS          |  2 ++\n include/linux/swap.h |  2 ++\n mm/Makefile          |  2 +-\n mm/swap_state.c      |  6 ++++++\n mm/vswap.c           | 35 +++++++++++++++++++++++++++++++++++\n 5 files changed, 46 insertions(+), 1 deletion(-)\n create mode 100644 mm/vswap.c\n\ndiff --git a/MAINTAINERS b/MAINTAINERS\nindex e087673237636..b21038b160a07 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -16728,6 +16728,7 @@ R:\tKemeng Shi <shikemeng@huaweicloud.com>\n R:\tNhat Pham <nphamcs@gmail.com>\n R:\tBaoquan He <bhe@redhat.com>\n R:\tBarry Song <baohua@kernel.org>\n+R:\tJohannes Weiner <hannes@cmpxchg.org>\n L:\tlinux-mm@kvack.org\n S:\tMaintained\n F:\tDocumentation/mm/swap-table.rst\n@@ -16740,6 +16741,7 @@ F:\tmm/swap.h\n F:\tmm/swap_table.h\n F:\tmm/swap_state.c\n F:\tmm/swapfile.c\n+F:\tmm/vswap.c\n \n MEMORY MANAGEMENT - THP (TRANSPARENT HUGE PAGE)\n M:\tAndrew Morton <akpm@linux-foundation.org>\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex 918b47da55f44..1ff463fb3a966 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -669,6 +669,8 @@ static inline bool mem_cgroup_swap_full(struct folio *folio)\n }\n #endif\n \n+int vswap_init(void);\n+\n /**\n  * swp_entry_to_swp_slot - look up the physical swap slot corresponding to a\n  *                         virtual swap slot.\ndiff --git a/mm/Makefile b/mm/Makefile\nindex 2d0570a16e5be..67fa4586e7e18 100644\n--- a/mm/Makefile\n+++ b/mm/Makefile\n@@ -75,7 +75,7 @@ ifdef CONFIG_MMU\n \tobj-$(CONFIG_ADVISE_SYSCALLS)\t+= madvise.o\n endif\n \n-obj-$(CONFIG_SWAP)\t+= page_io.o swap_state.o swapfile.o\n+obj-$(CONFIG_SWAP)\t+= page_io.o swap_state.o swapfile.o vswap.o\n obj-$(CONFIG_ZSWAP)\t+= zswap.o\n obj-$(CONFIG_HAS_DMA)\t+= dmapool.o\n obj-$(CONFIG_HUGETLBFS)\t+= hugetlb.o hugetlb_sysfs.o hugetlb_sysctl.o\ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex e2e9f55bea3bb..29ec666be4204 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -882,6 +882,12 @@ static int __init swap_init(void)\n \tint err;\n \tstruct kobject *swap_kobj;\n \n+\terr = vswap_init();\n+\tif (err) {\n+\t\tpr_err(\"failed to initialize virtual swap space\\n\");\n+\t\treturn err;\n+\t}\n+\n \tswap_kobj = kobject_create_and_add(\"swap\", mm_kobj);\n \tif (!swap_kobj) {\n \t\tpr_err(\"failed to create swap kobject\\n\");\ndiff --git a/mm/vswap.c b/mm/vswap.c\nnew file mode 100644\nindex 0000000000000..e68234f053fc9\n--- /dev/null\n+++ b/mm/vswap.c\n@@ -0,0 +1,35 @@\n+// SPDX-License-Identifier: GPL-2.0\n+/*\n+ * Virtual swap space\n+ *\n+ * Copyright (C) 2024 Meta Platforms, Inc., Nhat Pham\n+ */\n+#include <linux/swap.h>\n+\n+#ifdef CONFIG_DEBUG_FS\n+#include <linux/debugfs.h>\n+\n+static struct dentry *vswap_debugfs_root;\n+\n+static int vswap_debug_fs_init(void)\n+{\n+\tif (!debugfs_initialized())\n+\t\treturn -ENODEV;\n+\n+\tvswap_debugfs_root = debugfs_create_dir(\"vswap\", NULL);\n+\treturn 0;\n+}\n+#else\n+static int vswap_debug_fs_init(void)\n+{\n+\treturn 0;\n+}\n+#endif\n+\n+int vswap_init(void)\n+{\n+\tif (vswap_debug_fs_init())\n+\t\tpr_warn(\"Failed to initialize vswap debugfs\\n\");\n+\n+\treturn 0;\n+}\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the need to separate logical and physical swap slot representations by introducing new types (swp_entry_t and swp_slot_t) and renaming functions that operate at the physical level. The author confirmed that no behavioral change was made, but acknowledged that this is just the first step in preparing for swap virtualization.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged a concern",
            "confirmed no behavioral change"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "In preparation for swap virtualization, add a new type to represent the\nphysical swap slots of swapfile. This allows us to separates:\n\n1. The logical view of the swap entry (i.e what is stored in page table\n   entries and used to index into the swap cache), represented by the\n   old swp_entry_t type.\n\nfrom:\n\n2. Its physical backing state (i.e the actual backing slot on the swap\n   device), represented by the new swp_slot_t type.\n\nThe functions that operate at the physical level (i.e on the swp_slot_t\ntypes) are also renamed where appropriate (prefixed with swp_slot_* for\ne.g).\n\nNote that we have not made any behavioral change - the mapping between\nthe two types is the identity mapping. In later patches, we shall\ndynamically allocate a virtual swap slot (of type swp_entry_t) for each\nswapped out page to store in the page table entry, and associate it with\na backing store. A physical swap slot (i.e a slot on a physical swap\ndevice) is one of the backing options.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/mm_types.h |  16 +++\n include/linux/swap.h     |  47 ++++--\n include/linux/swapops.h  |  25 ++++\n kernel/power/swap.c      |   6 +-\n mm/internal.h            |  10 +-\n mm/page_io.c             |  33 +++--\n mm/shmem.c               |  19 ++-\n mm/swap.h                |  52 +++----\n mm/swap_cgroup.c         |  18 +--\n mm/swap_state.c          |  32 +++--\n mm/swapfile.c            | 300 ++++++++++++++++++++++-----------------\n 11 files changed, 352 insertions(+), 206 deletions(-)\n\ndiff --git a/include/linux/mm_types.h b/include/linux/mm_types.h\nindex 78950eb8926dc..bffde812decc5 100644\n--- a/include/linux/mm_types.h\n+++ b/include/linux/mm_types.h\n@@ -279,6 +279,13 @@ static __always_inline unsigned long encoded_nr_pages(struct encoded_page *page)\n }\n \n /*\n+ * Virtual swap slot.\n+ *\n+ * This type is used to represent a virtual swap slot, i.e an identifier of\n+ * a swap entry. This is stored in PTEs that originally refer to the swapped\n+ * out page, and is used to index into various swap architectures (swap cache,\n+ * zswap tree, swap cgroup array, etc.).\n+ *\n  * A swap entry has to fit into a \"unsigned long\", as the entry is hidden\n  * in the \"index\" field of the swapper address space.\n  */\n@@ -286,6 +293,15 @@ typedef struct {\n \tunsigned long val;\n } swp_entry_t;\n \n+/*\n+ * Physical swap slot.\n+ *\n+ * This type is used to represent a PAGE_SIZED slot on a swapfile.\n+ */\n+typedef struct {\n+\tunsigned long val;\n+} swp_slot_t;\n+\n /**\n  * typedef softleaf_t - Describes a page table software leaf entry, abstracted\n  * from its architecture-specific encoding.\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex f91a442ac0e82..918b47da55f44 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -241,7 +241,7 @@ enum {\n  * cluster to which it belongs being marked free. Therefore 0 is safe to use as\n  * a sentinel to indicate an entry is not valid.\n  */\n-#define SWAP_ENTRY_INVALID\t0\n+#define SWAP_SLOT_INVALID\t0\n \n #ifdef CONFIG_THP_SWAP\n #define SWAP_NR_ORDERS\t\t(PMD_ORDER + 1)\n@@ -442,11 +442,14 @@ static inline unsigned long total_swapcache_pages(void)\n {\n \treturn global_node_page_state(NR_SWAPCACHE);\n }\n+\n void free_folio_and_swap_cache(struct folio *folio);\n void free_pages_and_swap_cache(struct encoded_page **, int);\n void free_swap_cache(struct folio *folio);\n \n /* Physical swap allocator and swap device API (mm/swapfile.c) */\n+void swap_slot_free_nr(swp_slot_t slot, int nr_pages);\n+\n int add_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n \t\tunsigned long nr_pages, sector_t start_block);\n int generic_swapfile_activate(struct swap_info_struct *, struct file *,\n@@ -468,28 +471,28 @@ static inline long get_nr_swap_pages(void)\n }\n \n void si_swapinfo(struct sysinfo *);\n-swp_entry_t get_swap_page_of_type(int);\n+swp_slot_t swap_slot_alloc_of_type(int);\n int add_swap_count_continuation(swp_entry_t, gfp_t);\n int swap_type_of(dev_t device, sector_t offset);\n int find_first_swap(dev_t *device);\n unsigned int count_swap_pages(int, int);\n sector_t swapdev_block(int, pgoff_t);\n struct backing_dev_info;\n-struct swap_info_struct *get_swap_device(swp_entry_t entry);\n+struct swap_info_struct *swap_slot_tryget_swap_info(swp_slot_t slot);\n sector_t swap_folio_sector(struct folio *folio);\n \n-static inline void put_swap_device(struct swap_info_struct *si)\n+static inline void swap_slot_put_swap_info(struct swap_info_struct *si)\n {\n \tpercpu_ref_put(&si->users);\n }\n \n #else /* CONFIG_SWAP */\n-static inline struct swap_info_struct *get_swap_device(swp_entry_t entry)\n+static inline struct swap_info_struct *swap_slot_tryget_swap_info(swp_slot_t slot)\n {\n \treturn NULL;\n }\n \n-static inline void put_swap_device(struct swap_info_struct *si)\n+static inline void swap_slot_put_swap_info(struct swap_info_struct *si)\n {\n }\n \n@@ -536,7 +539,7 @@ static inline void swap_free_nr(swp_entry_t entry, int nr_pages)\n {\n }\n \n-static inline void put_swap_folio(struct folio *folio, swp_entry_t swp)\n+static inline void put_swap_folio(struct folio *folio, swp_entry_t entry)\n {\n }\n \n@@ -576,6 +579,7 @@ static inline int add_swap_extent(struct swap_info_struct *sis,\n {\n \treturn -EINVAL;\n }\n+\n #endif /* CONFIG_SWAP */\n \n static inline void free_swap_and_cache(swp_entry_t entry)\n@@ -665,10 +669,35 @@ static inline bool mem_cgroup_swap_full(struct folio *folio)\n }\n #endif\n \n+/**\n+ * swp_entry_to_swp_slot - look up the physical swap slot corresponding to a\n+ *                         virtual swap slot.\n+ * @entry: the virtual swap slot.\n+ *\n+ * Return: the physical swap slot corresponding to the virtual swap slot.\n+ */\n+static inline swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry)\n+{\n+\treturn (swp_slot_t) { entry.val };\n+}\n+\n+/**\n+ * swp_slot_to_swp_entry - look up the virtual swap slot corresponding to a\n+ *                         physical swap slot.\n+ * @slot: the physical swap slot.\n+ *\n+ * Return: the virtual swap slot corresponding to the physical swap slot.\n+ */\n+static inline swp_entry_t swp_slot_to_swp_entry(swp_slot_t slot)\n+{\n+\treturn (swp_entry_t) { slot.val };\n+}\n+\n static inline bool tryget_swap_entry(swp_entry_t entry,\n \t\t\t\tstruct swap_info_struct **sip)\n {\n-\tstruct swap_info_struct *si = get_swap_device(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tstruct swap_info_struct *si = swap_slot_tryget_swap_info(slot);\n \n \tif (sip)\n \t\t*sip = si;\n@@ -679,7 +708,7 @@ static inline bool tryget_swap_entry(swp_entry_t entry,\n static inline void put_swap_entry(swp_entry_t entry,\n \t\t\t\tstruct swap_info_struct *si)\n {\n-\tput_swap_device(si);\n+\tswap_slot_put_swap_info(si);\n }\n \n #endif /* __KERNEL__*/\ndiff --git a/include/linux/swapops.h b/include/linux/swapops.h\nindex 8cfc966eae48e..9e41c35664a95 100644\n--- a/include/linux/swapops.h\n+++ b/include/linux/swapops.h\n@@ -360,5 +360,30 @@ static inline pmd_t swp_entry_to_pmd(swp_entry_t entry)\n \n #endif  /* CONFIG_ARCH_ENABLE_THP_MIGRATION */\n \n+/* Physical swap slots operations */\n+\n+/*\n+ * Store a swap device type + offset into a swp_slot_t handle.\n+ */\n+static inline swp_slot_t swp_slot(unsigned long type, pgoff_t offset)\n+{\n+\tswp_slot_t ret;\n+\n+\tret.val = (type << SWP_TYPE_SHIFT) | (offset & SWP_OFFSET_MASK);\n+\treturn ret;\n+}\n+\n+/* Extract the `type' field from a swp_slot_t. */\n+static inline unsigned swp_slot_type(swp_slot_t slot)\n+{\n+\treturn (slot.val >> SWP_TYPE_SHIFT);\n+}\n+\n+/* Extract the `offset' field from a swp_slot_t. */\n+static inline pgoff_t swp_slot_offset(swp_slot_t slot)\n+{\n+\treturn slot.val & SWP_OFFSET_MASK;\n+}\n+\n #endif /* CONFIG_MMU */\n #endif /* _LINUX_SWAPOPS_H */\ndiff --git a/kernel/power/swap.c b/kernel/power/swap.c\nindex 8050e51828351..0129c5ffa649d 100644\n--- a/kernel/power/swap.c\n+++ b/kernel/power/swap.c\n@@ -174,10 +174,10 @@ sector_t alloc_swapdev_block(int swap)\n \t * Allocate a swap page and register that it has been allocated, so that\n \t * it can be freed in case of an error.\n \t */\n-\toffset = swp_offset(get_swap_page_of_type(swap));\n+\toffset = swp_slot_offset(swap_slot_alloc_of_type(swap));\n \tif (offset) {\n \t\tif (swsusp_extents_insert(offset))\n-\t\t\tswap_free(swp_entry(swap, offset));\n+\t\t\tswap_slot_free_nr(swp_slot(swap, offset), 1);\n \t\telse\n \t\t\treturn swapdev_block(swap, offset);\n \t}\n@@ -197,7 +197,7 @@ void free_all_swap_pages(int swap)\n \n \t\text = rb_entry(node, struct swsusp_extent, node);\n \t\trb_erase(node, &swsusp_extents);\n-\t\tswap_free_nr(swp_entry(swap, ext->start),\n+\t\tswap_slot_free_nr(swp_slot(swap, ext->start),\n \t\t\t     ext->end - ext->start + 1);\n \n \t\tkfree(ext);\ndiff --git a/mm/internal.h b/mm/internal.h\nindex f35dbcf99a86b..e739e8cac5b55 100644\n--- a/mm/internal.h\n+++ b/mm/internal.h\n@@ -334,9 +334,13 @@ unsigned int folio_pte_batch(struct folio *folio, pte_t *ptep, pte_t pte,\n  */\n static inline pte_t pte_move_swp_offset(pte_t pte, long delta)\n {\n-\tconst softleaf_t entry = softleaf_from_pte(pte);\n-\tpte_t new = __swp_entry_to_pte(__swp_entry(swp_type(entry),\n-\t\t\t\t\t\t   (swp_offset(entry) + delta)));\n+\tsoftleaf_t entry = softleaf_from_pte(pte), new_entry;\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tpte_t new;\n+\n+\tnew_entry = swp_slot_to_swp_entry(swp_slot(swp_slot_type(slot),\n+\t\t\tswp_slot_offset(slot) + delta));\n+\tnew = swp_entry_to_pte(new_entry);\n \n \tif (pte_swp_soft_dirty(pte))\n \t\tnew = pte_swp_mksoft_dirty(new);\ndiff --git a/mm/page_io.c b/mm/page_io.c\nindex 3c342db77ce38..0b02bcc85e2a8 100644\n--- a/mm/page_io.c\n+++ b/mm/page_io.c\n@@ -204,14 +204,17 @@ static bool is_folio_zero_filled(struct folio *folio)\n static void swap_zeromap_folio_set(struct folio *folio)\n {\n \tstruct obj_cgroup *objcg = get_obj_cgroup_from_folio(folio);\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(folio->swap);\n+\tstruct swap_info_struct *sis =\n+\t\t__swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n \tint nr_pages = folio_nr_pages(folio);\n \tswp_entry_t entry;\n+\tswp_slot_t slot;\n \tunsigned int i;\n \n \tfor (i = 0; i < folio_nr_pages(folio); i++) {\n \t\tentry = page_swap_entry(folio_page(folio, i));\n-\t\tset_bit(swp_offset(entry), sis->zeromap);\n+\t\tslot = swp_entry_to_swp_slot(entry);\n+\t\tset_bit(swp_slot_offset(slot), sis->zeromap);\n \t}\n \n \tcount_vm_events(SWPOUT_ZERO, nr_pages);\n@@ -223,13 +226,16 @@ static void swap_zeromap_folio_set(struct folio *folio)\n \n static void swap_zeromap_folio_clear(struct folio *folio)\n {\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(folio->swap);\n+\tstruct swap_info_struct *sis =\n+\t\t__swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n \tswp_entry_t entry;\n+\tswp_slot_t slot;\n \tunsigned int i;\n \n \tfor (i = 0; i < folio_nr_pages(folio); i++) {\n \t\tentry = page_swap_entry(folio_page(folio, i));\n-\t\tclear_bit(swp_offset(entry), sis->zeromap);\n+\t\tslot = swp_entry_to_swp_slot(entry);\n+\t\tclear_bit(swp_slot_offset(slot), sis->zeromap);\n \t}\n }\n \n@@ -357,7 +363,8 @@ static void sio_write_complete(struct kiocb *iocb, long ret)\n \t\t * messages.\n \t\t */\n \t\tpr_err_ratelimited(\"Write error %ld on dio swapfile (%llu)\\n\",\n-\t\t\t\t   ret, swap_dev_pos(page_swap_entry(page)));\n+\t\t\t\t   ret,\n+\t\t\t\t   swap_slot_pos(swp_entry_to_swp_slot(page_swap_entry(page))));\n \t\tfor (p = 0; p < sio->pages; p++) {\n \t\t\tpage = sio->bvec[p].bv_page;\n \t\t\tset_page_dirty(page);\n@@ -374,9 +381,10 @@ static void sio_write_complete(struct kiocb *iocb, long ret)\n static void swap_writepage_fs(struct folio *folio, struct swap_iocb **swap_plug)\n {\n \tstruct swap_iocb *sio = swap_plug ? *swap_plug : NULL;\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(folio->swap);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(folio->swap);\n+\tstruct swap_info_struct *sis = __swap_slot_to_info(slot);\n \tstruct file *swap_file = sis->swap_file;\n-\tloff_t pos = swap_dev_pos(folio->swap);\n+\tloff_t pos = swap_slot_pos(slot);\n \n \tcount_swpout_vm_event(folio);\n \tfolio_start_writeback(folio);\n@@ -446,7 +454,8 @@ static void swap_writepage_bdev_async(struct folio *folio,\n \n void __swap_writepage(struct folio *folio, struct swap_iocb **swap_plug)\n {\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(folio->swap);\n+\tstruct swap_info_struct *sis =\n+\t\t__swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n \n \tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio), folio);\n \t/*\n@@ -537,9 +546,10 @@ static bool swap_read_folio_zeromap(struct folio *folio)\n \n static void swap_read_folio_fs(struct folio *folio, struct swap_iocb **plug)\n {\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(folio->swap);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(folio->swap);\n+\tstruct swap_info_struct *sis = __swap_slot_to_info(slot);\n \tstruct swap_iocb *sio = NULL;\n-\tloff_t pos = swap_dev_pos(folio->swap);\n+\tloff_t pos = swap_slot_pos(slot);\n \n \tif (plug)\n \t\tsio = *plug;\n@@ -608,7 +618,8 @@ static void swap_read_folio_bdev_async(struct folio *folio,\n \n void swap_read_folio(struct folio *folio, struct swap_iocb **plug)\n {\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(folio->swap);\n+\tstruct swap_info_struct *sis =\n+\t\t__swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n \tbool synchronous = sis->flags & SWP_SYNCHRONOUS_IO;\n \tbool workingset = folio_test_workingset(folio);\n \tunsigned long pflags;\ndiff --git a/mm/shmem.c b/mm/shmem.c\nindex b40be22fa5f09..400e2fa8e77cb 100644\n--- a/mm/shmem.c\n+++ b/mm/shmem.c\n@@ -1442,6 +1442,7 @@ static unsigned int shmem_find_swap_entries(struct address_space *mapping,\n \tXA_STATE(xas, &mapping->i_pages, start);\n \tstruct folio *folio;\n \tswp_entry_t entry;\n+\tswp_slot_t slot;\n \n \trcu_read_lock();\n \txas_for_each(&xas, folio, ULONG_MAX) {\n@@ -1452,11 +1453,13 @@ static unsigned int shmem_find_swap_entries(struct address_space *mapping,\n \t\t\tcontinue;\n \n \t\tentry = radix_to_swp_entry(folio);\n+\t\tslot = swp_entry_to_swp_slot(entry);\n+\n \t\t/*\n \t\t * swapin error entries can be found in the mapping. But they're\n \t\t * deliberately ignored here as we've done everything we can do.\n \t\t */\n-\t\tif (swp_type(entry) != type)\n+\t\tif (swp_slot_type(slot) != type)\n \t\t\tcontinue;\n \n \t\tindices[folio_batch_count(fbatch)] = xas.xa_index;\n@@ -2224,6 +2227,7 @@ static int shmem_split_large_entry(struct inode *inode, pgoff_t index,\n \tXA_STATE_ORDER(xas, &mapping->i_pages, index, 0);\n \tint split_order = 0;\n \tint i;\n+\tswp_slot_t slot = swp_entry_to_swp_slot(swap);\n \n \t/* Convert user data gfp flags to xarray node gfp flags */\n \tgfp &= GFP_RECLAIM_MASK;\n@@ -2264,13 +2268,16 @@ static int shmem_split_large_entry(struct inode *inode, pgoff_t index,\n \t\t\t */\n \t\t\tfor (i = 0; i < 1 << cur_order;\n \t\t\t     i += (1 << split_order)) {\n-\t\t\t\tswp_entry_t tmp;\n+\t\t\t\tswp_entry_t tmp_entry;\n+\t\t\t\tswp_slot_t tmp_slot;\n+\n+\t\t\t\ttmp_slot =\n+\t\t\t\t\tswp_slot(swp_slot_type(slot),\n+\t\t\t\t\t\tswp_slot_offset(slot) + swap_offset + i);\n+\t\t\t\ttmp_entry = swp_slot_to_swp_entry(tmp_slot);\n \n-\t\t\t\ttmp = swp_entry(swp_type(swap),\n-\t\t\t\t\t\tswp_offset(swap) + swap_offset +\n-\t\t\t\t\t\t\ti);\n \t\t\t\t__xa_store(&mapping->i_pages, aligned_index + i,\n-\t\t\t\t\t   swp_to_radix_entry(tmp), 0);\n+\t\t\t\t\t   swp_to_radix_entry(tmp_entry), 0);\n \t\t\t}\n \t\t\tcur_order = split_order;\n \t\t\tsplit_order = xas_try_split_min_order(split_order);\ndiff --git a/mm/swap.h b/mm/swap.h\nindex 8726b587a5b5d..bdf7aca146643 100644\n--- a/mm/swap.h\n+++ b/mm/swap.h\n@@ -10,10 +10,10 @@ extern int page_cluster;\n \n #ifdef CONFIG_THP_SWAP\n #define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n-#define swap_entry_order(order)\t(order)\n+#define swap_slot_order(order)\t(order)\n #else\n #define SWAPFILE_CLUSTER\t256\n-#define swap_entry_order(order)\t0\n+#define swap_slot_order(order)\t0\n #endif\n \n extern struct swap_info_struct *swap_info[];\n@@ -57,9 +57,9 @@ enum swap_cluster_flags {\n #include <linux/swapops.h> /* for swp_offset */\n #include <linux/blk_types.h> /* for bio_end_io_t */\n \n-static inline unsigned int swp_cluster_offset(swp_entry_t entry)\n+static inline unsigned int swp_cluster_offset(swp_slot_t slot)\n {\n-\treturn swp_offset(entry) % SWAPFILE_CLUSTER;\n+\treturn swp_slot_offset(slot) % SWAPFILE_CLUSTER;\n }\n \n /*\n@@ -75,9 +75,9 @@ static inline struct swap_info_struct *__swap_type_to_info(int type)\n \treturn si;\n }\n \n-static inline struct swap_info_struct *__swap_entry_to_info(swp_entry_t entry)\n+static inline struct swap_info_struct *__swap_slot_to_info(swp_slot_t slot)\n {\n-\treturn __swap_type_to_info(swp_type(entry));\n+\treturn __swap_type_to_info(swp_slot_type(slot));\n }\n \n static inline struct swap_cluster_info *__swap_offset_to_cluster(\n@@ -88,10 +88,10 @@ static inline struct swap_cluster_info *__swap_offset_to_cluster(\n \treturn &si->cluster_info[offset / SWAPFILE_CLUSTER];\n }\n \n-static inline struct swap_cluster_info *__swap_entry_to_cluster(swp_entry_t entry)\n+static inline struct swap_cluster_info *__swap_slot_to_cluster(swp_slot_t slot)\n {\n-\treturn __swap_offset_to_cluster(__swap_entry_to_info(entry),\n-\t\t\t\t\tswp_offset(entry));\n+\treturn __swap_offset_to_cluster(__swap_slot_to_info(slot),\n+\t\t\t\t\tswp_slot_offset(slot));\n }\n \n static __always_inline struct swap_cluster_info *__swap_cluster_lock(\n@@ -120,7 +120,7 @@ static __always_inline struct swap_cluster_info *__swap_cluster_lock(\n /**\n  * swap_cluster_lock - Lock and return the swap cluster of given offset.\n  * @si: swap device the cluster belongs to.\n- * @offset: the swap entry offset, pointing to a valid slot.\n+ * @offset: the swap slot offset, pointing to a valid slot.\n  *\n  * Context: The caller must ensure the offset is in the valid range and\n  * protect the swap device with reference count or locks.\n@@ -134,10 +134,12 @@ static inline struct swap_cluster_info *swap_cluster_lock(\n static inline struct swap_cluster_info *__swap_cluster_get_and_lock(\n \t\tconst struct folio *folio, bool irq)\n {\n+\tswp_slot_t slot = swp_entry_to_swp_slot(folio->swap);\n+\n \tVM_WARN_ON_ONCE_FOLIO(!folio_test_locked(folio), folio);\n \tVM_WARN_ON_ONCE_FOLIO(!folio_test_swapcache(folio), folio);\n-\treturn __swap_cluster_lock(__swap_entry_to_info(folio->swap),\n-\t\t\t\t   swp_offset(folio->swap), irq);\n+\treturn __swap_cluster_lock(__swap_slot_to_info(slot),\n+\t\t\t\t   swp_slot_offset(slot), irq);\n }\n \n /*\n@@ -209,12 +211,10 @@ static inline struct address_space *swap_address_space(swp_entry_t entry)\n \treturn &swap_space;\n }\n \n-/*\n- * Return the swap device position of the swap entry.\n- */\n-static inline loff_t swap_dev_pos(swp_entry_t entry)\n+/* Return the swap device position of the swap slot. */\n+static inline loff_t swap_slot_pos(swp_slot_t slot)\n {\n-\treturn ((loff_t)swp_offset(entry)) << PAGE_SHIFT;\n+\treturn ((loff_t)swp_slot_offset(slot)) << PAGE_SHIFT;\n }\n \n /**\n@@ -276,7 +276,9 @@ void swap_update_readahead(struct folio *folio, struct vm_area_struct *vma,\n \n static inline unsigned int folio_swap_flags(struct folio *folio)\n {\n-\treturn __swap_entry_to_info(folio->swap)->flags;\n+\tswp_slot_t swp_slot = swp_entry_to_swp_slot(folio->swap);\n+\n+\treturn __swap_slot_to_info(swp_slot)->flags;\n }\n \n /*\n@@ -287,8 +289,9 @@ static inline unsigned int folio_swap_flags(struct folio *folio)\n static inline int swap_zeromap_batch(swp_entry_t entry, int max_nr,\n \t\tbool *is_zeromap)\n {\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(entry);\n-\tunsigned long start = swp_offset(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tstruct swap_info_struct *sis = __swap_slot_to_info(slot);\n+\tunsigned long start = swp_slot_offset(slot);\n \tunsigned long end = start + max_nr;\n \tbool first_bit;\n \n@@ -306,8 +309,9 @@ static inline int swap_zeromap_batch(swp_entry_t entry, int max_nr,\n \n static inline int non_swapcache_batch(swp_entry_t entry, int max_nr)\n {\n-\tstruct swap_info_struct *si = __swap_entry_to_info(entry);\n-\tpgoff_t offset = swp_offset(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tstruct swap_info_struct *si = __swap_slot_to_info(slot);\n+\tpgoff_t offset = swp_slot_offset(slot);\n \tint i;\n \n \t/*\n@@ -326,7 +330,7 @@ static inline int non_swapcache_batch(swp_entry_t entry, int max_nr)\n #else /* CONFIG_SWAP */\n struct swap_iocb;\n static inline struct swap_cluster_info *swap_cluster_lock(\n-\tstruct swap_info_struct *si, pgoff_t offset, bool irq)\n+\tstruct swap_info_struct *si, unsigned long offset)\n {\n \treturn NULL;\n }\n@@ -351,7 +355,7 @@ static inline void swap_cluster_unlock_irq(struct swap_cluster_info *ci)\n {\n }\n \n-static inline struct swap_info_struct *__swap_entry_to_info(swp_entry_t entry)\n+static inline struct swap_info_struct *__swap_slot_to_info(swp_slot_t slot)\n {\n \treturn NULL;\n }\ndiff --git a/mm/swap_cgroup.c b/mm/swap_cgroup.c\nindex de779fed8c210..77ce1d66c318d 100644\n--- a/mm/swap_cgroup.c\n+++ b/mm/swap_cgroup.c\n@@ -65,13 +65,14 @@ void swap_cgroup_record(struct folio *folio, unsigned short id,\n \t\t\tswp_entry_t ent)\n {\n \tunsigned int nr_ents = folio_nr_pages(folio);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(ent);\n \tstruct swap_cgroup *map;\n \tpgoff_t offset, end;\n \tunsigned short old;\n \n-\toffset = swp_offset(ent);\n+\toffset = swp_slot_offset(slot);\n \tend = offset + nr_ents;\n-\tmap = swap_cgroup_ctrl[swp_type(ent)].map;\n+\tmap = swap_cgroup_ctrl[swp_slot_type(slot)].map;\n \n \tdo {\n \t\told = __swap_cgroup_id_xchg(map, offset, id);\n@@ -92,13 +93,13 @@ void swap_cgroup_record(struct folio *folio, unsigned short id,\n  */\n unsigned short swap_cgroup_clear(swp_entry_t ent, unsigned int nr_ents)\n {\n-\tpgoff_t offset, end;\n+\tswp_slot_t slot = swp_entry_to_swp_slot(ent);\n+\tpgoff_t offset = swp_slot_offset(slot);\n+\tpgoff_t end = offset + nr_ents;\n \tstruct swap_cgroup *map;\n \tunsigned short old, iter = 0;\n \n-\toffset = swp_offset(ent);\n-\tend = offset + nr_ents;\n-\tmap = swap_cgroup_ctrl[swp_type(ent)].map;\n+\tmap = swap_cgroup_ctrl[swp_slot_type(slot)].map;\n \n \tdo {\n \t\told = __swap_cgroup_id_xchg(map, offset, 0);\n@@ -119,12 +120,13 @@ unsigned short swap_cgroup_clear(swp_entry_t ent, unsigned int nr_ents)\n unsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n {\n \tstruct swap_cgroup_ctrl *ctrl;\n+\tswp_slot_t slot = swp_entry_to_swp_slot(ent);\n \n \tif (mem_cgroup_disabled())\n \t\treturn 0;\n \n-\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n-\treturn __swap_cgroup_id_lookup(ctrl->map, swp_offset(ent));\n+\tctrl = &swap_cgroup_ctrl[swp_slot_type(slot)];\n+\treturn __swap_cgroup_id_lookup(ctrl->map, swp_slot_offset(slot));\n }\n \n int swap_cgroup_swapon(int type, unsigned long max_pages)\ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex bece18eb540fa..e2e9f55bea3bb 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -421,7 +421,8 @@ struct folio *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \t\tstruct mempolicy *mpol, pgoff_t ilx, bool *new_page_allocated,\n \t\tbool skip_if_exists)\n {\n-\tstruct swap_info_struct *si = __swap_entry_to_info(entry);\n+\tstruct swap_info_struct *si =\n+\t\t__swap_slot_to_info(swp_entry_to_swp_slot(entry));\n \tstruct folio *folio;\n \tstruct folio *new_folio = NULL;\n \tstruct folio *result = NULL;\n@@ -636,11 +637,12 @@ struct folio *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n \t\t\t\t    struct mempolicy *mpol, pgoff_t ilx)\n {\n \tstruct folio *folio;\n-\tunsigned long entry_offset = swp_offset(entry);\n-\tunsigned long offset = entry_offset;\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tunsigned long slot_offset = swp_slot_offset(slot);\n+\tunsigned long offset = slot_offset;\n \tunsigned long start_offset, end_offset;\n \tunsigned long mask;\n-\tstruct swap_info_struct *si = __swap_entry_to_info(entry);\n+\tstruct swap_info_struct *si = __swap_slot_to_info(slot);\n \tstruct blk_plug plug;\n \tstruct swap_iocb *splug = NULL;\n \tbool page_allocated;\n@@ -661,13 +663,13 @@ struct folio *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n \tfor (offset = start_offset; offset <= end_offset ; offset++) {\n \t\t/* Ok, do the async read-ahead now */\n \t\tfolio = __read_swap_cache_async(\n-\t\t\t\tswp_entry(swp_type(entry), offset),\n+\t\t\t\tswp_slot_to_swp_entry(swp_slot(swp_slot_type(slot), offset)),\n \t\t\t\tgfp_mask, mpol, ilx, &page_allocated, false);\n \t\tif (!folio)\n \t\t\tcontinue;\n \t\tif (page_allocated) {\n \t\t\tswap_read_folio(folio, &splug);\n-\t\t\tif (offset != entry_offset) {\n+\t\t\tif (offset != slot_offset) {\n \t\t\t\tfolio_set_readahead(folio);\n \t\t\t\tcount_vm_event(SWAP_RA);\n \t\t\t}\n@@ -779,16 +781,20 @@ static struct folio *swap_vma_readahead(swp_entry_t targ_entry, gfp_t gfp_mask,\n \t\t/*\n \t\t * Readahead entry may come from a device that we are not\n \t\t * holding a reference to, try to grab a reference, or skip.\n+\t\t *\n+\t\t * XXX: for now, always try to pin the swap entries in the\n+\t\t * readahead window to avoid the annoying conversion to physical\n+\t\t * swap slots. Once we move all swap metadata to virtual swap\n+\t\t * layer, we can simply compare the clusters of the target\n+\t\t * swap entry and the current swap entry, and pin the latter\n+\t\t * swap entry's cluster if it differ from the former's.\n \t\t */\n-\t\tif (swp_type(entry) != swp_type(targ_entry)) {\n-\t\t\tswapoff_locked = tryget_swap_entry(entry, &si);\n-\t\t\tif (!swapoff_locked)\n-\t\t\t\tcontinue;\n-\t\t}\n+\t\tswapoff_locked = tryget_swap_entry(entry, &si);\n+\t\tif (!swapoff_locked)\n+\t\t\tcontinue;\n \t\tfolio = __read_swap_cache_async(entry, gfp_mask, mpol, ilx,\n \t\t\t\t\t\t&page_allocated, false);\n-\t\tif (swapoff_locked)\n-\t\t\tput_swap_entry(entry, si);\n+\t\tput_swap_entry(entry, si);\n \t\tif (!folio)\n \t\t\tcontinue;\n \t\tif (page_allocated) {\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 3c89dedbd5718..4b4126d4e2769 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -53,9 +53,9 @@\n static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n \t\t\t\t unsigned char);\n static void free_swap_count_continuations(struct swap_info_struct *);\n-static void swap_entries_free(struct swap_info_struct *si,\n+static void swap_slots_free(struct swap_info_struct *si,\n \t\t\t      struct swap_cluster_info *ci,\n-\t\t\t      swp_entry_t entry, unsigned int nr_pages);\n+\t\t\t      swp_slot_t slot, unsigned int nr_pages);\n static void swap_range_alloc(struct swap_info_struct *si,\n \t\t\t     unsigned int nr_entries);\n static bool folio_swapcache_freeable(struct folio *folio);\n@@ -126,7 +126,7 @@ struct percpu_swap_cluster {\n \n static DEFINE_PER_CPU(struct percpu_swap_cluster, percpu_swap_cluster) = {\n \t.si = { NULL },\n-\t.offset = { SWAP_ENTRY_INVALID },\n+\t.offset = { SWAP_SLOT_INVALID },\n \t.lock = INIT_LOCAL_LOCK(),\n };\n \n@@ -139,9 +139,9 @@ static struct swap_info_struct *swap_type_to_info(int type)\n }\n \n /* May return NULL on invalid entry, caller must check for NULL return */\n-static struct swap_info_struct *swap_entry_to_info(swp_entry_t entry)\n+static struct swap_info_struct *swap_slot_to_info(swp_slot_t slot)\n {\n-\treturn swap_type_to_info(swp_type(entry));\n+\treturn swap_type_to_info(swp_slot_type(slot));\n }\n \n static inline unsigned char swap_count(unsigned char ent)\n@@ -204,9 +204,11 @@ static bool swap_only_has_cache(struct swap_info_struct *si,\n  */\n bool is_swap_cached(swp_entry_t entry)\n {\n-\tstruct swap_info_struct *si = __swap_entry_to_info(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tstruct swap_info_struct *si = swap_slot_to_info(slot);\n+\tunsigned long offset = swp_slot_offset(slot);\n \n-\treturn READ_ONCE(si->swap_map[swp_offset(entry)]) & SWAP_HAS_CACHE;\n+\treturn READ_ONCE(si->swap_map[offset]) & SWAP_HAS_CACHE;\n }\n \n static bool swap_is_last_map(struct swap_info_struct *si,\n@@ -236,7 +238,9 @@ static bool swap_is_last_map(struct swap_info_struct *si,\n static int __try_to_reclaim_swap(struct swap_info_struct *si,\n \t\t\t\t unsigned long offset, unsigned long flags)\n {\n-\tconst swp_entry_t entry = swp_entry(si->type, offset);\n+\tconst swp_entry_t entry =\n+\t\tswp_slot_to_swp_entry(swp_slot(si->type, offset));\n+\tswp_slot_t slot;\n \tstruct swap_cluster_info *ci;\n \tstruct folio *folio;\n \tint ret, nr_pages;\n@@ -268,7 +272,8 @@ static int __try_to_reclaim_swap(struct swap_info_struct *si,\n \t\tfolio_put(folio);\n \t\tgoto again;\n \t}\n-\toffset = swp_offset(folio->swap);\n+\tslot = swp_entry_to_swp_slot(folio->swap);\n+\toffset = swp_slot_offset(slot);\n \n \tneed_reclaim = ((flags & TTRS_ANYWAY) ||\n \t\t\t((flags & TTRS_UNMAPPED) && !folio_mapped(folio)) ||\n@@ -368,12 +373,12 @@ offset_to_swap_extent(struct swap_info_struct *sis, unsigned long offset)\n \n sector_t swap_folio_sector(struct folio *folio)\n {\n-\tstruct swap_info_struct *sis = __swap_entry_to_info(folio->swap);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(folio->swap);\n+\tstruct swap_info_struct *sis = __swap_slot_to_info(slot);\n \tstruct swap_extent *se;\n \tsector_t sector;\n-\tpgoff_t offset;\n+\tpgoff_t offset = swp_slot_offset(slot);\n \n-\toffset = swp_offset(folio->swap);\n \tse = offset_to_swap_extent(sis, offset);\n \tsector = se->start_block + (offset - se->start_page);\n \treturn sector << (PAGE_SHIFT - 9);\n@@ -890,7 +895,7 @@ static unsigned int alloc_swap_scan_cluster(struct swap_info_struct *si,\n \t\t\t\t\t    unsigned int order,\n \t\t\t\t\t    unsigned char usage)\n {\n-\tunsigned int next = SWAP_ENTRY_INVALID, found = SWAP_ENTRY_INVALID;\n+\tunsigned int next = SWAP_SLOT_INVALID, found = SWAP_SLOT_INVALID;\n \tunsigned long start = ALIGN_DOWN(offset, SWAPFILE_CLUSTER);\n \tunsigned long end = min(start + SWAPFILE_CLUSTER, si->max);\n \tunsigned int nr_pages = 1 << order;\n@@ -947,7 +952,7 @@ static unsigned int alloc_swap_scan_list(struct swap_info_struct *si,\n \t\t\t\t\t unsigned char usage,\n \t\t\t\t\t bool scan_all)\n {\n-\tunsigned int found = SWAP_ENTRY_INVALID;\n+\tunsigned int found = SWAP_SLOT_INVALID;\n \n \tdo {\n \t\tstruct swap_cluster_info *ci = isolate_lock_cluster(si, list);\n@@ -1017,11 +1022,11 @@ static void swap_reclaim_work(struct work_struct *work)\n  * Try to allocate swap entries with specified order and try set a new\n  * cluster for current CPU too.\n  */\n-static unsigned long cluster_alloc_swap_entry(struct swap_info_struct *si, int order,\n+static unsigned long cluster_alloc_swap_slot(struct swap_info_struct *si, int order,\n \t\t\t\t\t      unsigned char usage)\n {\n \tstruct swap_cluster_info *ci;\n-\tunsigned int offset = SWAP_ENTRY_INVALID, found = SWAP_ENTRY_INVALID;\n+\tunsigned int offset = SWAP_SLOT_INVALID, found = SWAP_SLOT_INVALID;\n \n \t/*\n \t * Swapfile is not block device so unable\n@@ -1034,7 +1039,7 @@ static unsigned long cluster_alloc_swap_entry(struct swap_info_struct *si, int o\n \t\t/* Serialize HDD SWAP allocation for each device. */\n \t\tspin_lock(&si->global_cluster_lock);\n \t\toffset = si->global_cluster->next[order];\n-\t\tif (offset == SWAP_ENTRY_INVALID)\n+\t\tif (offset == SWAP_SLOT_INVALID)\n \t\t\tgoto new_cluster;\n \n \t\tci = swap_cluster_lock(si, offset);\n@@ -1255,7 +1260,7 @@ static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n \t */\n \tfor (i = 0; i < nr_entries; i++) {\n \t\tclear_bit(offset + i, si->zeromap);\n-\t\tzswap_invalidate(swp_entry(si->type, offset + i));\n+\t\tzswap_invalidate(swp_slot_to_swp_entry(swp_slot(si->type, offset + i)));\n \t}\n \n \tif (si->flags & SWP_BLKDEV)\n@@ -1300,12 +1305,11 @@ static bool get_swap_device_info(struct swap_info_struct *si)\n  * Fast path try to get swap entries with specified order from current\n  * CPU's swap entry pool (a cluster).\n  */\n-static bool swap_alloc_fast(swp_entry_t *entry,\n-\t\t\t    int order)\n+static bool swap_alloc_fast(swp_slot_t *slot, int order)\n {\n \tstruct swap_cluster_info *ci;\n \tstruct swap_info_struct *si;\n-\tunsigned int offset, found = SWAP_ENTRY_INVALID;\n+\tunsigned int offset, found = SWAP_SLOT_INVALID;\n \n \t/*\n \t * Once allocated, swap_info_struct will never be completely freed,\n@@ -1322,18 +1326,17 @@ static bool swap_alloc_fast(swp_entry_t *entry,\n \t\t\toffset = cluster_offset(si, ci);\n \t\tfound = alloc_swap_scan_cluster(si, ci, offset, order, SWAP_HAS_CACHE);\n \t\tif (found)\n-\t\t\t*entry = swp_entry(si->type, found);\n+\t\t\t*slot = swp_slot(si->type, found);\n \t} else {\n \t\tswap_cluster_unlock(ci);\n \t}\n \n-\tput_swap_device(si);\n+\tswap_slot_put_swap_info(si);\n \treturn !!found;\n }\n \n /* Rotate the device and switch to a new cluster */\n-static void swap_alloc_slow(swp_entry_t *entry,\n-\t\t\t    int order)\n+static void swap_alloc_slow(swp_slot_t *slot, int order)\n {\n \tunsigned long offset;\n \tstruct swap_info_struct *si, *next;\n@@ -1345,10 +1348,10 @@ static void swap_alloc_slow(swp_entry_t *entry,\n \t\tplist_requeue(&si->avail_list, &swap_avail_head);\n \t\tspin_unlock(&swap_avail_lock);\n \t\tif (get_swap_device_info(si)) {\n-\t\t\toffset = cluster_alloc_swap_entry(si, order, SWAP_HAS_CACHE);\n-\t\t\tput_swap_device(si);\n+\t\t\toffset = cluster_alloc_swap_slot(si, order, SWAP_HAS_CACHE);\n+\t\t\tswap_slot_put_swap_info(si);\n \t\t\tif (offset) {\n-\t\t\t\t*entry = swp_entry(si->type, offset);\n+\t\t\t\t*slot = swp_slot(si->type, offset);\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (order)\n@@ -1388,7 +1391,7 @@ static bool swap_sync_discard(void)\n \t\tif (get_swap_device_info(si)) {\n \t\t\tif (si->flags & SWP_PAGE_DISCARD)\n \t\t\t\tret = swap_do_scheduled_discard(si);\n-\t\t\tput_swap_device(si);\n+\t\t\tswap_slot_put_swap_info(si);\n \t\t}\n \t\tif (ret)\n \t\t\treturn true;\n@@ -1402,25 +1405,9 @@ static bool swap_sync_discard(void)\n \treturn false;\n }\n \n-/**\n- * folio_alloc_swap - allocate swap space for a folio\n- * @folio: folio we want to move to swap\n- *\n- * Allocate swap space for the folio and add the folio to the\n- * swap cache.\n- *\n- * Context: Caller needs to hold the folio lock.\n- * Return: Whether the folio was added to the swap cache.\n- */\n-int folio_alloc_swap(struct folio *folio)\n+static int swap_slot_alloc(swp_slot_t *slot, unsigned int order)\n {\n-\tunsigned int order = folio_order(folio);\n \tunsigned int size = 1 << order;\n-\tswp_entry_t entry = {};\n-\tint err;\n-\n-\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n-\tVM_BUG_ON_FOLIO(!folio_test_uptodate(folio), folio);\n \n \tif (order) {\n \t\t/*\n@@ -1442,22 +1429,52 @@ int folio_alloc_swap(struct folio *folio)\n \n again:\n \tlocal_lock(&percpu_swap_cluster.lock);\n-\tif (!swap_alloc_fast(&entry, order))\n-\t\tswap_alloc_slow(&entry, order);\n+\tif (!swap_alloc_fast(slot, order))\n+\t\tswap_alloc_slow(slot, order);\n \tlocal_unlock(&percpu_swap_cluster.lock);\n \n-\tif (unlikely(!order && !entry.val)) {\n+\tif (unlikely(!order && !slot->val)) {\n \t\tif (swap_sync_discard())\n \t\t\tgoto again;\n \t}\n \n+\treturn 0;\n+}\n+\n+/**\n+ * folio_alloc_swap - allocate swap space for a folio\n+ * @folio: folio we want to move to swap\n+ *\n+ * Allocate swap space for the folio and add the folio to the\n+ * swap cache.\n+ *\n+ * Context: Caller needs to hold the folio lock.\n+ * Return: Whether the folio was added to the swap cache.\n+ */\n+int folio_alloc_swap(struct folio *folio)\n+{\n+\tunsigned int order = folio_order(folio);\n+\tswp_slot_t slot = { 0 };\n+\tswp_entry_t entry = {};\n+\tint err = 0, ret;\n+\n+\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n+\tVM_BUG_ON_FOLIO(!folio_test_uptodate(folio), folio);\n+\n+\tret = swap_slot_alloc(&slot, order);\n+\tif (ret)\n+\t\treturn ret;\n+\n+\t/* XXX: for now, physical and virtual swap slots are identical */\n+\tentry.val = slot.val;\n+\n \t/* Need to call this even if allocation failed, for MEMCG_SWAP_FAIL. */\n \tif (mem_cgroup_try_charge_swap(folio, entry)) {\n \t\terr = -ENOMEM;\n \t\tgoto out_free;\n \t}\n \n-\tif (!entry.val)\n+\tif (!slot.val)\n \t\treturn -ENOMEM;\n \n \terr = swap_cache_add_folio(folio, entry, __GFP_HIGH | __GFP_NOMEMALLOC | __GFP_NOWARN, NULL);\n@@ -1471,46 +1488,46 @@ int folio_alloc_swap(struct folio *folio)\n \treturn err;\n }\n \n-static struct swap_info_struct *_swap_info_get(swp_entry_t entry)\n+static struct swap_info_struct *_swap_info_get(swp_slot_t slot)\n {\n \tstruct swap_info_struct *si;\n \tunsigned long offset;\n \n-\tif (!entry.val)\n+\tif (!slot.val)\n \t\tgoto out;\n-\tsi = swap_entry_to_info(entry);\n+\tsi = swap_slot_to_info(slot);\n \tif (!si)\n \t\tgoto bad_nofile;\n \tif (data_race(!(si->flags & SWP_USED)))\n \t\tgoto bad_device;\n-\toffset = swp_offset(entry);\n+\toffset = swp_slot_offset(slot);\n \tif (offset >= si->max)\n \t\tgoto bad_offset;\n-\tif (data_race(!si->swap_map[swp_offset(entry)]))\n+\tif (data_race(!si->swap_map[swp_slot_offset(slot)]))\n \t\tgoto bad_free;\n \treturn si;\n \n bad_free:\n-\tpr_err(\"%s: %s%08lx\\n\", __func__, Unused_offset, entry.val);\n+\tpr_err(\"%s: %s%08lx\\n\", __func__, Unused_offset, slot.val);\n \tgoto out;\n bad_offset:\n-\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_offset, entry.val);\n+\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_offset, slot.val);\n \tgoto out;\n bad_device:\n-\tpr_err(\"%s: %s%08lx\\n\", __func__, Unused_file, entry.val);\n+\tpr_err(\"%s: %s%08lx\\n\", __func__, Unused_file, slot.val);\n \tgoto out;\n bad_nofile:\n-\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_file, entry.val);\n+\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_file, slot.val);\n out:\n \treturn NULL;\n }\n \n-static unsigned char swap_entry_put_locked(struct swap_info_struct *si,\n+static unsigned char swap_slot_put_locked(struct swap_info_struct *si,\n \t\t\t\t\t   struct swap_cluster_info *ci,\n-\t\t\t\t\t   swp_entry_t entry,\n+\t\t\t\t\t   swp_slot_t slot,\n \t\t\t\t\t   unsigned char usage)\n {\n-\tunsigned long offset = swp_offset(entry);\n+\tunsigned long offset = swp_slot_offset(slot);\n \tunsigned char count;\n \tunsigned char has_cache;\n \n@@ -1542,7 +1559,7 @@ static unsigned char swap_entry_put_locked(struct swap_info_struct *si,\n \tif (usage)\n \t\tWRITE_ONCE(si->swap_map[offset], usage);\n \telse\n-\t\tswap_entries_free(si, ci, entry, 1);\n+\t\tswap_slots_free(si, ci, slot, 1);\n \n \treturn usage;\n }\n@@ -1552,8 +1569,9 @@ static unsigned char swap_entry_put_locked(struct swap_info_struct *si,\n  * prevent swapoff, such as the folio in swap cache is locked, RCU\n  * reader side is locked, etc., the swap entry may become invalid\n  * because of swapoff.  Then, we need to enclose all swap related\n- * functions with get_swap_device() and put_swap_device(), unless the\n- * swap functions call get/put_swap_device() by themselves.\n+ * functions with swap_slot_tryget_swap_info() and\n+ * swap_slot_put_swap_info(), unless the swap functions call\n+ * swap_slot_(tryget|put)_swap_info by themselves.\n  *\n  * RCU reader side lock (including any spinlock) is sufficient to\n  * prevent swapoff, because synchronize_rcu() is called in swapoff()\n@@ -1562,11 +1580,11 @@ static unsigned char swap_entry_put_locked(struct swap_info_struct *si,\n  * Check whether swap entry is valid in the swap device.  If so,\n  * return pointer to swap_info_struct, and keep the swap entry valid\n  * via preventing the swap device from being swapoff, until\n- * put_swap_device() is called.  Otherwise return NULL.\n+ * swap_slot_put_swap_info() is called.  Otherwise return NULL.\n  *\n  * Notice that swapoff or swapoff+swapon can still happen before the\n- * percpu_ref_tryget_live() in get_swap_device() or after the\n- * percpu_ref_put() in put_swap_device() if there isn't any other way\n+ * percpu_ref_tryget_live() in swap_slot_tryget_swap_info() or after the\n+ * percpu_ref_put() in swap_slot_put_swap_info() if there isn't any other way\n  * to prevent swapoff.  The caller must be prepared for that.  For\n  * example, the following situation is possible.\n  *\n@@ -1586,53 +1604,53 @@ static unsigned char swap_entry_put_locked(struct swap_info_struct *si,\n  * changed with the page table locked to check whether the swap device\n  * has been swapoff or swapoff+swapon.\n  */\n-struct swap_info_struct *get_swap_device(swp_entry_t entry)\n+struct swap_info_struct *swap_slot_tryget_swap_info(swp_slot_t slot)\n {\n \tstruct swap_info_struct *si;\n \tunsigned long offset;\n \n-\tif (!entry.val)\n+\tif (!slot.val)\n \t\tgoto out;\n-\tsi = swap_entry_to_info(entry);\n+\tsi = swap_slot_to_info(slot);\n \tif (!si)\n \t\tgoto bad_nofile;\n \tif (!get_swap_device_info(si))\n \t\tgoto out;\n-\toffset = swp_offset(entry);\n+\toffset = swp_slot_offset(slot);\n \tif (offset >= si->max)\n \t\tgoto put_out;\n \n \treturn si;\n bad_nofile:\n-\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_file, entry.val);\n+\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_file, slot.val);\n out:\n \treturn NULL;\n put_out:\n-\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_offset, entry.val);\n+\tpr_err(\"%s: %s%08lx\\n\", __func__, Bad_offset, slot.val);\n \tpercpu_ref_put(&si->users);\n \treturn NULL;\n }\n \n-static void swap_entries_put_cache(struct swap_info_struct *si,\n-\t\t\t\t   swp_entry_t entry, int nr)\n+static void swap_slots_put_cache(struct swap_info_struct *si,\n+\t\t\t\t   swp_slot_t slot, int nr)\n {\n-\tunsigned long offset = swp_offset(entry);\n+\tunsigned long offset = swp_slot_offset(slot);\n \tstruct swap_cluster_info *ci;\n \n \tci = swap_cluster_lock(si, offset);\n \tif (swap_only_has_cache(si, offset, nr)) {\n-\t\tswap_entries_free(si, ci, entry, nr);\n+\t\tswap_slots_free(si, ci, slot, nr);\n \t} else {\n-\t\tfor (int i = 0; i < nr; i++, entry.val++)\n-\t\t\tswap_entry_put_locked(si, ci, entry, SWAP_HAS_CACHE);\n+\t\tfor (int i = 0; i < nr; i++, slot.val++)\n+\t\t\tswap_slot_put_locked(si, ci, slot, SWAP_HAS_CACHE);\n \t}\n \tswap_cluster_unlock(ci);\n }\n \n-static bool swap_entries_put_map(struct swap_info_struct *si,\n-\t\t\t\t swp_entry_t entry, int nr)\n+static bool swap_slots_put_map(struct swap_info_struct *si,\n+\t\t\t\t swp_slot_t slot, int nr)\n {\n-\tunsigned long offset = swp_offset(entry);\n+\tunsigned long offset = swp_slot_offset(slot);\n \tstruct swap_cluster_info *ci;\n \tbool has_cache = false;\n \tunsigned char count;\n@@ -1649,7 +1667,7 @@ static bool swap_entries_put_map(struct swap_info_struct *si,\n \t\tgoto locked_fallback;\n \t}\n \tif (!has_cache)\n-\t\tswap_entries_free(si, ci, entry, nr);\n+\t\tswap_slots_free(si, ci, slot, nr);\n \telse\n \t\tfor (i = 0; i < nr; i++)\n \t\t\tWRITE_ONCE(si->swap_map[offset + i], SWAP_HAS_CACHE);\n@@ -1660,8 +1678,8 @@ static bool swap_entries_put_map(struct swap_info_struct *si,\n fallback:\n \tci = swap_cluster_lock(si, offset);\n locked_fallback:\n-\tfor (i = 0; i < nr; i++, entry.val++) {\n-\t\tcount = swap_entry_put_locked(si, ci, entry, 1);\n+\tfor (i = 0; i < nr; i++, slot.val++) {\n+\t\tcount = swap_slot_put_locked(si, ci, slot, 1);\n \t\tif (count == SWAP_HAS_CACHE)\n \t\t\thas_cache = true;\n \t}\n@@ -1674,20 +1692,20 @@ static bool swap_entries_put_map(struct swap_info_struct *si,\n  * cross multi clusters, so ensure the range is within a single cluster\n  * when freeing entries with functions without \"_nr\" suffix.\n  */\n-static bool swap_entries_put_map_nr(struct swap_info_struct *si,\n-\t\t\t\t    swp_entry_t entry, int nr)\n+static bool swap_slots_put_map_nr(struct swap_info_struct *si,\n+\t\t\t\t    swp_slot_t slot, int nr)\n {\n \tint cluster_nr, cluster_rest;\n-\tunsigned long offset = swp_offset(entry);\n+\tunsigned long offset = swp_slot_offset(slot);\n \tbool has_cache = false;\n \n \tcluster_rest = SWAPFILE_CLUSTER - offset % SWAPFILE_CLUSTER;\n \twhile (nr) {\n \t\tcluster_nr = min(nr, cluster_rest);\n-\t\thas_cache |= swap_entries_put_map(si, entry, cluster_nr);\n+\t\thas_cache |= swap_slots_put_map(si, slot, cluster_nr);\n \t\tcluster_rest = SWAPFILE_CLUSTER;\n \t\tnr -= cluster_nr;\n-\t\tentry.val += cluster_nr;\n+\t\tslot.val += cluster_nr;\n \t}\n \n \treturn has_cache;\n@@ -1707,13 +1725,14 @@ static inline bool __maybe_unused swap_is_last_ref(unsigned char count)\n  * Drop the last ref of swap entries, caller have to ensure all entries\n  * belong to the same cgroup and cluster.\n  */\n-static void swap_entries_free(struct swap_info_struct *si,\n+static void swap_slots_free(struct swap_info_struct *si,\n \t\t\t      struct swap_cluster_info *ci,\n-\t\t\t      swp_entry_t entry, unsigned int nr_pages)\n+\t\t\t      swp_slot_t slot, unsigned int nr_pages)\n {\n-\tunsigned long offset = swp_offset(entry);\n+\tunsigned long offset = swp_slot_offset(slot);\n \tunsigned char *map = si->swap_map + offset;\n \tunsigned char *map_end = map + nr_pages;\n+\tswp_entry_t entry = swp_slot_to_swp_entry(slot);\n \n \t/* It should never free entries across different clusters */\n \tVM_BUG_ON(ci != __swap_offset_to_cluster(si, offset + nr_pages - 1));\n@@ -1739,43 +1758,54 @@ static void swap_entries_free(struct swap_info_struct *si,\n  * Caller has made sure that the swap device corresponding to entry\n  * is still around or has not been recycled.\n  */\n-void swap_free_nr(swp_entry_t entry, int nr_pages)\n+void swap_slot_free_nr(swp_slot_t slot, int nr_pages)\n {\n \tint nr;\n \tstruct swap_info_struct *sis;\n-\tunsigned long offset = swp_offset(entry);\n+\tunsigned long offset = swp_slot_offset(slot);\n \n-\tsis = _swap_info_get(entry);\n+\tsis = _swap_info_get(slot);\n \tif (!sis)\n \t\treturn;\n \n \twhile (nr_pages) {\n \t\tnr = min_t(int, nr_pages, SWAPFILE_CLUSTER - offset % SWAPFILE_CLUSTER);\n-\t\tswap_entries_put_map(sis, swp_entry(sis->type, offset), nr);\n+\t\tswap_slots_put_map(sis, swp_slot(sis->type, offset), nr);\n \t\toffset += nr;\n \t\tnr_pages -= nr;\n \t}\n }\n \n+/*\n+ * Caller has made sure that the swap device corresponding to entry\n+ * is still around or has not been recycled.\n+ */\n+void swap_free_nr(swp_entry_t entry, int nr_pages)\n+{\n+\tswap_slot_free_nr(swp_entry_to_swp_slot(entry), nr_pages);\n+}\n+\n /*\n  * Called after dropping swapcache to decrease refcnt to swap entries.\n  */\n void put_swap_folio(struct folio *folio, swp_entry_t entry)\n {\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n \tstruct swap_info_struct *si;\n-\tint size = 1 << swap_entry_order(folio_order(folio));\n+\tint size = 1 << swap_slot_order(folio_order(folio));\n \n-\tsi = _swap_info_get(entry);\n+\tsi = _swap_info_get(slot);\n \tif (!si)\n \t\treturn;\n \n-\tswap_entries_put_cache(si, entry, size);\n+\tswap_slots_put_cache(si, slot, size);\n }\n \n int __swap_count(swp_entry_t entry)\n {\n-\tstruct swap_info_struct *si = __swap_entry_to_info(entry);\n-\tpgoff_t offset = swp_offset(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tstruct swap_info_struct *si = __swap_slot_to_info(slot);\n+\tpgoff_t offset = swp_slot_offset(slot);\n \n \treturn swap_count(si->swap_map[offset]);\n }\n@@ -1787,7 +1817,8 @@ int __swap_count(swp_entry_t entry)\n  */\n bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry)\n {\n-\tpgoff_t offset = swp_offset(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tpgoff_t offset = swp_slot_offset(slot);\n \tstruct swap_cluster_info *ci;\n \tint count;\n \n@@ -1803,6 +1834,7 @@ bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry)\n  */\n int swp_swapcount(swp_entry_t entry)\n {\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n \tint count, tmp_count, n;\n \tstruct swap_info_struct *si;\n \tstruct swap_cluster_info *ci;\n@@ -1810,11 +1842,11 @@ int swp_swapcount(swp_entry_t entry)\n \tpgoff_t offset;\n \tunsigned char *map;\n \n-\tsi = _swap_info_get(entry);\n+\tsi = _swap_info_get(slot);\n \tif (!si)\n \t\treturn 0;\n \n-\toffset = swp_offset(entry);\n+\toffset = swp_slot_offset(slot);\n \n \tci = swap_cluster_lock(si, offset);\n \n@@ -1846,10 +1878,11 @@ int swp_swapcount(swp_entry_t entry)\n static bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n \t\t\t\t\t swp_entry_t entry, int order)\n {\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n \tstruct swap_cluster_info *ci;\n \tunsigned char *map = si->swap_map;\n \tunsigned int nr_pages = 1 << order;\n-\tunsigned long roffset = swp_offset(entry);\n+\tunsigned long roffset = swp_slot_offset(slot);\n \tunsigned long offset = round_down(roffset, nr_pages);\n \tint i;\n \tbool ret = false;\n@@ -1874,7 +1907,8 @@ static bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n static bool folio_swapped(struct folio *folio)\n {\n \tswp_entry_t entry = folio->swap;\n-\tstruct swap_info_struct *si = _swap_info_get(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tstruct swap_info_struct *si = _swap_info_get(slot);\n \n \tif (!si)\n \t\treturn false;\n@@ -1948,13 +1982,14 @@ bool folio_free_swap(struct folio *folio)\n  */\n void free_swap_and_cache_nr(swp_entry_t entry, int nr)\n {\n-\tconst unsigned long start_offset = swp_offset(entry);\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\tconst unsigned long start_offset = swp_slot_offset(slot);\n \tconst unsigned long end_offset = start_offset + nr;\n \tstruct swap_info_struct *si;\n \tbool any_only_cache = false;\n \tunsigned long offset;\n \n-\tsi = get_swap_device(entry);\n+\tsi = swap_slot_tryget_swap_info(slot);\n \tif (!si)\n \t\treturn;\n \n@@ -1964,7 +1999,7 @@ void free_swap_and_cache_nr(swp_entry_t entry, int nr)\n \t/*\n \t * First free all entries in the range.\n \t */\n-\tany_only_cache = swap_entries_put_map_nr(si, entry, nr);\n+\tany_only_cache = swap_slots_put_map_nr(si, slot, nr);\n \n \t/*\n \t * Short-circuit the below loop if none of the entries had their\n@@ -1998,16 +2033,16 @@ void free_swap_and_cache_nr(swp_entry_t entry, int nr)\n \t}\n \n out:\n-\tput_swap_device(si);\n+\tswap_slot_put_swap_info(si);\n }\n \n #ifdef CONFIG_HIBERNATION\n \n-swp_entry_t get_swap_page_of_type(int type)\n+swp_slot_t swap_slot_alloc_of_type(int type)\n {\n \tstruct swap_info_struct *si = swap_type_to_info(type);\n \tunsigned long offset;\n-\tswp_entry_t entry = {0};\n+\tswp_slot_t slot = {0};\n \n \tif (!si)\n \t\tgoto fail;\n@@ -2020,15 +2055,15 @@ swp_entry_t get_swap_page_of_type(int type)\n \t\t\t * with swap table allocation.\n \t\t\t */\n \t\t\tlocal_lock(&percpu_swap_cluster.lock);\n-\t\t\toffset = cluster_alloc_swap_entry(si, 0, 1);\n+\t\t\toffset = cluster_alloc_swap_slot(si, 0, 1);\n \t\t\tlocal_unlock(&percpu_swap_cluster.lock);\n \t\t\tif (offset)\n-\t\t\t\tentry = swp_entry(si->type, offset);\n+\t\t\t\tslot = swp_slot(si->type, offset);\n \t\t}\n-\t\tput_swap_device(si);\n+\t\tswap_slot_put_swap_info(si);\n \t}\n fail:\n-\treturn entry;\n+\treturn slot;\n }\n \n /*\n@@ -2257,6 +2292,7 @@ static int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n \t\tunsigned long offset;\n \t\tunsigned char swp_count;\n \t\tsoftleaf_t entry;\n+\t\tswp_slot_t slot;\n \t\tint ret;\n \t\tpte_t ptent;\n \n@@ -2271,10 +2307,12 @@ static int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n \n \t\tif (!softleaf_is_swap(entry))\n \t\t\tcontinue;\n-\t\tif (swp_type(entry) != type)\n+\n+\t\tslot = swp_entry_to_swp_slot(entry);\n+\t\tif (swp_slot_type(slot) != type)\n \t\t\tcontinue;\n \n-\t\toffset = swp_offset(entry);\n+\t\toffset = swp_slot_offset(slot);\n \t\tpte_unmap(pte);\n \t\tpte = NULL;\n \n@@ -2459,6 +2497,7 @@ static int try_to_unuse(unsigned int type)\n \tstruct swap_info_struct *si = swap_info[type];\n \tstruct folio *folio;\n \tswp_entry_t entry;\n+\tswp_slot_t slot;\n \tunsigned int i;\n \n \tif (!swap_usage_in_pages(si))\n@@ -2506,7 +2545,8 @@ static int try_to_unuse(unsigned int type)\n \t       !signal_pending(current) &&\n \t       (i = find_next_to_unuse(si, i)) != 0) {\n \n-\t\tentry = swp_entry(type, i);\n+\t\tslot = swp_slot(type, i);\n+\t\tentry = swp_slot_to_swp_entry(slot);\n \t\tfolio = swap_cache_get_folio(entry);\n \t\tif (!folio)\n \t\t\tcontinue;\n@@ -2890,7 +2930,7 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \t}\n \n \t/*\n-\t * Wait for swap operations protected by get/put_swap_device()\n+\t * Wait for swap operations protected by swap_slot_(tryget|put)_swap_info()\n \t * to complete.  Because of synchronize_rcu() here, all swap\n \t * operations protected by RCU reader side lock (including any\n \t * spinlock) will be waited too.  This makes it easy to\n@@ -3331,7 +3371,7 @@ static struct swap_cluster_info *setup_clusters(struct swap_info_struct *si,\n \t\tif (!si->global_cluster)\n \t\t\tgoto err;\n \t\tfor (i = 0; i < SWAP_NR_ORDERS; i++)\n-\t\t\tsi->global_cluster->next[i] = SWAP_ENTRY_INVALID;\n+\t\t\tsi->global_cluster->next[i] = SWAP_SLOT_INVALID;\n \t\tspin_lock_init(&si->global_cluster_lock);\n \t}\n \n@@ -3669,6 +3709,7 @@ void si_swapinfo(struct sysinfo *val)\n  */\n static int __swap_duplicate(swp_entry_t entry, unsigned char usage, int nr)\n {\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n \tstruct swap_info_struct *si;\n \tstruct swap_cluster_info *ci;\n \tunsigned long offset;\n@@ -3676,13 +3717,13 @@ static int __swap_duplicate(swp_entry_t entry, unsigned char usage, int nr)\n \tunsigned char has_cache;\n \tint err, i;\n \n-\tsi = swap_entry_to_info(entry);\n+\tsi = swap_slot_to_info(slot);\n \tif (WARN_ON_ONCE(!si)) {\n \t\tpr_err(\"%s%08lx\\n\", Bad_file, entry.val);\n \t\treturn -EINVAL;\n \t}\n \n-\toffset = swp_offset(entry);\n+\toffset = swp_slot_offset(slot);\n \tVM_WARN_ON(nr > SWAPFILE_CLUSTER - offset % SWAPFILE_CLUSTER);\n \tVM_WARN_ON(usage == 1 && nr > 1);\n \tci = swap_cluster_lock(si, offset);\n@@ -3788,7 +3829,7 @@ int swapcache_prepare(swp_entry_t entry, int nr)\n  */\n void swapcache_clear(struct swap_info_struct *si, swp_entry_t entry, int nr)\n {\n-\tswap_entries_put_cache(si, entry, nr);\n+\tswap_slots_put_cache(si, swp_entry_to_swp_slot(entry), nr);\n }\n \n /*\n@@ -3815,6 +3856,7 @@ int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n \tstruct page *list_page;\n \tpgoff_t offset;\n \tunsigned char count;\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n \tint ret = 0;\n \n \t/*\n@@ -3823,7 +3865,7 @@ int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n \t */\n \tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n \n-\tsi = get_swap_device(entry);\n+\tsi = swap_slot_tryget_swap_info(slot);\n \tif (!si) {\n \t\t/*\n \t\t * An acceptable race has occurred since the failing\n@@ -3832,7 +3874,7 @@ int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n \t\tgoto outer;\n \t}\n \n-\toffset = swp_offset(entry);\n+\toffset = swp_slot_offset(slot);\n \n \tci = swap_cluster_lock(si, offset);\n \n@@ -3895,7 +3937,7 @@ int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n \tspin_unlock(&si->cont_lock);\n out:\n \tswap_cluster_unlock(ci);\n-\tput_swap_device(si);\n+\tswap_slot_put_swap_info(si);\n outer:\n \tif (page)\n \t\t__free_page(page);\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author acknowledged that the zswap tree code's range partition logic can no longer be reused for the new virtual swap space design and decided to use a simple unified zswap tree in the new implementation.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged",
            "decided"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "The zswap tree code, specifically the range partition logic, can no\nlonger easily be reused for the new virtual swap space design. Use a\nsimple unified zswap tree in the new implementation for now.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/zswap.h |  7 -----\n mm/swapfile.c         |  9 +-----\n mm/zswap.c            | 69 +++++++------------------------------------\n 3 files changed, 11 insertions(+), 74 deletions(-)\n\ndiff --git a/include/linux/zswap.h b/include/linux/zswap.h\nindex 30c193a1207e1..1a04caf283dc8 100644\n--- a/include/linux/zswap.h\n+++ b/include/linux/zswap.h\n@@ -28,8 +28,6 @@ unsigned long zswap_total_pages(void);\n bool zswap_store(struct folio *folio);\n int zswap_load(struct folio *folio);\n void zswap_invalidate(swp_entry_t swp);\n-int zswap_swapon(int type, unsigned long nr_pages);\n-void zswap_swapoff(int type);\n void zswap_memcg_offline_cleanup(struct mem_cgroup *memcg);\n void zswap_lruvec_state_init(struct lruvec *lruvec);\n void zswap_folio_swapin(struct folio *folio);\n@@ -50,11 +48,6 @@ static inline int zswap_load(struct folio *folio)\n }\n \n static inline void zswap_invalidate(swp_entry_t swp) {}\n-static inline int zswap_swapon(int type, unsigned long nr_pages)\n-{\n-\treturn 0;\n-}\n-static inline void zswap_swapoff(int type) {}\n static inline void zswap_memcg_offline_cleanup(struct mem_cgroup *memcg) {}\n static inline void zswap_lruvec_state_init(struct lruvec *lruvec) {}\n static inline void zswap_folio_swapin(struct folio *folio) {}\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 4b4126d4e2769..3f70df488c1da 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -2970,7 +2970,6 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \tspin_unlock(&p->lock);\n \tspin_unlock(&swap_lock);\n \tarch_swap_invalidate_area(p->type);\n-\tzswap_swapoff(p->type);\n \tmutex_unlock(&swapon_mutex);\n \tkfree(p->global_cluster);\n \tp->global_cluster = NULL;\n@@ -3613,10 +3612,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \t\t}\n \t}\n \n-\terror = zswap_swapon(si->type, maxpages);\n-\tif (error)\n-\t\tgoto bad_swap_unlock_inode;\n-\n \t/*\n \t * Flush any pending IO and dirty mappings before we start using this\n \t * swap device.\n@@ -3625,7 +3620,7 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \terror = inode_drain_writes(inode);\n \tif (error) {\n \t\tinode->i_flags &= ~S_SWAPFILE;\n-\t\tgoto free_swap_zswap;\n+\t\tgoto bad_swap_unlock_inode;\n \t}\n \n \tmutex_lock(&swapon_mutex);\n@@ -3648,8 +3643,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \n \terror = 0;\n \tgoto out;\n-free_swap_zswap:\n-\tzswap_swapoff(si->type);\n bad_swap_unlock_inode:\n \tinode_unlock(inode);\n bad_swap:\ndiff --git a/mm/zswap.c b/mm/zswap.c\nindex a5a3f068bd1a6..f7313261673ff 100644\n--- a/mm/zswap.c\n+++ b/mm/zswap.c\n@@ -197,8 +197,6 @@ struct zswap_entry {\n \tstruct list_head lru;\n };\n \n-static struct xarray *zswap_trees[MAX_SWAPFILES];\n-static unsigned int nr_zswap_trees[MAX_SWAPFILES];\n \n /* RCU-protected iteration */\n static LIST_HEAD(zswap_pools);\n@@ -225,45 +223,35 @@ static bool zswap_has_pool;\n * helpers and fwd declarations\n **********************************/\n \n-/* One swap address space for each 64M swap space */\n-#define ZSWAP_ADDRESS_SPACE_SHIFT 14\n-#define ZSWAP_ADDRESS_SPACE_PAGES (1 << ZSWAP_ADDRESS_SPACE_SHIFT)\n-static inline struct xarray *swap_zswap_tree(swp_entry_t swp)\n-{\n-\treturn &zswap_trees[swp_type(swp)][swp_offset(swp)\n-\t\t>> ZSWAP_ADDRESS_SPACE_SHIFT];\n-}\n+static DEFINE_XARRAY(zswap_tree);\n+\n+#define zswap_tree_index(entry)\t(entry.val)\n \n static inline void *zswap_entry_store(swp_entry_t swpentry,\n \t\tstruct zswap_entry *entry)\n {\n-\tstruct xarray *tree = swap_zswap_tree(swpentry);\n-\tpgoff_t offset = swp_offset(swpentry);\n+\tpgoff_t offset = zswap_tree_index(swpentry);\n \n-\treturn xa_store(tree, offset, entry, GFP_KERNEL);\n+\treturn xa_store(&zswap_tree, offset, entry, GFP_KERNEL);\n }\n \n static inline void *zswap_entry_load(swp_entry_t swpentry)\n {\n-\tstruct xarray *tree = swap_zswap_tree(swpentry);\n-\tpgoff_t offset = swp_offset(swpentry);\n+\tpgoff_t offset = zswap_tree_index(swpentry);\n \n-\treturn xa_load(tree, offset);\n+\treturn xa_load(&zswap_tree, offset);\n }\n \n static inline void *zswap_entry_erase(swp_entry_t swpentry)\n {\n-\tstruct xarray *tree = swap_zswap_tree(swpentry);\n-\tpgoff_t offset = swp_offset(swpentry);\n+\tpgoff_t offset = zswap_tree_index(swpentry);\n \n-\treturn xa_erase(tree, offset);\n+\treturn xa_erase(&zswap_tree, offset);\n }\n \n static inline bool zswap_empty(swp_entry_t swpentry)\n {\n-\tstruct xarray *tree = swap_zswap_tree(swpentry);\n-\n-\treturn xa_empty(tree);\n+\treturn xa_empty(&zswap_tree);\n }\n \n #define zswap_pool_debug(msg, p)\t\t\t\\\n@@ -1691,43 +1679,6 @@ void zswap_invalidate(swp_entry_t swp)\n \t\tzswap_entry_free(entry);\n }\n \n-int zswap_swapon(int type, unsigned long nr_pages)\n-{\n-\tstruct xarray *trees, *tree;\n-\tunsigned int nr, i;\n-\n-\tnr = DIV_ROUND_UP(nr_pages, ZSWAP_ADDRESS_SPACE_PAGES);\n-\ttrees = kvcalloc(nr, sizeof(*tree), GFP_KERNEL);\n-\tif (!trees) {\n-\t\tpr_err(\"alloc failed, zswap disabled for swap type %d\\n\", type);\n-\t\treturn -ENOMEM;\n-\t}\n-\n-\tfor (i = 0; i < nr; i++)\n-\t\txa_init(trees + i);\n-\n-\tnr_zswap_trees[type] = nr;\n-\tzswap_trees[type] = trees;\n-\treturn 0;\n-}\n-\n-void zswap_swapoff(int type)\n-{\n-\tstruct xarray *trees = zswap_trees[type];\n-\tunsigned int i;\n-\n-\tif (!trees)\n-\t\treturn;\n-\n-\t/* try_to_unuse() invalidated all the entries already */\n-\tfor (i = 0; i < nr_zswap_trees[type]; i++)\n-\t\tWARN_ON_ONCE(!xa_empty(trees + i));\n-\n-\tkvfree(trees);\n-\tnr_zswap_trees[type] = 0;\n-\tzswap_trees[type] = NULL;\n-}\n-\n /*********************************\n * debugfs functions\n **********************************/\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the vswap free path's poor batching behavior, explaining that they changed the freeing ordering to clear the shadow, invalidate the zswap entry, and uncharge swap cgroup when releasing the virtual swap slot.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "For the new virtual swap space design, dynamically allocate a virtual\nslot (as well as an associated metadata structure) for each swapped out\npage, and associate it to the (physical) swap slot on the swapfile/swap\npartition. This virtual swap slot is now stored in page table entries\nand used to index into swap data structures (swap cache, zswap tree,\nswap cgroup array), in place of the old physical swap slot.\n\nFor now, there is always a physical slot in the swapfile associated for\neach virtual swap slot (except those about to be freed). The virtual\nswap slot's lifetime is still tied to the lifetime of its physical swap\nslot. We do change the freeing ordering a bit - we clear the shadow,\ninvalidate the zswap entry, and uncharge swap cgroup when we release the\nvirtual swap slot, as we now use virtual swap slot to index into these\nswap data structures.\n\nWe also repurpose the swap table infrastructure as a reverse map to look\nup the virtual swap slot from its associated physical swap slot on\nswapfile. This is used in cluster readahead, as well as several swapfile\noperations, such as the swap slot reclamation that happens when the\nswapfile is almost full.  It will also be used in a future patch that\nsimplifies swapoff.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/cpuhotplug.h |   1 +\n include/linux/swap.h       |  49 +--\n mm/internal.h              |  28 +-\n mm/page_io.c               |   6 +-\n mm/shmem.c                 |   9 +-\n mm/swap.h                  |   8 +-\n mm/swap_state.c            |   5 +-\n mm/swapfile.c              |  63 +---\n mm/vswap.c                 | 658 +++++++++++++++++++++++++++++++++++++\n 9 files changed, 710 insertions(+), 117 deletions(-)\n\ndiff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h\nindex 62cd7b35a29c9..85cb45022e796 100644\n--- a/include/linux/cpuhotplug.h\n+++ b/include/linux/cpuhotplug.h\n@@ -86,6 +86,7 @@ enum cpuhp_state {\n \tCPUHP_FS_BUFF_DEAD,\n \tCPUHP_PRINTK_DEAD,\n \tCPUHP_MM_MEMCQ_DEAD,\n+\tCPUHP_MM_VSWAP_DEAD,\n \tCPUHP_PERCPU_CNT_DEAD,\n \tCPUHP_RADIX_DEAD,\n \tCPUHP_PAGE_ALLOC,\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex 1ff463fb3a966..0410a00fd353c 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -471,6 +471,7 @@ static inline long get_nr_swap_pages(void)\n }\n \n void si_swapinfo(struct sysinfo *);\n+int swap_slot_alloc(swp_slot_t *slot, unsigned int order);\n swp_slot_t swap_slot_alloc_of_type(int);\n int add_swap_count_continuation(swp_entry_t, gfp_t);\n int swap_type_of(dev_t device, sector_t offset);\n@@ -670,48 +671,12 @@ static inline bool mem_cgroup_swap_full(struct folio *folio)\n #endif\n \n int vswap_init(void);\n-\n-/**\n- * swp_entry_to_swp_slot - look up the physical swap slot corresponding to a\n- *                         virtual swap slot.\n- * @entry: the virtual swap slot.\n- *\n- * Return: the physical swap slot corresponding to the virtual swap slot.\n- */\n-static inline swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry)\n-{\n-\treturn (swp_slot_t) { entry.val };\n-}\n-\n-/**\n- * swp_slot_to_swp_entry - look up the virtual swap slot corresponding to a\n- *                         physical swap slot.\n- * @slot: the physical swap slot.\n- *\n- * Return: the virtual swap slot corresponding to the physical swap slot.\n- */\n-static inline swp_entry_t swp_slot_to_swp_entry(swp_slot_t slot)\n-{\n-\treturn (swp_entry_t) { slot.val };\n-}\n-\n-static inline bool tryget_swap_entry(swp_entry_t entry,\n-\t\t\t\tstruct swap_info_struct **sip)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *si = swap_slot_tryget_swap_info(slot);\n-\n-\tif (sip)\n-\t\t*sip = si;\n-\n-\treturn si;\n-}\n-\n-static inline void put_swap_entry(swp_entry_t entry,\n-\t\t\t\tstruct swap_info_struct *si)\n-{\n-\tswap_slot_put_swap_info(si);\n-}\n+void vswap_exit(void);\n+void vswap_free(swp_entry_t entry, struct swap_cluster_info *ci);\n+swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry);\n+swp_entry_t swp_slot_to_swp_entry(swp_slot_t slot);\n+bool tryget_swap_entry(swp_entry_t entry, struct swap_info_struct **si);\n+void put_swap_entry(swp_entry_t entry, struct swap_info_struct *si);\n \n #endif /* __KERNEL__*/\n #endif /* _LINUX_SWAP_H */\ndiff --git a/mm/internal.h b/mm/internal.h\nindex e739e8cac5b55..7ced0def684ca 100644\n--- a/mm/internal.h\n+++ b/mm/internal.h\n@@ -322,6 +322,25 @@ static inline unsigned int folio_pte_batch_flags(struct folio *folio,\n unsigned int folio_pte_batch(struct folio *folio, pte_t *ptep, pte_t pte,\n \t\tunsigned int max_nr);\n \n+static inline swp_entry_t swap_nth(swp_entry_t entry, long n)\n+{\n+\treturn (swp_entry_t) { entry.val + n };\n+}\n+\n+/* similar to swap_nth, but check the backing physical slots as well. */\n+static inline swp_entry_t swap_move(swp_entry_t entry, long delta)\n+{\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry), next_slot;\n+\tswp_entry_t next_entry = swap_nth(entry, delta);\n+\n+\tnext_slot = swp_entry_to_swp_slot(next_entry);\n+\tif (swp_slot_type(slot) != swp_slot_type(next_slot) ||\n+\t\t\tswp_slot_offset(slot) + delta != swp_slot_offset(next_slot))\n+\t\tnext_entry.val = 0;\n+\n+\treturn next_entry;\n+}\n+\n /**\n  * pte_move_swp_offset - Move the swap entry offset field of a swap pte\n  *\t forward or backward by delta\n@@ -334,13 +353,8 @@ unsigned int folio_pte_batch(struct folio *folio, pte_t *ptep, pte_t pte,\n  */\n static inline pte_t pte_move_swp_offset(pte_t pte, long delta)\n {\n-\tsoftleaf_t entry = softleaf_from_pte(pte), new_entry;\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tpte_t new;\n-\n-\tnew_entry = swp_slot_to_swp_entry(swp_slot(swp_slot_type(slot),\n-\t\t\tswp_slot_offset(slot) + delta));\n-\tnew = swp_entry_to_pte(new_entry);\n+\tsoftleaf_t entry = softleaf_from_pte(pte);\n+\tpte_t new = swp_entry_to_pte(swap_move(entry, delta));\n \n \tif (pte_swp_soft_dirty(pte))\n \t\tnew = pte_swp_mksoft_dirty(new);\ndiff --git a/mm/page_io.c b/mm/page_io.c\nindex 0b02bcc85e2a8..5de3705572955 100644\n--- a/mm/page_io.c\n+++ b/mm/page_io.c\n@@ -364,7 +364,7 @@ static void sio_write_complete(struct kiocb *iocb, long ret)\n \t\t */\n \t\tpr_err_ratelimited(\"Write error %ld on dio swapfile (%llu)\\n\",\n \t\t\t\t   ret,\n-\t\t\t\t   swap_slot_pos(swp_entry_to_swp_slot(page_swap_entry(page))));\n+\t\t\t\t   swap_slot_dev_pos(swp_entry_to_swp_slot(page_swap_entry(page))));\n \t\tfor (p = 0; p < sio->pages; p++) {\n \t\t\tpage = sio->bvec[p].bv_page;\n \t\t\tset_page_dirty(page);\n@@ -384,7 +384,7 @@ static void swap_writepage_fs(struct folio *folio, struct swap_iocb **swap_plug)\n \tswp_slot_t slot = swp_entry_to_swp_slot(folio->swap);\n \tstruct swap_info_struct *sis = __swap_slot_to_info(slot);\n \tstruct file *swap_file = sis->swap_file;\n-\tloff_t pos = swap_slot_pos(slot);\n+\tloff_t pos = swap_slot_dev_pos(slot);\n \n \tcount_swpout_vm_event(folio);\n \tfolio_start_writeback(folio);\n@@ -549,7 +549,7 @@ static void swap_read_folio_fs(struct folio *folio, struct swap_iocb **plug)\n \tswp_slot_t slot = swp_entry_to_swp_slot(folio->swap);\n \tstruct swap_info_struct *sis = __swap_slot_to_info(slot);\n \tstruct swap_iocb *sio = NULL;\n-\tloff_t pos = swap_slot_pos(slot);\n+\tloff_t pos = swap_slot_dev_pos(slot);\n \n \tif (plug)\n \t\tsio = *plug;\ndiff --git a/mm/shmem.c b/mm/shmem.c\nindex 400e2fa8e77cb..13f7469a04c8a 100644\n--- a/mm/shmem.c\n+++ b/mm/shmem.c\n@@ -2227,7 +2227,6 @@ static int shmem_split_large_entry(struct inode *inode, pgoff_t index,\n \tXA_STATE_ORDER(xas, &mapping->i_pages, index, 0);\n \tint split_order = 0;\n \tint i;\n-\tswp_slot_t slot = swp_entry_to_swp_slot(swap);\n \n \t/* Convert user data gfp flags to xarray node gfp flags */\n \tgfp &= GFP_RECLAIM_MASK;\n@@ -2268,13 +2267,7 @@ static int shmem_split_large_entry(struct inode *inode, pgoff_t index,\n \t\t\t */\n \t\t\tfor (i = 0; i < 1 << cur_order;\n \t\t\t     i += (1 << split_order)) {\n-\t\t\t\tswp_entry_t tmp_entry;\n-\t\t\t\tswp_slot_t tmp_slot;\n-\n-\t\t\t\ttmp_slot =\n-\t\t\t\t\tswp_slot(swp_slot_type(slot),\n-\t\t\t\t\t\tswp_slot_offset(slot) + swap_offset + i);\n-\t\t\t\ttmp_entry = swp_slot_to_swp_entry(tmp_slot);\n+\t\t\t\tswp_entry_t tmp_entry = swap_nth(swap, swap_offset + i);\n \n \t\t\t\t__xa_store(&mapping->i_pages, aligned_index + i,\n \t\t\t\t\t   swp_to_radix_entry(tmp_entry), 0);\ndiff --git a/mm/swap.h b/mm/swap.h\nindex bdf7aca146643..5eb53758bbd5d 100644\n--- a/mm/swap.h\n+++ b/mm/swap.h\n@@ -36,7 +36,11 @@ struct swap_cluster_info {\n \tu16 count;\n \tu8 flags;\n \tu8 order;\n-\tatomic_long_t __rcu *table;\t/* Swap table entries, see mm/swap_table.h */\n+\t/*\n+\t * Reverse map, to look up the virtual swap slot backed by a given physical\n+\t * swap slot.\n+\t*/\n+\tatomic_long_t __rcu *table;\n \tstruct list_head list;\n };\n \n@@ -212,7 +216,7 @@ static inline struct address_space *swap_address_space(swp_entry_t entry)\n }\n \n /* Return the swap device position of the swap slot. */\n-static inline loff_t swap_slot_pos(swp_slot_t slot)\n+static inline loff_t swap_slot_dev_pos(swp_slot_t slot)\n {\n \treturn ((loff_t)swp_slot_offset(slot)) << PAGE_SHIFT;\n }\ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex 29ec666be4204..c5ceccd756699 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -891,7 +891,8 @@ static int __init swap_init(void)\n \tswap_kobj = kobject_create_and_add(\"swap\", mm_kobj);\n \tif (!swap_kobj) {\n \t\tpr_err(\"failed to create swap kobject\\n\");\n-\t\treturn -ENOMEM;\n+\t\terr = -ENOMEM;\n+\t\tgoto vswap_exit;\n \t}\n \terr = sysfs_create_group(swap_kobj, &swap_attr_group);\n \tif (err) {\n@@ -904,6 +905,8 @@ static int __init swap_init(void)\n \n delete_obj:\n \tkobject_put(swap_kobj);\n+vswap_exit:\n+\tvswap_exit();\n \treturn err;\n }\n subsys_initcall(swap_init);\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 3f70df488c1da..68ec5d9f05848 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -1249,7 +1249,6 @@ static void swap_range_alloc(struct swap_info_struct *si,\n static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n \t\t\t    unsigned int nr_entries)\n {\n-\tunsigned long begin = offset;\n \tunsigned long end = offset + nr_entries - 1;\n \tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n \tunsigned int i;\n@@ -1258,10 +1257,8 @@ static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n \t * Use atomic clear_bit operations only on zeromap instead of non-atomic\n \t * bitmap_clear to prevent adjacent bits corruption due to simultaneous writes.\n \t */\n-\tfor (i = 0; i < nr_entries; i++) {\n+\tfor (i = 0; i < nr_entries; i++)\n \t\tclear_bit(offset + i, si->zeromap);\n-\t\tzswap_invalidate(swp_slot_to_swp_entry(swp_slot(si->type, offset + i)));\n-\t}\n \n \tif (si->flags & SWP_BLKDEV)\n \t\tswap_slot_free_notify =\n@@ -1274,7 +1271,6 @@ static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n \t\t\tswap_slot_free_notify(si->bdev, offset);\n \t\toffset++;\n \t}\n-\tswap_cache_clear_shadow(swp_entry(si->type, begin), nr_entries);\n \n \t/*\n \t * Make sure that try_to_unuse() observes si->inuse_pages reaching 0\n@@ -1405,7 +1401,7 @@ static bool swap_sync_discard(void)\n \treturn false;\n }\n \n-static int swap_slot_alloc(swp_slot_t *slot, unsigned int order)\n+int swap_slot_alloc(swp_slot_t *slot, unsigned int order)\n {\n \tunsigned int size = 1 << order;\n \n@@ -1441,53 +1437,6 @@ static int swap_slot_alloc(swp_slot_t *slot, unsigned int order)\n \treturn 0;\n }\n \n-/**\n- * folio_alloc_swap - allocate swap space for a folio\n- * @folio: folio we want to move to swap\n- *\n- * Allocate swap space for the folio and add the folio to the\n- * swap cache.\n- *\n- * Context: Caller needs to hold the folio lock.\n- * Return: Whether the folio was added to the swap cache.\n- */\n-int folio_alloc_swap(struct folio *folio)\n-{\n-\tunsigned int order = folio_order(folio);\n-\tswp_slot_t slot = { 0 };\n-\tswp_entry_t entry = {};\n-\tint err = 0, ret;\n-\n-\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n-\tVM_BUG_ON_FOLIO(!folio_test_uptodate(folio), folio);\n-\n-\tret = swap_slot_alloc(&slot, order);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\t/* XXX: for now, physical and virtual swap slots are identical */\n-\tentry.val = slot.val;\n-\n-\t/* Need to call this even if allocation failed, for MEMCG_SWAP_FAIL. */\n-\tif (mem_cgroup_try_charge_swap(folio, entry)) {\n-\t\terr = -ENOMEM;\n-\t\tgoto out_free;\n-\t}\n-\n-\tif (!slot.val)\n-\t\treturn -ENOMEM;\n-\n-\terr = swap_cache_add_folio(folio, entry, __GFP_HIGH | __GFP_NOMEMALLOC | __GFP_NOWARN, NULL);\n-\tif (err)\n-\t\tgoto out_free;\n-\n-\treturn 0;\n-\n-out_free:\n-\tput_swap_folio(folio, entry);\n-\treturn err;\n-}\n-\n static struct swap_info_struct *_swap_info_get(swp_slot_t slot)\n {\n \tstruct swap_info_struct *si;\n@@ -1733,6 +1682,13 @@ static void swap_slots_free(struct swap_info_struct *si,\n \tunsigned char *map = si->swap_map + offset;\n \tunsigned char *map_end = map + nr_pages;\n \tswp_entry_t entry = swp_slot_to_swp_entry(slot);\n+\tint i;\n+\n+\t/* release all the associated (virtual) swap slots */\n+\tfor (i = 0; i < nr_pages; i++) {\n+\t\tvswap_free(entry, ci);\n+\t\tentry.val++;\n+\t}\n \n \t/* It should never free entries across different clusters */\n \tVM_BUG_ON(ci != __swap_offset_to_cluster(si, offset + nr_pages - 1));\n@@ -1745,7 +1701,6 @@ static void swap_slots_free(struct swap_info_struct *si,\n \t\t*map = 0;\n \t} while (++map < map_end);\n \n-\tmem_cgroup_uncharge_swap(entry, nr_pages);\n \tswap_range_free(si, offset, nr_pages);\n \n \tif (!ci->count)\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex e68234f053fc9..9aa95558f320a 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -4,7 +4,147 @@\n  *\n  * Copyright (C) 2024 Meta Platforms, Inc., Nhat Pham\n  */\n+#include <linux/mm.h>\n+#include <linux/gfp.h>\n #include <linux/swap.h>\n+#include <linux/swapops.h>\n+#include <linux/swap_cgroup.h>\n+#include <linux/cpuhotplug.h>\n+#include \"swap.h\"\n+#include \"swap_table.h\"\n+\n+/*\n+ * Virtual Swap Space\n+ *\n+ * We associate with each swapped out page a virtual swap slot. This will allow\n+ * us to change the backing state of a swapped out page without having to\n+ * update every single page table entries referring to it.\n+ *\n+ * For now, there is a one-to-one correspondence between a virtual swap slot\n+ * and its associated physical swap slot.\n+ *\n+ * Virtual swap slots are organized into PMD-sized clusters, analogous to\n+ * physical swap allocator. However, unlike the physical swap allocator,\n+ * the clusters are dynamically allocated and freed on-demand. There is no\n+ * \"free list\" of virtual swap clusters - new free clusters are allocated\n+ * directly from the cluster map xarray.\n+ *\n+ * This allows us to avoid the overhead of pre-allocating a large number of\n+ * virtual swap clusters.\n+ */\n+\n+/**\n+ * Swap descriptor - metadata of a swapped out page.\n+ *\n+ * @slot: The handle to the physical swap slot backing this page.\n+ */\n+struct swp_desc {\n+\tswp_slot_t slot;\n+};\n+\n+#define VSWAP_CLUSTER_SHIFT HPAGE_PMD_ORDER\n+#define VSWAP_CLUSTER_SIZE (1UL << VSWAP_CLUSTER_SHIFT)\n+#define VSWAP_CLUSTER_MASK (VSWAP_CLUSTER_SIZE - 1)\n+\n+/*\n+ * Map from a cluster id to the number of allocated virtual swap slots in the\n+ * (PMD-sized) cluster. This allows us to quickly allocate an empty cluster\n+ * for a large folio being swapped out.\n+ *\n+ * This xarray's lock is also used as the \"global\" allocator lock (for e.g, to\n+ * synchronize global cluster lists manipulation).\n+ */\n+static DEFINE_XARRAY_FLAGS(vswap_cluster_map, XA_FLAGS_TRACK_FREE);\n+\n+#if SWP_TYPE_SHIFT > 32\n+/*\n+ * In 64 bit architecture, the maximum number of virtual swap slots is capped\n+ * by the number of clusters (as the vswap_cluster_map xarray can only allocate\n+ * up to U32 clusters).\n+ */\n+#define MAX_VSWAP\t\\\n+\t(((unsigned long)U32_MAX << VSWAP_CLUSTER_SHIFT) + (VSWAP_CLUSTER_SIZE - 1))\n+#else\n+/*\n+ * In 32 bit architecture, just make sure the range of virtual swap slots is\n+ * the same as the range of physical swap slots.\n+ */\n+#define MAX_VSWAP\t(((MAX_SWAPFILES - 1) << SWP_TYPE_SHIFT) | SWP_OFFSET_MASK)\n+#endif\n+\n+static const struct xa_limit vswap_cluster_map_limit = {\n+\t.max = MAX_VSWAP >> VSWAP_CLUSTER_SHIFT,\n+\t.min = 0,\n+};\n+\n+static struct list_head partial_clusters_lists[SWAP_NR_ORDERS];\n+\n+/**\n+ * struct vswap_cluster\n+ *\n+ * @lock: Spinlock protecting the cluster's data\n+ * @rcu: RCU head for deferred freeing when the cluster is no longer in use\n+ * @list: List entry for tracking in partial_clusters_lists when not fully allocated\n+ * @id: Unique identifier for this cluster, used to calculate swap slot values\n+ * @count: Number of allocated virtual swap slots in this cluster\n+ * @order: Order of allocation (0 for single pages, higher for contiguous ranges)\n+ * @cached: Whether this cluster is cached in a per-CPU variable for fast allocation\n+ * @full: Whether this cluster is considered full (no more allocations possible)\n+ * @refcnt: Reference count tracking usage of slots in this cluster\n+ * @bitmap: Bitmap tracking which slots in the cluster are allocated\n+ * @descriptors: Pointer to array of swap descriptors for each slot in the cluster\n+ *\n+ * A vswap_cluster manages a PMD-sized group of contiguous virtual swap slots.\n+ * It tracks which slots are allocated using a bitmap and maintains the\n+ * swap descriptors in an array. The cluster is reference-counted and freed when\n+ * all of its slots are released and the cluster is not cached. Each cluster\n+ * only allocates aligned slots of a single order, determined when the cluster is\n+ * allocated (and never change for the entire lifetime of the cluster).\n+ *\n+ * Clusters can be in the following states:\n+ * - Cached in per-CPU variables for fast allocation.\n+ * - In partial_clusters_lists when partially allocated but not cached.\n+ * - Marked as full when no more allocations are possible.\n+ */\n+struct vswap_cluster {\n+\tspinlock_t lock;\n+\tunion {\n+\t\tstruct rcu_head rcu;\n+\t\tstruct list_head list;\n+\t};\n+\tunsigned long id;\n+\tunsigned int count:VSWAP_CLUSTER_SHIFT + 1;\n+\tunsigned int order:4;\n+\tbool cached:1;\n+\tbool full:1;\n+\trefcount_t refcnt;\n+\tDECLARE_BITMAP(bitmap, VSWAP_CLUSTER_SIZE);\n+\tstruct swp_desc descriptors[VSWAP_CLUSTER_SIZE];\n+};\n+\n+#define VSWAP_VAL_CLUSTER_IDX(val) ((val) >> VSWAP_CLUSTER_SHIFT)\n+#define VSWAP_CLUSTER_IDX(entry) VSWAP_VAL_CLUSTER_IDX(entry.val)\n+#define VSWAP_IDX_WITHIN_CLUSTER_VAL(val) ((val) & VSWAP_CLUSTER_MASK)\n+#define VSWAP_IDX_WITHIN_CLUSTER(entry)\tVSWAP_IDX_WITHIN_CLUSTER_VAL(entry.val)\n+\n+struct percpu_vswap_cluster {\n+\tstruct vswap_cluster *clusters[SWAP_NR_ORDERS];\n+\tlocal_lock_t lock;\n+};\n+\n+/*\n+ * Per-CPU cache of the last allocated cluster for each order. This allows\n+ * allocation fast path to skip the global vswap_cluster_map's spinlock, if\n+ * the locally cached cluster still has free slots. Note that caching a cluster\n+ * also increments its reference count.\n+ */\n+static DEFINE_PER_CPU(struct percpu_vswap_cluster, percpu_vswap_cluster) = {\n+\t.clusters = { NULL, },\n+\t.lock = INIT_LOCAL_LOCK(),\n+};\n+\n+static atomic_t vswap_alloc_reject;\n+static atomic_t vswap_used;\n \n #ifdef CONFIG_DEBUG_FS\n #include <linux/debugfs.h>\n@@ -17,6 +157,10 @@ static int vswap_debug_fs_init(void)\n \t\treturn -ENODEV;\n \n \tvswap_debugfs_root = debugfs_create_dir(\"vswap\", NULL);\n+\tdebugfs_create_atomic_t(\"alloc_reject\", 0444,\n+\t\tvswap_debugfs_root, &vswap_alloc_reject);\n+\tdebugfs_create_atomic_t(\"used\", 0444, vswap_debugfs_root, &vswap_used);\n+\n \treturn 0;\n }\n #else\n@@ -26,10 +170,524 @@ static int vswap_debug_fs_init(void)\n }\n #endif\n \n+static struct swp_desc *vswap_iter(struct vswap_cluster **clusterp, unsigned long i)\n+{\n+\tunsigned long cluster_id = VSWAP_VAL_CLUSTER_IDX(i);\n+\tstruct vswap_cluster *cluster = *clusterp;\n+\tstruct swp_desc *desc = NULL;\n+\tunsigned long slot_index;\n+\n+\tif (!cluster || cluster_id != cluster->id) {\n+\t\tif (cluster)\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\t\tif (!cluster)\n+\t\t\tgoto done;\n+\t\tVM_WARN_ON(cluster->id != cluster_id);\n+\t\tspin_lock(&cluster->lock);\n+\t}\n+\n+\tslot_index = VSWAP_IDX_WITHIN_CLUSTER_VAL(i);\n+\tif (test_bit(slot_index, cluster->bitmap))\n+\t\tdesc = &cluster->descriptors[slot_index];\n+\n+\tif (!desc) {\n+\t\tspin_unlock(&cluster->lock);\n+\t\tcluster = NULL;\n+\t}\n+\n+done:\n+\t*clusterp = cluster;\n+\treturn desc;\n+}\n+\n+static bool cluster_is_alloc_candidate(struct vswap_cluster *cluster)\n+{\n+\treturn cluster->count + (1 << (cluster->order)) <= VSWAP_CLUSTER_SIZE;\n+}\n+\n+static void __vswap_alloc_from_cluster(struct vswap_cluster *cluster, int start)\n+{\n+\tint i, nr = 1 << cluster->order;\n+\tstruct swp_desc *desc;\n+\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = &cluster->descriptors[start + i];\n+\t\tdesc->slot.val = 0;\n+\t}\n+\tcluster->count += nr;\n+}\n+\n+static unsigned long vswap_alloc_from_cluster(struct vswap_cluster *cluster)\n+{\n+\tint nr = 1 << cluster->order;\n+\tunsigned long i = cluster->id ? 0 : nr;\n+\n+\tVM_WARN_ON(!spin_is_locked(&cluster->lock));\n+\tif (!cluster_is_alloc_candidate(cluster))\n+\t\treturn 0;\n+\n+\t/* Find the first free range of nr contiguous aligned slots */\n+\ti = bitmap_find_next_zero_area(cluster->bitmap,\n+\t\t\tVSWAP_CLUSTER_SIZE, i, nr, nr - 1);\n+\tif (i >= VSWAP_CLUSTER_SIZE)\n+\t\treturn 0;\n+\n+\t/* Mark the range as allocated in the bitmap */\n+\tbitmap_set(cluster->bitmap, i, nr);\n+\n+\trefcount_add(nr, &cluster->refcnt);\n+\t__vswap_alloc_from_cluster(cluster, i);\n+\treturn i + (cluster->id << VSWAP_CLUSTER_SHIFT);\n+}\n+\n+/* Allocate a contiguous range of virtual swap slots */\n+static swp_entry_t vswap_alloc(int order)\n+{\n+\tstruct xa_limit limit = vswap_cluster_map_limit;\n+\tstruct vswap_cluster *local, *cluster;\n+\tint nr = 1 << order;\n+\tbool need_caching = true;\n+\tu32 cluster_id;\n+\tswp_entry_t entry;\n+\n+\tentry.val = 0;\n+\n+\t/* first, let's try the locally cached cluster */\n+\trcu_read_lock();\n+\tlocal_lock(&percpu_vswap_cluster.lock);\n+\tcluster = this_cpu_read(percpu_vswap_cluster.clusters[order]);\n+\tif (cluster) {\n+\t\tspin_lock(&cluster->lock);\n+\t\tentry.val = vswap_alloc_from_cluster(cluster);\n+\t\tneed_caching = !entry.val;\n+\n+\t\tif (!entry.val || !cluster_is_alloc_candidate(cluster)) {\n+\t\t\tthis_cpu_write(percpu_vswap_cluster.clusters[order], NULL);\n+\t\t\tcluster->cached = false;\n+\t\t\trefcount_dec(&cluster->refcnt);\n+\t\t\tcluster->full = true;\n+\t\t}\n+\t\tspin_unlock(&cluster->lock);\n+\t}\n+\tlocal_unlock(&percpu_vswap_cluster.lock);\n+\trcu_read_unlock();\n+\n+\t/*\n+\t * Local cluster does not have space. Let's try the uncached partial\n+\t * clusters before acquiring a new free cluster to reduce fragmentation,\n+\t * and avoid having to allocate a new cluster structure.\n+\t */\n+\tif (!entry.val) {\n+\t\tcluster = NULL;\n+\t\txa_lock(&vswap_cluster_map);\n+\t\tlist_for_each_entry_safe(cluster, local,\n+\t\t\t\t&partial_clusters_lists[order], list) {\n+\t\t\tif (!spin_trylock(&cluster->lock))\n+\t\t\t\tcontinue;\n+\n+\t\t\tentry.val = vswap_alloc_from_cluster(cluster);\n+\t\t\tlist_del_init(&cluster->list);\n+\t\t\tcluster->full = !entry.val || !cluster_is_alloc_candidate(cluster);\n+\t\t\tneed_caching = !cluster->full;\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\t\tif (entry.val)\n+\t\t\t\tbreak;\n+\t\t}\n+\t\txa_unlock(&vswap_cluster_map);\n+\t}\n+\n+\t/* try a new free cluster */\n+\tif (!entry.val) {\n+\t\tcluster = kvzalloc(sizeof(*cluster), GFP_KERNEL);\n+\t\tif (cluster) {\n+\t\t\t/* first cluster cannot allocate a PMD-sized THP */\n+\t\t\tif (order == SWAP_NR_ORDERS - 1)\n+\t\t\t\tlimit.min = 1;\n+\n+\t\t\tif (!xa_alloc(&vswap_cluster_map, &cluster_id, cluster, limit,\n+\t\t\t\t\t\tGFP_KERNEL)) {\n+\t\t\t\tspin_lock_init(&cluster->lock);\n+\t\t\t\tcluster->id = cluster_id;\n+\t\t\t\tcluster->order = order;\n+\t\t\t\tINIT_LIST_HEAD(&cluster->list);\n+\t\t\t\t/* Initialize bitmap to all zeros (all slots free) */\n+\t\t\t\tbitmap_zero(cluster->bitmap, VSWAP_CLUSTER_SIZE);\n+\t\t\t\tentry.val = cluster->id << VSWAP_CLUSTER_SHIFT;\n+\t\t\t\trefcount_set(&cluster->refcnt, nr);\n+\t\t\t\tif (!cluster_id)\n+\t\t\t\t\tentry.val += nr;\n+\t\t\t\t__vswap_alloc_from_cluster(cluster,\n+\t\t\t\t\t(entry.val & VSWAP_CLUSTER_MASK));\n+\t\t\t\t/* Mark the allocated range in the bitmap */\n+\t\t\t\tbitmap_set(cluster->bitmap, (entry.val & VSWAP_CLUSTER_MASK), nr);\n+\t\t\t\tneed_caching = cluster_is_alloc_candidate(cluster);\n+\t\t\t} else {\n+\t\t\t\t/* Failed to insert into cluster map, free the cluster */\n+\t\t\t\tkvfree(cluster);\n+\t\t\t\tcluster = NULL;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (need_caching && entry.val) {\n+\t\tlocal_lock(&percpu_vswap_cluster.lock);\n+\t\tlocal = this_cpu_read(percpu_vswap_cluster.clusters[order]);\n+\t\tif (local != cluster) {\n+\t\t\tif (local) {\n+\t\t\t\tspin_lock(&local->lock);\n+\t\t\t\t/* only update the local cache if cached cluster is full */\n+\t\t\t\tneed_caching = !cluster_is_alloc_candidate(local);\n+\t\t\t\tif (need_caching) {\n+\t\t\t\t\tthis_cpu_write(percpu_vswap_cluster.clusters[order], NULL);\n+\t\t\t\t\tlocal->cached = false;\n+\t\t\t\t\trefcount_dec(&local->refcnt);\n+\t\t\t\t}\n+\t\t\t\tspin_unlock(&local->lock);\n+\t\t\t}\n+\n+\t\t\tVM_WARN_ON(!cluster);\n+\t\t\tspin_lock(&cluster->lock);\n+\t\t\tif (cluster_is_alloc_candidate(cluster)) {\n+\t\t\t\tif (need_caching) {\n+\t\t\t\t\tthis_cpu_write(percpu_vswap_cluster.clusters[order], cluster);\n+\t\t\t\t\trefcount_inc(&cluster->refcnt);\n+\t\t\t\t\tcluster->cached = true;\n+\t\t\t\t} else {\n+\t\t\t\t\txa_lock(&vswap_cluster_map);\n+\t\t\t\t\tVM_WARN_ON(!list_empty(&cluster->list));\n+\t\t\t\t\tlist_add(&cluster->list, &partial_clusters_lists[order]);\n+\t\t\t\t\txa_unlock(&vswap_cluster_map);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\t}\n+\t\tlocal_unlock(&percpu_vswap_cluster.lock);\n+\t}\n+\n+\tif (entry.val) {\n+\t\tVM_WARN_ON(entry.val + nr - 1 > MAX_VSWAP);\n+\t\tatomic_add(nr, &vswap_used);\n+\t} else {\n+\t\tatomic_add(nr, &vswap_alloc_reject);\n+\t}\n+\treturn entry;\n+}\n+\n+static void vswap_cluster_free(struct vswap_cluster *cluster)\n+{\n+\tVM_WARN_ON(cluster->count || cluster->cached);\n+\tVM_WARN_ON(!spin_is_locked(&cluster->lock));\n+\txa_lock(&vswap_cluster_map);\n+\tlist_del_init(&cluster->list);\n+\t__xa_erase(&vswap_cluster_map, cluster->id);\n+\txa_unlock(&vswap_cluster_map);\n+\trcu_head_init(&cluster->rcu);\n+\tkvfree_rcu(cluster, rcu);\n+}\n+\n+static inline void release_vswap_slot(struct vswap_cluster *cluster,\n+\t\tunsigned long index)\n+{\n+\tunsigned long slot_index = VSWAP_IDX_WITHIN_CLUSTER_VAL(index);\n+\n+\tVM_WARN_ON(!spin_is_locked(&cluster->lock));\n+\tcluster->count--;\n+\n+\tbitmap_clear(cluster->bitmap, slot_index, 1);\n+\n+\t/* we only free uncached empty clusters */\n+\tif (refcount_dec_and_test(&cluster->refcnt))\n+\t\tvswap_cluster_free(cluster);\n+\telse if (cluster->full && cluster_is_alloc_candidate(cluster)) {\n+\t\tcluster->full = false;\n+\t\tif (!cluster->cached) {\n+\t\t\txa_lock(&vswap_cluster_map);\n+\t\t\tVM_WARN_ON(!list_empty(&cluster->list));\n+\t\t\tlist_add_tail(&cluster->list,\n+\t\t\t\t&partial_clusters_lists[cluster->order]);\n+\t\t\txa_unlock(&vswap_cluster_map);\n+\t\t}\n+\t}\n+\n+\tatomic_dec(&vswap_used);\n+}\n+\n+/*\n+ * Update the physical-to-virtual swap slot mapping.\n+ * Caller must ensure the physical swap slot's cluster is locked.\n+ */\n+static void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n+\t\t\t   unsigned long vswap, int nr)\n+{\n+\tatomic_long_t *table;\n+\tunsigned long slot_offset = swp_slot_offset(slot);\n+\tunsigned int ci_off = slot_offset % SWAPFILE_CLUSTER;\n+\tint i;\n+\n+\ttable = rcu_dereference_protected(ci->table, lockdep_is_held(&ci->lock));\n+\tVM_WARN_ON(!table);\n+\tfor (i = 0; i < nr; i++)\n+\t\t__swap_table_set(ci, ci_off + i, vswap ? vswap + i : 0);\n+}\n+\n+/**\n+ * vswap_free - free a virtual swap slot.\n+ * @entry: the virtual swap slot to free\n+ * @ci: the physical swap slot's cluster (optional, can be NULL)\n+ *\n+ * If @ci is NULL, this function is called to clean up a virtual swap entry\n+ * when no linkage has been established between physical and virtual swap slots.\n+ * If @ci is provided, the caller must ensure it is locked.\n+ */\n+void vswap_free(swp_entry_t entry, struct swap_cluster_info *ci)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\n+\tif (!entry.val)\n+\t\treturn;\n+\n+\tswap_cache_clear_shadow(entry, 1);\n+\tzswap_invalidate(entry);\n+\tmem_cgroup_uncharge_swap(entry, 1);\n+\n+\t/* do not immediately erase the virtual slot to prevent its reuse */\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tif (!desc) {\n+\t\trcu_read_unlock();\n+\t\treturn;\n+\t}\n+\n+\tif (desc->slot.val)\n+\t\tvswap_rmap_set(ci, desc->slot, 0, 1);\n+\n+\t/* erase forward mapping and release the virtual slot for reallocation */\n+\trelease_vswap_slot(cluster, entry.val);\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+/**\n+ * folio_alloc_swap - allocate swap space for a folio.\n+ * @folio: the folio.\n+ *\n+ * Return: 0, if the allocation succeeded, -ENOMEM, if the allocation failed.\n+ */\n+int folio_alloc_swap(struct folio *folio)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swap_info_struct *si;\n+\tstruct swap_cluster_info *ci;\n+\tint i, err, nr = folio_nr_pages(folio), order = folio_order(folio);\n+\tstruct swp_desc *desc;\n+\tswp_entry_t entry;\n+\tswp_slot_t slot;\n+\n+\tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n+\tVM_BUG_ON_FOLIO(!folio_test_uptodate(folio), folio);\n+\n+\tentry = vswap_alloc(folio_order(folio));\n+\tif (!entry.val)\n+\t\treturn -ENOMEM;\n+\n+\t/*\n+\t * XXX: for now, we always allocate a physical swap slot for each virtual\n+\t * swap slot, and their lifetime are coupled. This will change once we\n+\t * decouple virtual swap slots from their backing states, and only allocate\n+\t * physical swap slots for them on demand (i.e on zswap writeback, or\n+\t * fallback from zswap store failure).\n+\t */\n+\tif (swap_slot_alloc(&slot, order)) {\n+\t\tfor (i = 0; i < nr; i++)\n+\t\t\tvswap_free((swp_entry_t){entry.val + i}, NULL);\n+\t\tentry.val = 0;\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\t/* establish the vrtual <-> physical swap slots linkages. */\n+\tsi = __swap_slot_to_info(slot);\n+\tci = swap_cluster_lock(si, swp_slot_offset(slot));\n+\tvswap_rmap_set(ci, slot, entry.val, nr);\n+\tswap_cluster_unlock(ci);\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tVM_WARN_ON(!desc);\n+\n+\t\tdesc->slot.val = slot.val + i;\n+\t}\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\t/*\n+\t * XXX: for now, we charge towards the memory cgroup's swap limit on virtual\n+\t * swap slots allocation. This is acceptable because as noted above, each\n+\t * virtual swap slot corresponds to a physical swap slot. Once we have\n+\t * decoupled virtual and physical swap slots, we will only charge when we\n+\t * actually allocate a physical swap slot.\n+\t */\n+\tif (mem_cgroup_try_charge_swap(folio, entry))\n+\t\tgoto out_free;\n+\n+\terr = swap_cache_add_folio(folio, entry, __GFP_HIGH | __GFP_NOMEMALLOC | __GFP_NOWARN, NULL);\n+\tif (err)\n+\t\tgoto out_free;\n+\n+\treturn 0;\n+\n+out_free:\n+\tput_swap_folio(folio, entry);\n+\treturn -ENOMEM;\n+}\n+\n+/**\n+ * swp_entry_to_swp_slot - look up the physical swap slot corresponding to a\n+ *                         virtual swap slot.\n+ * @entry: the virtual swap slot.\n+ *\n+ * Return: the physical swap slot corresponding to the virtual swap slot.\n+ */\n+swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tswp_slot_t slot;\n+\n+\tslot.val = 0;\n+\tif (!entry.val)\n+\t\treturn slot;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tif (!desc) {\n+\t\trcu_read_unlock();\n+\t\treturn (swp_slot_t){0};\n+\t}\n+\tslot = desc->slot;\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\treturn slot;\n+}\n+\n+/**\n+ * swp_slot_to_swp_entry - look up the virtual swap slot corresponding to a\n+ *                         physical swap slot.\n+ * @slot: the physical swap slot.\n+ *\n+ * Return: the virtual swap slot corresponding to the physical swap slot.\n+ */\n+swp_entry_t swp_slot_to_swp_entry(swp_slot_t slot)\n+{\n+\tswp_entry_t ret;\n+\tstruct swap_cluster_info *ci;\n+\tunsigned long offset;\n+\tunsigned int ci_off;\n+\n+\tret.val = 0;\n+\tif (!slot.val)\n+\t\treturn ret;\n+\n+\toffset = swp_slot_offset(slot);\n+\tci_off = offset % SWAPFILE_CLUSTER;\n+\tci = __swap_slot_to_cluster(slot);\n+\n+\tret.val = swap_table_get(ci, ci_off);\n+\treturn ret;\n+}\n+\n+bool tryget_swap_entry(swp_entry_t entry, struct swap_info_struct **si)\n+{\n+\tstruct vswap_cluster *cluster;\n+\tswp_slot_t slot;\n+\n+\tslot = swp_entry_to_swp_slot(entry);\n+\t*si = swap_slot_tryget_swap_info(slot);\n+\tif (!*si)\n+\t\treturn false;\n+\n+\t/*\n+\t * Ensure the cluster and its associated data structures (swap cache etc.)\n+\t * remain valid.\n+\t */\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, VSWAP_CLUSTER_IDX(entry));\n+\tif (!cluster || !refcount_inc_not_zero(&cluster->refcnt)) {\n+\t\trcu_read_unlock();\n+\t\tswap_slot_put_swap_info(*si);\n+\t\t*si = NULL;\n+\t\treturn false;\n+\t}\n+\trcu_read_unlock();\n+\treturn true;\n+}\n+\n+void put_swap_entry(swp_entry_t entry, struct swap_info_struct *si)\n+{\n+\tstruct vswap_cluster *cluster;\n+\n+\tif (si)\n+\t\tswap_slot_put_swap_info(si);\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, VSWAP_CLUSTER_IDX(entry));\n+\tspin_lock(&cluster->lock);\n+\tif (refcount_dec_and_test(&cluster->refcnt))\n+\t\tvswap_cluster_free(cluster);\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+static int vswap_cpu_dead(unsigned int cpu)\n+{\n+\tstruct percpu_vswap_cluster *percpu_cluster;\n+\tstruct vswap_cluster *cluster;\n+\tint order;\n+\n+\tpercpu_cluster = per_cpu_ptr(&percpu_vswap_cluster, cpu);\n+\n+\trcu_read_lock();\n+\tlocal_lock(&percpu_cluster->lock);\n+\tfor (order = 0; order < SWAP_NR_ORDERS; order++) {\n+\t\tcluster = percpu_cluster->clusters[order];\n+\t\tif (cluster) {\n+\t\t\tpercpu_cluster->clusters[order] = NULL;\n+\t\t\tspin_lock(&cluster->lock);\n+\t\t\tcluster->cached = false;\n+\t\t\tif (refcount_dec_and_test(&cluster->refcnt))\n+\t\t\t\tvswap_cluster_free(cluster);\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\t}\n+\t}\n+\tlocal_unlock(&percpu_cluster->lock);\n+\trcu_read_unlock();\n+\n+\treturn 0;\n+}\n+\n+\n int vswap_init(void)\n {\n+\tint i;\n+\n+\tif (cpuhp_setup_state_nocalls(CPUHP_MM_VSWAP_DEAD, \"mm/vswap:dead\", NULL,\n+\t\t\t\tvswap_cpu_dead)) {\n+\t\tpr_err(\"Failed to register vswap CPU hotplug callback\\n\");\n+\t\treturn -ENOMEM;\n+\t}\n+\n \tif (vswap_debug_fs_init())\n \t\tpr_warn(\"Failed to initialize vswap debugfs\\n\");\n \n+\tfor (i = 0; i < SWAP_NR_ORDERS; i++)\n+\t\tINIT_LIST_HEAD(&partial_clusters_lists[i]);\n+\n \treturn 0;\n }\n+\n+void vswap_exit(void)\n+{\n+}\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the poor batching behavior of vswap free path, explaining that they will move the swap cache and working set shadow to the virtual swap descriptor, effectively range-partitioning the swap cache by virtual swap clusters (of PMD sized), which eliminates swap cache lock contention.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged a fix is needed",
            "agreed with the approach"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Move the swap cache (and workingset shadow for anonymous pages) to the\nvirtual swap descriptor. This effectively range-partitions the swap\ncache by virtual swap clusters (of PMD sized), eliminate swap cache lock\ncontention.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n mm/huge_memory.c |   4 +-\n mm/migrate.c     |   6 +-\n mm/shmem.c       |   4 +-\n mm/swap.h        |  16 +--\n mm/swap_state.c  | 251 +--------------------------------\n mm/vmscan.c      |   6 +-\n mm/vswap.c       | 350 ++++++++++++++++++++++++++++++++++++++++++++++-\n 7 files changed, 364 insertions(+), 273 deletions(-)\n\ndiff --git a/mm/huge_memory.c b/mm/huge_memory.c\nindex 21215ac870144..dcbd3821d6178 100644\n--- a/mm/huge_memory.c\n+++ b/mm/huge_memory.c\n@@ -3825,7 +3825,7 @@ static int __folio_freeze_and_split_unmapped(struct folio *folio, unsigned int n\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n \n-\t\t\tswap_cache_lock();\n+\t\t\tswap_cache_lock(folio->swap);\n \t\t}\n \n \t\t/* lock lru list/PageCompound, ref frozen by page_ref_freeze */\n@@ -3901,7 +3901,7 @@ static int __folio_freeze_and_split_unmapped(struct folio *folio, unsigned int n\n \t\t\tunlock_page_lruvec(lruvec);\n \n \t\tif (folio_test_swapcache(folio))\n-\t\t\tswap_cache_unlock();\n+\t\t\tswap_cache_unlock(folio->swap);\n \t} else {\n \t\tsplit_queue_unlock(ds_queue);\n \t\treturn -EAGAIN;\ndiff --git a/mm/migrate.c b/mm/migrate.c\nindex 11d9b43dff5d8..e850b05a232de 100644\n--- a/mm/migrate.c\n+++ b/mm/migrate.c\n@@ -600,13 +600,13 @@ static int __folio_migrate_mapping(struct address_space *mapping,\n \tnewzone = folio_zone(newfolio);\n \n \tif (folio_test_swapcache(folio))\n-\t\tswap_cache_lock_irq();\n+\t\tswap_cache_lock_irq(folio->swap);\n \telse\n \t\txas_lock_irq(&xas);\n \n \tif (!folio_ref_freeze(folio, expected_count)) {\n \t\tif (folio_test_swapcache(folio))\n-\t\t\tswap_cache_unlock_irq();\n+\t\t\tswap_cache_unlock_irq(folio->swap);\n \t\telse\n \t\t\txas_unlock_irq(&xas);\n \t\treturn -EAGAIN;\n@@ -652,7 +652,7 @@ static int __folio_migrate_mapping(struct address_space *mapping,\n \n \t/* Leave irq disabled to prevent preemption while updating stats */\n \tif (folio_test_swapcache(folio))\n-\t\tswap_cache_unlock();\n+\t\tswap_cache_unlock(folio->swap);\n \telse\n \t\txas_unlock(&xas);\n \ndiff --git a/mm/shmem.c b/mm/shmem.c\nindex 13f7469a04c8a..66cf8af6779ca 100644\n--- a/mm/shmem.c\n+++ b/mm/shmem.c\n@@ -2168,12 +2168,12 @@ static int shmem_replace_folio(struct folio **foliop, gfp_t gfp,\n \tnew->swap = entry;\n \tfolio_set_swapcache(new);\n \n-\tswap_cache_lock_irq();\n+\tswap_cache_lock_irq(entry);\n \t__swap_cache_replace_folio(old, new);\n \tmem_cgroup_replace_folio(old, new);\n \tshmem_update_stats(new, nr_pages);\n \tshmem_update_stats(old, -nr_pages);\n-\tswap_cache_unlock_irq();\n+\tswap_cache_unlock_irq(entry);\n \n \tfolio_add_lru(new);\n \t*foliop = new;\ndiff --git a/mm/swap.h b/mm/swap.h\nindex 5eb53758bbd5d..57ed24a2d6356 100644\n--- a/mm/swap.h\n+++ b/mm/swap.h\n@@ -205,10 +205,12 @@ void __swap_writepage(struct folio *folio, struct swap_iocb **swap_plug);\n \n /* linux/mm/swap_state.c */\n extern struct address_space swap_space __read_mostly;\n-void swap_cache_lock_irq(void);\n-void swap_cache_unlock_irq(void);\n-void swap_cache_lock(void);\n-void swap_cache_unlock(void);\n+\n+/* linux/mm/vswap.c */\n+void swap_cache_lock_irq(swp_entry_t entry);\n+void swap_cache_unlock_irq(swp_entry_t entry);\n+void swap_cache_lock(swp_entry_t entry);\n+void swap_cache_unlock(swp_entry_t entry);\n \n static inline struct address_space *swap_address_space(swp_entry_t entry)\n {\n@@ -256,12 +258,11 @@ static inline bool folio_matches_swap_entry(const struct folio *folio,\n  */\n struct folio *swap_cache_get_folio(swp_entry_t entry);\n void *swap_cache_get_shadow(swp_entry_t entry);\n-int swap_cache_add_folio(struct folio *folio, swp_entry_t entry, gfp_t gfp, void **shadow);\n+void swap_cache_add_folio(struct folio *folio, swp_entry_t entry, void **shadow);\n void swap_cache_del_folio(struct folio *folio);\n /* Below helpers require the caller to lock the swap cache. */\n void __swap_cache_del_folio(struct folio *folio, swp_entry_t entry, void *shadow);\n void __swap_cache_replace_folio(struct folio *old, struct folio *new);\n-void swap_cache_clear_shadow(swp_entry_t entry, int nr_ents);\n \n void show_swap_cache_info(void);\n void swapcache_clear(struct swap_info_struct *si, swp_entry_t entry, int nr);\n@@ -422,9 +423,8 @@ static inline void *swap_cache_get_shadow(swp_entry_t entry)\n \treturn NULL;\n }\n \n-static inline int swap_cache_add_folio(struct folio *folio, swp_entry_t entry, gfp_t gfp, void **shadow)\n+static inline void swap_cache_add_folio(struct folio *folio, swp_entry_t entry, void **shadow)\n {\n-\treturn 0;\n }\n \n static inline void swap_cache_del_folio(struct folio *folio)\ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex c5ceccd756699..00fa3e76a5c19 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -41,28 +41,6 @@ struct address_space swap_space __read_mostly = {\n \t.a_ops = &swap_aops,\n };\n \n-static DEFINE_XARRAY(swap_cache);\n-\n-void swap_cache_lock_irq(void)\n-{\n-\txa_lock_irq(&swap_cache);\n-}\n-\n-void swap_cache_unlock_irq(void)\n-{\n-\txa_unlock_irq(&swap_cache);\n-}\n-\n-void swap_cache_lock(void)\n-{\n-\txa_lock(&swap_cache);\n-}\n-\n-void swap_cache_unlock(void)\n-{\n-\txa_unlock(&swap_cache);\n-}\n-\n static bool enable_vma_readahead __read_mostly = true;\n \n #define SWAP_RA_ORDER_CEILING\t5\n@@ -94,231 +72,6 @@ void show_swap_cache_info(void)\n \tprintk(\"Total swap = %lukB\\n\", K(total_swap_pages));\n }\n \n-/**\n- * swap_cache_get_folio - Looks up a folio in the swap cache.\n- * @entry: swap entry used for the lookup.\n- *\n- * A found folio will be returned unlocked and with its refcount increased.\n- *\n- * Context: Caller must ensure @entry is valid and protect the swap device\n- * with reference count or locks.\n- * Return: Returns the found folio on success, NULL otherwise. The caller\n- * must lock nd check if the folio still matches the swap entry before\n- * use (e.g., folio_matches_swap_entry).\n- */\n-struct folio *swap_cache_get_folio(swp_entry_t entry)\n-{\n-\tvoid *entry_val;\n-\tstruct folio *folio;\n-\n-\tfor (;;) {\n-\t\trcu_read_lock();\n-\t\tentry_val = xa_load(&swap_cache, entry.val);\n-\t\tif (!entry_val || xa_is_value(entry_val)) {\n-\t\t\trcu_read_unlock();\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tfolio = entry_val;\n-\t\tif (likely(folio_try_get(folio))) {\n-\t\t\trcu_read_unlock();\n-\t\t\treturn folio;\n-\t\t}\n-\t\trcu_read_unlock();\n-\t}\n-\n-\treturn NULL;\n-}\n-\n-/**\n- * swap_cache_get_shadow - Looks up a shadow in the swap cache.\n- * @entry: swap entry used for the lookup.\n- *\n- * Context: Caller must ensure @entry is valid and protect the swap device\n- * with reference count or locks.\n- * Return: Returns either NULL or an XA_VALUE (shadow).\n- */\n-void *swap_cache_get_shadow(swp_entry_t entry)\n-{\n-\tvoid *entry_val;\n-\n-\trcu_read_lock();\n-\tentry_val = xa_load(&swap_cache, entry.val);\n-\trcu_read_unlock();\n-\n-\tif (xa_is_value(entry_val))\n-\t\treturn entry_val;\n-\treturn NULL;\n-}\n-\n-/**\n- * swap_cache_add_folio - Add a folio into the swap cache.\n- * @folio: The folio to be added.\n- * @entry: The swap entry corresponding to the folio.\n- * @gfp: gfp_mask for XArray node allocation.\n- * @shadowp: If a shadow is found, return the shadow.\n- *\n- * Context: Caller must ensure @entry is valid and protect the swap device\n- * with reference count or locks.\n- * The caller also needs to update the corresponding swap_map slots with\n- * SWAP_HAS_CACHE bit to avoid race or conflict.\n- *\n- * Return: 0 on success, negative error code on failure.\n- */\n-int swap_cache_add_folio(struct folio *folio, swp_entry_t entry, gfp_t gfp, void **shadowp)\n-{\n-\tXA_STATE_ORDER(xas, &swap_cache, entry.val, folio_order(folio));\n-\tunsigned long nr_pages = folio_nr_pages(folio);\n-\tunsigned long i;\n-\tvoid *old;\n-\n-\tVM_WARN_ON_ONCE_FOLIO(!folio_test_locked(folio), folio);\n-\tVM_WARN_ON_ONCE_FOLIO(folio_test_swapcache(folio), folio);\n-\tVM_WARN_ON_ONCE_FOLIO(!folio_test_swapbacked(folio), folio);\n-\n-\tfolio_ref_add(folio, nr_pages);\n-\tfolio_set_swapcache(folio);\n-\tfolio->swap = entry;\n-\n-\tdo {\n-\t\txas_lock_irq(&xas);\n-\t\txas_create_range(&xas);\n-\t\tif (xas_error(&xas))\n-\t\t\tgoto unlock;\n-\t\tfor (i = 0; i < nr_pages; i++) {\n-\t\t\tVM_BUG_ON_FOLIO(xas.xa_index != entry.val + i, folio);\n-\t\t\told = xas_load(&xas);\n-\t\t\tif (old && !xa_is_value(old)) {\n-\t\t\t\tVM_WARN_ON_ONCE_FOLIO(1, folio);\n-\t\t\t\txas_set_err(&xas, -EEXIST);\n-\t\t\t\tgoto unlock;\n-\t\t\t}\n-\t\t\tif (shadowp && xa_is_value(old) && !*shadowp)\n-\t\t\t\t*shadowp = old;\n-\t\t\txas_store(&xas, folio);\n-\t\t\txas_next(&xas);\n-\t\t}\n-\t\tnode_stat_mod_folio(folio, NR_FILE_PAGES, nr_pages);\n-\t\tlruvec_stat_mod_folio(folio, NR_SWAPCACHE, nr_pages);\n-unlock:\n-\t\txas_unlock_irq(&xas);\n-\t} while (xas_nomem(&xas, gfp));\n-\n-\tif (!xas_error(&xas))\n-\t\treturn 0;\n-\n-\tfolio_clear_swapcache(folio);\n-\tfolio_ref_sub(folio, nr_pages);\n-\treturn xas_error(&xas);\n-}\n-\n-/**\n- * __swap_cache_del_folio - Removes a folio from the swap cache.\n- * @folio: The folio.\n- * @entry: The first swap entry that the folio corresponds to.\n- * @shadow: shadow value to be filled in the swap cache.\n- *\n- * Removes a folio from the swap cache and fills a shadow in place.\n- * This won't put the folio's refcount. The caller has to do that.\n- *\n- * Context: Caller must ensure the folio is locked and in the swap cache\n- * using the index of @entry, and lock the swap cache xarray.\n- */\n-void __swap_cache_del_folio(struct folio *folio, swp_entry_t entry, void *shadow)\n-{\n-\tlong nr_pages = folio_nr_pages(folio);\n-\tXA_STATE(xas, &swap_cache, entry.val);\n-\tint i;\n-\n-\tVM_WARN_ON_ONCE_FOLIO(!folio_test_locked(folio), folio);\n-\tVM_WARN_ON_ONCE_FOLIO(!folio_test_swapcache(folio), folio);\n-\tVM_WARN_ON_ONCE_FOLIO(folio_test_writeback(folio), folio);\n-\n-\tfor (i = 0; i < nr_pages; i++) {\n-\t\tvoid *old = xas_store(&xas, shadow);\n-\t\tVM_WARN_ON_FOLIO(old != folio, folio);\n-\t\txas_next(&xas);\n-\t}\n-\n-\tfolio->swap.val = 0;\n-\tfolio_clear_swapcache(folio);\n-\tnode_stat_mod_folio(folio, NR_FILE_PAGES, -nr_pages);\n-\tlruvec_stat_mod_folio(folio, NR_SWAPCACHE, -nr_pages);\n-}\n-\n-/**\n- * swap_cache_del_folio - Removes a folio from the swap cache.\n- * @folio: The folio.\n- *\n- * Same as __swap_cache_del_folio, but handles lock and refcount. The\n- * caller must ensure the folio is either clean or has a swap count\n- * equal to zero, or it may cause data loss.\n- *\n- * Context: Caller must ensure the folio is locked and in the swap cache.\n- */\n-void swap_cache_del_folio(struct folio *folio)\n-{\n-\tswp_entry_t entry = folio->swap;\n-\n-\txa_lock_irq(&swap_cache);\n-\t__swap_cache_del_folio(folio, entry, NULL);\n-\txa_unlock_irq(&swap_cache);\n-\n-\tput_swap_folio(folio, entry);\n-\tfolio_ref_sub(folio, folio_nr_pages(folio));\n-}\n-\n-/**\n- * __swap_cache_replace_folio - Replace a folio in the swap cache.\n- * @old: The old folio to be replaced.\n- * @new: The new folio.\n- *\n- * Replace an existing folio in the swap cache with a new folio. The\n- * caller is responsible for setting up the new folio's flag and swap\n- * entries. Replacement will take the new folio's swap entry value as\n- * the starting offset to override all slots covered by the new folio.\n- *\n- * Context: Caller must ensure both folios are locked, and lock the\n- * swap cache xarray.\n- */\n-void __swap_cache_replace_folio(struct folio *old, struct folio *new)\n-{\n-\tswp_entry_t entry = new->swap;\n-\tunsigned long nr_pages = folio_nr_pages(new);\n-\tXA_STATE(xas, &swap_cache, entry.val);\n-\tint i;\n-\n-\tVM_WARN_ON_ONCE(!folio_test_swapcache(old) || !folio_test_swapcache(new));\n-\tVM_WARN_ON_ONCE(!folio_test_locked(old) || !folio_test_locked(new));\n-\tVM_WARN_ON_ONCE(!entry.val);\n-\n-\tfor (i = 0; i < nr_pages; i++) {\n-\t\tvoid *old_entry = xas_store(&xas, new);\n-\t\tWARN_ON_ONCE(!old_entry || xa_is_value(old_entry) || old_entry != old);\n-\t\txas_next(&xas);\n-\t}\n-}\n-\n-/**\n- * swap_cache_clear_shadow - Clears a set of shadows in the swap cache.\n- * @entry: The starting index entry.\n- * @nr_ents: How many slots need to be cleared.\n- *\n- * Context: Caller must ensure the range is valid and all in one single cluster,\n- * not occupied by any folio.\n- */\n-void swap_cache_clear_shadow(swp_entry_t entry, int nr_ents)\n-{\n-\tXA_STATE(xas, &swap_cache, entry.val);\n-\tint i;\n-\n-\txas_lock(&xas);\n-\tfor (i = 0; i < nr_ents; i++) {\n-\t\txas_store(&xas, NULL);\n-\t\txas_next(&xas);\n-\t}\n-\txas_unlock(&xas);\n-}\n-\n /*\n  * If we are the only user, then try to free up the swap cache.\n  *\n@@ -497,9 +250,7 @@ struct folio *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \tif (mem_cgroup_swapin_charge_folio(new_folio, NULL, gfp_mask, entry))\n \t\tgoto fail_unlock;\n \n-\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n-\tif (swap_cache_add_folio(new_folio, entry, gfp_mask & GFP_RECLAIM_MASK, &shadow))\n-\t\tgoto fail_unlock;\n+\tswap_cache_add_folio(new_folio, entry, &shadow);\n \n \tmemcg1_swapin(entry, 1);\n \ndiff --git a/mm/vmscan.c b/mm/vmscan.c\nindex 558ff7f413786..c9ec1a1458b4e 100644\n--- a/mm/vmscan.c\n+++ b/mm/vmscan.c\n@@ -712,7 +712,7 @@ static int __remove_mapping(struct address_space *mapping, struct folio *folio,\n \tBUG_ON(mapping != folio_mapping(folio));\n \n \tif (folio_test_swapcache(folio)) {\n-\t\tswap_cache_lock_irq();\n+\t\tswap_cache_lock_irq(folio->swap);\n \t} else {\n \t\tspin_lock(&mapping->host->i_lock);\n \t\txa_lock_irq(&mapping->i_pages);\n@@ -759,7 +759,7 @@ static int __remove_mapping(struct address_space *mapping, struct folio *folio,\n \t\t\tshadow = workingset_eviction(folio, target_memcg);\n \t\t__swap_cache_del_folio(folio, swap, shadow);\n \t\tmemcg1_swapout(folio, swap);\n-\t\tswap_cache_unlock_irq();\n+\t\tswap_cache_unlock_irq(swap);\n \t\tput_swap_folio(folio, swap);\n \t} else {\n \t\tvoid (*free_folio)(struct folio *);\n@@ -798,7 +798,7 @@ static int __remove_mapping(struct address_space *mapping, struct folio *folio,\n \n cannot_free:\n \tif (folio_test_swapcache(folio)) {\n-\t\tswap_cache_unlock_irq();\n+\t\tswap_cache_unlock_irq(folio->swap);\n \t} else {\n \t\txa_unlock_irq(&mapping->i_pages);\n \t\tspin_unlock(&mapping->host->i_lock);\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex 9aa95558f320a..d44199dc059a3 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -37,9 +37,15 @@\n  * Swap descriptor - metadata of a swapped out page.\n  *\n  * @slot: The handle to the physical swap slot backing this page.\n+ * @swap_cache: The folio in swap cache.\n+ * @shadow: The shadow entry.\n  */\n struct swp_desc {\n \tswp_slot_t slot;\n+\tunion {\n+\t\tstruct folio *swap_cache;\n+\t\tvoid *shadow;\n+\t};\n };\n \n #define VSWAP_CLUSTER_SHIFT HPAGE_PMD_ORDER\n@@ -170,6 +176,24 @@ static int vswap_debug_fs_init(void)\n }\n #endif\n \n+/*\n+ * Lockless version of vswap_iter - assumes caller holds cluster lock.\n+ * Used when iterating within the same cluster with the lock already held.\n+ */\n+static struct swp_desc *__vswap_iter(struct vswap_cluster *cluster, unsigned long i)\n+{\n+\tunsigned long slot_index;\n+\n+\tlockdep_assert_held(&cluster->lock);\n+\tVM_WARN_ON(cluster->id != VSWAP_VAL_CLUSTER_IDX(i));\n+\n+\tslot_index = VSWAP_IDX_WITHIN_CLUSTER_VAL(i);\n+\tif (test_bit(slot_index, cluster->bitmap))\n+\t\treturn &cluster->descriptors[slot_index];\n+\n+\treturn NULL;\n+}\n+\n static struct swp_desc *vswap_iter(struct vswap_cluster **clusterp, unsigned long i)\n {\n \tunsigned long cluster_id = VSWAP_VAL_CLUSTER_IDX(i);\n@@ -448,7 +472,6 @@ void vswap_free(swp_entry_t entry, struct swap_cluster_info *ci)\n \tif (!entry.val)\n \t\treturn;\n \n-\tswap_cache_clear_shadow(entry, 1);\n \tzswap_invalidate(entry);\n \tmem_cgroup_uncharge_swap(entry, 1);\n \n@@ -460,6 +483,10 @@ void vswap_free(swp_entry_t entry, struct swap_cluster_info *ci)\n \t\treturn;\n \t}\n \n+\t/* Clear shadow if present */\n+\tif (xa_is_value(desc->shadow))\n+\t\tdesc->shadow = NULL;\n+\n \tif (desc->slot.val)\n \t\tvswap_rmap_set(ci, desc->slot, 0, 1);\n \n@@ -480,7 +507,7 @@ int folio_alloc_swap(struct folio *folio)\n \tstruct vswap_cluster *cluster = NULL;\n \tstruct swap_info_struct *si;\n \tstruct swap_cluster_info *ci;\n-\tint i, err, nr = folio_nr_pages(folio), order = folio_order(folio);\n+\tint i, nr = folio_nr_pages(folio), order = folio_order(folio);\n \tstruct swp_desc *desc;\n \tswp_entry_t entry;\n \tswp_slot_t slot;\n@@ -533,9 +560,7 @@ int folio_alloc_swap(struct folio *folio)\n \tif (mem_cgroup_try_charge_swap(folio, entry))\n \t\tgoto out_free;\n \n-\terr = swap_cache_add_folio(folio, entry, __GFP_HIGH | __GFP_NOMEMALLOC | __GFP_NOWARN, NULL);\n-\tif (err)\n-\t\tgoto out_free;\n+\tswap_cache_add_folio(folio, entry, NULL);\n \n \treturn 0;\n \n@@ -668,6 +693,321 @@ static int vswap_cpu_dead(unsigned int cpu)\n \treturn 0;\n }\n \n+/**\n+ * swap_cache_lock - lock the swap cache for a swap entry\n+ * @entry: the swap entry\n+ *\n+ * Locks the vswap cluster spinlock for the given swap entry.\n+ */\n+void swap_cache_lock(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster;\n+\tunsigned long cluster_id = VSWAP_CLUSTER_IDX(entry);\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\tVM_WARN_ON(!cluster);\n+\tspin_lock(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+/**\n+ * swap_cache_unlock - unlock the swap cache for a swap entry\n+ * @entry: the swap entry\n+ *\n+ * Unlocks the vswap cluster spinlock for the given swap entry.\n+ */\n+void swap_cache_unlock(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster;\n+\tunsigned long cluster_id = VSWAP_CLUSTER_IDX(entry);\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\tVM_WARN_ON(!cluster);\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+/**\n+ * swap_cache_lock_irq - lock the swap cache with interrupts disabled\n+ * @entry: the swap entry\n+ *\n+ * Locks the vswap cluster spinlock and disables interrupts for the given swap entry.\n+ */\n+void swap_cache_lock_irq(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster;\n+\tunsigned long cluster_id = VSWAP_CLUSTER_IDX(entry);\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\tVM_WARN_ON(!cluster);\n+\tspin_lock_irq(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+/**\n+ * swap_cache_unlock_irq - unlock the swap cache with interrupts enabled\n+ * @entry: the swap entry\n+ *\n+ * Unlocks the vswap cluster spinlock and enables interrupts for the given swap entry.\n+ */\n+void swap_cache_unlock_irq(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster;\n+\tunsigned long cluster_id = VSWAP_CLUSTER_IDX(entry);\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\tVM_WARN_ON(!cluster);\n+\tspin_unlock_irq(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+/**\n+ * swap_cache_get_folio - Looks up a folio in the swap cache.\n+ * @entry: swap entry used for the lookup.\n+ *\n+ * A found folio will be returned unlocked and with its refcount increased.\n+ *\n+ * Context: Caller must ensure @entry is valid and protect the cluster with\n+ * reference count or locks.\n+ *\n+ * Return: Returns the found folio on success, NULL otherwise. The caller\n+ * must lock and check if the folio still matches the swap entry before\n+ * use (e.g., folio_matches_swap_entry).\n+ */\n+struct folio *swap_cache_get_folio(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tstruct folio *folio;\n+\n+\tfor (;;) {\n+\t\trcu_read_lock();\n+\t\tdesc = vswap_iter(&cluster, entry.val);\n+\t\tif (!desc) {\n+\t\t\trcu_read_unlock();\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\t/* Check if this is a shadow value (xa_is_value equivalent) */\n+\t\tif (xa_is_value(desc->shadow)) {\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\t\trcu_read_unlock();\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfolio = desc->swap_cache;\n+\t\tif (!folio) {\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\t\trcu_read_unlock();\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tif (likely(folio_try_get(folio))) {\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\t\trcu_read_unlock();\n+\t\t\treturn folio;\n+\t\t}\n+\t\tspin_unlock(&cluster->lock);\n+\t\trcu_read_unlock();\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+/**\n+ * swap_cache_get_shadow - Looks up a shadow in the swap cache.\n+ * @entry: swap entry used for the lookup.\n+ *\n+ * Context: Caller must ensure @entry is valid and protect the cluster with\n+ * reference count or locks.\n+ *\n+ * Return: Returns either NULL or an XA_VALUE (shadow).\n+ */\n+void *swap_cache_get_shadow(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tvoid *shadow;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tif (!desc) {\n+\t\trcu_read_unlock();\n+\t\treturn NULL;\n+\t}\n+\n+\tshadow = desc->shadow;\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\tif (xa_is_value(shadow))\n+\t\treturn shadow;\n+\treturn NULL;\n+}\n+\n+/**\n+ * swap_cache_add_folio - Add a folio into the swap cache.\n+ * @folio: The folio to be added.\n+ * @entry: The swap entry corresponding to the folio.\n+ * @shadowp: If a shadow is found, return the shadow.\n+ *\n+ * Context: Caller must ensure @entry is valid and protect the cluster with\n+ * reference count or locks.\n+ *\n+ * The caller also needs to update the corresponding swap_map slots with\n+ * SWAP_HAS_CACHE bit to avoid race or conflict.\n+ */\n+void swap_cache_add_folio(struct folio *folio, swp_entry_t entry, void **shadowp)\n+{\n+\tstruct vswap_cluster *cluster;\n+\tunsigned long nr_pages = folio_nr_pages(folio);\n+\tunsigned long cluster_id = VSWAP_CLUSTER_IDX(entry);\n+\tunsigned long i;\n+\tstruct swp_desc *desc;\n+\tvoid *old;\n+\n+\tVM_WARN_ON_ONCE_FOLIO(!folio_test_locked(folio), folio);\n+\tVM_WARN_ON_ONCE_FOLIO(folio_test_swapcache(folio), folio);\n+\tVM_WARN_ON_ONCE_FOLIO(!folio_test_swapbacked(folio), folio);\n+\n+\tfolio_ref_add(folio, nr_pages);\n+\tfolio_set_swapcache(folio);\n+\tfolio->swap = entry;\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\tVM_WARN_ON(!cluster);\n+\tspin_lock_irq(&cluster->lock);\n+\n+\tfor (i = 0; i < nr_pages; i++) {\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n+\t\tVM_WARN_ON(!desc);\n+\t\told = desc->shadow;\n+\n+\t\t/* Warn if slot is already occupied by a folio */\n+\t\tVM_WARN_ON_FOLIO(old && !xa_is_value(old), folio);\n+\n+\t\t/* Save shadow if found and not yet saved */\n+\t\tif (shadowp && xa_is_value(old) && !*shadowp)\n+\t\t\t*shadowp = old;\n+\n+\t\tdesc->swap_cache = folio;\n+\t}\n+\n+\tspin_unlock_irq(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\tnode_stat_mod_folio(folio, NR_FILE_PAGES, nr_pages);\n+\tlruvec_stat_mod_folio(folio, NR_SWAPCACHE, nr_pages);\n+}\n+\n+/**\n+ * __swap_cache_del_folio - Removes a folio from the swap cache.\n+ * @folio: The folio.\n+ * @entry: The first swap entry that the folio corresponds to.\n+ * @shadow: shadow value to be filled in the swap cache.\n+ *\n+ * Removes a folio from the swap cache and fills a shadow in place.\n+ * This won't put the folio's refcount. The caller has to do that.\n+ *\n+ * Context: Caller must ensure the folio is locked and in the swap cache\n+ * using the index of @entry, and lock the swap cache.\n+ */\n+void __swap_cache_del_folio(struct folio *folio, swp_entry_t entry, void *shadow)\n+{\n+\tlong nr_pages = folio_nr_pages(folio);\n+\tstruct vswap_cluster *cluster;\n+\tstruct swp_desc *desc;\n+\tunsigned long cluster_id = VSWAP_CLUSTER_IDX(entry);\n+\tint i;\n+\n+\tVM_WARN_ON_ONCE_FOLIO(!folio_test_locked(folio), folio);\n+\tVM_WARN_ON_ONCE_FOLIO(!folio_test_swapcache(folio), folio);\n+\tVM_WARN_ON_ONCE_FOLIO(folio_test_writeback(folio), folio);\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\tVM_WARN_ON(!cluster);\n+\n+\tfor (i = 0; i < nr_pages; i++) {\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n+\t\tVM_WARN_ON_FOLIO(!desc || desc->swap_cache != folio, folio);\n+\t\tdesc->shadow = shadow;\n+\t}\n+\trcu_read_unlock();\n+\n+\tfolio->swap.val = 0;\n+\tfolio_clear_swapcache(folio);\n+\tnode_stat_mod_folio(folio, NR_FILE_PAGES, -nr_pages);\n+\tlruvec_stat_mod_folio(folio, NR_SWAPCACHE, -nr_pages);\n+}\n+\n+/**\n+ * swap_cache_del_folio - Removes a folio from the swap cache.\n+ * @folio: The folio.\n+ *\n+ * Same as __swap_cache_del_folio, but handles lock and refcount. The\n+ * caller must ensure the folio is either clean or has a swap count\n+ * equal to zero, or it may cause data loss.\n+ *\n+ * Context: Caller must ensure the folio is locked and in the swap cache.\n+ */\n+void swap_cache_del_folio(struct folio *folio)\n+{\n+\tswp_entry_t entry = folio->swap;\n+\n+\tswap_cache_lock_irq(entry);\n+\t__swap_cache_del_folio(folio, entry, NULL);\n+\tswap_cache_unlock_irq(entry);\n+\n+\tput_swap_folio(folio, entry);\n+\tfolio_ref_sub(folio, folio_nr_pages(folio));\n+}\n+\n+/**\n+ * __swap_cache_replace_folio - Replace a folio in the swap cache.\n+ * @old: The old folio to be replaced.\n+ * @new: The new folio.\n+ *\n+ * Replace an existing folio in the swap cache with a new folio. The\n+ * caller is responsible for setting up the new folio's flag and swap\n+ * entries. Replacement will take the new folio's swap entry value as\n+ * the starting offset to override all slots covered by the new folio.\n+ *\n+ * Context: Caller must ensure both folios are locked, and lock the\n+ * swap cache.\n+ */\n+void __swap_cache_replace_folio(struct folio *old, struct folio *new)\n+{\n+\tswp_entry_t entry = new->swap;\n+\tunsigned long nr_pages = folio_nr_pages(new);\n+\tstruct vswap_cluster *cluster;\n+\tstruct swp_desc *desc;\n+\tunsigned long cluster_id = VSWAP_CLUSTER_IDX(entry);\n+\tvoid *old_entry;\n+\tint i;\n+\n+\tVM_WARN_ON_ONCE(!folio_test_swapcache(old) || !folio_test_swapcache(new));\n+\tVM_WARN_ON_ONCE(!folio_test_locked(old) || !folio_test_locked(new));\n+\tVM_WARN_ON_ONCE(!entry.val);\n+\n+\trcu_read_lock();\n+\tcluster = xa_load(&vswap_cluster_map, cluster_id);\n+\tVM_WARN_ON(!cluster);\n+\n+\tfor (i = 0; i < nr_pages; i++) {\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n+\t\tVM_WARN_ON(!desc);\n+\t\told_entry = desc->swap_cache;\n+\t\tVM_WARN_ON(!old_entry || xa_is_value(old_entry) || old_entry != old);\n+\t\tdesc->swap_cache = new;\n+\t}\n+\trcu_read_unlock();\n+}\n \n int vswap_init(void)\n {\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the poor batching behavior of vswap free path by removing the zswap tree and managing zswap entries directly through the virtual swap descriptor, which eliminates zswap tree lock contention.",
          "sentiment": "positive",
          "sentiment_signals": [
            "eliminates zswap tree lock contention"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Remove the zswap tree and manage zswap entries directly\nthrough the virtual swap descriptor. This re-partitions the zswap pool\n(by virtual swap cluster), which eliminates zswap tree lock contention.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/zswap.h |   6 +++\n mm/vswap.c            | 100 ++++++++++++++++++++++++++++++++++++++++++\n mm/zswap.c            |  40 -----------------\n 3 files changed, 106 insertions(+), 40 deletions(-)\n\ndiff --git a/include/linux/zswap.h b/include/linux/zswap.h\nindex 1a04caf283dc8..7eb3ce7e124fc 100644\n--- a/include/linux/zswap.h\n+++ b/include/linux/zswap.h\n@@ -6,6 +6,7 @@\n #include <linux/mm_types.h>\n \n struct lruvec;\n+struct zswap_entry;\n \n extern atomic_long_t zswap_stored_pages;\n \n@@ -33,6 +34,11 @@ void zswap_lruvec_state_init(struct lruvec *lruvec);\n void zswap_folio_swapin(struct folio *folio);\n bool zswap_is_enabled(void);\n bool zswap_never_enabled(void);\n+void *zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry);\n+void *zswap_entry_load(swp_entry_t swpentry);\n+void *zswap_entry_erase(swp_entry_t swpentry);\n+bool zswap_empty(swp_entry_t swpentry);\n+\n #else\n \n struct zswap_lruvec_state {};\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex d44199dc059a3..9bb733f00fd21 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -10,6 +10,7 @@\n #include <linux/swapops.h>\n #include <linux/swap_cgroup.h>\n #include <linux/cpuhotplug.h>\n+#include <linux/zswap.h>\n #include \"swap.h\"\n #include \"swap_table.h\"\n \n@@ -37,11 +38,13 @@\n  * Swap descriptor - metadata of a swapped out page.\n  *\n  * @slot: The handle to the physical swap slot backing this page.\n+ * @zswap_entry: The zswap entry associated with this swap slot.\n  * @swap_cache: The folio in swap cache.\n  * @shadow: The shadow entry.\n  */\n struct swp_desc {\n \tswp_slot_t slot;\n+\tstruct zswap_entry *zswap_entry;\n \tunion {\n \t\tstruct folio *swap_cache;\n \t\tvoid *shadow;\n@@ -238,6 +241,7 @@ static void __vswap_alloc_from_cluster(struct vswap_cluster *cluster, int start)\n \tfor (i = 0; i < nr; i++) {\n \t\tdesc = &cluster->descriptors[start + i];\n \t\tdesc->slot.val = 0;\n+\t\tdesc->zswap_entry = NULL;\n \t}\n \tcluster->count += nr;\n }\n@@ -1009,6 +1013,102 @@ void __swap_cache_replace_folio(struct folio *old, struct folio *new)\n \trcu_read_unlock();\n }\n \n+#ifdef CONFIG_ZSWAP\n+/**\n+ * zswap_entry_store - store a zswap entry for a swap entry\n+ * @swpentry: the swap entry\n+ * @entry: the zswap entry to store\n+ *\n+ * Stores a zswap entry in the swap descriptor for the given swap entry.\n+ * The cluster is locked during the store operation.\n+ *\n+ * Return: the old zswap entry if one existed, NULL otherwise\n+ */\n+void *zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tvoid *old;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, swpentry.val);\n+\tif (!desc) {\n+\t\trcu_read_unlock();\n+\t\treturn NULL;\n+\t}\n+\n+\told = desc->zswap_entry;\n+\tdesc->zswap_entry = entry;\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\treturn old;\n+}\n+\n+/**\n+ * zswap_entry_load - load a zswap entry for a swap entry\n+ * @swpentry: the swap entry\n+ *\n+ * Loads the zswap entry from the swap descriptor for the given swap entry.\n+ *\n+ * Return: the zswap entry if one exists, NULL otherwise\n+ */\n+void *zswap_entry_load(swp_entry_t swpentry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tvoid *zswap_entry;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, swpentry.val);\n+\tif (!desc) {\n+\t\trcu_read_unlock();\n+\t\treturn NULL;\n+\t}\n+\n+\tzswap_entry = desc->zswap_entry;\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\treturn zswap_entry;\n+}\n+\n+/**\n+ * zswap_entry_erase - erase a zswap entry for a swap entry\n+ * @swpentry: the swap entry\n+ *\n+ * Erases the zswap entry from the swap descriptor for the given swap entry.\n+ * The cluster is locked during the erase operation.\n+ *\n+ * Return: the zswap entry that was erased, NULL if none existed\n+ */\n+void *zswap_entry_erase(swp_entry_t swpentry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tvoid *old;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, swpentry.val);\n+\tif (!desc) {\n+\t\trcu_read_unlock();\n+\t\treturn NULL;\n+\t}\n+\n+\told = desc->zswap_entry;\n+\tdesc->zswap_entry = NULL;\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\treturn old;\n+}\n+\n+bool zswap_empty(swp_entry_t swpentry)\n+{\n+\treturn xa_empty(&vswap_cluster_map);\n+}\n+#endif /* CONFIG_ZSWAP */\n+\n int vswap_init(void)\n {\n \tint i;\ndiff --git a/mm/zswap.c b/mm/zswap.c\nindex f7313261673ff..72441131f094e 100644\n--- a/mm/zswap.c\n+++ b/mm/zswap.c\n@@ -223,37 +223,6 @@ static bool zswap_has_pool;\n * helpers and fwd declarations\n **********************************/\n \n-static DEFINE_XARRAY(zswap_tree);\n-\n-#define zswap_tree_index(entry)\t(entry.val)\n-\n-static inline void *zswap_entry_store(swp_entry_t swpentry,\n-\t\tstruct zswap_entry *entry)\n-{\n-\tpgoff_t offset = zswap_tree_index(swpentry);\n-\n-\treturn xa_store(&zswap_tree, offset, entry, GFP_KERNEL);\n-}\n-\n-static inline void *zswap_entry_load(swp_entry_t swpentry)\n-{\n-\tpgoff_t offset = zswap_tree_index(swpentry);\n-\n-\treturn xa_load(&zswap_tree, offset);\n-}\n-\n-static inline void *zswap_entry_erase(swp_entry_t swpentry)\n-{\n-\tpgoff_t offset = zswap_tree_index(swpentry);\n-\n-\treturn xa_erase(&zswap_tree, offset);\n-}\n-\n-static inline bool zswap_empty(swp_entry_t swpentry)\n-{\n-\treturn xa_empty(&zswap_tree);\n-}\n-\n #define zswap_pool_debug(msg, p)\t\t\t\\\n \tpr_debug(\"%s pool %s\\n\", msg, (p)->tfm_name)\n \n@@ -1445,13 +1414,6 @@ static bool zswap_store_page(struct page *page,\n \t\tgoto compress_failed;\n \n \told = zswap_entry_store(page_swpentry, entry);\n-\tif (xa_is_err(old)) {\n-\t\tint err = xa_err(old);\n-\n-\t\tWARN_ONCE(err != -ENOMEM, \"unexpected xarray error: %d\\n\", err);\n-\t\tzswap_reject_alloc_fail++;\n-\t\tgoto store_failed;\n-\t}\n \n \t/*\n \t * We may have had an existing entry that became stale when\n@@ -1498,8 +1460,6 @@ static bool zswap_store_page(struct page *page,\n \n \treturn true;\n \n-store_failed:\n-\tzs_free(pool->zs_pool, entry->handle);\n compress_failed:\n \tzswap_entry_cache_free(entry);\n \treturn false;\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the memory overhead of swap cgroup information, explaining that it is now dynamically incurred when the virtual swap cluster is allocated and reducing the memory overhead in a huge but sparsely used swap space.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Once we decouple a swap entry from its backing store via the virtual\nswap, we can no longer statically allocate an array to store the swap\nentries' cgroup information. Move it to the swap descriptor.\n\nNote that the memory overhead for swap cgroup information is now on\ndemand, i.e dynamically incurred when the virtual swap cluster is\nallocated. This help reduces the memory overhead in a huge but\nsparsely used swap space.\n\nFor instance, a 2 TB swapfile consists of 2147483648 swap slots, each\nincurring 2 bytes of overhead for swap cgroup, for a total of 1 GB. If\nwe only utilize 10% of the swapfile, we will save 900 MB.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap_cgroup.h |  13 ---\n mm/Makefile                 |   3 -\n mm/swap_cgroup.c            | 174 ------------------------------------\n mm/swapfile.c               |   7 --\n mm/vswap.c                  |  95 ++++++++++++++++++++\n 5 files changed, 95 insertions(+), 197 deletions(-)\n delete mode 100644 mm/swap_cgroup.c\n\ndiff --git a/include/linux/swap_cgroup.h b/include/linux/swap_cgroup.h\nindex 91cdf12190a03..a2abb4d6fa085 100644\n--- a/include/linux/swap_cgroup.h\n+++ b/include/linux/swap_cgroup.h\n@@ -9,8 +9,6 @@\n extern void swap_cgroup_record(struct folio *folio, unsigned short id, swp_entry_t ent);\n extern unsigned short swap_cgroup_clear(swp_entry_t ent, unsigned int nr_ents);\n extern unsigned short lookup_swap_cgroup_id(swp_entry_t ent);\n-extern int swap_cgroup_swapon(int type, unsigned long max_pages);\n-extern void swap_cgroup_swapoff(int type);\n \n #else\n \n@@ -31,17 +29,6 @@ unsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n \treturn 0;\n }\n \n-static inline int\n-swap_cgroup_swapon(int type, unsigned long max_pages)\n-{\n-\treturn 0;\n-}\n-\n-static inline void swap_cgroup_swapoff(int type)\n-{\n-\treturn;\n-}\n-\n #endif\n \n #endif /* __LINUX_SWAP_CGROUP_H */\ndiff --git a/mm/Makefile b/mm/Makefile\nindex 67fa4586e7e18..a7538784191bf 100644\n--- a/mm/Makefile\n+++ b/mm/Makefile\n@@ -103,9 +103,6 @@ obj-$(CONFIG_PAGE_COUNTER) += page_counter.o\n obj-$(CONFIG_LIVEUPDATE) += memfd_luo.o\n obj-$(CONFIG_MEMCG_V1) += memcontrol-v1.o\n obj-$(CONFIG_MEMCG) += memcontrol.o vmpressure.o\n-ifdef CONFIG_SWAP\n-obj-$(CONFIG_MEMCG) += swap_cgroup.o\n-endif\n obj-$(CONFIG_CGROUP_HUGETLB) += hugetlb_cgroup.o\n obj-$(CONFIG_GUP_TEST) += gup_test.o\n obj-$(CONFIG_DMAPOOL_TEST) += dmapool_test.o\ndiff --git a/mm/swap_cgroup.c b/mm/swap_cgroup.c\ndeleted file mode 100644\nindex 77ce1d66c318d..0000000000000\n--- a/mm/swap_cgroup.c\n+++ /dev/null\n@@ -1,174 +0,0 @@\n-// SPDX-License-Identifier: GPL-2.0\n-#include <linux/swap_cgroup.h>\n-#include <linux/vmalloc.h>\n-#include <linux/mm.h>\n-\n-#include <linux/swapops.h> /* depends on mm.h include */\n-\n-static DEFINE_MUTEX(swap_cgroup_mutex);\n-\n-/* Pack two cgroup id (short) of two entries in one swap_cgroup (atomic_t) */\n-#define ID_PER_SC (sizeof(struct swap_cgroup) / sizeof(unsigned short))\n-#define ID_SHIFT (BITS_PER_TYPE(unsigned short))\n-#define ID_MASK (BIT(ID_SHIFT) - 1)\n-struct swap_cgroup {\n-\tatomic_t ids;\n-};\n-\n-struct swap_cgroup_ctrl {\n-\tstruct swap_cgroup *map;\n-};\n-\n-static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n-\n-static unsigned short __swap_cgroup_id_lookup(struct swap_cgroup *map,\n-\t\t\t\t\t      pgoff_t offset)\n-{\n-\tunsigned int shift = (offset % ID_PER_SC) * ID_SHIFT;\n-\tunsigned int old_ids = atomic_read(&map[offset / ID_PER_SC].ids);\n-\n-\tBUILD_BUG_ON(!is_power_of_2(ID_PER_SC));\n-\tBUILD_BUG_ON(sizeof(struct swap_cgroup) != sizeof(atomic_t));\n-\n-\treturn (old_ids >> shift) & ID_MASK;\n-}\n-\n-static unsigned short __swap_cgroup_id_xchg(struct swap_cgroup *map,\n-\t\t\t\t\t    pgoff_t offset,\n-\t\t\t\t\t    unsigned short new_id)\n-{\n-\tunsigned short old_id;\n-\tstruct swap_cgroup *sc = &map[offset / ID_PER_SC];\n-\tunsigned int shift = (offset % ID_PER_SC) * ID_SHIFT;\n-\tunsigned int new_ids, old_ids = atomic_read(&sc->ids);\n-\n-\tdo {\n-\t\told_id = (old_ids >> shift) & ID_MASK;\n-\t\tnew_ids = (old_ids & ~(ID_MASK << shift));\n-\t\tnew_ids |= ((unsigned int)new_id) << shift;\n-\t} while (!atomic_try_cmpxchg(&sc->ids, &old_ids, new_ids));\n-\n-\treturn old_id;\n-}\n-\n-/**\n- * swap_cgroup_record - record mem_cgroup for a set of swap entries.\n- * These entries must belong to one single folio, and that folio\n- * must be being charged for swap space (swap out), and these\n- * entries must not have been charged\n- *\n- * @folio: the folio that the swap entry belongs to\n- * @id: mem_cgroup ID to be recorded\n- * @ent: the first swap entry to be recorded\n- */\n-void swap_cgroup_record(struct folio *folio, unsigned short id,\n-\t\t\tswp_entry_t ent)\n-{\n-\tunsigned int nr_ents = folio_nr_pages(folio);\n-\tswp_slot_t slot = swp_entry_to_swp_slot(ent);\n-\tstruct swap_cgroup *map;\n-\tpgoff_t offset, end;\n-\tunsigned short old;\n-\n-\toffset = swp_slot_offset(slot);\n-\tend = offset + nr_ents;\n-\tmap = swap_cgroup_ctrl[swp_slot_type(slot)].map;\n-\n-\tdo {\n-\t\told = __swap_cgroup_id_xchg(map, offset, id);\n-\t\tVM_BUG_ON(old);\n-\t} while (++offset != end);\n-}\n-\n-/**\n- * swap_cgroup_clear - clear mem_cgroup for a set of swap entries.\n- * These entries must be being uncharged from swap. They either\n- * belongs to one single folio in the swap cache (swap in for\n- * cgroup v1), or no longer have any users (slot freeing).\n- *\n- * @ent: the first swap entry to be recorded into\n- * @nr_ents: number of swap entries to be recorded\n- *\n- * Returns the existing old value.\n- */\n-unsigned short swap_cgroup_clear(swp_entry_t ent, unsigned int nr_ents)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(ent);\n-\tpgoff_t offset = swp_slot_offset(slot);\n-\tpgoff_t end = offset + nr_ents;\n-\tstruct swap_cgroup *map;\n-\tunsigned short old, iter = 0;\n-\n-\tmap = swap_cgroup_ctrl[swp_slot_type(slot)].map;\n-\n-\tdo {\n-\t\told = __swap_cgroup_id_xchg(map, offset, 0);\n-\t\tif (!iter)\n-\t\t\titer = old;\n-\t\tVM_BUG_ON(iter != old);\n-\t} while (++offset != end);\n-\n-\treturn old;\n-}\n-\n-/**\n- * lookup_swap_cgroup_id - lookup mem_cgroup id tied to swap entry\n- * @ent: swap entry to be looked up.\n- *\n- * Returns ID of mem_cgroup at success. 0 at failure. (0 is invalid ID)\n- */\n-unsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n-{\n-\tstruct swap_cgroup_ctrl *ctrl;\n-\tswp_slot_t slot = swp_entry_to_swp_slot(ent);\n-\n-\tif (mem_cgroup_disabled())\n-\t\treturn 0;\n-\n-\tctrl = &swap_cgroup_ctrl[swp_slot_type(slot)];\n-\treturn __swap_cgroup_id_lookup(ctrl->map, swp_slot_offset(slot));\n-}\n-\n-int swap_cgroup_swapon(int type, unsigned long max_pages)\n-{\n-\tstruct swap_cgroup *map;\n-\tstruct swap_cgroup_ctrl *ctrl;\n-\n-\tif (mem_cgroup_disabled())\n-\t\treturn 0;\n-\n-\tBUILD_BUG_ON(sizeof(unsigned short) * ID_PER_SC !=\n-\t\t     sizeof(struct swap_cgroup));\n-\tmap = vzalloc(DIV_ROUND_UP(max_pages, ID_PER_SC) *\n-\t\t      sizeof(struct swap_cgroup));\n-\tif (!map)\n-\t\tgoto nomem;\n-\n-\tctrl = &swap_cgroup_ctrl[type];\n-\tmutex_lock(&swap_cgroup_mutex);\n-\tctrl->map = map;\n-\tmutex_unlock(&swap_cgroup_mutex);\n-\n-\treturn 0;\n-nomem:\n-\tpr_info(\"couldn't allocate enough memory for swap_cgroup\\n\");\n-\tpr_info(\"swap_cgroup can be disabled by swapaccount=0 boot option\\n\");\n-\treturn -ENOMEM;\n-}\n-\n-void swap_cgroup_swapoff(int type)\n-{\n-\tstruct swap_cgroup *map;\n-\tstruct swap_cgroup_ctrl *ctrl;\n-\n-\tif (mem_cgroup_disabled())\n-\t\treturn;\n-\n-\tmutex_lock(&swap_cgroup_mutex);\n-\tctrl = &swap_cgroup_ctrl[type];\n-\tmap = ctrl->map;\n-\tctrl->map = NULL;\n-\tmutex_unlock(&swap_cgroup_mutex);\n-\n-\tvfree(map);\n-}\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 68ec5d9f05848..345877786e432 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -2931,8 +2931,6 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \tvfree(swap_map);\n \tkvfree(zeromap);\n \tfree_cluster_info(cluster_info, maxpages);\n-\t/* Destroy swap account information */\n-\tswap_cgroup_swapoff(p->type);\n \n \tinode = mapping->host;\n \n@@ -3497,10 +3495,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \t\tgoto bad_swap_unlock_inode;\n \t}\n \n-\terror = swap_cgroup_swapon(si->type, maxpages);\n-\tif (error)\n-\t\tgoto bad_swap_unlock_inode;\n-\n \terror = setup_swap_map(si, swap_header, swap_map, maxpages);\n \tif (error)\n \t\tgoto bad_swap_unlock_inode;\n@@ -3605,7 +3599,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tsi->global_cluster = NULL;\n \tinode = NULL;\n \tdestroy_swap_extents(si);\n-\tswap_cgroup_swapoff(si->type);\n \tspin_lock(&swap_lock);\n \tsi->swap_file = NULL;\n \tsi->flags = 0;\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex 9bb733f00fd21..64747493ca9f7 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -41,6 +41,7 @@\n  * @zswap_entry: The zswap entry associated with this swap slot.\n  * @swap_cache: The folio in swap cache.\n  * @shadow: The shadow entry.\n+ * @memcgid: The memcg id of the owning memcg, if any.\n  */\n struct swp_desc {\n \tswp_slot_t slot;\n@@ -49,6 +50,9 @@ struct swp_desc {\n \t\tstruct folio *swap_cache;\n \t\tvoid *shadow;\n \t};\n+#ifdef CONFIG_MEMCG\n+\tunsigned short memcgid;\n+#endif\n };\n \n #define VSWAP_CLUSTER_SHIFT HPAGE_PMD_ORDER\n@@ -242,6 +246,9 @@ static void __vswap_alloc_from_cluster(struct vswap_cluster *cluster, int start)\n \t\tdesc = &cluster->descriptors[start + i];\n \t\tdesc->slot.val = 0;\n \t\tdesc->zswap_entry = NULL;\n+#ifdef CONFIG_MEMCG\n+\t\tdesc->memcgid = 0;\n+#endif\n \t}\n \tcluster->count += nr;\n }\n@@ -1109,6 +1116,94 @@ bool zswap_empty(swp_entry_t swpentry)\n }\n #endif /* CONFIG_ZSWAP */\n \n+#ifdef CONFIG_MEMCG\n+static unsigned short vswap_cgroup_record(swp_entry_t entry,\n+\t\t\t\tunsigned short memcgid, unsigned int nr_ents)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tunsigned short oldid, iter = 0;\n+\tint i;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr_ents; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tVM_WARN_ON(!desc);\n+\t\toldid = desc->memcgid;\n+\t\tdesc->memcgid = memcgid;\n+\t\tif (!iter)\n+\t\t\titer = oldid;\n+\t\tVM_WARN_ON(iter != oldid);\n+\t}\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\treturn oldid;\n+}\n+\n+/**\n+ * swap_cgroup_record - record mem_cgroup for a set of swap entries.\n+ * These entries must belong to one single folio, and that folio\n+ * must be being charged for swap space (swap out), and these\n+ * entries must not have been charged\n+ *\n+ * @folio: the folio that the swap entry belongs to\n+ * @memcgid: mem_cgroup ID to be recorded\n+ * @entry: the first swap entry to be recorded\n+ */\n+void swap_cgroup_record(struct folio *folio, unsigned short memcgid,\n+\t\t\tswp_entry_t entry)\n+{\n+\tunsigned short oldid =\n+\t\tvswap_cgroup_record(entry, memcgid, folio_nr_pages(folio));\n+\n+\tVM_WARN_ON(oldid);\n+}\n+\n+/**\n+ * swap_cgroup_clear - clear mem_cgroup for a set of swap entries.\n+ * These entries must be being uncharged from swap. They either\n+ * belongs to one single folio in the swap cache (swap in for\n+ * cgroup v1), or no longer have any users (slot freeing).\n+ *\n+ * @entry: the first swap entry to be recorded into\n+ * @nr_ents: number of swap entries to be recorded\n+ *\n+ * Returns the existing old value.\n+ */\n+unsigned short swap_cgroup_clear(swp_entry_t entry, unsigned int nr_ents)\n+{\n+\treturn vswap_cgroup_record(entry, 0, nr_ents);\n+}\n+\n+/**\n+ * lookup_swap_cgroup_id - lookup mem_cgroup id tied to swap entry\n+ * @entry: swap entry to be looked up.\n+ *\n+ * Returns ID of mem_cgroup at success. 0 at failure. (0 is invalid ID)\n+ */\n+unsigned short lookup_swap_cgroup_id(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tunsigned short ret;\n+\n+\t/*\n+\t * Note that the virtual swap slot can be freed under us, for instance in\n+\t * the invocation of mem_cgroup_swapin_charge_folio. We need to wrap the\n+\t * entire lookup in RCU read-side critical section, and double check the\n+\t * existence of the swap descriptor.\n+\t */\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tret = desc ? desc->memcgid : 0;\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\treturn ret;\n+}\n+#endif /* CONFIG_MEMCG */\n+\n int vswap_init(void)\n {\n \tint i;\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the vswap free path's poor batching behavior by explaining that they have re-implemented all swap entry lifecycle API in the virtual swap layer, but did not implement swap count continuation yet.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "This patch moves the swap entry lifecycle management to the virtual swap\nlayer by adding to the swap descriptor two fields:\n\n1. in_swapcache, i.e whether the swap entry is in swap cache (or about\n   to be added).\n2. The swap count of the swap entry, which counts the number of page\n   table entries at which the swap entry is inserted.\n\nand re-implementing all of the swap entry lifecycle API\n(swap_duplicate(), swap_free_nr(), swapcache_prepare(), etc.) in the\nvirtual swap layer.\n\nFor now, we do not implement swap count continuation - the swap_count\nfield in the swap descriptor is big enough to hold the maximum number of\nswap counts. This vastly simplifies the logic.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h  |  29 +-\n include/linux/zswap.h |   5 +-\n mm/memory.c           |   8 +-\n mm/shmem.c            |   4 +-\n mm/swap.h             |  58 ++--\n mm/swap_state.c       |   4 +-\n mm/swapfile.c         | 786 ++----------------------------------------\n mm/vswap.c            | 452 ++++++++++++++++++++++--\n mm/zswap.c            |  14 +-\n 9 files changed, 502 insertions(+), 858 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex 0410a00fd353c..aae2e502d9975 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -223,17 +223,9 @@ enum {\n #define SWAP_CLUSTER_MAX_SKIPPED (SWAP_CLUSTER_MAX << 10)\n #define COMPACT_CLUSTER_MAX SWAP_CLUSTER_MAX\n \n-/* Bit flag in swap_map */\n-#define SWAP_HAS_CACHE\t0x40\t/* Flag page is cached, in first swap_map */\n-#define COUNT_CONTINUED\t0x80\t/* Flag swap_map continuation for full count */\n-\n-/* Special value in first swap_map */\n-#define SWAP_MAP_MAX\t0x3e\t/* Max count */\n-#define SWAP_MAP_BAD\t0x3f\t/* Note page is bad */\n-#define SWAP_MAP_SHMEM\t0xbf\t/* Owned by shmem/tmpfs */\n-\n-/* Special value in each swap_map continuation */\n-#define SWAP_CONT_MAX\t0x7f\t/* Max count */\n+/* Swapfile's swap map state*/\n+#define SWAP_MAP_ALLOCATED\t0x01\t/* Page is allocated */\n+#define SWAP_MAP_BAD\t0x02\t/* Page is bad */\n \n /*\n  * The first page in the swap file is the swap header, which is always marked\n@@ -423,7 +415,7 @@ extern void __meminit kswapd_stop(int nid);\n \n #ifdef CONFIG_SWAP\n \n-/* Lifecycle swap API (mm/swapfile.c) */\n+/* Lifecycle swap API (mm/swapfile.c and mm/vswap.c) */\n int folio_alloc_swap(struct folio *folio);\n bool folio_free_swap(struct folio *folio);\n void put_swap_folio(struct folio *folio, swp_entry_t entry);\n@@ -433,7 +425,7 @@ int swapcache_prepare(swp_entry_t entry, int nr);\n void swap_free_nr(swp_entry_t entry, int nr_pages);\n void free_swap_and_cache_nr(swp_entry_t entry, int nr);\n int __swap_count(swp_entry_t entry);\n-bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry);\n+bool swap_entry_swapped(swp_entry_t entry);\n int swp_swapcount(swp_entry_t entry);\n bool is_swap_cached(swp_entry_t entry);\n \n@@ -473,7 +465,6 @@ static inline long get_nr_swap_pages(void)\n void si_swapinfo(struct sysinfo *);\n int swap_slot_alloc(swp_slot_t *slot, unsigned int order);\n swp_slot_t swap_slot_alloc_of_type(int);\n-int add_swap_count_continuation(swp_entry_t, gfp_t);\n int swap_type_of(dev_t device, sector_t offset);\n int find_first_swap(dev_t *device);\n unsigned int count_swap_pages(int, int);\n@@ -517,11 +508,6 @@ static inline void free_swap_cache(struct folio *folio)\n {\n }\n \n-static inline int add_swap_count_continuation(swp_entry_t swp, gfp_t gfp_mask)\n-{\n-\treturn 0;\n-}\n-\n static inline void swap_shmem_alloc(swp_entry_t swp, int nr)\n {\n }\n@@ -549,7 +535,7 @@ static inline int __swap_count(swp_entry_t entry)\n \treturn 0;\n }\n \n-static inline bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry)\n+static inline bool swap_entry_swapped(swp_entry_t entry)\n {\n \treturn false;\n }\n@@ -672,11 +658,12 @@ static inline bool mem_cgroup_swap_full(struct folio *folio)\n \n int vswap_init(void);\n void vswap_exit(void);\n-void vswap_free(swp_entry_t entry, struct swap_cluster_info *ci);\n swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry);\n swp_entry_t swp_slot_to_swp_entry(swp_slot_t slot);\n bool tryget_swap_entry(swp_entry_t entry, struct swap_info_struct **si);\n void put_swap_entry(swp_entry_t entry, struct swap_info_struct *si);\n+bool folio_swapped(struct folio *folio);\n+bool vswap_only_has_cache(swp_entry_t entry, int nr);\n \n #endif /* __KERNEL__*/\n #endif /* _LINUX_SWAP_H */\ndiff --git a/include/linux/zswap.h b/include/linux/zswap.h\nindex 7eb3ce7e124fc..07b2936c38f29 100644\n--- a/include/linux/zswap.h\n+++ b/include/linux/zswap.h\n@@ -28,7 +28,6 @@ struct zswap_lruvec_state {\n unsigned long zswap_total_pages(void);\n bool zswap_store(struct folio *folio);\n int zswap_load(struct folio *folio);\n-void zswap_invalidate(swp_entry_t swp);\n void zswap_memcg_offline_cleanup(struct mem_cgroup *memcg);\n void zswap_lruvec_state_init(struct lruvec *lruvec);\n void zswap_folio_swapin(struct folio *folio);\n@@ -38,6 +37,7 @@ void *zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry);\n void *zswap_entry_load(swp_entry_t swpentry);\n void *zswap_entry_erase(swp_entry_t swpentry);\n bool zswap_empty(swp_entry_t swpentry);\n+void zswap_entry_free(struct zswap_entry *entry);\n \n #else\n \n@@ -53,7 +53,6 @@ static inline int zswap_load(struct folio *folio)\n \treturn -ENOENT;\n }\n \n-static inline void zswap_invalidate(swp_entry_t swp) {}\n static inline void zswap_memcg_offline_cleanup(struct mem_cgroup *memcg) {}\n static inline void zswap_lruvec_state_init(struct lruvec *lruvec) {}\n static inline void zswap_folio_swapin(struct folio *folio) {}\n@@ -68,6 +67,8 @@ static inline bool zswap_never_enabled(void)\n \treturn true;\n }\n \n+static inline void zswap_entry_free(struct zswap_entry *entry) {}\n+\n #endif\n \n #endif /* _LINUX_ZSWAP_H */\ndiff --git a/mm/memory.c b/mm/memory.c\nindex 90031f833f52e..641e3f65edc00 100644\n--- a/mm/memory.c\n+++ b/mm/memory.c\n@@ -1333,10 +1333,6 @@ copy_pte_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,\n \n \tif (ret == -EIO) {\n \t\tVM_WARN_ON_ONCE(!entry.val);\n-\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0) {\n-\t\t\tret = -ENOMEM;\n-\t\t\tgoto out;\n-\t\t}\n \t\tentry.val = 0;\n \t} else if (ret == -EBUSY || unlikely(ret == -EHWPOISON)) {\n \t\tgoto out;\n@@ -5044,7 +5040,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n out:\n \t/* Clear the swap cache pin for direct swapin after PTL unlock */\n \tif (need_clear_cache) {\n-\t\tswapcache_clear(si, entry, nr_pages);\n+\t\tswapcache_clear(entry, nr_pages);\n \t\tif (waitqueue_active(&swapcache_wq))\n \t\t\twake_up(&swapcache_wq);\n \t}\n@@ -5063,7 +5059,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\tfolio_put(swapcache);\n \t}\n \tif (need_clear_cache) {\n-\t\tswapcache_clear(si, entry, nr_pages);\n+\t\tswapcache_clear(entry, nr_pages);\n \t\tif (waitqueue_active(&swapcache_wq))\n \t\t\twake_up(&swapcache_wq);\n \t}\ndiff --git a/mm/shmem.c b/mm/shmem.c\nindex 66cf8af6779ca..780571c830e5b 100644\n--- a/mm/shmem.c\n+++ b/mm/shmem.c\n@@ -2442,7 +2442,7 @@ static int shmem_swapin_folio(struct inode *inode, pgoff_t index,\n \n \tif (skip_swapcache) {\n \t\tfolio->swap.val = 0;\n-\t\tswapcache_clear(si, swap, nr_pages);\n+\t\tswapcache_clear(swap, nr_pages);\n \t} else {\n \t\tswap_cache_del_folio(folio);\n \t}\n@@ -2463,7 +2463,7 @@ static int shmem_swapin_folio(struct inode *inode, pgoff_t index,\n \t\tfolio_unlock(folio);\n failed_nolock:\n \tif (skip_swapcache)\n-\t\tswapcache_clear(si, folio->swap, folio_nr_pages(folio));\n+\t\tswapcache_clear(folio->swap, folio_nr_pages(folio));\n \tif (folio)\n \t\tfolio_put(folio);\n \tput_swap_entry(swap, si);\ndiff --git a/mm/swap.h b/mm/swap.h\nindex 57ed24a2d6356..ae97cf9712c5c 100644\n--- a/mm/swap.h\n+++ b/mm/swap.h\n@@ -211,6 +211,8 @@ void swap_cache_lock_irq(swp_entry_t entry);\n void swap_cache_unlock_irq(swp_entry_t entry);\n void swap_cache_lock(swp_entry_t entry);\n void swap_cache_unlock(swp_entry_t entry);\n+void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n+\t\t\t   unsigned long vswap, int nr);\n \n static inline struct address_space *swap_address_space(swp_entry_t entry)\n {\n@@ -245,6 +247,31 @@ static inline bool folio_matches_swap_entry(const struct folio *folio,\n \treturn folio_entry.val == round_down(entry.val, nr_pages);\n }\n \n+/**\n+ * folio_matches_swap_slot - Check if a folio matches both the virtual\n+ *                           swap entry and its backing physical swap slot.\n+ * @folio: The folio.\n+ * @entry: The virtual swap entry to check against.\n+ * @slot: The physical swap slot to check against.\n+ *\n+ * Context: The caller should have the folio locked to ensure it's stable\n+ * and nothing will move it in or out of the swap cache.\n+ * Return: true if both checks pass, false otherwise.\n+ */\n+static inline bool folio_matches_swap_slot(const struct folio *folio,\n+\t\t\t\t\t   swp_entry_t entry,\n+\t\t\t\t\t   swp_slot_t slot)\n+{\n+\tif (!folio_matches_swap_entry(folio, entry))\n+\t\treturn false;\n+\n+\t/*\n+\t * Confirm the virtual swap entry is still backed by the same\n+\t * physical swap slot.\n+\t */\n+\treturn slot.val == swp_entry_to_swp_slot(entry).val;\n+}\n+\n /*\n  * All swap cache helpers below require the caller to ensure the swap entries\n  * used are valid and stablize the device by any of the following ways:\n@@ -265,7 +292,7 @@ void __swap_cache_del_folio(struct folio *folio, swp_entry_t entry, void *shadow\n void __swap_cache_replace_folio(struct folio *old, struct folio *new);\n \n void show_swap_cache_info(void);\n-void swapcache_clear(struct swap_info_struct *si, swp_entry_t entry, int nr);\n+void swapcache_clear(swp_entry_t entry, int nr);\n struct folio *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \t\tstruct vm_area_struct *vma, unsigned long addr,\n \t\tstruct swap_iocb **plug);\n@@ -312,25 +339,7 @@ static inline int swap_zeromap_batch(swp_entry_t entry, int max_nr,\n \t\treturn find_next_bit(sis->zeromap, end, start) - start;\n }\n \n-static inline int non_swapcache_batch(swp_entry_t entry, int max_nr)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *si = __swap_slot_to_info(slot);\n-\tpgoff_t offset = swp_slot_offset(slot);\n-\tint i;\n-\n-\t/*\n-\t * While allocating a large folio and doing mTHP swapin, we need to\n-\t * ensure all entries are not cached, otherwise, the mTHP folio will\n-\t * be in conflict with the folio in swap cache.\n-\t */\n-\tfor (i = 0; i < max_nr; i++) {\n-\t\tif ((si->swap_map[offset + i] & SWAP_HAS_CACHE))\n-\t\t\treturn i;\n-\t}\n-\n-\treturn i;\n-}\n+int non_swapcache_batch(swp_entry_t entry, int max_nr);\n \n #else /* CONFIG_SWAP */\n struct swap_iocb;\n@@ -382,6 +391,13 @@ static inline bool folio_matches_swap_entry(const struct folio *folio, swp_entry\n \treturn false;\n }\n \n+static inline bool folio_matches_swap_slot(const struct folio *folio,\n+\t\t\t\t\t   swp_entry_t entry,\n+\t\t\t\t\t   swp_slot_t slot)\n+{\n+\treturn false;\n+}\n+\n static inline void show_swap_cache_info(void)\n {\n }\n@@ -409,7 +425,7 @@ static inline int swap_writeout(struct folio *folio,\n \treturn 0;\n }\n \n-static inline void swapcache_clear(struct swap_info_struct *si, swp_entry_t entry, int nr)\n+static inline void swapcache_clear(swp_entry_t entry, int nr)\n {\n }\n \ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex 00fa3e76a5c19..1827527e88d33 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -174,8 +174,6 @@ struct folio *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \t\tstruct mempolicy *mpol, pgoff_t ilx, bool *new_page_allocated,\n \t\tbool skip_if_exists)\n {\n-\tstruct swap_info_struct *si =\n-\t\t__swap_slot_to_info(swp_entry_to_swp_slot(entry));\n \tstruct folio *folio;\n \tstruct folio *new_folio = NULL;\n \tstruct folio *result = NULL;\n@@ -196,7 +194,7 @@ struct folio *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \t\t/*\n \t\t * Just skip read ahead for unused swap slot.\n \t\t */\n-\t\tif (!swap_entry_swapped(si, entry))\n+\t\tif (!swap_entry_swapped(entry))\n \t\t\tgoto put_and_return;\n \n \t\t/*\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 345877786e432..6c5e46bf40701 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -50,9 +50,6 @@\n #include \"internal.h\"\n #include \"swap.h\"\n \n-static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n-\t\t\t\t unsigned char);\n-static void free_swap_count_continuations(struct swap_info_struct *);\n static void swap_slots_free(struct swap_info_struct *si,\n \t\t\t      struct swap_cluster_info *ci,\n \t\t\t      swp_slot_t slot, unsigned int nr_pages);\n@@ -146,7 +143,7 @@ static struct swap_info_struct *swap_slot_to_info(swp_slot_t slot)\n \n static inline unsigned char swap_count(unsigned char ent)\n {\n-\treturn ent & ~SWAP_HAS_CACHE;\t/* may include COUNT_CONTINUED flag */\n+\treturn ent;\n }\n \n /*\n@@ -182,52 +179,14 @@ static long swap_usage_in_pages(struct swap_info_struct *si)\n static bool swap_only_has_cache(struct swap_info_struct *si,\n \t\t\t      unsigned long offset, int nr_pages)\n {\n-\tunsigned char *map = si->swap_map + offset;\n-\tunsigned char *map_end = map + nr_pages;\n-\n-\tdo {\n-\t\tVM_BUG_ON(!(*map & SWAP_HAS_CACHE));\n-\t\tif (*map != SWAP_HAS_CACHE)\n-\t\t\treturn false;\n-\t} while (++map < map_end);\n+\tswp_entry_t entry = swp_slot_to_swp_entry(swp_slot(si->type, offset));\n \n-\treturn true;\n+\treturn vswap_only_has_cache(entry, nr_pages);\n }\n \n-/**\n- * is_swap_cached - check if the swap entry is cached\n- * @entry: swap entry to check\n- *\n- * Check swap_map directly to minimize overhead, READ_ONCE is sufficient.\n- *\n- * Returns true if the swap entry is cached, false otherwise.\n- */\n-bool is_swap_cached(swp_entry_t entry)\n+static bool swap_cache_only(struct swap_info_struct *si, unsigned long offset)\n {\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *si = swap_slot_to_info(slot);\n-\tunsigned long offset = swp_slot_offset(slot);\n-\n-\treturn READ_ONCE(si->swap_map[offset]) & SWAP_HAS_CACHE;\n-}\n-\n-static bool swap_is_last_map(struct swap_info_struct *si,\n-\t\tunsigned long offset, int nr_pages, bool *has_cache)\n-{\n-\tunsigned char *map = si->swap_map + offset;\n-\tunsigned char *map_end = map + nr_pages;\n-\tunsigned char count = *map;\n-\n-\tif (swap_count(count) != 1 && swap_count(count) != SWAP_MAP_SHMEM)\n-\t\treturn false;\n-\n-\twhile (++map < map_end) {\n-\t\tif (*map != count)\n-\t\t\treturn false;\n-\t}\n-\n-\t*has_cache = !!(count & SWAP_HAS_CACHE);\n-\treturn true;\n+\treturn swap_only_has_cache(si, offset, 1);\n }\n \n /*\n@@ -238,15 +197,15 @@ static bool swap_is_last_map(struct swap_info_struct *si,\n static int __try_to_reclaim_swap(struct swap_info_struct *si,\n \t\t\t\t unsigned long offset, unsigned long flags)\n {\n-\tconst swp_entry_t entry =\n-\t\tswp_slot_to_swp_entry(swp_slot(si->type, offset));\n-\tswp_slot_t slot;\n+\tconst swp_slot_t slot = swp_slot(si->type, offset);\n+\tswp_entry_t entry;\n \tstruct swap_cluster_info *ci;\n \tstruct folio *folio;\n \tint ret, nr_pages;\n \tbool need_reclaim;\n \n again:\n+\tentry = swp_slot_to_swp_entry(slot);\n \tfolio = swap_cache_get_folio(entry);\n \tif (!folio)\n \t\treturn 0;\n@@ -266,14 +225,15 @@ static int __try_to_reclaim_swap(struct swap_info_struct *si,\n \t/*\n \t * Offset could point to the middle of a large folio, or folio\n \t * may no longer point to the expected offset before it's locked.\n+\t * Additionally, the virtual swap entry may no longer be backed\n+\t * by the same physical swap slot.\n \t */\n-\tif (!folio_matches_swap_entry(folio, entry)) {\n+\tif (!folio_matches_swap_slot(folio, entry, slot)) {\n \t\tfolio_unlock(folio);\n \t\tfolio_put(folio);\n \t\tgoto again;\n \t}\n-\tslot = swp_entry_to_swp_slot(folio->swap);\n-\toffset = swp_slot_offset(slot);\n+\toffset = swp_slot_offset(swp_entry_to_swp_slot(folio->swap));\n \n \tneed_reclaim = ((flags & TTRS_ANYWAY) ||\n \t\t\t((flags & TTRS_UNMAPPED) && !folio_mapped(folio)) ||\n@@ -283,8 +243,7 @@ static int __try_to_reclaim_swap(struct swap_info_struct *si,\n \n \t/*\n \t * It's safe to delete the folio from swap cache only if the folio's\n-\t * swap_map is HAS_CACHE only, which means the slots have no page table\n-\t * reference or pending writeback, and can't be allocated to others.\n+\t * swap slots have no page table reference or pending writeback.\n \t */\n \tci = swap_cluster_lock(si, offset);\n \tneed_reclaim = swap_only_has_cache(si, offset, nr_pages);\n@@ -811,7 +770,7 @@ static bool cluster_reclaim_range(struct swap_info_struct *si,\n \t\tcase 0:\n \t\t\toffset++;\n \t\t\tbreak;\n-\t\tcase SWAP_HAS_CACHE:\n+\t\tcase SWAP_MAP_ALLOCATED:\n \t\t\tnr_reclaim = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n \t\t\tif (nr_reclaim > 0)\n \t\t\t\toffset += nr_reclaim;\n@@ -842,22 +801,23 @@ static bool cluster_scan_range(struct swap_info_struct *si,\n {\n \tunsigned long offset, end = start + nr_pages;\n \tunsigned char *map = si->swap_map;\n+\tunsigned char count;\n \n \tif (cluster_is_empty(ci))\n \t\treturn true;\n \n \tfor (offset = start; offset < end; offset++) {\n-\t\tswitch (READ_ONCE(map[offset])) {\n-\t\tcase 0:\n+\t\tcount = READ_ONCE(map[offset]);\n+\t\tif (!count)\n \t\t\tcontinue;\n-\t\tcase SWAP_HAS_CACHE:\n+\n+\t\tif (swap_cache_only(si, offset)) {\n \t\t\tif (!vm_swap_full())\n \t\t\t\treturn false;\n \t\t\t*need_reclaim = true;\n \t\t\tcontinue;\n-\t\tdefault:\n-\t\t\treturn false;\n \t\t}\n+\t\treturn false;\n \t}\n \n \treturn true;\n@@ -974,7 +934,6 @@ static void swap_reclaim_full_clusters(struct swap_info_struct *si, bool force)\n \tlong to_scan = 1;\n \tunsigned long offset, end;\n \tstruct swap_cluster_info *ci;\n-\tunsigned char *map = si->swap_map;\n \tint nr_reclaim;\n \n \tif (force)\n@@ -986,7 +945,7 @@ static void swap_reclaim_full_clusters(struct swap_info_struct *si, bool force)\n \t\tto_scan--;\n \n \t\twhile (offset < end) {\n-\t\t\tif (READ_ONCE(map[offset]) == SWAP_HAS_CACHE) {\n+\t\t\tif (swap_cache_only(si, offset)) {\n \t\t\t\tspin_unlock(&ci->lock);\n \t\t\t\tnr_reclaim = __try_to_reclaim_swap(si, offset,\n \t\t\t\t\t\t\t\t   TTRS_ANYWAY);\n@@ -1320,7 +1279,8 @@ static bool swap_alloc_fast(swp_slot_t *slot, int order)\n \tif (cluster_is_usable(ci, order)) {\n \t\tif (cluster_is_empty(ci))\n \t\t\toffset = cluster_offset(si, ci);\n-\t\tfound = alloc_swap_scan_cluster(si, ci, offset, order, SWAP_HAS_CACHE);\n+\t\tfound = alloc_swap_scan_cluster(si, ci, offset, order,\n+\t\t\tSWAP_MAP_ALLOCATED);\n \t\tif (found)\n \t\t\t*slot = swp_slot(si->type, found);\n \t} else {\n@@ -1344,7 +1304,7 @@ static void swap_alloc_slow(swp_slot_t *slot, int order)\n \t\tplist_requeue(&si->avail_list, &swap_avail_head);\n \t\tspin_unlock(&swap_avail_lock);\n \t\tif (get_swap_device_info(si)) {\n-\t\t\toffset = cluster_alloc_swap_slot(si, order, SWAP_HAS_CACHE);\n+\t\t\toffset = cluster_alloc_swap_slot(si, order, SWAP_MAP_ALLOCATED);\n \t\t\tswap_slot_put_swap_info(si);\n \t\t\tif (offset) {\n \t\t\t\t*slot = swp_slot(si->type, offset);\n@@ -1471,48 +1431,6 @@ static struct swap_info_struct *_swap_info_get(swp_slot_t slot)\n \treturn NULL;\n }\n \n-static unsigned char swap_slot_put_locked(struct swap_info_struct *si,\n-\t\t\t\t\t   struct swap_cluster_info *ci,\n-\t\t\t\t\t   swp_slot_t slot,\n-\t\t\t\t\t   unsigned char usage)\n-{\n-\tunsigned long offset = swp_slot_offset(slot);\n-\tunsigned char count;\n-\tunsigned char has_cache;\n-\n-\tcount = si->swap_map[offset];\n-\n-\thas_cache = count & SWAP_HAS_CACHE;\n-\tcount &= ~SWAP_HAS_CACHE;\n-\n-\tif (usage == SWAP_HAS_CACHE) {\n-\t\tVM_BUG_ON(!has_cache);\n-\t\thas_cache = 0;\n-\t} else if (count == SWAP_MAP_SHMEM) {\n-\t\t/*\n-\t\t * Or we could insist on shmem.c using a special\n-\t\t * swap_shmem_free() and free_shmem_swap_and_cache()...\n-\t\t */\n-\t\tcount = 0;\n-\t} else if ((count & ~COUNT_CONTINUED) <= SWAP_MAP_MAX) {\n-\t\tif (count == COUNT_CONTINUED) {\n-\t\t\tif (swap_count_continued(si, offset, count))\n-\t\t\t\tcount = SWAP_MAP_MAX | COUNT_CONTINUED;\n-\t\t\telse\n-\t\t\t\tcount = SWAP_MAP_MAX;\n-\t\t} else\n-\t\t\tcount--;\n-\t}\n-\n-\tusage = count | has_cache;\n-\tif (usage)\n-\t\tWRITE_ONCE(si->swap_map[offset], usage);\n-\telse\n-\t\tswap_slots_free(si, ci, slot, 1);\n-\n-\treturn usage;\n-}\n-\n /*\n  * When we get a swap entry, if there aren't some other ways to\n  * prevent swapoff, such as the folio in swap cache is locked, RCU\n@@ -1580,94 +1498,23 @@ struct swap_info_struct *swap_slot_tryget_swap_info(swp_slot_t slot)\n \treturn NULL;\n }\n \n-static void swap_slots_put_cache(struct swap_info_struct *si,\n-\t\t\t\t   swp_slot_t slot, int nr)\n-{\n-\tunsigned long offset = swp_slot_offset(slot);\n-\tstruct swap_cluster_info *ci;\n-\n-\tci = swap_cluster_lock(si, offset);\n-\tif (swap_only_has_cache(si, offset, nr)) {\n-\t\tswap_slots_free(si, ci, slot, nr);\n-\t} else {\n-\t\tfor (int i = 0; i < nr; i++, slot.val++)\n-\t\t\tswap_slot_put_locked(si, ci, slot, SWAP_HAS_CACHE);\n-\t}\n-\tswap_cluster_unlock(ci);\n-}\n-\n static bool swap_slots_put_map(struct swap_info_struct *si,\n \t\t\t\t swp_slot_t slot, int nr)\n {\n \tunsigned long offset = swp_slot_offset(slot);\n \tstruct swap_cluster_info *ci;\n-\tbool has_cache = false;\n-\tunsigned char count;\n-\tint i;\n-\n-\tif (nr <= 1)\n-\t\tgoto fallback;\n-\tcount = swap_count(data_race(si->swap_map[offset]));\n-\tif (count != 1 && count != SWAP_MAP_SHMEM)\n-\t\tgoto fallback;\n \n \tci = swap_cluster_lock(si, offset);\n-\tif (!swap_is_last_map(si, offset, nr, &has_cache)) {\n-\t\tgoto locked_fallback;\n-\t}\n-\tif (!has_cache)\n-\t\tswap_slots_free(si, ci, slot, nr);\n-\telse\n-\t\tfor (i = 0; i < nr; i++)\n-\t\t\tWRITE_ONCE(si->swap_map[offset + i], SWAP_HAS_CACHE);\n+\tvswap_rmap_set(ci, slot, 0, nr);\n+\tswap_slots_free(si, ci, slot, nr);\n \tswap_cluster_unlock(ci);\n \n-\treturn has_cache;\n-\n-fallback:\n-\tci = swap_cluster_lock(si, offset);\n-locked_fallback:\n-\tfor (i = 0; i < nr; i++, slot.val++) {\n-\t\tcount = swap_slot_put_locked(si, ci, slot, 1);\n-\t\tif (count == SWAP_HAS_CACHE)\n-\t\t\thas_cache = true;\n-\t}\n-\tswap_cluster_unlock(ci);\n-\treturn has_cache;\n-}\n-\n-/*\n- * Only functions with \"_nr\" suffix are able to free entries spanning\n- * cross multi clusters, so ensure the range is within a single cluster\n- * when freeing entries with functions without \"_nr\" suffix.\n- */\n-static bool swap_slots_put_map_nr(struct swap_info_struct *si,\n-\t\t\t\t    swp_slot_t slot, int nr)\n-{\n-\tint cluster_nr, cluster_rest;\n-\tunsigned long offset = swp_slot_offset(slot);\n-\tbool has_cache = false;\n-\n-\tcluster_rest = SWAPFILE_CLUSTER - offset % SWAPFILE_CLUSTER;\n-\twhile (nr) {\n-\t\tcluster_nr = min(nr, cluster_rest);\n-\t\thas_cache |= swap_slots_put_map(si, slot, cluster_nr);\n-\t\tcluster_rest = SWAPFILE_CLUSTER;\n-\t\tnr -= cluster_nr;\n-\t\tslot.val += cluster_nr;\n-\t}\n-\n-\treturn has_cache;\n+\treturn true;\n }\n \n-/*\n- * Check if it's the last ref of swap entry in the freeing path.\n- * Qualified value includes 1, SWAP_HAS_CACHE or SWAP_MAP_SHMEM.\n- */\n static inline bool __maybe_unused swap_is_last_ref(unsigned char count)\n {\n-\treturn (count == SWAP_HAS_CACHE) || (count == 1) ||\n-\t       (count == SWAP_MAP_SHMEM);\n+\treturn count == SWAP_MAP_ALLOCATED;\n }\n \n /*\n@@ -1681,14 +1528,6 @@ static void swap_slots_free(struct swap_info_struct *si,\n \tunsigned long offset = swp_slot_offset(slot);\n \tunsigned char *map = si->swap_map + offset;\n \tunsigned char *map_end = map + nr_pages;\n-\tswp_entry_t entry = swp_slot_to_swp_entry(slot);\n-\tint i;\n-\n-\t/* release all the associated (virtual) swap slots */\n-\tfor (i = 0; i < nr_pages; i++) {\n-\t\tvswap_free(entry, ci);\n-\t\tentry.val++;\n-\t}\n \n \t/* It should never free entries across different clusters */\n \tVM_BUG_ON(ci != __swap_offset_to_cluster(si, offset + nr_pages - 1));\n@@ -1731,149 +1570,6 @@ void swap_slot_free_nr(swp_slot_t slot, int nr_pages)\n \t}\n }\n \n-/*\n- * Caller has made sure that the swap device corresponding to entry\n- * is still around or has not been recycled.\n- */\n-void swap_free_nr(swp_entry_t entry, int nr_pages)\n-{\n-\tswap_slot_free_nr(swp_entry_to_swp_slot(entry), nr_pages);\n-}\n-\n-/*\n- * Called after dropping swapcache to decrease refcnt to swap entries.\n- */\n-void put_swap_folio(struct folio *folio, swp_entry_t entry)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *si;\n-\tint size = 1 << swap_slot_order(folio_order(folio));\n-\n-\tsi = _swap_info_get(slot);\n-\tif (!si)\n-\t\treturn;\n-\n-\tswap_slots_put_cache(si, slot, size);\n-}\n-\n-int __swap_count(swp_entry_t entry)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *si = __swap_slot_to_info(slot);\n-\tpgoff_t offset = swp_slot_offset(slot);\n-\n-\treturn swap_count(si->swap_map[offset]);\n-}\n-\n-/*\n- * How many references to @entry are currently swapped out?\n- * This does not give an exact answer when swap count is continued,\n- * but does include the high COUNT_CONTINUED flag to allow for that.\n- */\n-bool swap_entry_swapped(struct swap_info_struct *si, swp_entry_t entry)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tpgoff_t offset = swp_slot_offset(slot);\n-\tstruct swap_cluster_info *ci;\n-\tint count;\n-\n-\tci = swap_cluster_lock(si, offset);\n-\tcount = swap_count(si->swap_map[offset]);\n-\tswap_cluster_unlock(ci);\n-\treturn !!count;\n-}\n-\n-/*\n- * How many references to @entry are currently swapped out?\n- * This considers COUNT_CONTINUED so it returns exact answer.\n- */\n-int swp_swapcount(swp_entry_t entry)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tint count, tmp_count, n;\n-\tstruct swap_info_struct *si;\n-\tstruct swap_cluster_info *ci;\n-\tstruct page *page;\n-\tpgoff_t offset;\n-\tunsigned char *map;\n-\n-\tsi = _swap_info_get(slot);\n-\tif (!si)\n-\t\treturn 0;\n-\n-\toffset = swp_slot_offset(slot);\n-\n-\tci = swap_cluster_lock(si, offset);\n-\n-\tcount = swap_count(si->swap_map[offset]);\n-\tif (!(count & COUNT_CONTINUED))\n-\t\tgoto out;\n-\n-\tcount &= ~COUNT_CONTINUED;\n-\tn = SWAP_MAP_MAX + 1;\n-\n-\tpage = vmalloc_to_page(si->swap_map + offset);\n-\toffset &= ~PAGE_MASK;\n-\tVM_BUG_ON(page_private(page) != SWP_CONTINUED);\n-\n-\tdo {\n-\t\tpage = list_next_entry(page, lru);\n-\t\tmap = kmap_local_page(page);\n-\t\ttmp_count = map[offset];\n-\t\tkunmap_local(map);\n-\n-\t\tcount += (tmp_count & ~COUNT_CONTINUED) * n;\n-\t\tn *= (SWAP_CONT_MAX + 1);\n-\t} while (tmp_count & COUNT_CONTINUED);\n-out:\n-\tswap_cluster_unlock(ci);\n-\treturn count;\n-}\n-\n-static bool swap_page_trans_huge_swapped(struct swap_info_struct *si,\n-\t\t\t\t\t swp_entry_t entry, int order)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_cluster_info *ci;\n-\tunsigned char *map = si->swap_map;\n-\tunsigned int nr_pages = 1 << order;\n-\tunsigned long roffset = swp_slot_offset(slot);\n-\tunsigned long offset = round_down(roffset, nr_pages);\n-\tint i;\n-\tbool ret = false;\n-\n-\tci = swap_cluster_lock(si, offset);\n-\tif (nr_pages == 1) {\n-\t\tif (swap_count(map[roffset]))\n-\t\t\tret = true;\n-\t\tgoto unlock_out;\n-\t}\n-\tfor (i = 0; i < nr_pages; i++) {\n-\t\tif (swap_count(map[offset + i])) {\n-\t\t\tret = true;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-unlock_out:\n-\tswap_cluster_unlock(ci);\n-\treturn ret;\n-}\n-\n-static bool folio_swapped(struct folio *folio)\n-{\n-\tswp_entry_t entry = folio->swap;\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *si = _swap_info_get(slot);\n-\n-\tif (!si)\n-\t\treturn false;\n-\n-\tif (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!folio_test_large(folio)))\n-\t\treturn swap_entry_swapped(si, entry);\n-\n-\treturn swap_page_trans_huge_swapped(si, entry, folio_order(folio));\n-}\n-\n static bool folio_swapcache_freeable(struct folio *folio)\n {\n \tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n@@ -1925,72 +1621,6 @@ bool folio_free_swap(struct folio *folio)\n \treturn true;\n }\n \n-/**\n- * free_swap_and_cache_nr() - Release reference on range of swap entries and\n- *                            reclaim their cache if no more references remain.\n- * @entry: First entry of range.\n- * @nr: Number of entries in range.\n- *\n- * For each swap entry in the contiguous range, release a reference. If any swap\n- * entries become free, try to reclaim their underlying folios, if present. The\n- * offset range is defined by [entry.offset, entry.offset + nr).\n- */\n-void free_swap_and_cache_nr(swp_entry_t entry, int nr)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tconst unsigned long start_offset = swp_slot_offset(slot);\n-\tconst unsigned long end_offset = start_offset + nr;\n-\tstruct swap_info_struct *si;\n-\tbool any_only_cache = false;\n-\tunsigned long offset;\n-\n-\tsi = swap_slot_tryget_swap_info(slot);\n-\tif (!si)\n-\t\treturn;\n-\n-\tif (WARN_ON(end_offset > si->max))\n-\t\tgoto out;\n-\n-\t/*\n-\t * First free all entries in the range.\n-\t */\n-\tany_only_cache = swap_slots_put_map_nr(si, slot, nr);\n-\n-\t/*\n-\t * Short-circuit the below loop if none of the entries had their\n-\t * reference drop to zero.\n-\t */\n-\tif (!any_only_cache)\n-\t\tgoto out;\n-\n-\t/*\n-\t * Now go back over the range trying to reclaim the swap cache.\n-\t */\n-\tfor (offset = start_offset; offset < end_offset; offset += nr) {\n-\t\tnr = 1;\n-\t\tif (READ_ONCE(si->swap_map[offset]) == SWAP_HAS_CACHE) {\n-\t\t\t/*\n-\t\t\t * Folios are always naturally aligned in swap so\n-\t\t\t * advance forward to the next boundary. Zero means no\n-\t\t\t * folio was found for the swap entry, so advance by 1\n-\t\t\t * in this case. Negative value means folio was found\n-\t\t\t * but could not be reclaimed. Here we can still advance\n-\t\t\t * to the next boundary.\n-\t\t\t */\n-\t\t\tnr = __try_to_reclaim_swap(si, offset,\n-\t\t\t\t\t\t   TTRS_UNMAPPED | TTRS_FULL);\n-\t\t\tif (nr == 0)\n-\t\t\t\tnr = 1;\n-\t\t\telse if (nr < 0)\n-\t\t\t\tnr = -nr;\n-\t\t\tnr = ALIGN(offset + 1, nr) - offset;\n-\t\t}\n-\t}\n-\n-out:\n-\tswap_slot_put_swap_info(si);\n-}\n-\n #ifdef CONFIG_HIBERNATION\n \n swp_slot_t swap_slot_alloc_of_type(int type)\n@@ -2901,8 +2531,6 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \tflush_percpu_swap_cluster(p);\n \n \tdestroy_swap_extents(p);\n-\tif (p->flags & SWP_CONTINUED)\n-\t\tfree_swap_count_continuations(p);\n \n \tif (!(p->flags & SWP_SOLIDSTATE))\n \t\tatomic_dec(&nr_rotate_swap);\n@@ -3638,364 +3266,6 @@ void si_swapinfo(struct sysinfo *val)\n \tspin_unlock(&swap_lock);\n }\n \n-/*\n- * Verify that nr swap entries are valid and increment their swap map counts.\n- *\n- * Returns error code in following case.\n- * - success -> 0\n- * - swp_entry is invalid -> EINVAL\n- * - swap-cache reference is requested but there is already one. -> EEXIST\n- * - swap-cache reference is requested but the entry is not used. -> ENOENT\n- * - swap-mapped reference requested but needs continued swap count. -> ENOMEM\n- */\n-static int __swap_duplicate(swp_entry_t entry, unsigned char usage, int nr)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *si;\n-\tstruct swap_cluster_info *ci;\n-\tunsigned long offset;\n-\tunsigned char count;\n-\tunsigned char has_cache;\n-\tint err, i;\n-\n-\tsi = swap_slot_to_info(slot);\n-\tif (WARN_ON_ONCE(!si)) {\n-\t\tpr_err(\"%s%08lx\\n\", Bad_file, entry.val);\n-\t\treturn -EINVAL;\n-\t}\n-\n-\toffset = swp_slot_offset(slot);\n-\tVM_WARN_ON(nr > SWAPFILE_CLUSTER - offset % SWAPFILE_CLUSTER);\n-\tVM_WARN_ON(usage == 1 && nr > 1);\n-\tci = swap_cluster_lock(si, offset);\n-\n-\terr = 0;\n-\tfor (i = 0; i < nr; i++) {\n-\t\tcount = si->swap_map[offset + i];\n-\n-\t\t/*\n-\t\t * swapin_readahead() doesn't check if a swap entry is valid, so the\n-\t\t * swap entry could be SWAP_MAP_BAD. Check here with lock held.\n-\t\t */\n-\t\tif (unlikely(swap_count(count) == SWAP_MAP_BAD)) {\n-\t\t\terr = -ENOENT;\n-\t\t\tgoto unlock_out;\n-\t\t}\n-\n-\t\thas_cache = count & SWAP_HAS_CACHE;\n-\t\tcount &= ~SWAP_HAS_CACHE;\n-\n-\t\tif (!count && !has_cache) {\n-\t\t\terr = -ENOENT;\n-\t\t} else if (usage == SWAP_HAS_CACHE) {\n-\t\t\tif (has_cache)\n-\t\t\t\terr = -EEXIST;\n-\t\t} else if ((count & ~COUNT_CONTINUED) > SWAP_MAP_MAX) {\n-\t\t\terr = -EINVAL;\n-\t\t}\n-\n-\t\tif (err)\n-\t\t\tgoto unlock_out;\n-\t}\n-\n-\tfor (i = 0; i < nr; i++) {\n-\t\tcount = si->swap_map[offset + i];\n-\t\thas_cache = count & SWAP_HAS_CACHE;\n-\t\tcount &= ~SWAP_HAS_CACHE;\n-\n-\t\tif (usage == SWAP_HAS_CACHE)\n-\t\t\thas_cache = SWAP_HAS_CACHE;\n-\t\telse if ((count & ~COUNT_CONTINUED) < SWAP_MAP_MAX)\n-\t\t\tcount += usage;\n-\t\telse if (swap_count_continued(si, offset + i, count))\n-\t\t\tcount = COUNT_CONTINUED;\n-\t\telse {\n-\t\t\t/*\n-\t\t\t * Don't need to rollback changes, because if\n-\t\t\t * usage == 1, there must be nr == 1.\n-\t\t\t */\n-\t\t\terr = -ENOMEM;\n-\t\t\tgoto unlock_out;\n-\t\t}\n-\n-\t\tWRITE_ONCE(si->swap_map[offset + i], count | has_cache);\n-\t}\n-\n-unlock_out:\n-\tswap_cluster_unlock(ci);\n-\treturn err;\n-}\n-\n-/*\n- * Help swapoff by noting that swap entry belongs to shmem/tmpfs\n- * (in which case its reference count is never incremented).\n- */\n-void swap_shmem_alloc(swp_entry_t entry, int nr)\n-{\n-\t__swap_duplicate(entry, SWAP_MAP_SHMEM, nr);\n-}\n-\n-/*\n- * Increase reference count of swap entry by 1.\n- * Returns 0 for success, or -ENOMEM if a swap_count_continuation is required\n- * but could not be atomically allocated.  Returns 0, just as if it succeeded,\n- * if __swap_duplicate() fails for another reason (-EINVAL or -ENOENT), which\n- * might occur if a page table entry has got corrupted.\n- */\n-int swap_duplicate(swp_entry_t entry)\n-{\n-\tint err = 0;\n-\n-\twhile (!err && __swap_duplicate(entry, 1, 1) == -ENOMEM)\n-\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n-\treturn err;\n-}\n-\n-/*\n- * @entry: first swap entry from which we allocate nr swap cache.\n- *\n- * Called when allocating swap cache for existing swap entries,\n- * This can return error codes. Returns 0 at success.\n- * -EEXIST means there is a swap cache.\n- * Note: return code is different from swap_duplicate().\n- */\n-int swapcache_prepare(swp_entry_t entry, int nr)\n-{\n-\treturn __swap_duplicate(entry, SWAP_HAS_CACHE, nr);\n-}\n-\n-/*\n- * Caller should ensure entries belong to the same folio so\n- * the entries won't span cross cluster boundary.\n- */\n-void swapcache_clear(struct swap_info_struct *si, swp_entry_t entry, int nr)\n-{\n-\tswap_slots_put_cache(si, swp_entry_to_swp_slot(entry), nr);\n-}\n-\n-/*\n- * add_swap_count_continuation - called when a swap count is duplicated\n- * beyond SWAP_MAP_MAX, it allocates a new page and links that to the entry's\n- * page of the original vmalloc'ed swap_map, to hold the continuation count\n- * (for that entry and for its neighbouring PAGE_SIZE swap entries).  Called\n- * again when count is duplicated beyond SWAP_MAP_MAX * SWAP_CONT_MAX, etc.\n- *\n- * These continuation pages are seldom referenced: the common paths all work\n- * on the original swap_map, only referring to a continuation page when the\n- * low \"digit\" of a count is incremented or decremented through SWAP_MAP_MAX.\n- *\n- * add_swap_count_continuation(, GFP_ATOMIC) can be called while holding\n- * page table locks; if it fails, add_swap_count_continuation(, GFP_KERNEL)\n- * can be called after dropping locks.\n- */\n-int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n-{\n-\tstruct swap_info_struct *si;\n-\tstruct swap_cluster_info *ci;\n-\tstruct page *head;\n-\tstruct page *page;\n-\tstruct page *list_page;\n-\tpgoff_t offset;\n-\tunsigned char count;\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tint ret = 0;\n-\n-\t/*\n-\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n-\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n-\t */\n-\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n-\n-\tsi = swap_slot_tryget_swap_info(slot);\n-\tif (!si) {\n-\t\t/*\n-\t\t * An acceptable race has occurred since the failing\n-\t\t * __swap_duplicate(): the swap device may be swapoff\n-\t\t */\n-\t\tgoto outer;\n-\t}\n-\n-\toffset = swp_slot_offset(slot);\n-\n-\tci = swap_cluster_lock(si, offset);\n-\n-\tcount = swap_count(si->swap_map[offset]);\n-\n-\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n-\t\t/*\n-\t\t * The higher the swap count, the more likely it is that tasks\n-\t\t * will race to add swap count continuation: we need to avoid\n-\t\t * over-provisioning.\n-\t\t */\n-\t\tgoto out;\n-\t}\n-\n-\tif (!page) {\n-\t\tret = -ENOMEM;\n-\t\tgoto out;\n-\t}\n-\n-\thead = vmalloc_to_page(si->swap_map + offset);\n-\toffset &= ~PAGE_MASK;\n-\n-\tspin_lock(&si->cont_lock);\n-\t/*\n-\t * Page allocation does not initialize the page's lru field,\n-\t * but it does always reset its private field.\n-\t */\n-\tif (!page_private(head)) {\n-\t\tBUG_ON(count & COUNT_CONTINUED);\n-\t\tINIT_LIST_HEAD(&head->lru);\n-\t\tset_page_private(head, SWP_CONTINUED);\n-\t\tsi->flags |= SWP_CONTINUED;\n-\t}\n-\n-\tlist_for_each_entry(list_page, &head->lru, lru) {\n-\t\tunsigned char *map;\n-\n-\t\t/*\n-\t\t * If the previous map said no continuation, but we've found\n-\t\t * a continuation page, free our allocation and use this one.\n-\t\t */\n-\t\tif (!(count & COUNT_CONTINUED))\n-\t\t\tgoto out_unlock_cont;\n-\n-\t\tmap = kmap_local_page(list_page) + offset;\n-\t\tcount = *map;\n-\t\tkunmap_local(map);\n-\n-\t\t/*\n-\t\t * If this continuation count now has some space in it,\n-\t\t * free our allocation and use this one.\n-\t\t */\n-\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n-\t\t\tgoto out_unlock_cont;\n-\t}\n-\n-\tlist_add_tail(&page->lru, &head->lru);\n-\tpage = NULL;\t\t\t/* now it's attached, don't free it */\n-out_unlock_cont:\n-\tspin_unlock(&si->cont_lock);\n-out:\n-\tswap_cluster_unlock(ci);\n-\tswap_slot_put_swap_info(si);\n-outer:\n-\tif (page)\n-\t\t__free_page(page);\n-\treturn ret;\n-}\n-\n-/*\n- * swap_count_continued - when the original swap_map count is incremented\n- * from SWAP_MAP_MAX, check if there is already a continuation page to carry\n- * into, carry if so, or else fail until a new continuation page is allocated;\n- * when the original swap_map count is decremented from 0 with continuation,\n- * borrow from the continuation and report whether it still holds more.\n- * Called while __swap_duplicate() or caller of swap_entry_put_locked()\n- * holds cluster lock.\n- */\n-static bool swap_count_continued(struct swap_info_struct *si,\n-\t\t\t\t pgoff_t offset, unsigned char count)\n-{\n-\tstruct page *head;\n-\tstruct page *page;\n-\tunsigned char *map;\n-\tbool ret;\n-\n-\thead = vmalloc_to_page(si->swap_map + offset);\n-\tif (page_private(head) != SWP_CONTINUED) {\n-\t\tBUG_ON(count & COUNT_CONTINUED);\n-\t\treturn false;\t\t/* need to add count continuation */\n-\t}\n-\n-\tspin_lock(&si->cont_lock);\n-\toffset &= ~PAGE_MASK;\n-\tpage = list_next_entry(head, lru);\n-\tmap = kmap_local_page(page) + offset;\n-\n-\tif (count == SWAP_MAP_MAX)\t/* initial increment from swap_map */\n-\t\tgoto init_map;\t\t/* jump over SWAP_CONT_MAX checks */\n-\n-\tif (count == (SWAP_MAP_MAX | COUNT_CONTINUED)) { /* incrementing */\n-\t\t/*\n-\t\t * Think of how you add 1 to 999\n-\t\t */\n-\t\twhile (*map == (SWAP_CONT_MAX | COUNT_CONTINUED)) {\n-\t\t\tkunmap_local(map);\n-\t\t\tpage = list_next_entry(page, lru);\n-\t\t\tBUG_ON(page == head);\n-\t\t\tmap = kmap_local_page(page) + offset;\n-\t\t}\n-\t\tif (*map == SWAP_CONT_MAX) {\n-\t\t\tkunmap_local(map);\n-\t\t\tpage = list_next_entry(page, lru);\n-\t\t\tif (page == head) {\n-\t\t\t\tret = false;\t/* add count continuation */\n-\t\t\t\tgoto out;\n-\t\t\t}\n-\t\t\tmap = kmap_local_page(page) + offset;\n-init_map:\t\t*map = 0;\t\t/* we didn't zero the page */\n-\t\t}\n-\t\t*map += 1;\n-\t\tkunmap_local(map);\n-\t\twhile ((page = list_prev_entry(page, lru)) != head) {\n-\t\t\tmap = kmap_local_page(page) + offset;\n-\t\t\t*map = COUNT_CONTINUED;\n-\t\t\tkunmap_local(map);\n-\t\t}\n-\t\tret = true;\t\t\t/* incremented */\n-\n-\t} else {\t\t\t\t/* decrementing */\n-\t\t/*\n-\t\t * Think of how you subtract 1 from 1000\n-\t\t */\n-\t\tBUG_ON(count != COUNT_CONTINUED);\n-\t\twhile (*map == COUNT_CONTINUED) {\n-\t\t\tkunmap_local(map);\n-\t\t\tpage = list_next_entry(page, lru);\n-\t\t\tBUG_ON(page == head);\n-\t\t\tmap = kmap_local_page(page) + offset;\n-\t\t}\n-\t\tBUG_ON(*map == 0);\n-\t\t*map -= 1;\n-\t\tif (*map == 0)\n-\t\t\tcount = 0;\n-\t\tkunmap_local(map);\n-\t\twhile ((page = list_prev_entry(page, lru)) != head) {\n-\t\t\tmap = kmap_local_page(page) + offset;\n-\t\t\t*map = SWAP_CONT_MAX | count;\n-\t\t\tcount = COUNT_CONTINUED;\n-\t\t\tkunmap_local(map);\n-\t\t}\n-\t\tret = count == COUNT_CONTINUED;\n-\t}\n-out:\n-\tspin_unlock(&si->cont_lock);\n-\treturn ret;\n-}\n-\n-/*\n- * free_swap_count_continuations - swapoff free all the continuation pages\n- * appended to the swap_map, after swap_map is quiesced, before vfree'ing it.\n- */\n-static void free_swap_count_continuations(struct swap_info_struct *si)\n-{\n-\tpgoff_t offset;\n-\n-\tfor (offset = 0; offset < si->max; offset += PAGE_SIZE) {\n-\t\tstruct page *head;\n-\t\thead = vmalloc_to_page(si->swap_map + offset);\n-\t\tif (page_private(head)) {\n-\t\t\tstruct page *page, *next;\n-\n-\t\t\tlist_for_each_entry_safe(page, next, &head->lru, lru) {\n-\t\t\t\tlist_del(&page->lru);\n-\t\t\t\t__free_page(page);\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n #if defined(CONFIG_MEMCG) && defined(CONFIG_BLK_CGROUP)\n static bool __has_usable_swap(void)\n {\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex 64747493ca9f7..318933071edc6 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -24,6 +24,8 @@\n  * For now, there is a one-to-one correspondence between a virtual swap slot\n  * and its associated physical swap slot.\n  *\n+ * I. Allocation\n+ *\n  * Virtual swap slots are organized into PMD-sized clusters, analogous to\n  * physical swap allocator. However, unlike the physical swap allocator,\n  * the clusters are dynamically allocated and freed on-demand. There is no\n@@ -32,6 +34,26 @@\n  *\n  * This allows us to avoid the overhead of pre-allocating a large number of\n  * virtual swap clusters.\n+ *\n+ * II. Swap Entry Lifecycle\n+ *\n+ * The swap entry's lifecycle is managed at the virtual swap layer. Conceptually,\n+ * each virtual swap slot has a reference count, which includes:\n+ *\n+ * 1. The number of page table entries that refer to the virtual swap slot, i.e\n+ *    its swap count.\n+ *\n+ * 2. Whether the virtual swap slot has been added to the swap cache - if so,\n+ *    its reference count is incremented by 1.\n+ *\n+ * Each virtual swap slot starts out with a reference count of 1 (since it is\n+ * about to be added to the swap cache). Its reference count is incremented or\n+ * decremented every time it is mapped to or unmapped from a PTE, as well as\n+ * when it is added to or removed from the swap cache. Finally, when its\n+ * reference count reaches 0, the virtual swap slot is freed.\n+ *\n+ * Note that we do not have a reference count field per se - it is derived from\n+ * the swap_count and the in_swapcache fields.\n  */\n \n /**\n@@ -42,6 +64,8 @@\n  * @swap_cache: The folio in swap cache.\n  * @shadow: The shadow entry.\n  * @memcgid: The memcg id of the owning memcg, if any.\n+ * @swap_count: The number of page table entries that refer to the swap entry.\n+ * @in_swapcache: Whether the swap entry is (about to be) pinned in swap cache.\n  */\n struct swp_desc {\n \tswp_slot_t slot;\n@@ -50,9 +74,14 @@ struct swp_desc {\n \t\tstruct folio *swap_cache;\n \t\tvoid *shadow;\n \t};\n+\n+\tunsigned int swap_count;\n+\n #ifdef CONFIG_MEMCG\n \tunsigned short memcgid;\n #endif\n+\n+\tbool in_swapcache;\n };\n \n #define VSWAP_CLUSTER_SHIFT HPAGE_PMD_ORDER\n@@ -249,6 +278,8 @@ static void __vswap_alloc_from_cluster(struct vswap_cluster *cluster, int start)\n #ifdef CONFIG_MEMCG\n \t\tdesc->memcgid = 0;\n #endif\n+\t\tdesc->swap_count = 0;\n+\t\tdesc->in_swapcache = true;\n \t}\n \tcluster->count += nr;\n }\n@@ -452,7 +483,7 @@ static inline void release_vswap_slot(struct vswap_cluster *cluster,\n  * Update the physical-to-virtual swap slot mapping.\n  * Caller must ensure the physical swap slot's cluster is locked.\n  */\n-static void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n+void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \t\t\t   unsigned long vswap, int nr)\n {\n \tatomic_long_t *table;\n@@ -466,45 +497,50 @@ static void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \t\t__swap_table_set(ci, ci_off + i, vswap ? vswap + i : 0);\n }\n \n-/**\n- * vswap_free - free a virtual swap slot.\n- * @entry: the virtual swap slot to free\n- * @ci: the physical swap slot's cluster (optional, can be NULL)\n+/*\n+ * Entered with the cluster locked, but might unlock the cluster.\n+ * This is because several operations, such as releasing physical swap slots\n+ * (i.e swap_slot_free_nr()) require the cluster to be unlocked to avoid\n+ * deadlocks.\n  *\n- * If @ci is NULL, this function is called to clean up a virtual swap entry\n- * when no linkage has been established between physical and virtual swap slots.\n- * If @ci is provided, the caller must ensure it is locked.\n+ * This is safe, because:\n+ *\n+ * 1. The swap entry to be freed has refcnt (swap count and swapcache pin)\n+ *    down to 0, so no one can change its internal state\n+ *\n+ * 2. The swap entry to be freed still holds a refcnt to the cluster, keeping\n+ *    the cluster itself valid.\n+ *\n+ * We will exit the function with the cluster re-locked.\n  */\n-void vswap_free(swp_entry_t entry, struct swap_cluster_info *ci)\n+static void vswap_free(struct vswap_cluster *cluster, struct swp_desc *desc,\n+\tswp_entry_t entry)\n {\n-\tstruct vswap_cluster *cluster = NULL;\n-\tstruct swp_desc *desc;\n+\tstruct zswap_entry *zswap_entry;\n+\tswp_slot_t slot;\n \n-\tif (!entry.val)\n-\t\treturn;\n+\t/* Clear shadow if present */\n+\tif (xa_is_value(desc->shadow))\n+\t\tdesc->shadow = NULL;\n \n-\tzswap_invalidate(entry);\n-\tmem_cgroup_uncharge_swap(entry, 1);\n+\tslot = desc->slot;\n+\tdesc->slot.val = 0;\n \n-\t/* do not immediately erase the virtual slot to prevent its reuse */\n-\trcu_read_lock();\n-\tdesc = vswap_iter(&cluster, entry.val);\n-\tif (!desc) {\n-\t\trcu_read_unlock();\n-\t\treturn;\n+\tzswap_entry = desc->zswap_entry;\n+\tif (zswap_entry) {\n+\t\tdesc->zswap_entry = NULL;\n+\t\tzswap_entry_free(zswap_entry);\n \t}\n+\tspin_unlock(&cluster->lock);\n \n-\t/* Clear shadow if present */\n-\tif (xa_is_value(desc->shadow))\n-\t\tdesc->shadow = NULL;\n+\tmem_cgroup_uncharge_swap(entry, 1);\n \n-\tif (desc->slot.val)\n-\t\tvswap_rmap_set(ci, desc->slot, 0, 1);\n+\tif (slot.val)\n+\t\tswap_slot_free_nr(slot, 1);\n \n+\tspin_lock(&cluster->lock);\n \t/* erase forward mapping and release the virtual slot for reallocation */\n \trelease_vswap_slot(cluster, entry.val);\n-\tspin_unlock(&cluster->lock);\n-\trcu_read_unlock();\n }\n \n /**\n@@ -538,8 +574,12 @@ int folio_alloc_swap(struct folio *folio)\n \t * fallback from zswap store failure).\n \t */\n \tif (swap_slot_alloc(&slot, order)) {\n-\t\tfor (i = 0; i < nr; i++)\n-\t\t\tvswap_free((swp_entry_t){entry.val + i}, NULL);\n+\t\tfor (i = 0; i < nr; i++) {\n+\t\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\t\tVM_WARN_ON(!desc);\n+\t\t\tvswap_free(cluster, desc, (swp_entry_t){ entry.val + i });\n+\t\t}\n+\t\tspin_unlock(&cluster->lock);\n \t\tentry.val = 0;\n \t\treturn -ENOMEM;\n \t}\n@@ -603,9 +643,11 @@ swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry)\n \t\trcu_read_unlock();\n \t\treturn (swp_slot_t){0};\n \t}\n+\n \tslot = desc->slot;\n \tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n+\n \treturn slot;\n }\n \n@@ -635,6 +677,352 @@ swp_entry_t swp_slot_to_swp_entry(swp_slot_t slot)\n \treturn ret;\n }\n \n+/*\n+ * Decrease the swap count of nr contiguous swap entries by 1 (when the swap\n+ * entries are removed from a range of PTEs), and check if any of the swap\n+ * entries are in swap cache only after its swap count is decreased.\n+ *\n+ * The check is racy, but it is OK because free_swap_and_cache_nr() only use\n+ * the result as a hint.\n+ */\n+static bool vswap_free_nr_any_cache_only(swp_entry_t entry, int nr)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tbool ret = false;\n+\tint i;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val);\n+\t\tVM_WARN_ON(!desc);\n+\t\tret |= (desc->swap_count == 1 && desc->in_swapcache);\n+\t\tdesc->swap_count--;\n+\t\tif (!desc->swap_count && !desc->in_swapcache)\n+\t\t\tvswap_free(cluster, desc, entry);\n+\t\tentry.val++;\n+\t}\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\treturn ret;\n+}\n+\n+/**\n+ * swap_free_nr - decrease the swap count of nr contiguous swap entries by 1\n+ *                (when the swap entries are removed from a range of PTEs).\n+ * @entry: the first entry in the range.\n+ * @nr: the number of entries in the range.\n+ */\n+void swap_free_nr(swp_entry_t entry, int nr)\n+{\n+\tvswap_free_nr_any_cache_only(entry, nr);\n+}\n+\n+static int swap_duplicate_nr(swp_entry_t entry, int nr)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tint i = 0;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tif (!desc || (!desc->swap_count && !desc->in_swapcache))\n+\t\t\tgoto done;\n+\t\tdesc->swap_count++;\n+\t}\n+done:\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\tif (i && i < nr)\n+\t\tswap_free_nr(entry, i);\n+\n+\treturn i == nr ? 0 : -ENOENT;\n+}\n+\n+/**\n+ * swap_duplicate - increase the swap count of the swap entry by 1 (i.e when\n+ *                  the swap entry is stored at a new PTE).\n+ * @entry: the swap entry.\n+ *\n+ * Return: -ENONENT, if we try to duplicate a non-existent swap entry.\n+ */\n+int swap_duplicate(swp_entry_t entry)\n+{\n+\treturn swap_duplicate_nr(entry, 1);\n+}\n+\n+\n+bool folio_swapped(struct folio *folio)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tswp_entry_t entry = folio->swap;\n+\tint i, nr = folio_nr_pages(folio);\n+\tstruct swp_desc *desc;\n+\tbool swapped = false;\n+\n+\tif (!entry.val)\n+\t\treturn false;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tif (desc && desc->swap_count) {\n+\t\t\tswapped = true;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\treturn swapped;\n+}\n+\n+/**\n+ * swp_swapcount - return the swap count of the swap entry.\n+ * @id: the swap entry.\n+ *\n+ * Note that all the swap count functions are identical in the new design,\n+ * since we no longer need swap count continuation.\n+ *\n+ * Return: the swap count of the swap entry.\n+ */\n+int swp_swapcount(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tunsigned int ret;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tret = desc ? desc->swap_count : 0;\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\treturn ret;\n+}\n+\n+int __swap_count(swp_entry_t entry)\n+{\n+\treturn swp_swapcount(entry);\n+}\n+\n+bool swap_entry_swapped(swp_entry_t entry)\n+{\n+\treturn !!swp_swapcount(entry);\n+}\n+\n+void swap_shmem_alloc(swp_entry_t entry, int nr)\n+{\n+\tswap_duplicate_nr(entry, nr);\n+}\n+\n+void swapcache_clear(swp_entry_t entry, int nr)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tint i;\n+\n+\tif (!nr)\n+\t\treturn;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val);\n+\t\tdesc->in_swapcache = false;\n+\t\tif (!desc->swap_count)\n+\t\t\tvswap_free(cluster, desc, entry);\n+\t\tentry.val++;\n+\t}\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+int swapcache_prepare(swp_entry_t entry, int nr)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tint i, ret = 0;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\n+\t\tif (!desc) {\n+\t\t\tret = -ENOENT;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\tif (!desc->swap_count && !desc->in_swapcache) {\n+\t\t\tret = -ENOENT;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\tif (desc->in_swapcache) {\n+\t\t\tret = -EEXIST;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\tdesc->in_swapcache = true;\n+\t}\n+done:\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\tif (i && i < nr)\n+\t\tswapcache_clear(entry, i);\n+\tif (i < nr && !ret)\n+\t\tret = -ENOENT;\n+\treturn ret;\n+}\n+\n+/**\n+ * is_swap_cached - check if the swap entry is cached\n+ * @entry: swap entry to check\n+ *\n+ * Returns true if the swap entry is cached, false otherwise.\n+ */\n+bool is_swap_cached(swp_entry_t entry)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tbool cached;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tcached = desc ? desc->in_swapcache : false;\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\treturn cached;\n+}\n+\n+/**\n+ * vswap_only_has_cache - check if all the slots in the range are still valid,\n+ *                        and are in swap cache only (i.e not stored in any\n+ *                        PTEs).\n+ * @entry: the first slot in the range.\n+ * @nr: the number of slots in the range.\n+ *\n+ * Return: true if all the slots in the range are still valid, and are in swap\n+ * cache only, or false otherwise.\n+ */\n+bool vswap_only_has_cache(swp_entry_t entry, int nr)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tint i = 0;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tif (!desc || desc->swap_count || !desc->in_swapcache)\n+\t\t\tgoto done;\n+\t}\n+done:\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\treturn i == nr;\n+}\n+\n+/**\n+ * non_swapcache_batch - count the longest range starting from a particular\n+ *                       swap slot that are stil valid, but not in swap cache.\n+ * @entry: the first slot to check.\n+ * @max_nr: the maximum number of slots to check.\n+ *\n+ * Return: the number of slots in the longest range that are still valid, but\n+ * not in swap cache.\n+ */\n+int non_swapcache_batch(swp_entry_t entry, int max_nr)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tint i;\n+\n+\tif (!entry.val)\n+\t\treturn 0;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < max_nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tif (!desc || desc->in_swapcache || !desc->swap_count)\n+\t\t\tgoto done;\n+\t}\n+done:\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\treturn i;\n+}\n+\n+/**\n+ * free_swap_and_cache_nr() - Release a swap count on range of swap entries and\n+ *                            reclaim their cache if no more references remain.\n+ * @entry: First entry of range.\n+ * @nr: Number of entries in range.\n+ *\n+ * For each swap entry in the contiguous range, release a swap count. If any\n+ * swap entries have their swap count decremented to zero, try to reclaim their\n+ * associated swap cache pages.\n+ */\n+void free_swap_and_cache_nr(swp_entry_t entry, int nr)\n+{\n+\tint i = 0, incr = 1;\n+\tstruct folio *folio;\n+\n+\tif (vswap_free_nr_any_cache_only(entry, nr)) {\n+\t\twhile (i < nr) {\n+\t\t\tincr = 1;\n+\t\t\tif (vswap_only_has_cache(entry, 1)) {\n+\t\t\t\tfolio = swap_cache_get_folio(entry);\n+\t\t\t\tif (!folio)\n+\t\t\t\t\tgoto next;\n+\n+\t\t\t\tif (!folio_trylock(folio)) {\n+\t\t\t\t\tfolio_put(folio);\n+\t\t\t\t\tgoto next;\n+\t\t\t\t}\n+\n+\t\t\t\tif (!folio_matches_swap_entry(folio, entry)) {\n+\t\t\t\t\tfolio_unlock(folio);\n+\t\t\t\t\tfolio_put(folio);\n+\t\t\t\t\tgoto next;\n+\t\t\t\t}\n+\n+\t\t\t\t/*\n+\t\t\t\t * Folios are always naturally aligned in swap so\n+\t\t\t\t * advance forward to the next boundary.\n+\t\t\t\t */\n+\t\t\t\tincr = ALIGN(entry.val + 1, folio_nr_pages(folio)) - entry.val;\n+\t\t\t\tfolio_free_swap(folio);\n+\t\t\t\tfolio_unlock(folio);\n+\t\t\t\tfolio_put(folio);\n+\t\t\t}\n+next:\n+\t\t\ti += incr;\n+\t\t\tentry.val += incr;\n+\t\t}\n+\t}\n+}\n+\n+/*\n+ * Called after dropping swapcache to decrease refcnt to swap entries.\n+ */\n+void put_swap_folio(struct folio *folio, swp_entry_t entry)\n+{\n+\tint nr = folio_nr_pages(folio);\n+\n+\tVM_WARN_ON(!folio_test_locked(folio));\n+\tswapcache_clear(entry, nr);\n+}\n+\n bool tryget_swap_entry(swp_entry_t entry, struct swap_info_struct **si)\n {\n \tstruct vswap_cluster *cluster;\n@@ -869,8 +1257,8 @@ void *swap_cache_get_shadow(swp_entry_t entry)\n  * Context: Caller must ensure @entry is valid and protect the cluster with\n  * reference count or locks.\n  *\n- * The caller also needs to update the corresponding swap_map slots with\n- * SWAP_HAS_CACHE bit to avoid race or conflict.\n+ * The caller also needs to obtain the swap entries' swap cache pins to avoid\n+ * race or conflict.\n  */\n void swap_cache_add_folio(struct folio *folio, swp_entry_t entry, void **shadowp)\n {\ndiff --git a/mm/zswap.c b/mm/zswap.c\nindex 72441131f094e..e46349f9c90bb 100644\n--- a/mm/zswap.c\n+++ b/mm/zswap.c\n@@ -703,7 +703,7 @@ static void zswap_entry_cache_free(struct zswap_entry *entry)\n  * Carries out the common pattern of freeing an entry's zsmalloc allocation,\n  * freeing the entry itself, and decrementing the number of stored pages.\n  */\n-static void zswap_entry_free(struct zswap_entry *entry)\n+void zswap_entry_free(struct zswap_entry *entry)\n {\n \tzswap_lru_del(&zswap_list_lru, entry);\n \tzs_free(entry->pool->zs_pool, entry->handle);\n@@ -1627,18 +1627,6 @@ int zswap_load(struct folio *folio)\n \treturn 0;\n }\n \n-void zswap_invalidate(swp_entry_t swp)\n-{\n-\tstruct zswap_entry *entry;\n-\n-\tif (zswap_empty(swp))\n-\t\treturn;\n-\n-\tentry = zswap_entry_erase(swp);\n-\tif (entry)\n-\t\tzswap_entry_free(entry);\n-}\n-\n /*********************************\n * debugfs functions\n **********************************/\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author acknowledged that the vswap free path needs to be more careful about batched swap operations, specifically requiring a consistent backing state for all entries in the batch. They explained that zswap-backed entries are not supported for these batched operations and provided rules for ensuring consistency. The author did not mention any plans to address this issue in the current patch or provide a fix.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a problem",
            "explained requirements"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "This patch presents the first real use case of the new virtual swap\ndesign. It leverages the virtualization of the swap space to decouple a\nswap entry and its backing storage. A swap entry can now be backed by\none of the following options:\n\n1. A physical swap slot (i.e on a physical swapfile/swap partition).\n2. A \"zero swap page\", i.e the swapped out page is a zero page.\n3. A compressed object in the zswap pool.\n4. An in-memory page. This can happen when a page is loaded\n   (exclusively) from the zswap pool, or if the page is rejected by\n   zswap and zswap writeback is disabled.\n\nThis allows us to use zswap and the zero swap page optimization, without\nhaving to reserved a slot on a swapfile, or a swapfile at all. This\ntranslates to tens to hundreds of GBs of disk saving on hosts and\nworkloads that have high memory usage, as well as removes this spurious\nlimit on the usage of these optimizations.\n\nOne implication of this change is that we need to be much more careful\nwith THP swapin and batched swap free operations. The central\nrequirement is the range of entries we are working with must\nhave no mixed backing states:\n\n1. For now, zswap-backed entries are not supported for these batched\n   operations.\n2. All the entries must be backed by the same type.\n3. If the swap entries in the batch are backed by in-memory folio, it\n   must be the same folio (i.e they correspond to the subpages of that\n   folio).\n4. If the swap entries in the batch are backed by slots on swapfiles, it\n   must be the same swapfile, and these physical swap slots must also be\n   contiguous.\n\nFor now, we still charge virtual swap slots towards the memcg's swap\nusage. In a following patch, we will change this behavior and only\ncharge physical (i.e on swapfile) swap slots towards the memcg's swap\nusage.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h  |  14 +\n include/linux/zswap.h |   3 +-\n mm/internal.h         |  14 +-\n mm/memcontrol.c       |  65 +++--\n mm/memory.c           |  84 ++++--\n mm/page_io.c          |  74 ++---\n mm/shmem.c            |   6 +-\n mm/swap.h             |  32 +--\n mm/swap_state.c       |  29 +-\n mm/swapfile.c         |   8 -\n mm/vmscan.c           |  19 +-\n mm/vswap.c            | 638 ++++++++++++++++++++++++++++++++++--------\n mm/zswap.c            |  45 ++-\n 13 files changed, 729 insertions(+), 302 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex aae2e502d9975..54df972608047 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -658,12 +658,26 @@ static inline bool mem_cgroup_swap_full(struct folio *folio)\n \n int vswap_init(void);\n void vswap_exit(void);\n+bool vswap_alloc_swap_slot(struct folio *folio);\n swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry);\n swp_entry_t swp_slot_to_swp_entry(swp_slot_t slot);\n bool tryget_swap_entry(swp_entry_t entry, struct swap_info_struct **si);\n void put_swap_entry(swp_entry_t entry, struct swap_info_struct *si);\n bool folio_swapped(struct folio *folio);\n bool vswap_only_has_cache(swp_entry_t entry, int nr);\n+int non_swapcache_batch(swp_entry_t entry, int nr);\n+bool vswap_swapfile_backed(swp_entry_t entry, int nr);\n+bool vswap_folio_backed(swp_entry_t entry, int nr);\n+void vswap_store_folio(swp_entry_t entry, struct folio *folio);\n+void swap_zeromap_folio_set(struct folio *folio);\n+void vswap_assoc_zswap(swp_entry_t entry, struct zswap_entry *zswap_entry);\n+bool vswap_can_swapin_thp(swp_entry_t entry, int nr);\n \n+static inline struct swap_info_struct *vswap_get_device(swp_entry_t entry)\n+{\n+\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n+\n+\treturn slot.val ? swap_slot_tryget_swap_info(slot) : NULL;\n+}\n #endif /* __KERNEL__*/\n #endif /* _LINUX_SWAP_H */\ndiff --git a/include/linux/zswap.h b/include/linux/zswap.h\nindex 07b2936c38f29..f33b4433a5ee8 100644\n--- a/include/linux/zswap.h\n+++ b/include/linux/zswap.h\n@@ -33,9 +33,8 @@ void zswap_lruvec_state_init(struct lruvec *lruvec);\n void zswap_folio_swapin(struct folio *folio);\n bool zswap_is_enabled(void);\n bool zswap_never_enabled(void);\n-void *zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry);\n+void zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry);\n void *zswap_entry_load(swp_entry_t swpentry);\n-void *zswap_entry_erase(swp_entry_t swpentry);\n bool zswap_empty(swp_entry_t swpentry);\n void zswap_entry_free(struct zswap_entry *entry);\n \ndiff --git a/mm/internal.h b/mm/internal.h\nindex 7ced0def684ca..cfe97501e4885 100644\n--- a/mm/internal.h\n+++ b/mm/internal.h\n@@ -327,19 +327,7 @@ static inline swp_entry_t swap_nth(swp_entry_t entry, long n)\n \treturn (swp_entry_t) { entry.val + n };\n }\n \n-/* similar to swap_nth, but check the backing physical slots as well. */\n-static inline swp_entry_t swap_move(swp_entry_t entry, long delta)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry), next_slot;\n-\tswp_entry_t next_entry = swap_nth(entry, delta);\n-\n-\tnext_slot = swp_entry_to_swp_slot(next_entry);\n-\tif (swp_slot_type(slot) != swp_slot_type(next_slot) ||\n-\t\t\tswp_slot_offset(slot) + delta != swp_slot_offset(next_slot))\n-\t\tnext_entry.val = 0;\n-\n-\treturn next_entry;\n-}\n+swp_entry_t swap_move(swp_entry_t entry, long delta);\n \n /**\n  * pte_move_swp_offset - Move the swap entry offset field of a swap pte\ndiff --git a/mm/memcontrol.c b/mm/memcontrol.c\nindex 86f43b7e5f710..2ba5811e7edba 100644\n--- a/mm/memcontrol.c\n+++ b/mm/memcontrol.c\n@@ -5247,10 +5247,18 @@ void __mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n \trcu_read_unlock();\n }\n \n+static bool mem_cgroup_may_zswap(struct mem_cgroup *original_memcg);\n+\n long mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg)\n {\n-\tlong nr_swap_pages = get_nr_swap_pages();\n+\tlong nr_swap_pages, nr_zswap_pages = 0;\n+\n+\tif (zswap_is_enabled() && (mem_cgroup_disabled() || do_memsw_account() ||\n+\t\t\t\tmem_cgroup_may_zswap(memcg))) {\n+\t\tnr_zswap_pages = PAGE_COUNTER_MAX;\n+\t}\n \n+\tnr_swap_pages = max_t(long, nr_zswap_pages, get_nr_swap_pages());\n \tif (mem_cgroup_disabled() || do_memsw_account())\n \t\treturn nr_swap_pages;\n \tfor (; !mem_cgroup_is_root(memcg); memcg = parent_mem_cgroup(memcg))\n@@ -5419,6 +5427,29 @@ static struct cftype swap_files[] = {\n };\n \n #ifdef CONFIG_ZSWAP\n+static bool mem_cgroup_may_zswap(struct mem_cgroup *original_memcg)\n+{\n+\tstruct mem_cgroup *memcg;\n+\n+\tfor (memcg = original_memcg; !mem_cgroup_is_root(memcg);\n+\t     memcg = parent_mem_cgroup(memcg)) {\n+\t\tunsigned long max = READ_ONCE(memcg->zswap_max);\n+\t\tunsigned long pages;\n+\n+\t\tif (max == PAGE_COUNTER_MAX)\n+\t\t\tcontinue;\n+\t\tif (max == 0)\n+\t\t\treturn false;\n+\n+\t\t/* Force flush to get accurate stats for charging */\n+\t\t__mem_cgroup_flush_stats(memcg, true);\n+\t\tpages = memcg_page_state(memcg, MEMCG_ZSWAP_B) / PAGE_SIZE;\n+\t\tif (pages >= max)\n+\t\t\treturn false;\n+\t}\n+\treturn true;\n+}\n+\n /**\n  * obj_cgroup_may_zswap - check if this cgroup can zswap\n  * @objcg: the object cgroup\n@@ -5433,34 +5464,15 @@ static struct cftype swap_files[] = {\n  */\n bool obj_cgroup_may_zswap(struct obj_cgroup *objcg)\n {\n-\tstruct mem_cgroup *memcg, *original_memcg;\n+\tstruct mem_cgroup *memcg;\n \tbool ret = true;\n \n \tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n \t\treturn true;\n \n-\toriginal_memcg = get_mem_cgroup_from_objcg(objcg);\n-\tfor (memcg = original_memcg; !mem_cgroup_is_root(memcg);\n-\t     memcg = parent_mem_cgroup(memcg)) {\n-\t\tunsigned long max = READ_ONCE(memcg->zswap_max);\n-\t\tunsigned long pages;\n-\n-\t\tif (max == PAGE_COUNTER_MAX)\n-\t\t\tcontinue;\n-\t\tif (max == 0) {\n-\t\t\tret = false;\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\t/* Force flush to get accurate stats for charging */\n-\t\t__mem_cgroup_flush_stats(memcg, true);\n-\t\tpages = memcg_page_state(memcg, MEMCG_ZSWAP_B) / PAGE_SIZE;\n-\t\tif (pages < max)\n-\t\t\tcontinue;\n-\t\tret = false;\n-\t\tbreak;\n-\t}\n-\tmem_cgroup_put(original_memcg);\n+\tmemcg = get_mem_cgroup_from_objcg(objcg);\n+\tret = mem_cgroup_may_zswap(memcg);\n+\tmem_cgroup_put(memcg);\n \treturn ret;\n }\n \n@@ -5604,6 +5616,11 @@ static struct cftype zswap_files[] = {\n \t},\n \t{ }\t/* terminate */\n };\n+#else\n+static inline bool mem_cgroup_may_zswap(struct mem_cgroup *original_memcg)\n+{\n+\treturn false;\n+}\n #endif /* CONFIG_ZSWAP */\n \n static int __init mem_cgroup_swap_init(void)\ndiff --git a/mm/memory.c b/mm/memory.c\nindex 641e3f65edc00..a16bf84ebaaf9 100644\n--- a/mm/memory.c\n+++ b/mm/memory.c\n@@ -4362,6 +4362,15 @@ static inline bool should_try_to_free_swap(struct folio *folio,\n \tif (mem_cgroup_swap_full(folio) || (vma->vm_flags & VM_LOCKED) ||\n \t    folio_test_mlocked(folio))\n \t\treturn true;\n+\n+\t/*\n+\t * Mixed and/or non-swapfile backends cannot be re-used for future swapouts\n+\t * anyway. Try to free swap space unless the folio is backed by contiguous\n+\t * physical swap slots.\n+\t */\n+\tif (!vswap_swapfile_backed(folio->swap, folio_nr_pages(folio)))\n+\t\treturn true;\n+\n \t/*\n \t * If we want to map a page that's in the swapcache writable, we\n \t * have to detect via the refcount if we're really the exclusive\n@@ -4623,12 +4632,12 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \tstruct folio *swapcache, *folio = NULL;\n \tDECLARE_WAITQUEUE(wait, current);\n \tstruct page *page;\n-\tstruct swap_info_struct *si = NULL;\n+\tstruct swap_info_struct *si = NULL, *stable_si;\n \trmap_t rmap_flags = RMAP_NONE;\n \tbool need_clear_cache = false;\n \tbool swapoff_locked = false;\n \tbool exclusive = false;\n-\tsoftleaf_t entry;\n+\tsoftleaf_t orig_entry, entry;\n \tpte_t pte;\n \tvm_fault_t ret = 0;\n \tvoid *shadow = NULL;\n@@ -4641,6 +4650,11 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\tgoto out;\n \n \tentry = softleaf_from_pte(vmf->orig_pte);\n+\t/*\n+\t * entry might change if we get a large folio - remember the original entry\n+\t * for unlocking swapoff etc.\n+\t */\n+\torig_entry = entry;\n \tif (unlikely(!softleaf_is_swap(entry))) {\n \t\tif (softleaf_is_migration(entry)) {\n \t\t\tmigration_entry_wait(vma->vm_mm, vmf->pmd,\n@@ -4705,7 +4719,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \tswapcache = folio;\n \n \tif (!folio) {\n-\t\tif (data_race(si->flags & SWP_SYNCHRONOUS_IO) &&\n+\t\tif (si && data_race(si->flags & SWP_SYNCHRONOUS_IO) &&\n \t\t    __swap_count(entry) == 1) {\n \t\t\t/* skip swapcache */\n \t\t\tfolio = alloc_swap_folio(vmf);\n@@ -4736,6 +4750,17 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\t\t\t}\n \t\t\t\tneed_clear_cache = true;\n \n+\t\t\t\t/*\n+\t\t\t\t * Recheck to make sure the entire range is still\n+\t\t\t\t * THP-swapin-able. Note that before we call\n+\t\t\t\t * swapcache_prepare(), entries in the range can\n+\t\t\t\t * still have their backing status changed.\n+\t\t\t\t */\n+\t\t\t\tif (!vswap_can_swapin_thp(entry, nr_pages)) {\n+\t\t\t\t\tschedule_timeout_uninterruptible(1);\n+\t\t\t\t\tgoto out_page;\n+\t\t\t\t}\n+\n \t\t\t\tmemcg1_swapin(entry, nr_pages);\n \n \t\t\t\tshadow = swap_cache_get_shadow(entry);\n@@ -4916,27 +4941,40 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\t\t * swapcache -> certainly exclusive.\n \t\t\t */\n \t\t\texclusive = true;\n-\t\t} else if (exclusive && folio_test_writeback(folio) &&\n-\t\t\t  data_race(si->flags & SWP_STABLE_WRITES)) {\n+\t\t} else if (exclusive && folio_test_writeback(folio)) {\n \t\t\t/*\n-\t\t\t * This is tricky: not all swap backends support\n-\t\t\t * concurrent page modifications while under writeback.\n-\t\t\t *\n-\t\t\t * So if we stumble over such a page in the swapcache\n-\t\t\t * we must not set the page exclusive, otherwise we can\n-\t\t\t * map it writable without further checks and modify it\n-\t\t\t * while still under writeback.\n+\t\t\t * We need to look up the swap device again here, because\n+\t\t\t * the si we got from tryget_swap_entry() might have changed\n+\t\t\t * before we pin the backend.\n \t\t\t *\n-\t\t\t * For these problematic swap backends, simply drop the\n-\t\t\t * exclusive marker: this is perfectly fine as we start\n-\t\t\t * writeback only if we fully unmapped the page and\n-\t\t\t * there are no unexpected references on the page after\n-\t\t\t * unmapping succeeded. After fully unmapped, no\n-\t\t\t * further GUP references (FOLL_GET and FOLL_PIN) can\n-\t\t\t * appear, so dropping the exclusive marker and mapping\n-\t\t\t * it only R/O is fine.\n+\t\t\t * With the folio locked and loaded into the swap cache, we can\n+\t\t\t * now guarantee a stable backing state.\n \t\t\t */\n-\t\t\texclusive = false;\n+\t\t\tstable_si = vswap_get_device(entry);\n+\t\t\tif (stable_si && data_race(stable_si->flags & SWP_STABLE_WRITES)) {\n+\t\t\t\t/*\n+\t\t\t\t * This is tricky: not all swap backends support\n+\t\t\t\t * concurrent page modifications while under writeback.\n+\t\t\t\t *\n+\t\t\t\t * So if we stumble over such a page in the swapcache\n+\t\t\t\t * we must not set the page exclusive, otherwise we can\n+\t\t\t\t * map it writable without further checks and modify it\n+\t\t\t\t * while still under writeback.\n+\t\t\t\t *\n+\t\t\t\t * For these problematic swap backends, simply drop the\n+\t\t\t\t * exclusive marker: this is perfectly fine as we start\n+\t\t\t\t * writeback only if we fully unmapped the page and\n+\t\t\t\t * there are no unexpected references on the page after\n+\t\t\t\t * unmapping succeeded. After fully unmapped, no\n+\t\t\t\t * further GUP references (FOLL_GET and FOLL_PIN) can\n+\t\t\t\t * appear, so dropping the exclusive marker and mapping\n+\t\t\t\t * it only R/O is fine.\n+\t\t\t\t */\n+\t\t\t\texclusive = false;\n+\t\t\t}\n+\n+\t\t\tif (stable_si)\n+\t\t\t\tswap_slot_put_swap_info(stable_si);\n \t\t}\n \t}\n \n@@ -5045,7 +5083,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\t\twake_up(&swapcache_wq);\n \t}\n \tif (swapoff_locked)\n-\t\tput_swap_entry(entry, si);\n+\t\tput_swap_entry(orig_entry, si);\n \treturn ret;\n out_nomap:\n \tif (vmf->pte)\n@@ -5064,7 +5102,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\t\twake_up(&swapcache_wq);\n \t}\n \tif (swapoff_locked)\n-\t\tput_swap_entry(entry, si);\n+\t\tput_swap_entry(orig_entry, si);\n \treturn ret;\n }\n \ndiff --git a/mm/page_io.c b/mm/page_io.c\nindex 5de3705572955..675ec6445609b 100644\n--- a/mm/page_io.c\n+++ b/mm/page_io.c\n@@ -201,44 +201,6 @@ static bool is_folio_zero_filled(struct folio *folio)\n \treturn true;\n }\n \n-static void swap_zeromap_folio_set(struct folio *folio)\n-{\n-\tstruct obj_cgroup *objcg = get_obj_cgroup_from_folio(folio);\n-\tstruct swap_info_struct *sis =\n-\t\t__swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n-\tint nr_pages = folio_nr_pages(folio);\n-\tswp_entry_t entry;\n-\tswp_slot_t slot;\n-\tunsigned int i;\n-\n-\tfor (i = 0; i < folio_nr_pages(folio); i++) {\n-\t\tentry = page_swap_entry(folio_page(folio, i));\n-\t\tslot = swp_entry_to_swp_slot(entry);\n-\t\tset_bit(swp_slot_offset(slot), sis->zeromap);\n-\t}\n-\n-\tcount_vm_events(SWPOUT_ZERO, nr_pages);\n-\tif (objcg) {\n-\t\tcount_objcg_events(objcg, SWPOUT_ZERO, nr_pages);\n-\t\tobj_cgroup_put(objcg);\n-\t}\n-}\n-\n-static void swap_zeromap_folio_clear(struct folio *folio)\n-{\n-\tstruct swap_info_struct *sis =\n-\t\t__swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n-\tswp_entry_t entry;\n-\tswp_slot_t slot;\n-\tunsigned int i;\n-\n-\tfor (i = 0; i < folio_nr_pages(folio); i++) {\n-\t\tentry = page_swap_entry(folio_page(folio, i));\n-\t\tslot = swp_entry_to_swp_slot(entry);\n-\t\tclear_bit(swp_slot_offset(slot), sis->zeromap);\n-\t}\n-}\n-\n /*\n  * We may have stale swap cache pages in memory: notice\n  * them here and get rid of the unnecessary final write.\n@@ -260,23 +222,22 @@ int swap_writeout(struct folio *folio, struct swap_iocb **swap_plug)\n \t\tgoto out_unlock;\n \t}\n \n-\t/*\n-\t * Use a bitmap (zeromap) to avoid doing IO for zero-filled pages.\n-\t * The bits in zeromap are protected by the locked swapcache folio\n-\t * and atomic updates are used to protect against read-modify-write\n-\t * corruption due to other zero swap entries seeing concurrent updates.\n-\t */\n \tif (is_folio_zero_filled(folio)) {\n \t\tswap_zeromap_folio_set(folio);\n \t\tgoto out_unlock;\n \t}\n \n \t/*\n-\t * Clear bits this folio occupies in the zeromap to prevent zero data\n-\t * being read in from any previous zero writes that occupied the same\n-\t * swap entries.\n+\t * Release swap backends to make sure we do not have mixed backends\n+\t *\n+\t * The only exception is if the folio is already backed by a\n+\t * contiguous range of physical swap slots (for e.g, from a previous\n+\t * swapout attempt when zswap is disabled).\n+\t *\n+\t * Keep that backend to avoid reallocation of physical swap slots.\n \t */\n-\tswap_zeromap_folio_clear(folio);\n+\tif (!vswap_swapfile_backed(folio->swap, folio_nr_pages(folio)))\n+\t\tvswap_store_folio(folio->swap, folio);\n \n \tif (zswap_store(folio)) {\n \t\tcount_mthp_stat(folio_order(folio), MTHP_STAT_ZSWPOUT);\n@@ -287,6 +248,12 @@ int swap_writeout(struct folio *folio, struct swap_iocb **swap_plug)\n \t\treturn AOP_WRITEPAGE_ACTIVATE;\n \t}\n \n+\t/* fall back to physical swap device */\n+\tif (!vswap_alloc_swap_slot(folio)) {\n+\t\tfolio_mark_dirty(folio);\n+\t\treturn AOP_WRITEPAGE_ACTIVATE;\n+\t}\n+\n \t__swap_writepage(folio, swap_plug);\n \treturn 0;\n out_unlock:\n@@ -618,14 +585,11 @@ static void swap_read_folio_bdev_async(struct folio *folio,\n \n void swap_read_folio(struct folio *folio, struct swap_iocb **plug)\n {\n-\tstruct swap_info_struct *sis =\n-\t\t__swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n-\tbool synchronous = sis->flags & SWP_SYNCHRONOUS_IO;\n-\tbool workingset = folio_test_workingset(folio);\n+\tstruct swap_info_struct *sis;\n+\tbool synchronous, workingset = folio_test_workingset(folio);\n \tunsigned long pflags;\n \tbool in_thrashing;\n \n-\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio) && !synchronous, folio);\n \tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n \tVM_BUG_ON_FOLIO(folio_test_uptodate(folio), folio);\n \n@@ -651,6 +615,10 @@ void swap_read_folio(struct folio *folio, struct swap_iocb **plug)\n \t/* We have to read from slower devices. Increase zswap protection. */\n \tzswap_folio_swapin(folio);\n \n+\tsis = __swap_slot_to_info(swp_entry_to_swp_slot(folio->swap));\n+\tsynchronous = sis->flags & SWP_SYNCHRONOUS_IO;\n+\tVM_BUG_ON_FOLIO(!folio_test_swapcache(folio) && !synchronous, folio);\n+\n \tif (data_race(sis->flags & SWP_FS_OPS)) {\n \t\tswap_read_folio_fs(folio, plug);\n \t} else if (synchronous) {\ndiff --git a/mm/shmem.c b/mm/shmem.c\nindex 780571c830e5b..3a346cca114ab 100644\n--- a/mm/shmem.c\n+++ b/mm/shmem.c\n@@ -1459,7 +1459,7 @@ static unsigned int shmem_find_swap_entries(struct address_space *mapping,\n \t\t * swapin error entries can be found in the mapping. But they're\n \t\t * deliberately ignored here as we've done everything we can do.\n \t\t */\n-\t\tif (swp_slot_type(slot) != type)\n+\t\tif (!slot.val || swp_slot_type(slot) != type)\n \t\t\tcontinue;\n \n \t\tindices[folio_batch_count(fbatch)] = xas.xa_index;\n@@ -1604,7 +1604,7 @@ int shmem_writeout(struct folio *folio, struct swap_iocb **plug,\n \tif ((info->flags & SHMEM_F_LOCKED) || sbinfo->noswap)\n \t\tgoto redirty;\n \n-\tif (!total_swap_pages)\n+\tif (!zswap_is_enabled() && !total_swap_pages)\n \t\tgoto redirty;\n \n \t/*\n@@ -2341,7 +2341,7 @@ static int shmem_swapin_folio(struct inode *inode, pgoff_t index,\n \t/* Look it up and read it in.. */\n \tfolio = swap_cache_get_folio(swap);\n \tif (!folio) {\n-\t\tif (data_race(si->flags & SWP_SYNCHRONOUS_IO)) {\n+\t\tif (si && data_race(si->flags & SWP_SYNCHRONOUS_IO)) {\n \t\t\t/* Direct swapin skipping swap cache & readahead */\n \t\t\tfolio = shmem_swap_alloc_folio(inode, vma, index,\n \t\t\t\t\t\t       index_entry, order, gfp);\ndiff --git a/mm/swap.h b/mm/swap.h\nindex ae97cf9712c5c..d41e6a0e70753 100644\n--- a/mm/swap.h\n+++ b/mm/swap.h\n@@ -310,35 +310,15 @@ static inline unsigned int folio_swap_flags(struct folio *folio)\n {\n \tswp_slot_t swp_slot = swp_entry_to_swp_slot(folio->swap);\n \n+\t/* The folio might not be backed by any physical swap slots\n+\t * (for e.g zswap-backed only).\n+\t */\n+\tif (!swp_slot.val)\n+\t\treturn 0;\n \treturn __swap_slot_to_info(swp_slot)->flags;\n }\n \n-/*\n- * Return the count of contiguous swap entries that share the same\n- * zeromap status as the starting entry. If is_zeromap is not NULL,\n- * it will return the zeromap status of the starting entry.\n- */\n-static inline int swap_zeromap_batch(swp_entry_t entry, int max_nr,\n-\t\tbool *is_zeromap)\n-{\n-\tswp_slot_t slot = swp_entry_to_swp_slot(entry);\n-\tstruct swap_info_struct *sis = __swap_slot_to_info(slot);\n-\tunsigned long start = swp_slot_offset(slot);\n-\tunsigned long end = start + max_nr;\n-\tbool first_bit;\n-\n-\tfirst_bit = test_bit(start, sis->zeromap);\n-\tif (is_zeromap)\n-\t\t*is_zeromap = first_bit;\n-\n-\tif (max_nr <= 1)\n-\t\treturn max_nr;\n-\tif (first_bit)\n-\t\treturn find_next_zero_bit(sis->zeromap, end, start) - start;\n-\telse\n-\t\treturn find_next_bit(sis->zeromap, end, start) - start;\n-}\n-\n+int swap_zeromap_batch(swp_entry_t entry, int max_nr, bool *is_zeromap);\n int non_swapcache_batch(swp_entry_t entry, int max_nr);\n \n #else /* CONFIG_SWAP */\ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex 1827527e88d33..ad80bf098b63f 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -179,6 +179,10 @@ struct folio *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \tstruct folio *result = NULL;\n \tvoid *shadow = NULL;\n \n+\t/* we might get an unsed entry from cluster readahead - just skip */\n+\tif (!entry.val)\n+\t\treturn NULL;\n+\n \t*new_page_allocated = false;\n \tfor (;;) {\n \t\tint err;\n@@ -213,8 +217,20 @@ struct folio *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n \t\t * Swap entry may have been freed since our caller observed it.\n \t\t */\n \t\terr = swapcache_prepare(entry, 1);\n-\t\tif (!err)\n+\t\tif (!err) {\n+\t\t\t/* This might be invoked by swap_cluster_readahead(), which can\n+\t\t\t * race with shmem_swapin_folio(). The latter might have already\n+\t\t\t * called swap_cache_del_folio(), allowing swapcache_prepare()\n+\t\t\t * to succeed here. This can lead to reading bogus data to populate\n+\t\t\t * the page. To prevent this, skip folio-backed virtual swap slots,\n+\t\t\t * and let caller retry if necessary.\n+\t\t\t */\n+\t\t\tif (vswap_folio_backed(entry, 1)) {\n+\t\t\t\tswapcache_clear(entry, 1);\n+\t\t\t\tgoto put_and_return;\n+\t\t\t}\n \t\t\tbreak;\n+\t\t}\n \t\telse if (err != -EEXIST)\n \t\t\tgoto put_and_return;\n \n@@ -391,11 +407,18 @@ struct folio *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n \tunsigned long offset = slot_offset;\n \tunsigned long start_offset, end_offset;\n \tunsigned long mask;\n-\tstruct swap_info_struct *si = __swap_slot_to_info(slot);\n+\tstruct swap_info_struct *si = swap_slot_tryget_swap_info(slot);\n \tstruct blk_plug plug;\n \tstruct swap_iocb *splug = NULL;\n \tbool page_allocated;\n \n+\t/*\n+\t * The swap entry might not be backed by any physical swap slot. In that\n+\t * case, just skip readahead and bring in the target entry.\n+\t */\n+\tif (!si)\n+\t\tgoto skip;\n+\n \tmask = swapin_nr_pages(offset) - 1;\n \tif (!mask)\n \t\tgoto skip;\n@@ -429,6 +452,8 @@ struct folio *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n \tswap_read_unplug(splug);\n \tlru_add_drain();\t/* Push any new pages onto the LRU now */\n skip:\n+\tif (si)\n+\t\tswap_slot_put_swap_info(si);\n \t/* The page was likely read above, so no need for plugging here */\n \tfolio = __read_swap_cache_async(entry, gfp_mask, mpol, ilx,\n \t\t\t\t\t&page_allocated, false);\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 6c5e46bf40701..1aa29dd220f9a 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -1210,14 +1210,6 @@ static void swap_range_free(struct swap_info_struct *si, unsigned long offset,\n {\n \tunsigned long end = offset + nr_entries - 1;\n \tvoid (*swap_slot_free_notify)(struct block_device *, unsigned long);\n-\tunsigned int i;\n-\n-\t/*\n-\t * Use atomic clear_bit operations only on zeromap instead of non-atomic\n-\t * bitmap_clear to prevent adjacent bits corruption due to simultaneous writes.\n-\t */\n-\tfor (i = 0; i < nr_entries; i++)\n-\t\tclear_bit(offset + i, si->zeromap);\n \n \tif (si->flags & SWP_BLKDEV)\n \t\tswap_slot_free_notify =\ndiff --git a/mm/vmscan.c b/mm/vmscan.c\nindex c9ec1a1458b4e..6b200a6bb1160 100644\n--- a/mm/vmscan.c\n+++ b/mm/vmscan.c\n@@ -365,10 +365,11 @@ static inline bool can_reclaim_anon_pages(struct mem_cgroup *memcg,\n {\n \tif (memcg == NULL) {\n \t\t/*\n-\t\t * For non-memcg reclaim, is there\n-\t\t * space in any swap device?\n+\t\t * For non-memcg reclaim:\n+\t\t *\n+\t\t * Check if zswap is enabled or if there is space in any swap device?\n \t\t */\n-\t\tif (get_nr_swap_pages() > 0)\n+\t\tif (zswap_is_enabled() || get_nr_swap_pages() > 0)\n \t\t\treturn true;\n \t} else {\n \t\t/* Is the memcg below its swap limit? */\n@@ -2640,12 +2641,12 @@ static void get_scan_count(struct lruvec *lruvec, struct scan_control *sc,\n static bool can_age_anon_pages(struct lruvec *lruvec,\n \t\t\t       struct scan_control *sc)\n {\n-\t/* Aging the anon LRU is valuable if swap is present: */\n-\tif (total_swap_pages > 0)\n-\t\treturn true;\n-\n-\t/* Also valuable if anon pages can be demoted: */\n-\treturn can_demote(lruvec_pgdat(lruvec)->node_id, sc,\n+\t/*\n+\t * Aging the anon LRU is valuable if zswap or physical swap is available or\n+\t * anon pages can be demoted\n+\t */\n+\treturn zswap_is_enabled() || total_swap_pages > 0 ||\n+\t\t\tcan_demote(lruvec_pgdat(lruvec)->node_id, sc,\n \t\t\t  lruvec_memcg(lruvec));\n }\n \ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex 318933071edc6..fb6179ce3ace7 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -11,6 +11,7 @@\n #include <linux/swap_cgroup.h>\n #include <linux/cpuhotplug.h>\n #include <linux/zswap.h>\n+#include \"internal.h\"\n #include \"swap.h\"\n #include \"swap_table.h\"\n \n@@ -54,22 +55,48 @@\n  *\n  * Note that we do not have a reference count field per se - it is derived from\n  * the swap_count and the in_swapcache fields.\n+ *\n+ * III. Backing State\n+ *\n+ * Each virtual swap slot can be backed by:\n+ *\n+ * 1. A slot on a physical swap device (i.e a swapfile or a swap partition).\n+ * 2. A swapped out zero-filled page.\n+ * 3. A compressed object in zswap.\n+ * 4. An in-memory folio, that is not backed by neither a physical swap device\n+ *    nor zswap (i.e only in swap cache). This is used for pages that are\n+ *    rejected by zswap, but not (yet) backed by a physical swap device,\n+ *    (for e.g, due to zswap.writeback = 0), or for pages that were previously\n+ *    stored in zswap, but has since been loaded back into memory (and has its\n+ *    zswap copy invalidated).\n  */\n \n+/* The backing state options of a virtual swap slot */\n+enum swap_type {\n+\tVSWAP_SWAPFILE,\n+\tVSWAP_ZERO,\n+\tVSWAP_ZSWAP,\n+\tVSWAP_FOLIO\n+};\n+\n /**\n  * Swap descriptor - metadata of a swapped out page.\n  *\n  * @slot: The handle to the physical swap slot backing this page.\n  * @zswap_entry: The zswap entry associated with this swap slot.\n- * @swap_cache: The folio in swap cache.\n+ * @swap_cache: The folio in swap cache. If the swap entry backing type is\n+ *              VSWAP_FOLIO, the backend is also stored here.\n  * @shadow: The shadow entry.\n- * @memcgid: The memcg id of the owning memcg, if any.\n  * @swap_count: The number of page table entries that refer to the swap entry.\n+ * @memcgid: The memcg id of the owning memcg, if any.\n  * @in_swapcache: Whether the swap entry is (about to be) pinned in swap cache.\n+ * @type: The backing store type of the swap entry.\n  */\n struct swp_desc {\n-\tswp_slot_t slot;\n-\tstruct zswap_entry *zswap_entry;\n+\tunion {\n+\t\tswp_slot_t slot;\n+\t\tstruct zswap_entry *zswap_entry;\n+\t};\n \tunion {\n \t\tstruct folio *swap_cache;\n \t\tvoid *shadow;\n@@ -78,10 +105,10 @@ struct swp_desc {\n \tunsigned int swap_count;\n \n #ifdef CONFIG_MEMCG\n-\tunsigned short memcgid;\n+\tunsigned short memcgid:16;\n #endif\n-\n-\tbool in_swapcache;\n+\tbool in_swapcache:1;\n+\tenum swap_type type:2;\n };\n \n #define VSWAP_CLUSTER_SHIFT HPAGE_PMD_ORDER\n@@ -266,15 +293,16 @@ static bool cluster_is_alloc_candidate(struct vswap_cluster *cluster)\n \treturn cluster->count + (1 << (cluster->order)) <= VSWAP_CLUSTER_SIZE;\n }\n \n-static void __vswap_alloc_from_cluster(struct vswap_cluster *cluster, int start)\n+static void __vswap_alloc_from_cluster(struct vswap_cluster *cluster,\n+\t\tint start, struct folio *folio)\n {\n \tint i, nr = 1 << cluster->order;\n \tstruct swp_desc *desc;\n \n \tfor (i = 0; i < nr; i++) {\n \t\tdesc = &cluster->descriptors[start + i];\n-\t\tdesc->slot.val = 0;\n-\t\tdesc->zswap_entry = NULL;\n+\t\tdesc->type = VSWAP_FOLIO;\n+\t\tdesc->swap_cache = folio;\n #ifdef CONFIG_MEMCG\n \t\tdesc->memcgid = 0;\n #endif\n@@ -284,7 +312,8 @@ static void __vswap_alloc_from_cluster(struct vswap_cluster *cluster, int start)\n \tcluster->count += nr;\n }\n \n-static unsigned long vswap_alloc_from_cluster(struct vswap_cluster *cluster)\n+static unsigned long vswap_alloc_from_cluster(struct vswap_cluster *cluster,\n+\t\tstruct folio *folio)\n {\n \tint nr = 1 << cluster->order;\n \tunsigned long i = cluster->id ? 0 : nr;\n@@ -303,16 +332,16 @@ static unsigned long vswap_alloc_from_cluster(struct vswap_cluster *cluster)\n \tbitmap_set(cluster->bitmap, i, nr);\n \n \trefcount_add(nr, &cluster->refcnt);\n-\t__vswap_alloc_from_cluster(cluster, i);\n+\t__vswap_alloc_from_cluster(cluster, i, folio);\n \treturn i + (cluster->id << VSWAP_CLUSTER_SHIFT);\n }\n \n /* Allocate a contiguous range of virtual swap slots */\n-static swp_entry_t vswap_alloc(int order)\n+static swp_entry_t vswap_alloc(struct folio *folio)\n {\n \tstruct xa_limit limit = vswap_cluster_map_limit;\n \tstruct vswap_cluster *local, *cluster;\n-\tint nr = 1 << order;\n+\tint order = folio_order(folio), nr = 1 << order;\n \tbool need_caching = true;\n \tu32 cluster_id;\n \tswp_entry_t entry;\n@@ -325,7 +354,7 @@ static swp_entry_t vswap_alloc(int order)\n \tcluster = this_cpu_read(percpu_vswap_cluster.clusters[order]);\n \tif (cluster) {\n \t\tspin_lock(&cluster->lock);\n-\t\tentry.val = vswap_alloc_from_cluster(cluster);\n+\t\tentry.val = vswap_alloc_from_cluster(cluster, folio);\n \t\tneed_caching = !entry.val;\n \n \t\tif (!entry.val || !cluster_is_alloc_candidate(cluster)) {\n@@ -352,7 +381,7 @@ static swp_entry_t vswap_alloc(int order)\n \t\t\tif (!spin_trylock(&cluster->lock))\n \t\t\t\tcontinue;\n \n-\t\t\tentry.val = vswap_alloc_from_cluster(cluster);\n+\t\t\tentry.val = vswap_alloc_from_cluster(cluster, folio);\n \t\t\tlist_del_init(&cluster->list);\n \t\t\tcluster->full = !entry.val || !cluster_is_alloc_candidate(cluster);\n \t\t\tneed_caching = !cluster->full;\n@@ -384,7 +413,7 @@ static swp_entry_t vswap_alloc(int order)\n \t\t\t\tif (!cluster_id)\n \t\t\t\t\tentry.val += nr;\n \t\t\t\t__vswap_alloc_from_cluster(cluster,\n-\t\t\t\t\t(entry.val & VSWAP_CLUSTER_MASK));\n+\t\t\t\t\t(entry.val & VSWAP_CLUSTER_MASK), folio);\n \t\t\t\t/* Mark the allocated range in the bitmap */\n \t\t\t\tbitmap_set(cluster->bitmap, (entry.val & VSWAP_CLUSTER_MASK), nr);\n \t\t\t\tneed_caching = cluster_is_alloc_candidate(cluster);\n@@ -497,6 +526,84 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \t\t__swap_table_set(ci, ci_off + i, vswap ? vswap + i : 0);\n }\n \n+/*\n+ * Caller needs to handle races with other operations themselves.\n+ *\n+ * Specifically, this function is safe to be called in contexts where the swap\n+ * entry has been added to the swap cache and the associated folio is locked.\n+ * We cannot race with other accessors, and the swap entry is guaranteed to be\n+ * valid the whole time (since swap cache implies one refcount).\n+ *\n+ * We cannot assume that the backends will be of the same type,\n+ * contiguous, etc. We might have a large folio coalesced from subpages with\n+ * mixed backend, which is only rectified when it is reclaimed.\n+ */\n+ static void release_backing(swp_entry_t entry, int nr)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tunsigned long flush_nr, phys_swap_start = 0, phys_swap_end = 0;\n+\tunsigned int phys_swap_type = 0;\n+\tbool need_flushing_phys_swap = false;\n+\tswp_slot_t flush_slot;\n+\tint i;\n+\n+\tVM_WARN_ON(!entry.val);\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tVM_WARN_ON(!desc);\n+\n+\t\t/*\n+\t\t * We batch contiguous physical swap slots for more efficient\n+\t\t * freeing.\n+\t\t */\n+\t\tif (phys_swap_start != phys_swap_end &&\n+\t\t\t\t(desc->type != VSWAP_SWAPFILE ||\n+\t\t\t\t\tswp_slot_type(desc->slot) != phys_swap_type ||\n+\t\t\t\t\tswp_slot_offset(desc->slot) != phys_swap_end)) {\n+\t\t\tneed_flushing_phys_swap = true;\n+\t\t\tflush_slot = swp_slot(phys_swap_type, phys_swap_start);\n+\t\t\tflush_nr = phys_swap_end - phys_swap_start;\n+\t\t\tphys_swap_start = phys_swap_end = 0;\n+\t\t}\n+\n+\t\tif (desc->type == VSWAP_ZSWAP && desc->zswap_entry) {\n+\t\t\tzswap_entry_free(desc->zswap_entry);\n+\t\t} else if (desc->type == VSWAP_SWAPFILE) {\n+\t\t\tif (!phys_swap_start) {\n+\t\t\t\t/* start a new contiguous range of phys swap */\n+\t\t\t\tphys_swap_start = swp_slot_offset(desc->slot);\n+\t\t\t\tphys_swap_end = phys_swap_start + 1;\n+\t\t\t\tphys_swap_type = swp_slot_type(desc->slot);\n+\t\t\t} else {\n+\t\t\t\t/* extend the current contiguous range of phys swap */\n+\t\t\t\tphys_swap_end++;\n+\t\t\t}\n+\t\t}\n+\n+\t\tdesc->slot.val = 0;\n+\n+\t\tif (need_flushing_phys_swap) {\n+\t\t\tspin_unlock(&cluster->lock);\n+\t\t\tcluster = NULL;\n+\t\t\tswap_slot_free_nr(flush_slot, flush_nr);\n+\t\t\tneed_flushing_phys_swap = false;\n+\t\t}\n+\t}\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\t/* Flush any remaining physical swap range */\n+\tif (phys_swap_start) {\n+\t\tflush_slot = swp_slot(phys_swap_type, phys_swap_start);\n+\t\tflush_nr = phys_swap_end - phys_swap_start;\n+\t\tswap_slot_free_nr(flush_slot, flush_nr);\n+\t}\n+ }\n+\n /*\n  * Entered with the cluster locked, but might unlock the cluster.\n  * This is because several operations, such as releasing physical swap slots\n@@ -516,35 +623,21 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n static void vswap_free(struct vswap_cluster *cluster, struct swp_desc *desc,\n \tswp_entry_t entry)\n {\n-\tstruct zswap_entry *zswap_entry;\n-\tswp_slot_t slot;\n-\n \t/* Clear shadow if present */\n \tif (xa_is_value(desc->shadow))\n \t\tdesc->shadow = NULL;\n-\n-\tslot = desc->slot;\n-\tdesc->slot.val = 0;\n-\n-\tzswap_entry = desc->zswap_entry;\n-\tif (zswap_entry) {\n-\t\tdesc->zswap_entry = NULL;\n-\t\tzswap_entry_free(zswap_entry);\n-\t}\n \tspin_unlock(&cluster->lock);\n \n+\trelease_backing(entry, 1);\n \tmem_cgroup_uncharge_swap(entry, 1);\n \n-\tif (slot.val)\n-\t\tswap_slot_free_nr(slot, 1);\n-\n-\tspin_lock(&cluster->lock);\n \t/* erase forward mapping and release the virtual slot for reallocation */\n+\tspin_lock(&cluster->lock);\n \trelease_vswap_slot(cluster, entry.val);\n }\n \n /**\n- * folio_alloc_swap - allocate swap space for a folio.\n+ * folio_alloc_swap - allocate virtual swap space for a folio.\n  * @folio: the folio.\n  *\n  * Return: 0, if the allocation succeeded, -ENOMEM, if the allocation failed.\n@@ -552,38 +645,77 @@ static void vswap_free(struct vswap_cluster *cluster, struct swp_desc *desc,\n int folio_alloc_swap(struct folio *folio)\n {\n \tstruct vswap_cluster *cluster = NULL;\n-\tstruct swap_info_struct *si;\n-\tstruct swap_cluster_info *ci;\n-\tint i, nr = folio_nr_pages(folio), order = folio_order(folio);\n+\tint i, nr = folio_nr_pages(folio);\n \tstruct swp_desc *desc;\n \tswp_entry_t entry;\n-\tswp_slot_t slot;\n \n \tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n \tVM_BUG_ON_FOLIO(!folio_test_uptodate(folio), folio);\n \n-\tentry = vswap_alloc(folio_order(folio));\n+\tentry = vswap_alloc(folio);\n \tif (!entry.val)\n \t\treturn -ENOMEM;\n \n \t/*\n-\t * XXX: for now, we always allocate a physical swap slot for each virtual\n-\t * swap slot, and their lifetime are coupled. This will change once we\n-\t * decouple virtual swap slots from their backing states, and only allocate\n-\t * physical swap slots for them on demand (i.e on zswap writeback, or\n-\t * fallback from zswap store failure).\n+\t * XXX: for now, we charge towards the memory cgroup's swap limit on virtual\n+\t * swap slots allocation. This will be changed soon - we will only charge on\n+\t * physical swap slots allocation.\n \t */\n-\tif (swap_slot_alloc(&slot, order)) {\n+\tif (mem_cgroup_try_charge_swap(folio, entry)) {\n+\t\trcu_read_lock();\n \t\tfor (i = 0; i < nr; i++) {\n \t\t\tdesc = vswap_iter(&cluster, entry.val + i);\n \t\t\tVM_WARN_ON(!desc);\n \t\t\tvswap_free(cluster, desc, (swp_entry_t){ entry.val + i });\n \t\t}\n \t\tspin_unlock(&cluster->lock);\n+\t\trcu_read_unlock();\n+\t\tatomic_add(nr, &vswap_alloc_reject);\n \t\tentry.val = 0;\n \t\treturn -ENOMEM;\n \t}\n \n+\tswap_cache_add_folio(folio, entry, NULL);\n+\n+\treturn 0;\n+}\n+\n+/**\n+ * vswap_alloc_swap_slot - allocate physical swap space for a folio that is\n+ *                         already associated with virtual swap slots.\n+ * @folio: folio we want to allocate physical swap space for.\n+ *\n+ * Note that this does NOT release existing swap backends of the folio.\n+ * Callers need to handle this themselves.\n+\n+ * Return: true if the folio is now backed by physical swap slots, false\n+ * otherwise.\n+ */\n+bool vswap_alloc_swap_slot(struct folio *folio)\n+{\n+\tint i, nr = folio_nr_pages(folio);\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swap_info_struct *si;\n+\tstruct swap_cluster_info *ci;\n+\tswp_slot_t slot = { .val = 0 };\n+\tswp_entry_t entry = folio->swap;\n+\tstruct swp_desc *desc;\n+\tbool fallback = false;\n+\n+\t/*\n+\t * We might have already allocated a backing physical swap slot in past\n+\t * attempts (for instance, when we disable zswap). If the entire range is\n+\t * already swapfile-backed we can skip swapfile case.\n+\t */\n+\tif (vswap_swapfile_backed(entry, nr))\n+\t\treturn true;\n+\n+\tif (swap_slot_alloc(&slot, folio_order(folio)))\n+\t\treturn false;\n+\n+\tif (!slot.val)\n+\t\treturn false;\n+\n \t/* establish the vrtual <-> physical swap slots linkages. */\n \tsi = __swap_slot_to_info(slot);\n \tci = swap_cluster_lock(si, swp_slot_offset(slot));\n@@ -595,29 +727,29 @@ int folio_alloc_swap(struct folio *folio)\n \t\tdesc = vswap_iter(&cluster, entry.val + i);\n \t\tVM_WARN_ON(!desc);\n \n+\t\tif (desc->type == VSWAP_FOLIO) {\n+\t\t\t/* case 1: fallback from zswap store failure */\n+\t\t\tfallback = true;\n+\t\t\tif (!folio)\n+\t\t\t\tfolio = desc->swap_cache;\n+\t\t\telse\n+\t\t\t\tVM_WARN_ON(folio != desc->swap_cache);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * Case 2: zswap writeback.\n+\t\t\t *\n+\t\t\t * No need to free zswap entry here - it will be freed once zswap\n+\t\t\t * writeback suceeds.\n+\t\t\t */\n+\t\t\tVM_WARN_ON(desc->type != VSWAP_ZSWAP);\n+\t\t\tVM_WARN_ON(fallback);\n+\t\t}\n+\t\tdesc->type = VSWAP_SWAPFILE;\n \t\tdesc->slot.val = slot.val + i;\n \t}\n-\tif (cluster)\n-\t\tspin_unlock(&cluster->lock);\n+\tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n-\n-\t/*\n-\t * XXX: for now, we charge towards the memory cgroup's swap limit on virtual\n-\t * swap slots allocation. This is acceptable because as noted above, each\n-\t * virtual swap slot corresponds to a physical swap slot. Once we have\n-\t * decoupled virtual and physical swap slots, we will only charge when we\n-\t * actually allocate a physical swap slot.\n-\t */\n-\tif (mem_cgroup_try_charge_swap(folio, entry))\n-\t\tgoto out_free;\n-\n-\tswap_cache_add_folio(folio, entry, NULL);\n-\n-\treturn 0;\n-\n-out_free:\n-\tput_swap_folio(folio, entry);\n-\treturn -ENOMEM;\n+\treturn true;\n }\n \n /**\n@@ -625,7 +757,9 @@ int folio_alloc_swap(struct folio *folio)\n  *                         virtual swap slot.\n  * @entry: the virtual swap slot.\n  *\n- * Return: the physical swap slot corresponding to the virtual swap slot.\n+ * Return: the physical swap slot corresponding to the virtual swap slot, if\n+ * exists, or the zero physical swap slot if the virtual swap slot is not\n+ * backed by any physical slot on a swapfile.\n  */\n swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry)\n {\n@@ -644,7 +778,10 @@ swp_slot_t swp_entry_to_swp_slot(swp_entry_t entry)\n \t\treturn (swp_slot_t){0};\n \t}\n \n-\tslot = desc->slot;\n+\tif (desc->type != VSWAP_SWAPFILE)\n+\t\tslot.val = 0;\n+\telse\n+\t\tslot = desc->slot;\n \tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n \n@@ -962,6 +1099,293 @@ int non_swapcache_batch(swp_entry_t entry, int max_nr)\n \treturn i;\n }\n \n+/**\n+ * vswap_store_folio - set a folio as the backing of a range of virtual swap\n+ *                     slots.\n+ * @entry: the first virtual swap slot in the range.\n+ * @folio: the folio.\n+ */\n+void vswap_store_folio(swp_entry_t entry, struct folio *folio)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tint i, nr = folio_nr_pages(folio);\n+\tstruct swp_desc *desc;\n+\n+\tVM_BUG_ON(!folio_test_locked(folio));\n+\tVM_BUG_ON(folio->swap.val != entry.val);\n+\n+\trelease_backing(entry, nr);\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tVM_WARN_ON(!desc);\n+\t\tdesc->type = VSWAP_FOLIO;\n+\t\tdesc->swap_cache = folio;\n+\t}\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+}\n+\n+/**\n+ * swap_zeromap_folio_set - mark a range of virtual swap slots corresponding to\n+ *                          a folio as zero-filled.\n+ * @folio: the folio\n+ */\n+void swap_zeromap_folio_set(struct folio *folio)\n+{\n+\tstruct obj_cgroup *objcg = get_obj_cgroup_from_folio(folio);\n+\tstruct vswap_cluster *cluster = NULL;\n+\tswp_entry_t entry = folio->swap;\n+\tint i, nr = folio_nr_pages(folio);\n+\tstruct swp_desc *desc;\n+\n+\tVM_BUG_ON(!folio_test_locked(folio));\n+\tVM_BUG_ON(!entry.val);\n+\n+\trelease_backing(entry, nr);\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tVM_WARN_ON(!desc);\n+\t\tdesc->type = VSWAP_ZERO;\n+\t}\n+\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\n+\tcount_vm_events(SWPOUT_ZERO, nr);\n+\tif (objcg) {\n+\t\tcount_objcg_events(objcg, SWPOUT_ZERO, nr);\n+\t\tobj_cgroup_put(objcg);\n+\t}\n+}\n+\n+/*\n+ * Iterate through the entire range of virtual swap slots, returning the\n+ * longest contiguous range of slots starting from the first slot that satisfies:\n+ *\n+ * 1. If the first slot is zero-mapped, the entire range should be\n+ *    zero-mapped.\n+ * 2. If the first slot is backed by a swapfile, the entire range should\n+ *    be backed by a range of contiguous swap slots on the same swapfile.\n+ * 3. If the first slot is zswap-backed, the entire range should be\n+ *    zswap-backed.\n+ * 4. If the first slot is backed by a folio, the entire range should\n+ *    be backed by the same folio.\n+ *\n+ * Note that this check is racy unless we can ensure that the entire range\n+ * has their backing state stable - for instance, if the caller was the one\n+ * who set the swap cache pin.\n+ */\n+static int vswap_check_backing(swp_entry_t entry, enum swap_type *type, int nr)\n+{\n+\tunsigned int swapfile_type;\n+\tstruct vswap_cluster *cluster = NULL;\n+\tenum swap_type first_type;\n+\tstruct swp_desc *desc;\n+\tpgoff_t first_offset;\n+\tstruct folio *folio;\n+\tint i = 0;\n+\n+\tif (!entry.val)\n+\t\treturn 0;\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tif (!desc)\n+\t\t\tgoto done;\n+\n+\t\tif (!i) {\n+\t\t\tfirst_type = desc->type;\n+\t\t\tif (first_type == VSWAP_SWAPFILE) {\n+\t\t\t\tswapfile_type = swp_slot_type(desc->slot);\n+\t\t\t\tfirst_offset = swp_slot_offset(desc->slot);\n+\t\t\t} else if (first_type == VSWAP_FOLIO) {\n+\t\t\t\tfolio = desc->swap_cache;\n+\t\t\t}\n+\t\t} else if (desc->type != first_type) {\n+\t\t\tgoto done;\n+\t\t} else if (first_type == VSWAP_SWAPFILE &&\n+\t\t\t\t(swp_slot_type(desc->slot) != swapfile_type ||\n+\t\t\t\t\tswp_slot_offset(desc->slot) != first_offset + i)) {\n+\t\t\tgoto done;\n+\t\t} else if (first_type == VSWAP_FOLIO && desc->swap_cache != folio) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+done:\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\tif (type)\n+\t\t*type = first_type;\n+\treturn i;\n+}\n+\n+/**\n+ * vswap_swapfile_backed - check if the virtual swap slots are backed by physical\n+ *                         swap slots.\n+ * @entry: the first entry in the range.\n+ * @nr: the number of entries in the range.\n+ */\n+bool vswap_swapfile_backed(swp_entry_t entry, int nr)\n+{\n+\tenum swap_type type;\n+\n+\treturn vswap_check_backing(entry, &type, nr) == nr\n+\t\t\t\t&& type == VSWAP_SWAPFILE;\n+}\n+\n+/**\n+ * vswap_folio_backed - check if the virtual swap slots are backed by in-memory\n+ *                      pages.\n+ * @entry: the first virtual swap slot in the range.\n+ * @nr: the number of slots in the range.\n+ */\n+bool vswap_folio_backed(swp_entry_t entry, int nr)\n+{\n+\tenum swap_type type;\n+\n+\treturn vswap_check_backing(entry, &type, nr) == nr && type == VSWAP_FOLIO;\n+}\n+\n+/**\n+ * vswap_can_swapin_thp - check if the swap entries can be swapped in as a THP.\n+ * @entry: the first virtual swap slot in the range.\n+ * @nr: the number of slots in the range.\n+ *\n+ * For now, we can only swap in a THP if the entire range is zero-filled, or if\n+ * the entire range is backed by a contiguous range of physical swap slots on a\n+ * swapfile.\n+ */\n+bool vswap_can_swapin_thp(swp_entry_t entry, int nr)\n+{\n+\tenum swap_type type;\n+\n+\treturn vswap_check_backing(entry, &type, nr) == nr &&\n+\t\t(type == VSWAP_ZERO || type == VSWAP_SWAPFILE);\n+}\n+\n+/**\n+ * swap_move - increment the swap slot by delta, checking the backing state and\n+ *             return 0 if the backing state does not match (i.e wrong backing\n+ *             state type, or wrong offset on the backing stores).\n+ * @entry: the original virtual swap slot.\n+ * @delta: the offset to increment the original slot.\n+ *\n+ * Note that this function is racy unless we can pin the backing state of these\n+ * swap slots down with swapcache_prepare().\n+ *\n+ * Caller should only rely on this function as a best-effort hint otherwise,\n+ * and should double-check after ensuring the whole range is pinned down.\n+ *\n+ * Return: the incremented virtual swap slot if the backing state matches, or\n+ *         0 if the backing state does not match.\n+ */\n+swp_entry_t swap_move(swp_entry_t entry, long delta)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc, *next_desc;\n+\tswp_entry_t next_entry;\n+\tstruct folio *folio = NULL, *next_folio = NULL;\n+\tenum swap_type type, next_type;\n+\tswp_slot_t slot = {0}, next_slot = {0};\n+\n+\tnext_entry.val = entry.val + delta;\n+\n+\trcu_read_lock();\n+\n+\t/* Look up first descriptor and get its type and backing store */\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tif (!desc) {\n+\t\trcu_read_unlock();\n+\t\treturn (swp_entry_t){0};\n+\t}\n+\n+\ttype = desc->type;\n+\tif (type == VSWAP_ZSWAP) {\n+\t\t/* zswap not supported for move */\n+\t\tspin_unlock(&cluster->lock);\n+\t\trcu_read_unlock();\n+\t\treturn (swp_entry_t){0};\n+\t}\n+\tif (type == VSWAP_FOLIO)\n+\t\tfolio = desc->swap_cache;\n+\telse if (type == VSWAP_SWAPFILE)\n+\t\tslot = desc->slot;\n+\n+\t/* Look up second descriptor and get its type and backing store */\n+\tnext_desc = vswap_iter(&cluster, next_entry.val);\n+\tif (!next_desc) {\n+\t\trcu_read_unlock();\n+\t\treturn (swp_entry_t){0};\n+\t}\n+\n+\tnext_type = next_desc->type;\n+\tif (next_type == VSWAP_FOLIO)\n+\t\tnext_folio = next_desc->swap_cache;\n+\telse if (next_type == VSWAP_SWAPFILE)\n+\t\tnext_slot = next_desc->slot;\n+\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\n+\trcu_read_unlock();\n+\n+\t/* Check if types match */\n+\tif (next_type != type)\n+\t\treturn (swp_entry_t){0};\n+\n+\t/* Check backing state consistency */\n+\tif (type == VSWAP_SWAPFILE &&\n+\t\t\t(swp_slot_type(next_slot) != swp_slot_type(slot) ||\n+\t\t\t\tswp_slot_offset(next_slot) !=\n+\t\t\t\t\t\t\tswp_slot_offset(slot) + delta))\n+\t\treturn (swp_entry_t){0};\n+\n+\tif (type == VSWAP_FOLIO && next_folio != folio)\n+\t\treturn (swp_entry_t){0};\n+\n+\treturn next_entry;\n+}\n+\n+/*\n+ * Return the count of contiguous swap entries that share the same\n+ * VSWAP_ZERO status as the starting entry. If is_zeromap is not NULL,\n+ * it will return the VSWAP_ZERO status of the starting entry.\n+ */\n+int swap_zeromap_batch(swp_entry_t entry, int max_nr, bool *is_zeromap)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tint i = 0;\n+\tbool is_zero = false;\n+\n+\tVM_WARN_ON(!entry.val);\n+\n+\trcu_read_lock();\n+\tfor (i = 0; i < max_nr; i++) {\n+\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tif (!desc)\n+\t\t\tgoto done;\n+\n+\t\tif (!i)\n+\t\t\tis_zero = (desc->type == VSWAP_ZERO);\n+\t\telse if ((desc->type == VSWAP_ZERO) != is_zero)\n+\t\t\tgoto done;\n+\t}\n+done:\n+\tif (cluster)\n+\t\tspin_unlock(&cluster->lock);\n+\trcu_read_unlock();\n+\tif (i && is_zeromap)\n+\t\t*is_zeromap = is_zero;\n+\n+\treturn i;\n+}\n+\n /**\n  * free_swap_and_cache_nr() - Release a swap count on range of swap entries and\n  *                            reclaim their cache if no more references remain.\n@@ -1028,11 +1452,6 @@ bool tryget_swap_entry(swp_entry_t entry, struct swap_info_struct **si)\n \tstruct vswap_cluster *cluster;\n \tswp_slot_t slot;\n \n-\tslot = swp_entry_to_swp_slot(entry);\n-\t*si = swap_slot_tryget_swap_info(slot);\n-\tif (!*si)\n-\t\treturn false;\n-\n \t/*\n \t * Ensure the cluster and its associated data structures (swap cache etc.)\n \t * remain valid.\n@@ -1041,11 +1460,30 @@ bool tryget_swap_entry(swp_entry_t entry, struct swap_info_struct **si)\n \tcluster = xa_load(&vswap_cluster_map, VSWAP_CLUSTER_IDX(entry));\n \tif (!cluster || !refcount_inc_not_zero(&cluster->refcnt)) {\n \t\trcu_read_unlock();\n-\t\tswap_slot_put_swap_info(*si);\n \t\t*si = NULL;\n \t\treturn false;\n \t}\n \trcu_read_unlock();\n+\n+\tslot = swp_entry_to_swp_slot(entry);\n+\t/*\n+\t * Note that this function does not provide any guarantee that the virtual\n+\t * swap slot's backing state will be stable. This has several implications:\n+\t *\n+\t * 1. We have to obtain a reference to the swap device itself, because we\n+\t * need swap device's metadata in certain scenarios, for example when we\n+\t * need to inspect the swap device flag in do_swap_page().\n+\t *\n+\t * 2. The swap device we are looking up here might be outdated by the time we\n+\t * return to the caller. It is perfectly OK, if the swap_info_struct is only\n+\t * used in a best-effort manner (i.e optimization). If we need the precise\n+\t * backing state, we need to re-check after the entry is pinned in swapcache.\n+\t */\n+\tif (slot.val)\n+\t\t*si = swap_slot_tryget_swap_info(slot);\n+\telse\n+\t\t*si = NULL;\n+\n \treturn true;\n }\n \n@@ -1288,7 +1726,7 @@ void swap_cache_add_folio(struct folio *folio, swp_entry_t entry, void **shadowp\n \t\told = desc->shadow;\n \n \t\t/* Warn if slot is already occupied by a folio */\n-\t\tVM_WARN_ON_FOLIO(old && !xa_is_value(old), folio);\n+\t\tVM_WARN_ON_FOLIO(old && !xa_is_value(old) && old != folio, folio);\n \n \t\t/* Save shadow if found and not yet saved */\n \t\tif (shadowp && xa_is_value(old) && !*shadowp)\n@@ -1415,29 +1853,22 @@ void __swap_cache_replace_folio(struct folio *old, struct folio *new)\n  * @entry: the zswap entry to store\n  *\n  * Stores a zswap entry in the swap descriptor for the given swap entry.\n- * The cluster is locked during the store operation.\n- *\n- * Return: the old zswap entry if one existed, NULL otherwise\n+ * Releases the old backend if one existed.\n  */\n-void *zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry)\n+void zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry)\n {\n \tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n-\tvoid *old;\n+\n+\trelease_backing(swpentry, 1);\n \n \trcu_read_lock();\n \tdesc = vswap_iter(&cluster, swpentry.val);\n-\tif (!desc) {\n-\t\trcu_read_unlock();\n-\t\treturn NULL;\n-\t}\n-\n-\told = desc->zswap_entry;\n+\tVM_WARN_ON(!desc);\n \tdesc->zswap_entry = entry;\n+\tdesc->type = VSWAP_ZSWAP;\n \tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n-\n-\treturn old;\n }\n \n /**\n@@ -1452,6 +1883,7 @@ void *zswap_entry_load(swp_entry_t swpentry)\n {\n \tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n+\tenum swap_type type;\n \tvoid *zswap_entry;\n \n \trcu_read_lock();\n@@ -1461,41 +1893,15 @@ void *zswap_entry_load(swp_entry_t swpentry)\n \t\treturn NULL;\n \t}\n \n+\ttype = desc->type;\n \tzswap_entry = desc->zswap_entry;\n \tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n \n-\treturn zswap_entry;\n-}\n-\n-/**\n- * zswap_entry_erase - erase a zswap entry for a swap entry\n- * @swpentry: the swap entry\n- *\n- * Erases the zswap entry from the swap descriptor for the given swap entry.\n- * The cluster is locked during the erase operation.\n- *\n- * Return: the zswap entry that was erased, NULL if none existed\n- */\n-void *zswap_entry_erase(swp_entry_t swpentry)\n-{\n-\tstruct vswap_cluster *cluster = NULL;\n-\tstruct swp_desc *desc;\n-\tvoid *old;\n-\n-\trcu_read_lock();\n-\tdesc = vswap_iter(&cluster, swpentry.val);\n-\tif (!desc) {\n-\t\trcu_read_unlock();\n+\tif (type != VSWAP_ZSWAP)\n \t\treturn NULL;\n-\t}\n \n-\told = desc->zswap_entry;\n-\tdesc->zswap_entry = NULL;\n-\tspin_unlock(&cluster->lock);\n-\trcu_read_unlock();\n-\n-\treturn old;\n+\treturn zswap_entry;\n }\n \n bool zswap_empty(swp_entry_t swpentry)\ndiff --git a/mm/zswap.c b/mm/zswap.c\nindex e46349f9c90bb..c5e1d252cb463 100644\n--- a/mm/zswap.c\n+++ b/mm/zswap.c\n@@ -991,8 +991,9 @@ static int zswap_writeback_entry(struct zswap_entry *entry,\n {\n \tstruct folio *folio;\n \tstruct mempolicy *mpol;\n-\tbool folio_was_allocated;\n+\tbool folio_was_allocated, phys_swap_alloced = false;\n \tstruct swap_info_struct *si;\n+\tstruct zswap_entry *new_entry = NULL;\n \tint ret = 0;\n \n \t/* try to allocate swap cache folio */\n@@ -1027,18 +1028,23 @@ static int zswap_writeback_entry(struct zswap_entry *entry,\n \t * old compressed data. Only when this is successful can the entry\n \t * be dereferenced.\n \t */\n-\tif (entry != zswap_entry_load(swpentry)) {\n+\tnew_entry = zswap_entry_load(swpentry);\n+\tif (entry != new_entry) {\n \t\tret = -ENOMEM;\n \t\tgoto out;\n \t}\n \n+\tif (!vswap_alloc_swap_slot(folio)) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\tphys_swap_alloced = true;\n+\n \tif (!zswap_decompress(entry, folio)) {\n \t\tret = -EIO;\n \t\tgoto out;\n \t}\n \n-\tzswap_entry_erase(swpentry);\n-\n \tcount_vm_event(ZSWPWB);\n \tif (entry->objcg)\n \t\tcount_objcg_events(entry->objcg, ZSWPWB, 1);\n@@ -1056,6 +1062,8 @@ static int zswap_writeback_entry(struct zswap_entry *entry,\n \n out:\n \tif (ret && ret != -EEXIST) {\n+\t\tif (phys_swap_alloced)\n+\t\t\tzswap_entry_store(swpentry, new_entry);\n \t\tswap_cache_del_folio(folio);\n \t\tfolio_unlock(folio);\n \t}\n@@ -1401,7 +1409,7 @@ static bool zswap_store_page(struct page *page,\n \t\t\t     struct zswap_pool *pool)\n {\n \tswp_entry_t page_swpentry = page_swap_entry(page);\n-\tstruct zswap_entry *entry, *old;\n+\tstruct zswap_entry *entry;\n \n \t/* allocate entry */\n \tentry = zswap_entry_cache_alloc(GFP_KERNEL, page_to_nid(page));\n@@ -1413,15 +1421,12 @@ static bool zswap_store_page(struct page *page,\n \tif (!zswap_compress(page, entry, pool))\n \t\tgoto compress_failed;\n \n-\told = zswap_entry_store(page_swpentry, entry);\n-\n \t/*\n \t * We may have had an existing entry that became stale when\n \t * the folio was redirtied and now the new version is being\n-\t * swapped out. Get rid of the old.\n+\t * swapped out. zswap_entry_store() will get rid of the old.\n \t */\n-\tif (old)\n-\t\tzswap_entry_free(old);\n+\tzswap_entry_store(page_swpentry, entry);\n \n \t/*\n \t * The entry is successfully compressed and stored in the tree, there is\n@@ -1533,18 +1538,13 @@ bool zswap_store(struct folio *folio)\n \t * the possibly stale entries which were previously stored at the\n \t * offsets corresponding to each page of the folio. Otherwise,\n \t * writeback could overwrite the new data in the swapfile.\n+\t *\n+\t * The only exception is if we still have a full contiguous\n+\t * range of physical swap slots backing the folio. Keep them for\n+\t * fallback disk swapping.\n \t */\n-\tif (!ret) {\n-\t\tunsigned type = swp_type(swp);\n-\t\tpgoff_t offset = swp_offset(swp);\n-\t\tstruct zswap_entry *entry;\n-\n-\t\tfor (index = 0; index < nr_pages; ++index) {\n-\t\t\tentry = zswap_entry_erase(swp_entry(type, offset + index));\n-\t\t\tif (entry)\n-\t\t\t\tzswap_entry_free(entry);\n-\t\t}\n-\t}\n+\tif (!ret && !vswap_swapfile_backed(swp, nr_pages))\n+\t\tvswap_store_folio(swp, folio);\n \n \treturn ret;\n }\n@@ -1619,8 +1619,7 @@ int zswap_load(struct folio *folio)\n \t */\n \tif (swapcache) {\n \t\tfolio_mark_dirty(folio);\n-\t\tzswap_entry_erase(swp);\n-\t\tzswap_entry_free(entry);\n+\t\tvswap_store_folio(swp, folio);\n \t}\n \n \tfolio_unlock(folio);\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the zswap shrinker being started even when there is no physical swap available, explaining that this is because virtualized swap does not pre-allocate slots on the swap file for zswap entries.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged fix needed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "When swap is virtualized, we no longer pre-allocate a slot on swapfile\nfor each zswap entry. Do not start the zswap shrinker if there is no\nphysical swap slots available.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n mm/zswap.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/mm/zswap.c b/mm/zswap.c\nindex c5e1d252cb463..9d1822753d321 100644\n--- a/mm/zswap.c\n+++ b/mm/zswap.c\n@@ -1211,6 +1211,14 @@ static unsigned long zswap_shrinker_count(struct shrinker *shrinker,\n \tif (!zswap_shrinker_enabled || !mem_cgroup_zswap_writeback_enabled(memcg))\n \t\treturn 0;\n \n+\t/*\n+\t * When swap is virtualized, we do not have any swap slots on swapfile\n+\t * preallocated for zswap objects. If there is no slot available, we\n+\t * cannot writeback and should just bail out here.\n+\t */\n+\tif (!get_nr_swap_pages())\n+\t\treturn 0;\n+\n \t/*\n \t * The shrinker resumes swap writeback, which will enter block\n \t * and may enter fs. XXX: Harmonize with vmscan.c __GFP_FS\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the swapoff path needing to drop the per-vswap spinlock before calling try_to_unmap(). They acknowledged that this is necessary and added a check in vswap_same_cluster() to skip pinning entries in the same virtual swap cluster as the target entry, which already has a reference.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged fix needed",
            "added check"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "When we perform swap readahead, the target entry is already pinned by\nthe caller. No need to pin swap entries in the readahead window that\nbelongs in the same virtual swap cluster as the target swap entry.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n mm/swap.h       |  1 +\n mm/swap_state.c | 22 +++++++++-------------\n mm/vswap.c      | 10 ++++++++++\n 3 files changed, 20 insertions(+), 13 deletions(-)\n\ndiff --git a/mm/swap.h b/mm/swap.h\nindex d41e6a0e70753..08a6369a6dfad 100644\n--- a/mm/swap.h\n+++ b/mm/swap.h\n@@ -213,6 +213,7 @@ void swap_cache_lock(swp_entry_t entry);\n void swap_cache_unlock(swp_entry_t entry);\n void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \t\t\t   unsigned long vswap, int nr);\n+bool vswap_same_cluster(swp_entry_t entry1, swp_entry_t entry2);\n \n static inline struct address_space *swap_address_space(swp_entry_t entry)\n {\ndiff --git a/mm/swap_state.c b/mm/swap_state.c\nindex ad80bf098b63f..e8e0905c7723f 100644\n--- a/mm/swap_state.c\n+++ b/mm/swap_state.c\n@@ -553,22 +553,18 @@ static struct folio *swap_vma_readahead(swp_entry_t targ_entry, gfp_t gfp_mask,\n \t\tpte_unmap(pte);\n \t\tpte = NULL;\n \t\t/*\n-\t\t * Readahead entry may come from a device that we are not\n-\t\t * holding a reference to, try to grab a reference, or skip.\n-\t\t *\n-\t\t * XXX: for now, always try to pin the swap entries in the\n-\t\t * readahead window to avoid the annoying conversion to physical\n-\t\t * swap slots. Once we move all swap metadata to virtual swap\n-\t\t * layer, we can simply compare the clusters of the target\n-\t\t * swap entry and the current swap entry, and pin the latter\n-\t\t * swap entry's cluster if it differ from the former's.\n+\t\t * The target entry is already pinned - if the readahead entry\n+\t\t * belongs to the same cluster, it's already protected.\n \t\t */\n-\t\tswapoff_locked = tryget_swap_entry(entry, &si);\n-\t\tif (!swapoff_locked)\n-\t\t\tcontinue;\n+\t\tif (!vswap_same_cluster(entry, targ_entry)) {\n+\t\t\tswapoff_locked = tryget_swap_entry(entry, &si);\n+\t\t\tif (!swapoff_locked)\n+\t\t\t\tcontinue;\n+\t\t}\n \t\tfolio = __read_swap_cache_async(entry, gfp_mask, mpol, ilx,\n \t\t\t\t\t\t&page_allocated, false);\n-\t\tput_swap_entry(entry, si);\n+\t\tif (swapoff_locked)\n+\t\t\tput_swap_entry(entry, si);\n \t\tif (!folio)\n \t\t\tcontinue;\n \t\tif (page_allocated) {\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex fb6179ce3ace7..7563107eb8eee 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -1503,6 +1503,16 @@ void put_swap_entry(swp_entry_t entry, struct swap_info_struct *si)\n \trcu_read_unlock();\n }\n \n+/*\n+ * Check if two virtual swap entries belong to the same vswap cluster.\n+ * Useful for optimizing readahead when entries in the same cluster\n+ * share protection from a pinned target entry.\n+ */\n+bool vswap_same_cluster(swp_entry_t entry1, swp_entry_t entry2)\n+{\n+\treturn VSWAP_CLUSTER_IDX(entry1) == VSWAP_CLUSTER_IDX(entry2);\n+}\n+\n static int vswap_cpu_dead(unsigned int cpu)\n {\n \tstruct percpu_vswap_cluster *percpu_cluster;\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the memory overhead of the zeromap bitmap, explained that removing it does not change behavior and saves memory, and confirmed that this patch is just a cleanup.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged fix",
            "confirmed approach"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Zero swap entries are now treated as a separate, decoupled backend in\nthe virtual swap layer. The zeromap bitmap of physical swapfile is no\nlonger used - remove it. This does not have any behavioral change, and\nsave 1 bit per swap page in terms of memory overhead.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h |  1 -\n mm/swapfile.c        | 30 +++++-------------------------\n 2 files changed, 5 insertions(+), 26 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex 54df972608047..9cd45eab313f8 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -260,7 +260,6 @@ struct swap_info_struct {\n \tsigned char\ttype;\t\t/* strange name for an index */\n \tunsigned int\tmax;\t\t/* extent of the swap_map */\n \tunsigned char *swap_map;\t/* vmalloc'ed array of usage counts */\n-\tunsigned long *zeromap;\t\t/* kvmalloc'ed bitmap to track zero pages */\n \tstruct swap_cluster_info *cluster_info; /* cluster info. Only for SSD */\n \tstruct list_head free_clusters; /* free clusters list */\n \tstruct list_head full_clusters; /* full clusters list */\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 1aa29dd220f9a..e1cb01b821ff3 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -2317,8 +2317,7 @@ static int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)\n \n static void setup_swap_info(struct swap_info_struct *si, int prio,\n \t\t\t    unsigned char *swap_map,\n-\t\t\t    struct swap_cluster_info *cluster_info,\n-\t\t\t    unsigned long *zeromap)\n+\t\t\t    struct swap_cluster_info *cluster_info)\n {\n \tsi->prio = prio;\n \t/*\n@@ -2329,7 +2328,6 @@ static void setup_swap_info(struct swap_info_struct *si, int prio,\n \tsi->avail_list.prio = -si->prio;\n \tsi->swap_map = swap_map;\n \tsi->cluster_info = cluster_info;\n-\tsi->zeromap = zeromap;\n }\n \n static void _enable_swap_info(struct swap_info_struct *si)\n@@ -2347,12 +2345,11 @@ static void _enable_swap_info(struct swap_info_struct *si)\n \n static void enable_swap_info(struct swap_info_struct *si, int prio,\n \t\t\t\tunsigned char *swap_map,\n-\t\t\t\tstruct swap_cluster_info *cluster_info,\n-\t\t\t\tunsigned long *zeromap)\n+\t\t\t\tstruct swap_cluster_info *cluster_info)\n {\n \tspin_lock(&swap_lock);\n \tspin_lock(&si->lock);\n-\tsetup_swap_info(si, prio, swap_map, cluster_info, zeromap);\n+\tsetup_swap_info(si, prio, swap_map, cluster_info);\n \tspin_unlock(&si->lock);\n \tspin_unlock(&swap_lock);\n \t/*\n@@ -2370,7 +2367,7 @@ static void reinsert_swap_info(struct swap_info_struct *si)\n {\n \tspin_lock(&swap_lock);\n \tspin_lock(&si->lock);\n-\tsetup_swap_info(si, si->prio, si->swap_map, si->cluster_info, si->zeromap);\n+\tsetup_swap_info(si, si->prio, si->swap_map, si->cluster_info);\n \t_enable_swap_info(si);\n \tspin_unlock(&si->lock);\n \tspin_unlock(&swap_lock);\n@@ -2441,7 +2438,6 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n {\n \tstruct swap_info_struct *p = NULL;\n \tunsigned char *swap_map;\n-\tunsigned long *zeromap;\n \tstruct swap_cluster_info *cluster_info;\n \tstruct file *swap_file, *victim;\n \tstruct address_space *mapping;\n@@ -2536,8 +2532,6 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \tp->swap_file = NULL;\n \tswap_map = p->swap_map;\n \tp->swap_map = NULL;\n-\tzeromap = p->zeromap;\n-\tp->zeromap = NULL;\n \tmaxpages = p->max;\n \tcluster_info = p->cluster_info;\n \tp->max = 0;\n@@ -2549,7 +2543,6 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \tkfree(p->global_cluster);\n \tp->global_cluster = NULL;\n \tvfree(swap_map);\n-\tkvfree(zeromap);\n \tfree_cluster_info(cluster_info, maxpages);\n \n \tinode = mapping->host;\n@@ -3013,7 +3006,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tsector_t span;\n \tunsigned long maxpages;\n \tunsigned char *swap_map = NULL;\n-\tunsigned long *zeromap = NULL;\n \tstruct swap_cluster_info *cluster_info = NULL;\n \tstruct folio *folio = NULL;\n \tstruct inode *inode = NULL;\n@@ -3119,17 +3111,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tif (error)\n \t\tgoto bad_swap_unlock_inode;\n \n-\t/*\n-\t * Use kvmalloc_array instead of bitmap_zalloc as the allocation order might\n-\t * be above MAX_PAGE_ORDER incase of a large swap file.\n-\t */\n-\tzeromap = kvmalloc_array(BITS_TO_LONGS(maxpages), sizeof(long),\n-\t\t\t\t    GFP_KERNEL | __GFP_ZERO);\n-\tif (!zeromap) {\n-\t\terror = -ENOMEM;\n-\t\tgoto bad_swap_unlock_inode;\n-\t}\n-\n \tif (si->bdev && bdev_stable_writes(si->bdev))\n \t\tsi->flags |= SWP_STABLE_WRITES;\n \n@@ -3196,7 +3177,7 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tprio = DEF_SWAP_PRIO;\n \tif (swap_flags & SWAP_FLAG_PREFER)\n \t\tprio = swap_flags & SWAP_FLAG_PRIO_MASK;\n-\tenable_swap_info(si, prio, swap_map, cluster_info, zeromap);\n+\tenable_swap_info(si, prio, swap_map, cluster_info);\n \n \tpr_info(\"Adding %uk swap on %s.  Priority:%d extents:%d across:%lluk %s%s%s%s\\n\",\n \t\tK(si->pages), name->name, si->prio, nr_extents,\n@@ -3224,7 +3205,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tsi->flags = 0;\n \tspin_unlock(&swap_lock);\n \tvfree(swap_map);\n-\tkvfree(zeromap);\n \tif (cluster_info)\n \t\tfree_cluster_info(cluster_info, maxpages);\n \tif (inced_nr_rotate_swap)\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about charging physical swap space for zswap and zero-filled swap pages, agreeing to only record the memcg id on virtual swap slot allocation and defer physical swap charging until the virtual swap slot is backed by an actual physical swap slot. The author confirmed that this change will be included in v2 of the patch.",
          "sentiment": "positive",
          "sentiment_signals": [
            "agreed to address a concern",
            "confirmed changes for v2"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Now that zswap and the zero-filled swap page optimization no longer\ntakes up any physical swap space, we should not charge towards the swap\nusage and limits of the memcg in these case. We will only record the\nmemcg id on virtual swap slot allocation, and defer physical swap\ncharging (i.e towards memory.swap.current) until the virtual swap slot\nis backed by an actual physical swap slot (on zswap store failure\nfallback or zswap writeback).\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h | 16 +++++++++\n mm/memcontrol-v1.c   |  6 ++++\n mm/memcontrol.c      | 83 ++++++++++++++++++++++++++++++++------------\n mm/vswap.c           | 39 +++++++++------------\n 4 files changed, 98 insertions(+), 46 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex 9cd45eab313f8..a30d382fb5ee1 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -613,6 +613,22 @@ static inline void folio_throttle_swaprate(struct folio *folio, gfp_t gfp)\n #endif\n \n #if defined(CONFIG_MEMCG) && defined(CONFIG_SWAP)\n+void __mem_cgroup_record_swap(struct folio *folio, swp_entry_t entry);\n+static inline void mem_cgroup_record_swap(struct folio *folio,\n+\t\tswp_entry_t entry)\n+{\n+\tif (!mem_cgroup_disabled())\n+\t\t__mem_cgroup_record_swap(folio, entry);\n+}\n+\n+void __mem_cgroup_clear_swap(swp_entry_t entry, unsigned int nr_pages);\n+static inline void mem_cgroup_clear_swap(swp_entry_t entry,\n+\t\tunsigned int nr_pages)\n+{\n+\tif (!mem_cgroup_disabled())\n+\t\t__mem_cgroup_clear_swap(entry, nr_pages);\n+}\n+\n int __mem_cgroup_try_charge_swap(struct folio *folio, swp_entry_t entry);\n static inline int mem_cgroup_try_charge_swap(struct folio *folio,\n \t\tswp_entry_t entry)\ndiff --git a/mm/memcontrol-v1.c b/mm/memcontrol-v1.c\nindex 6eed14bff7426..4580a034dcf72 100644\n--- a/mm/memcontrol-v1.c\n+++ b/mm/memcontrol-v1.c\n@@ -680,6 +680,12 @@ void memcg1_swapin(swp_entry_t entry, unsigned int nr_pages)\n \t\t * memory+swap charge, drop the swap entry duplicate.\n \t\t */\n \t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n+\n+\t\t/*\n+\t\t * Clear the cgroup association now to prevent double memsw\n+\t\t * uncharging when the backends are released later.\n+\t\t */\n+\t\tmem_cgroup_clear_swap(entry, nr_pages);\n \t}\n }\n \ndiff --git a/mm/memcontrol.c b/mm/memcontrol.c\nindex 2ba5811e7edba..50be8066bebec 100644\n--- a/mm/memcontrol.c\n+++ b/mm/memcontrol.c\n@@ -5172,6 +5172,49 @@ int __init mem_cgroup_init(void)\n }\n \n #ifdef CONFIG_SWAP\n+/**\n+ * __mem_cgroup_record_swap - record the folio's cgroup for the swap entries.\n+ * @folio: folio being swapped out.\n+ * @entry: the first swap entry in the range.\n+ */\n+void __mem_cgroup_record_swap(struct folio *folio, swp_entry_t entry)\n+{\n+\tunsigned int nr_pages = folio_nr_pages(folio);\n+\tstruct mem_cgroup *memcg;\n+\n+\t/* Recording will be done by memcg1_swapout(). */\n+\tif (do_memsw_account())\n+\t\treturn;\n+\n+\tmemcg = folio_memcg(folio);\n+\n+\tVM_WARN_ON_ONCE_FOLIO(!memcg, folio);\n+\tif (!memcg)\n+\t\treturn;\n+\n+\tmemcg = mem_cgroup_id_get_online(memcg);\n+\tif (nr_pages > 1)\n+\t\tmem_cgroup_id_get_many(memcg, nr_pages - 1);\n+\tswap_cgroup_record(folio, mem_cgroup_id(memcg), entry);\n+}\n+\n+/**\n+ * __mem_cgroup_clear_swap - clear cgroup information of the swap entries.\n+ * @folio: folio being swapped out.\n+ * @entry: the first swap entry in the range.\n+ */\n+void __mem_cgroup_clear_swap(swp_entry_t entry, unsigned int nr_pages)\n+{\n+\tunsigned short id = swap_cgroup_clear(entry, nr_pages);\n+\tstruct mem_cgroup *memcg;\n+\n+\trcu_read_lock();\n+\tmemcg = mem_cgroup_from_id(id);\n+\tif (memcg)\n+\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n+\trcu_read_unlock();\n+}\n+\n /**\n  * __mem_cgroup_try_charge_swap - try charging swap space for a folio\n  * @folio: folio being added to swap\n@@ -5190,34 +5233,24 @@ int __mem_cgroup_try_charge_swap(struct folio *folio, swp_entry_t entry)\n \tif (do_memsw_account())\n \t\treturn 0;\n \n-\tmemcg = folio_memcg(folio);\n-\n-\tVM_WARN_ON_ONCE_FOLIO(!memcg, folio);\n-\tif (!memcg)\n-\t\treturn 0;\n-\n-\tif (!entry.val) {\n-\t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n-\t\treturn 0;\n-\t}\n-\n-\tmemcg = mem_cgroup_id_get_online(memcg);\n+\t/*\n+\t * We already record the cgroup on virtual swap allocation.\n+\t * Note that the virtual swap slot holds a reference to memcg,\n+\t * so this lookup should be safe.\n+\t */\n+\trcu_read_lock();\n+\tmemcg = mem_cgroup_from_id(lookup_swap_cgroup_id(entry));\n+\trcu_read_unlock();\n \n \tif (!mem_cgroup_is_root(memcg) &&\n \t    !page_counter_try_charge(&memcg->swap, nr_pages, &counter)) {\n \t\tmemcg_memory_event(memcg, MEMCG_SWAP_MAX);\n \t\tmemcg_memory_event(memcg, MEMCG_SWAP_FAIL);\n-\t\tmem_cgroup_id_put(memcg);\n \t\treturn -ENOMEM;\n \t}\n \n-\t/* Get references for the tail pages, too */\n-\tif (nr_pages > 1)\n-\t\tmem_cgroup_id_get_many(memcg, nr_pages - 1);\n \tmod_memcg_state(memcg, MEMCG_SWAP, nr_pages);\n \n-\tswap_cgroup_record(folio, mem_cgroup_id(memcg), entry);\n-\n \treturn 0;\n }\n \n@@ -5231,7 +5264,8 @@ void __mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n \tstruct mem_cgroup *memcg;\n \tunsigned short id;\n \n-\tid = swap_cgroup_clear(entry, nr_pages);\n+\tid = lookup_swap_cgroup_id(entry);\n+\n \trcu_read_lock();\n \tmemcg = mem_cgroup_from_id(id);\n \tif (memcg) {\n@@ -5242,7 +5276,6 @@ void __mem_cgroup_uncharge_swap(swp_entry_t entry, unsigned int nr_pages)\n \t\t\t\tpage_counter_uncharge(&memcg->swap, nr_pages);\n \t\t}\n \t\tmod_memcg_state(memcg, MEMCG_SWAP, -nr_pages);\n-\t\tmem_cgroup_id_put_many(memcg, nr_pages);\n \t}\n \trcu_read_unlock();\n }\n@@ -5251,14 +5284,18 @@ static bool mem_cgroup_may_zswap(struct mem_cgroup *original_memcg);\n \n long mem_cgroup_get_nr_swap_pages(struct mem_cgroup *memcg)\n {\n-\tlong nr_swap_pages, nr_zswap_pages = 0;\n+\tlong nr_swap_pages;\n \n \tif (zswap_is_enabled() && (mem_cgroup_disabled() || do_memsw_account() ||\n \t\t\t\tmem_cgroup_may_zswap(memcg))) {\n-\t\tnr_zswap_pages = PAGE_COUNTER_MAX;\n+\t\t/*\n+\t\t * No need to check swap cgroup limits, since zswap is not charged\n+\t\t * towards swap consumption.\n+\t\t */\n+\t\treturn PAGE_COUNTER_MAX;\n \t}\n \n-\tnr_swap_pages = max_t(long, nr_zswap_pages, get_nr_swap_pages());\n+\tnr_swap_pages = get_nr_swap_pages();\n \tif (mem_cgroup_disabled() || do_memsw_account())\n \t\treturn nr_swap_pages;\n \tfor (; !mem_cgroup_is_root(memcg); memcg = parent_mem_cgroup(memcg))\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex 7563107eb8eee..2a071d5ae173c 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -543,6 +543,7 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n \tunsigned long flush_nr, phys_swap_start = 0, phys_swap_end = 0;\n+\tunsigned long phys_swap_released = 0;\n \tunsigned int phys_swap_type = 0;\n \tbool need_flushing_phys_swap = false;\n \tswp_slot_t flush_slot;\n@@ -572,6 +573,7 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \t\tif (desc->type == VSWAP_ZSWAP && desc->zswap_entry) {\n \t\t\tzswap_entry_free(desc->zswap_entry);\n \t\t} else if (desc->type == VSWAP_SWAPFILE) {\n+\t\t\tphys_swap_released++;\n \t\t\tif (!phys_swap_start) {\n \t\t\t\t/* start a new contiguous range of phys swap */\n \t\t\t\tphys_swap_start = swp_slot_offset(desc->slot);\n@@ -602,6 +604,9 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \t\tflush_nr = phys_swap_end - phys_swap_start;\n \t\tswap_slot_free_nr(flush_slot, flush_nr);\n \t}\n+\n+\tif (phys_swap_released)\n+\t\tmem_cgroup_uncharge_swap(entry, phys_swap_released);\n  }\n \n /*\n@@ -629,7 +634,7 @@ static void vswap_free(struct vswap_cluster *cluster, struct swp_desc *desc,\n \tspin_unlock(&cluster->lock);\n \n \trelease_backing(entry, 1);\n-\tmem_cgroup_uncharge_swap(entry, 1);\n+\tmem_cgroup_clear_swap(entry, 1);\n \n \t/* erase forward mapping and release the virtual slot for reallocation */\n \tspin_lock(&cluster->lock);\n@@ -644,9 +649,6 @@ static void vswap_free(struct vswap_cluster *cluster, struct swp_desc *desc,\n  */\n int folio_alloc_swap(struct folio *folio)\n {\n-\tstruct vswap_cluster *cluster = NULL;\n-\tint i, nr = folio_nr_pages(folio);\n-\tstruct swp_desc *desc;\n \tswp_entry_t entry;\n \n \tVM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);\n@@ -656,25 +658,7 @@ int folio_alloc_swap(struct folio *folio)\n \tif (!entry.val)\n \t\treturn -ENOMEM;\n \n-\t/*\n-\t * XXX: for now, we charge towards the memory cgroup's swap limit on virtual\n-\t * swap slots allocation. This will be changed soon - we will only charge on\n-\t * physical swap slots allocation.\n-\t */\n-\tif (mem_cgroup_try_charge_swap(folio, entry)) {\n-\t\trcu_read_lock();\n-\t\tfor (i = 0; i < nr; i++) {\n-\t\t\tdesc = vswap_iter(&cluster, entry.val + i);\n-\t\t\tVM_WARN_ON(!desc);\n-\t\t\tvswap_free(cluster, desc, (swp_entry_t){ entry.val + i });\n-\t\t}\n-\t\tspin_unlock(&cluster->lock);\n-\t\trcu_read_unlock();\n-\t\tatomic_add(nr, &vswap_alloc_reject);\n-\t\tentry.val = 0;\n-\t\treturn -ENOMEM;\n-\t}\n-\n+\tmem_cgroup_record_swap(folio, entry);\n \tswap_cache_add_folio(folio, entry, NULL);\n \n \treturn 0;\n@@ -716,6 +700,15 @@ bool vswap_alloc_swap_slot(struct folio *folio)\n \tif (!slot.val)\n \t\treturn false;\n \n+\tif (mem_cgroup_try_charge_swap(folio, entry)) {\n+\t\t/*\n+\t\t * We have not updated the backing type of the virtual swap slot.\n+\t\t * Simply free up the physical swap slots here!\n+\t\t */\n+\t\tswap_slot_free_nr(slot, nr);\n+\t\treturn false;\n+\t}\n+\n \t/* establish the vrtual <-> physical swap slots linkages. */\n \tsi = __swap_slot_to_info(slot);\n \tci = swap_cluster_lock(si, swp_slot_offset(slot));\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the swapoff path needing to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2, and provided benchmark results showing improved performance.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged fix needed",
            "agreed to restructure"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "This patch presents the second applications of virtual swap design -\nsimplifying and optimizing swapoff.\n\nWith virtual swap slots stored at page table entries and used as indices\nto various swap-related data structures, we no longer have to perform a\npage table walk in swapoff. Simply iterate through all the allocated\nswap slots on the swapfile, find their corresponding virtual swap slots,\nand fault them in.\n\nThis is significantly cleaner, as well as slightly more performant,\nespecially when there are a lot of unrelated VMAs (since the old swapoff\ncode would have to traverse through all of them).\n\nIn a simple benchmark, in which we swapoff a 32 GB swapfile that is 50%\nfull, and in which there is a process that maps a 128GB file into\nmemory:\n\nBaseline:\nsys: 11.48s\n\nNew Design:\nsys: 9.96s\n\nDisregarding the real time reduction (which is mostly due to more IO\nasynchrony), the new design reduces the kernel CPU time by about 13%.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/shmem_fs.h |   7 +-\n mm/shmem.c               | 184 +--------------\n mm/swapfile.c            | 474 +++++++++------------------------------\n 3 files changed, 113 insertions(+), 552 deletions(-)\n\ndiff --git a/include/linux/shmem_fs.h b/include/linux/shmem_fs.h\nindex e2069b3179c41..bac6b6cafe89c 100644\n--- a/include/linux/shmem_fs.h\n+++ b/include/linux/shmem_fs.h\n@@ -41,17 +41,13 @@ struct shmem_inode_info {\n \tunsigned long\t\tswapped;\t/* subtotal assigned to swap */\n \tunion {\n \t    struct offset_ctx\tdir_offsets;\t/* stable directory offsets */\n-\t    struct {\n-\t\tstruct list_head shrinklist;\t/* shrinkable hpage inodes */\n-\t\tstruct list_head swaplist;\t/* chain of maybes on swap */\n-\t    };\n+\t    struct list_head\tshrinklist;\t/* shrinkable hpage inodes */\n \t};\n \tstruct timespec64\ti_crtime;\t/* file creation time */\n \tstruct shared_policy\tpolicy;\t\t/* NUMA memory alloc policy */\n \tstruct simple_xattrs\txattrs;\t\t/* list of xattrs */\n \tpgoff_t\t\t\tfallocend;\t/* highest fallocate endindex */\n \tunsigned int\t\tfsflags;\t/* for FS_IOC_[SG]ETFLAGS */\n-\tatomic_t\t\tstop_eviction;\t/* hold when working on inode */\n #ifdef CONFIG_TMPFS_QUOTA\n \tstruct dquot __rcu\t*i_dquot[MAXQUOTAS];\n #endif\n@@ -127,7 +123,6 @@ struct page *shmem_read_mapping_page_gfp(struct address_space *mapping,\n int shmem_writeout(struct folio *folio, struct swap_iocb **plug,\n \t\tstruct list_head *folio_list);\n void shmem_truncate_range(struct inode *inode, loff_t start, uoff_t end);\n-int shmem_unuse(unsigned int type);\n \n #ifdef CONFIG_TRANSPARENT_HUGEPAGE\n unsigned long shmem_allowable_huge_orders(struct inode *inode,\ndiff --git a/mm/shmem.c b/mm/shmem.c\nindex 3a346cca114ab..61790752bdf6d 100644\n--- a/mm/shmem.c\n+++ b/mm/shmem.c\n@@ -290,9 +290,6 @@ bool vma_is_shmem(const struct vm_area_struct *vma)\n \treturn vma_is_anon_shmem(vma) || vma->vm_ops == &shmem_vm_ops;\n }\n \n-static LIST_HEAD(shmem_swaplist);\n-static DEFINE_SPINLOCK(shmem_swaplist_lock);\n-\n #ifdef CONFIG_TMPFS_QUOTA\n \n static int shmem_enable_quotas(struct super_block *sb,\n@@ -1413,16 +1410,6 @@ static void shmem_evict_inode(struct inode *inode)\n \t\t\t}\n \t\t\tspin_unlock(&sbinfo->shrinklist_lock);\n \t\t}\n-\t\twhile (!list_empty(&info->swaplist)) {\n-\t\t\t/* Wait while shmem_unuse() is scanning this inode... */\n-\t\t\twait_var_event(&info->stop_eviction,\n-\t\t\t\t       !atomic_read(&info->stop_eviction));\n-\t\t\tspin_lock(&shmem_swaplist_lock);\n-\t\t\t/* ...but beware of the race if we peeked too early */\n-\t\t\tif (!atomic_read(&info->stop_eviction))\n-\t\t\t\tlist_del_init(&info->swaplist);\n-\t\t\tspin_unlock(&shmem_swaplist_lock);\n-\t\t}\n \t}\n \n \tsimple_xattrs_free(&info->xattrs, sbinfo->max_inodes ? &freed : NULL);\n@@ -1435,153 +1422,6 @@ static void shmem_evict_inode(struct inode *inode)\n #endif\n }\n \n-static unsigned int shmem_find_swap_entries(struct address_space *mapping,\n-\t\t\t\tpgoff_t start, struct folio_batch *fbatch,\n-\t\t\t\tpgoff_t *indices, unsigned int type)\n-{\n-\tXA_STATE(xas, &mapping->i_pages, start);\n-\tstruct folio *folio;\n-\tswp_entry_t entry;\n-\tswp_slot_t slot;\n-\n-\trcu_read_lock();\n-\txas_for_each(&xas, folio, ULONG_MAX) {\n-\t\tif (xas_retry(&xas, folio))\n-\t\t\tcontinue;\n-\n-\t\tif (!xa_is_value(folio))\n-\t\t\tcontinue;\n-\n-\t\tentry = radix_to_swp_entry(folio);\n-\t\tslot = swp_entry_to_swp_slot(entry);\n-\n-\t\t/*\n-\t\t * swapin error entries can be found in the mapping. But they're\n-\t\t * deliberately ignored here as we've done everything we can do.\n-\t\t */\n-\t\tif (!slot.val || swp_slot_type(slot) != type)\n-\t\t\tcontinue;\n-\n-\t\tindices[folio_batch_count(fbatch)] = xas.xa_index;\n-\t\tif (!folio_batch_add(fbatch, folio))\n-\t\t\tbreak;\n-\n-\t\tif (need_resched()) {\n-\t\t\txas_pause(&xas);\n-\t\t\tcond_resched_rcu();\n-\t\t}\n-\t}\n-\trcu_read_unlock();\n-\n-\treturn folio_batch_count(fbatch);\n-}\n-\n-/*\n- * Move the swapped pages for an inode to page cache. Returns the count\n- * of pages swapped in, or the error in case of failure.\n- */\n-static int shmem_unuse_swap_entries(struct inode *inode,\n-\t\tstruct folio_batch *fbatch, pgoff_t *indices)\n-{\n-\tint i = 0;\n-\tint ret = 0;\n-\tint error = 0;\n-\tstruct address_space *mapping = inode->i_mapping;\n-\n-\tfor (i = 0; i < folio_batch_count(fbatch); i++) {\n-\t\tstruct folio *folio = fbatch->folios[i];\n-\n-\t\terror = shmem_swapin_folio(inode, indices[i], &folio, SGP_CACHE,\n-\t\t\t\t\tmapping_gfp_mask(mapping), NULL, NULL);\n-\t\tif (error == 0) {\n-\t\t\tfolio_unlock(folio);\n-\t\t\tfolio_put(folio);\n-\t\t\tret++;\n-\t\t}\n-\t\tif (error == -ENOMEM)\n-\t\t\tbreak;\n-\t\terror = 0;\n-\t}\n-\treturn error ? error : ret;\n-}\n-\n-/*\n- * If swap found in inode, free it and move page from swapcache to filecache.\n- */\n-static int shmem_unuse_inode(struct inode *inode, unsigned int type)\n-{\n-\tstruct address_space *mapping = inode->i_mapping;\n-\tpgoff_t start = 0;\n-\tstruct folio_batch fbatch;\n-\tpgoff_t indices[PAGEVEC_SIZE];\n-\tint ret = 0;\n-\n-\tdo {\n-\t\tfolio_batch_init(&fbatch);\n-\t\tif (!shmem_find_swap_entries(mapping, start, &fbatch,\n-\t\t\t\t\t     indices, type)) {\n-\t\t\tret = 0;\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\tret = shmem_unuse_swap_entries(inode, &fbatch, indices);\n-\t\tif (ret < 0)\n-\t\t\tbreak;\n-\n-\t\tstart = indices[folio_batch_count(&fbatch) - 1];\n-\t} while (true);\n-\n-\treturn ret;\n-}\n-\n-/*\n- * Read all the shared memory data that resides in the swap\n- * device 'type' back into memory, so the swap device can be\n- * unused.\n- */\n-int shmem_unuse(unsigned int type)\n-{\n-\tstruct shmem_inode_info *info, *next;\n-\tint error = 0;\n-\n-\tif (list_empty(&shmem_swaplist))\n-\t\treturn 0;\n-\n-\tspin_lock(&shmem_swaplist_lock);\n-start_over:\n-\tlist_for_each_entry_safe(info, next, &shmem_swaplist, swaplist) {\n-\t\tif (!info->swapped) {\n-\t\t\tlist_del_init(&info->swaplist);\n-\t\t\tcontinue;\n-\t\t}\n-\t\t/*\n-\t\t * Drop the swaplist mutex while searching the inode for swap;\n-\t\t * but before doing so, make sure shmem_evict_inode() will not\n-\t\t * remove placeholder inode from swaplist, nor let it be freed\n-\t\t * (igrab() would protect from unlink, but not from unmount).\n-\t\t */\n-\t\tatomic_inc(&info->stop_eviction);\n-\t\tspin_unlock(&shmem_swaplist_lock);\n-\n-\t\terror = shmem_unuse_inode(&info->vfs_inode, type);\n-\t\tcond_resched();\n-\n-\t\tspin_lock(&shmem_swaplist_lock);\n-\t\tif (atomic_dec_and_test(&info->stop_eviction))\n-\t\t\twake_up_var(&info->stop_eviction);\n-\t\tif (error)\n-\t\t\tbreak;\n-\t\tif (list_empty(&info->swaplist))\n-\t\t\tgoto start_over;\n-\t\tnext = list_next_entry(info, swaplist);\n-\t\tif (!info->swapped)\n-\t\t\tlist_del_init(&info->swaplist);\n-\t}\n-\tspin_unlock(&shmem_swaplist_lock);\n-\n-\treturn error;\n-}\n-\n /**\n  * shmem_writeout - Write the folio to swap\n  * @folio: The folio to write\n@@ -1668,24 +1508,9 @@ int shmem_writeout(struct folio *folio, struct swap_iocb **plug,\n \t}\n \n \tif (!folio_alloc_swap(folio)) {\n-\t\tbool first_swapped = shmem_recalc_inode(inode, 0, nr_pages);\n \t\tint error;\n \n-\t\t/*\n-\t\t * Add inode to shmem_unuse()'s list of swapped-out inodes,\n-\t\t * if it's not already there.  Do it now before the folio is\n-\t\t * removed from page cache, when its pagelock no longer\n-\t\t * protects the inode from eviction.  And do it now, after\n-\t\t * we've incremented swapped, because shmem_unuse() will\n-\t\t * prune a !swapped inode from the swaplist.\n-\t\t */\n-\t\tif (first_swapped) {\n-\t\t\tspin_lock(&shmem_swaplist_lock);\n-\t\t\tif (list_empty(&info->swaplist))\n-\t\t\t\tlist_add(&info->swaplist, &shmem_swaplist);\n-\t\t\tspin_unlock(&shmem_swaplist_lock);\n-\t\t}\n-\n+\t\tshmem_recalc_inode(inode, 0, nr_pages);\n \t\tswap_shmem_alloc(folio->swap, nr_pages);\n \t\tshmem_delete_from_page_cache(folio, swp_to_radix_entry(folio->swap));\n \n@@ -3106,7 +2931,6 @@ static struct inode *__shmem_get_inode(struct mnt_idmap *idmap,\n \tinfo = SHMEM_I(inode);\n \tmemset(info, 0, (char *)inode - (char *)info);\n \tspin_lock_init(&info->lock);\n-\tatomic_set(&info->stop_eviction, 0);\n \tinfo->seals = F_SEAL_SEAL;\n \tinfo->flags = (flags & VM_NORESERVE) ? SHMEM_F_NORESERVE : 0;\n \tinfo->i_crtime = inode_get_mtime(inode);\n@@ -3115,7 +2939,6 @@ static struct inode *__shmem_get_inode(struct mnt_idmap *idmap,\n \tif (info->fsflags)\n \t\tshmem_set_inode_flags(inode, info->fsflags, NULL);\n \tINIT_LIST_HEAD(&info->shrinklist);\n-\tINIT_LIST_HEAD(&info->swaplist);\n \tsimple_xattrs_init(&info->xattrs);\n \tcache_no_acl(inode);\n \tif (sbinfo->noswap)\n@@ -5785,11 +5608,6 @@ void __init shmem_init(void)\n \tBUG_ON(IS_ERR(shm_mnt));\n }\n \n-int shmem_unuse(unsigned int type)\n-{\n-\treturn 0;\n-}\n-\n int shmem_lock(struct file *file, int lock, struct ucounts *ucounts)\n {\n \treturn 0;\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex e1cb01b821ff3..9478707ce3ffa 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -1738,300 +1738,12 @@ unsigned int count_swap_pages(int type, int free)\n }\n #endif /* CONFIG_HIBERNATION */\n \n-static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n+static bool swap_slot_allocated(struct swap_info_struct *si,\n+\t\tunsigned long offset)\n {\n-\treturn pte_same(pte_swp_clear_flags(pte), swp_pte);\n-}\n-\n-/*\n- * No need to decide whether this PTE shares the swap entry with others,\n- * just let do_wp_page work it out if a write is requested later - to\n- * force COW, vm_page_prot omits write permission from any private vma.\n- */\n-static int unuse_pte(struct vm_area_struct *vma, pmd_t *pmd,\n-\t\tunsigned long addr, swp_entry_t entry, struct folio *folio)\n-{\n-\tstruct page *page;\n-\tstruct folio *swapcache;\n-\tspinlock_t *ptl;\n-\tpte_t *pte, new_pte, old_pte;\n-\tbool hwpoisoned = false;\n-\tint ret = 1;\n-\n-\t/*\n-\t * If the folio is removed from swap cache by others, continue to\n-\t * unuse other PTEs. try_to_unuse may try again if we missed this one.\n-\t */\n-\tif (!folio_matches_swap_entry(folio, entry))\n-\t\treturn 0;\n-\n-\tswapcache = folio;\n-\tfolio = ksm_might_need_to_copy(folio, vma, addr);\n-\tif (unlikely(!folio))\n-\t\treturn -ENOMEM;\n-\telse if (unlikely(folio == ERR_PTR(-EHWPOISON))) {\n-\t\thwpoisoned = true;\n-\t\tfolio = swapcache;\n-\t}\n-\n-\tpage = folio_file_page(folio, swp_offset(entry));\n-\tif (PageHWPoison(page))\n-\t\thwpoisoned = true;\n-\n-\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n-\tif (unlikely(!pte || !pte_same_as_swp(ptep_get(pte),\n-\t\t\t\t\t\tswp_entry_to_pte(entry)))) {\n-\t\tret = 0;\n-\t\tgoto out;\n-\t}\n-\n-\told_pte = ptep_get(pte);\n-\n-\tif (unlikely(hwpoisoned || !folio_test_uptodate(folio))) {\n-\t\tswp_entry_t swp_entry;\n-\n-\t\tdec_mm_counter(vma->vm_mm, MM_SWAPENTS);\n-\t\tif (hwpoisoned) {\n-\t\t\tswp_entry = make_hwpoison_entry(page);\n-\t\t} else {\n-\t\t\tswp_entry = make_poisoned_swp_entry();\n-\t\t}\n-\t\tnew_pte = swp_entry_to_pte(swp_entry);\n-\t\tret = 0;\n-\t\tgoto setpte;\n-\t}\n-\n-\t/*\n-\t * Some architectures may have to restore extra metadata to the page\n-\t * when reading from swap. This metadata may be indexed by swap entry\n-\t * so this must be called before swap_free().\n-\t */\n-\tarch_swap_restore(folio_swap(entry, folio), folio);\n-\n-\tdec_mm_counter(vma->vm_mm, MM_SWAPENTS);\n-\tinc_mm_counter(vma->vm_mm, MM_ANONPAGES);\n-\tfolio_get(folio);\n-\tif (folio == swapcache) {\n-\t\trmap_t rmap_flags = RMAP_NONE;\n-\n-\t\t/*\n-\t\t * See do_swap_page(): writeback would be problematic.\n-\t\t * However, we do a folio_wait_writeback() just before this\n-\t\t * call and have the folio locked.\n-\t\t */\n-\t\tVM_BUG_ON_FOLIO(folio_test_writeback(folio), folio);\n-\t\tif (pte_swp_exclusive(old_pte))\n-\t\t\trmap_flags |= RMAP_EXCLUSIVE;\n-\t\t/*\n-\t\t * We currently only expect small !anon folios, which are either\n-\t\t * fully exclusive or fully shared. If we ever get large folios\n-\t\t * here, we have to be careful.\n-\t\t */\n-\t\tif (!folio_test_anon(folio)) {\n-\t\t\tVM_WARN_ON_ONCE(folio_test_large(folio));\n-\t\t\tVM_WARN_ON_FOLIO(!folio_test_locked(folio), folio);\n-\t\t\tfolio_add_new_anon_rmap(folio, vma, addr, rmap_flags);\n-\t\t} else {\n-\t\t\tfolio_add_anon_rmap_pte(folio, page, vma, addr, rmap_flags);\n-\t\t}\n-\t} else { /* ksm created a completely new copy */\n-\t\tfolio_add_new_anon_rmap(folio, vma, addr, RMAP_EXCLUSIVE);\n-\t\tfolio_add_lru_vma(folio, vma);\n-\t}\n-\tnew_pte = pte_mkold(mk_pte(page, vma->vm_page_prot));\n-\tif (pte_swp_soft_dirty(old_pte))\n-\t\tnew_pte = pte_mksoft_dirty(new_pte);\n-\tif (pte_swp_uffd_wp(old_pte))\n-\t\tnew_pte = pte_mkuffd_wp(new_pte);\n-setpte:\n-\tset_pte_at(vma->vm_mm, addr, pte, new_pte);\n-\tswap_free(entry);\n-out:\n-\tif (pte)\n-\t\tpte_unmap_unlock(pte, ptl);\n-\tif (folio != swapcache) {\n-\t\tfolio_unlock(folio);\n-\t\tfolio_put(folio);\n-\t}\n-\treturn ret;\n-}\n-\n-static int unuse_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n-\t\t\tunsigned long addr, unsigned long end,\n-\t\t\tunsigned int type)\n-{\n-\tpte_t *pte = NULL;\n-\tstruct swap_info_struct *si;\n-\n-\tsi = swap_info[type];\n-\tdo {\n-\t\tstruct folio *folio;\n-\t\tunsigned long offset;\n-\t\tunsigned char swp_count;\n-\t\tsoftleaf_t entry;\n-\t\tswp_slot_t slot;\n-\t\tint ret;\n-\t\tpte_t ptent;\n-\n-\t\tif (!pte++) {\n-\t\t\tpte = pte_offset_map(pmd, addr);\n-\t\t\tif (!pte)\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\tptent = ptep_get_lockless(pte);\n-\t\tentry = softleaf_from_pte(ptent);\n-\n-\t\tif (!softleaf_is_swap(entry))\n-\t\t\tcontinue;\n-\n-\t\tslot = swp_entry_to_swp_slot(entry);\n-\t\tif (swp_slot_type(slot) != type)\n-\t\t\tcontinue;\n-\n-\t\toffset = swp_slot_offset(slot);\n-\t\tpte_unmap(pte);\n-\t\tpte = NULL;\n-\n-\t\tfolio = swap_cache_get_folio(entry);\n-\t\tif (!folio) {\n-\t\t\tstruct vm_fault vmf = {\n-\t\t\t\t.vma = vma,\n-\t\t\t\t.address = addr,\n-\t\t\t\t.real_address = addr,\n-\t\t\t\t.pmd = pmd,\n-\t\t\t};\n-\n-\t\t\tfolio = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n-\t\t\t\t\t\t&vmf);\n-\t\t}\n-\t\tif (!folio) {\n-\t\t\tswp_count = READ_ONCE(si->swap_map[offset]);\n-\t\t\tif (swp_count == 0 || swp_count == SWAP_MAP_BAD)\n-\t\t\t\tcontinue;\n-\t\t\treturn -ENOMEM;\n-\t\t}\n-\n-\t\tfolio_lock(folio);\n-\t\tfolio_wait_writeback(folio);\n-\t\tret = unuse_pte(vma, pmd, addr, entry, folio);\n-\t\tif (ret < 0) {\n-\t\t\tfolio_unlock(folio);\n-\t\t\tfolio_put(folio);\n-\t\t\treturn ret;\n-\t\t}\n-\n-\t\tfolio_free_swap(folio);\n-\t\tfolio_unlock(folio);\n-\t\tfolio_put(folio);\n-\t} while (addr += PAGE_SIZE, addr != end);\n-\n-\tif (pte)\n-\t\tpte_unmap(pte);\n-\treturn 0;\n-}\n-\n-static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n-\t\t\t\tunsigned long addr, unsigned long end,\n-\t\t\t\tunsigned int type)\n-{\n-\tpmd_t *pmd;\n-\tunsigned long next;\n-\tint ret;\n-\n-\tpmd = pmd_offset(pud, addr);\n-\tdo {\n-\t\tcond_resched();\n-\t\tnext = pmd_addr_end(addr, end);\n-\t\tret = unuse_pte_range(vma, pmd, addr, next, type);\n-\t\tif (ret)\n-\t\t\treturn ret;\n-\t} while (pmd++, addr = next, addr != end);\n-\treturn 0;\n-}\n-\n-static inline int unuse_pud_range(struct vm_area_struct *vma, p4d_t *p4d,\n-\t\t\t\tunsigned long addr, unsigned long end,\n-\t\t\t\tunsigned int type)\n-{\n-\tpud_t *pud;\n-\tunsigned long next;\n-\tint ret;\n-\n-\tpud = pud_offset(p4d, addr);\n-\tdo {\n-\t\tnext = pud_addr_end(addr, end);\n-\t\tif (pud_none_or_clear_bad(pud))\n-\t\t\tcontinue;\n-\t\tret = unuse_pmd_range(vma, pud, addr, next, type);\n-\t\tif (ret)\n-\t\t\treturn ret;\n-\t} while (pud++, addr = next, addr != end);\n-\treturn 0;\n-}\n-\n-static inline int unuse_p4d_range(struct vm_area_struct *vma, pgd_t *pgd,\n-\t\t\t\tunsigned long addr, unsigned long end,\n-\t\t\t\tunsigned int type)\n-{\n-\tp4d_t *p4d;\n-\tunsigned long next;\n-\tint ret;\n-\n-\tp4d = p4d_offset(pgd, addr);\n-\tdo {\n-\t\tnext = p4d_addr_end(addr, end);\n-\t\tif (p4d_none_or_clear_bad(p4d))\n-\t\t\tcontinue;\n-\t\tret = unuse_pud_range(vma, p4d, addr, next, type);\n-\t\tif (ret)\n-\t\t\treturn ret;\n-\t} while (p4d++, addr = next, addr != end);\n-\treturn 0;\n-}\n-\n-static int unuse_vma(struct vm_area_struct *vma, unsigned int type)\n-{\n-\tpgd_t *pgd;\n-\tunsigned long addr, end, next;\n-\tint ret;\n-\n-\taddr = vma->vm_start;\n-\tend = vma->vm_end;\n-\n-\tpgd = pgd_offset(vma->vm_mm, addr);\n-\tdo {\n-\t\tnext = pgd_addr_end(addr, end);\n-\t\tif (pgd_none_or_clear_bad(pgd))\n-\t\t\tcontinue;\n-\t\tret = unuse_p4d_range(vma, pgd, addr, next, type);\n-\t\tif (ret)\n-\t\t\treturn ret;\n-\t} while (pgd++, addr = next, addr != end);\n-\treturn 0;\n-}\n+\tunsigned char count = READ_ONCE(si->swap_map[offset]);\n \n-static int unuse_mm(struct mm_struct *mm, unsigned int type)\n-{\n-\tstruct vm_area_struct *vma;\n-\tint ret = 0;\n-\tVMA_ITERATOR(vmi, mm, 0);\n-\n-\tmmap_read_lock(mm);\n-\tif (check_stable_address_space(mm))\n-\t\tgoto unlock;\n-\tfor_each_vma(vmi, vma) {\n-\t\tif (vma->anon_vma && !is_vm_hugetlb_page(vma)) {\n-\t\t\tret = unuse_vma(vma, type);\n-\t\t\tif (ret)\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\tcond_resched();\n-\t}\n-unlock:\n-\tmmap_read_unlock(mm);\n-\treturn ret;\n+\treturn count && swap_count(count) != SWAP_MAP_BAD;\n }\n \n /*\n@@ -2043,7 +1755,6 @@ static unsigned int find_next_to_unuse(struct swap_info_struct *si,\n \t\t\t\t\tunsigned int prev)\n {\n \tunsigned int i;\n-\tunsigned char count;\n \n \t/*\n \t * No need for swap_lock here: we're just looking\n@@ -2052,8 +1763,7 @@ static unsigned int find_next_to_unuse(struct swap_info_struct *si,\n \t * allocations from this area (while holding swap_lock).\n \t */\n \tfor (i = prev + 1; i < si->max; i++) {\n-\t\tcount = READ_ONCE(si->swap_map[i]);\n-\t\tif (count && swap_count(count) != SWAP_MAP_BAD)\n+\t\tif (swap_slot_allocated(si, i))\n \t\t\tbreak;\n \t\tif ((i % LATENCY_LIMIT) == 0)\n \t\t\tcond_resched();\n@@ -2065,101 +1775,139 @@ static unsigned int find_next_to_unuse(struct swap_info_struct *si,\n \treturn i;\n }\n \n+#define\tfor_each_allocated_offset(si, offset)\t\\\n+\twhile (swap_usage_in_pages(si) && \\\n+\t\t!signal_pending(current) && \\\n+\t\t(offset = find_next_to_unuse(si, offset)) != 0)\n+\n+static struct folio *pagein(swp_entry_t entry, struct swap_iocb **splug,\n+\t\tstruct mempolicy *mpol)\n+{\n+\tbool folio_was_allocated;\n+\tstruct folio *folio = __read_swap_cache_async(entry, GFP_KERNEL, mpol,\n+\t\t\tNO_INTERLEAVE_INDEX, &folio_was_allocated, false);\n+\n+\tif (folio_was_allocated)\n+\t\tswap_read_folio(folio, splug);\n+\treturn folio;\n+}\n+\n static int try_to_unuse(unsigned int type)\n {\n-\tstruct mm_struct *prev_mm;\n-\tstruct mm_struct *mm;\n-\tstruct list_head *p;\n-\tint retval = 0;\n \tstruct swap_info_struct *si = swap_info[type];\n+\tstruct swap_iocb *splug = NULL;\n+\tstruct mempolicy *mpol;\n+\tstruct blk_plug plug;\n+\tunsigned long offset;\n \tstruct folio *folio;\n \tswp_entry_t entry;\n \tswp_slot_t slot;\n-\tunsigned int i;\n+\tint ret = 0;\n \n \tif (!swap_usage_in_pages(si))\n \t\tgoto success;\n \n-retry:\n-\tretval = shmem_unuse(type);\n-\tif (retval)\n-\t\treturn retval;\n-\n-\tprev_mm = &init_mm;\n-\tmmget(prev_mm);\n-\n-\tspin_lock(&mmlist_lock);\n-\tp = &init_mm.mmlist;\n-\twhile (swap_usage_in_pages(si) &&\n-\t       !signal_pending(current) &&\n-\t       (p = p->next) != &init_mm.mmlist) {\n+\tmpol = get_task_policy(current);\n+\tblk_start_plug(&plug);\n \n-\t\tmm = list_entry(p, struct mm_struct, mmlist);\n-\t\tif (!mmget_not_zero(mm))\n+\t/* first round - submit the reads */\n+\toffset = 0;\n+\tfor_each_allocated_offset(si, offset) {\n+\t\tslot = swp_slot(type, offset);\n+\t\tentry = swp_slot_to_swp_entry(slot);\n+\t\tif (!entry.val)\n \t\t\tcontinue;\n-\t\tspin_unlock(&mmlist_lock);\n-\t\tmmput(prev_mm);\n-\t\tprev_mm = mm;\n-\t\tretval = unuse_mm(mm, type);\n-\t\tif (retval) {\n-\t\t\tmmput(prev_mm);\n-\t\t\treturn retval;\n-\t\t}\n \n-\t\t/*\n-\t\t * Make sure that we aren't completely killing\n-\t\t * interactive performance.\n-\t\t */\n-\t\tcond_resched();\n-\t\tspin_lock(&mmlist_lock);\n+\t\tfolio = pagein(entry, &splug, mpol);\n+\t\tif (folio)\n+\t\t\tfolio_put(folio);\n \t}\n-\tspin_unlock(&mmlist_lock);\n+\tblk_finish_plug(&plug);\n+\tswap_read_unplug(splug);\n+\tsplug = NULL;\n+\tlru_add_drain();\n+\n+\t/* second round - updating the virtual swap slots' backing state */\n+\toffset = 0;\n+\tfor_each_allocated_offset(si, offset) {\n+\t\tslot = swp_slot(type, offset);\n+retry:\n+\t\tentry = swp_slot_to_swp_entry(slot);\n+\t\tif (!entry.val) {\n+\t\t\tif (!swap_slot_allocated(si, offset))\n+\t\t\t\tcontinue;\n \n-\tmmput(prev_mm);\n+\t\t\tif (signal_pending(current)) {\n+\t\t\t\tret = -EINTR;\n+\t\t\t\tgoto out;\n+\t\t\t}\n \n-\ti = 0;\n-\twhile (swap_usage_in_pages(si) &&\n-\t       !signal_pending(current) &&\n-\t       (i = find_next_to_unuse(si, i)) != 0) {\n+\t\t\t/* we might be racing with zswap writeback or disk swapout */\n+\t\t\tschedule_timeout_uninterruptible(1);\n+\t\t\tgoto retry;\n+\t\t}\n \n-\t\tslot = swp_slot(type, i);\n-\t\tentry = swp_slot_to_swp_entry(slot);\n-\t\tfolio = swap_cache_get_folio(entry);\n-\t\tif (!folio)\n-\t\t\tcontinue;\n+\t\t/* try to allocate swap cache folio */\n+\t\tfolio = pagein(entry, &splug, mpol);\n+\t\tif (!folio) {\n+\t\t\tif (!swp_slot_to_swp_entry(swp_slot(type, offset)).val)\n+\t\t\t\tcontinue;\n \n+\t\t\tret = -ENOMEM;\n+\t\t\tpr_err(\"swapoff: unable to allocate swap cache folio for %lu\\n\",\n+\t\t\t\t\t\tentry.val);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tfolio_lock(folio);\n \t\t/*\n-\t\t * It is conceivable that a racing task removed this folio from\n-\t\t * swap cache just before we acquired the page lock. The folio\n-\t\t * might even be back in swap cache on another swap area. But\n-\t\t * that is okay, folio_free_swap() only removes stale folios.\n+\t\t * We need to check if the folio is still in swap cache, and is still\n+\t\t * backed by the physical swap slot we are trying to release.\n+\t\t *\n+\t\t * We can, for instance, race with zswap writeback, obtaining the\n+\t\t * temporary folio it allocated for decompression and writeback, which\n+\t\t * would be promptly deleted from swap cache. By the time we lock that\n+\t\t * folio, it might have already contained stale data.\n+\t\t *\n+\t\t * Concurrent swap operations might have also come in before we\n+\t\t * reobtain the folio's lock, deleting the folio from swap cache,\n+\t\t * invalidating the virtual swap slot, then swapping out the folio\n+\t\t * again to a different swap backends.\n+\t\t *\n+\t\t * In all of these cases, we must retry the physical -> virtual lookup.\n \t\t */\n-\t\tfolio_lock(folio);\n+\t\tif (!folio_matches_swap_slot(folio, entry, slot)) {\n+\t\t\tfolio_unlock(folio);\n+\t\t\tfolio_put(folio);\n+\t\t\tif (signal_pending(current)) {\n+\t\t\t\tret = -EINTR;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tschedule_timeout_uninterruptible(1);\n+\t\t\tgoto retry;\n+\t\t}\n+\n \t\tfolio_wait_writeback(folio);\n-\t\tfolio_free_swap(folio);\n+\t\tvswap_store_folio(entry, folio);\n+\t\tfolio_mark_dirty(folio);\n \t\tfolio_unlock(folio);\n \t\tfolio_put(folio);\n \t}\n \n-\t/*\n-\t * Lets check again to see if there are still swap entries in the map.\n-\t * If yes, we would need to do retry the unuse logic again.\n-\t * Under global memory pressure, swap entries can be reinserted back\n-\t * into process space after the mmlist loop above passes over them.\n-\t *\n-\t * Limit the number of retries? No: when mmget_not_zero()\n-\t * above fails, that mm is likely to be freeing swap from\n-\t * exit_mmap(), which proceeds at its own independent pace;\n-\t * and even shmem_writeout() could have been preempted after\n-\t * folio_alloc_swap(), temporarily hiding that swap.  It's easy\n-\t * and robust (though cpu-intensive) just to keep retrying.\n-\t */\n-\tif (swap_usage_in_pages(si)) {\n-\t\tif (!signal_pending(current))\n-\t\t\tgoto retry;\n-\t\treturn -EINTR;\n+\t/* concurrent swappers might still be releasing physical swap slots... */\n+\twhile (swap_usage_in_pages(si)) {\n+\t\tif (signal_pending(current)) {\n+\t\t\tret = -EINTR;\n+\t\t\tgoto out;\n+\t\t}\n+\t\tschedule_timeout_uninterruptible(1);\n \t}\n \n+out:\n+\tswap_read_unplug(splug);\n+\tif (ret)\n+\t\treturn ret;\n+\n success:\n \t/*\n \t * Make sure that further cleanups after try_to_unuse() returns happen\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the inefficient use of bits in the swap map by replacing it with two bitmaps, one for allocated state and one for bad state, saving 6 bits per swap entry.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged fix needed",
            "agreed to restructure"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Now that we have moved the swap count state to virtual swap layer, each\nswap map entry only has 3 possible states: free, allocated, and bad.\nReplace the swap map with 2 bitmaps (one for allocated state and one for\nbad state), saving 6 bits per swap entry.\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/swap.h |  3 +-\n mm/swapfile.c        | 81 +++++++++++++++++++++++---------------------\n 2 files changed, 44 insertions(+), 40 deletions(-)\n\ndiff --git a/include/linux/swap.h b/include/linux/swap.h\nindex a30d382fb5ee1..a02ce3fb2358b 100644\n--- a/include/linux/swap.h\n+++ b/include/linux/swap.h\n@@ -259,7 +259,8 @@ struct swap_info_struct {\n \tstruct plist_node list;\t\t/* entry in swap_active_head */\n \tsigned char\ttype;\t\t/* strange name for an index */\n \tunsigned int\tmax;\t\t/* extent of the swap_map */\n-\tunsigned char *swap_map;\t/* vmalloc'ed array of usage counts */\n+\tunsigned long *swap_map;\t/* bitmap for allocated state */\n+\tunsigned long *bad_map;\t\t/* bitmap for bad state */\n \tstruct swap_cluster_info *cluster_info; /* cluster info. Only for SSD */\n \tstruct list_head free_clusters; /* free clusters list */\n \tstruct list_head full_clusters; /* full clusters list */\ndiff --git a/mm/swapfile.c b/mm/swapfile.c\nindex 9478707ce3ffa..b7661ffa312be 100644\n--- a/mm/swapfile.c\n+++ b/mm/swapfile.c\n@@ -760,25 +760,19 @@ static bool cluster_reclaim_range(struct swap_info_struct *si,\n \t\t\t\t  struct swap_cluster_info *ci,\n \t\t\t\t  unsigned long start, unsigned long end)\n {\n-\tunsigned char *map = si->swap_map;\n \tunsigned long offset = start;\n \tint nr_reclaim;\n \n \tspin_unlock(&ci->lock);\n \tdo {\n-\t\tswitch (READ_ONCE(map[offset])) {\n-\t\tcase 0:\n+\t\tif (!test_bit(offset, si->swap_map)) {\n \t\t\toffset++;\n-\t\t\tbreak;\n-\t\tcase SWAP_MAP_ALLOCATED:\n+\t\t} else {\n \t\t\tnr_reclaim = __try_to_reclaim_swap(si, offset, TTRS_ANYWAY);\n \t\t\tif (nr_reclaim > 0)\n \t\t\t\toffset += nr_reclaim;\n \t\t\telse\n \t\t\t\tgoto out;\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tgoto out;\n \t\t}\n \t} while (offset < end);\n out:\n@@ -787,11 +781,7 @@ static bool cluster_reclaim_range(struct swap_info_struct *si,\n \t * Recheck the range no matter reclaim succeeded or not, the slot\n \t * could have been be freed while we are not holding the lock.\n \t */\n-\tfor (offset = start; offset < end; offset++)\n-\t\tif (READ_ONCE(map[offset]))\n-\t\t\treturn false;\n-\n-\treturn true;\n+\treturn find_next_bit(si->swap_map, end, start) >= end;\n }\n \n static bool cluster_scan_range(struct swap_info_struct *si,\n@@ -800,15 +790,16 @@ static bool cluster_scan_range(struct swap_info_struct *si,\n \t\t\t       bool *need_reclaim)\n {\n \tunsigned long offset, end = start + nr_pages;\n-\tunsigned char *map = si->swap_map;\n-\tunsigned char count;\n \n \tif (cluster_is_empty(ci))\n \t\treturn true;\n \n \tfor (offset = start; offset < end; offset++) {\n-\t\tcount = READ_ONCE(map[offset]);\n-\t\tif (!count)\n+\t\t/* Bad slots cannot be used for allocation */\n+\t\tif (test_bit(offset, si->bad_map))\n+\t\t\treturn false;\n+\n+\t\tif (!test_bit(offset, si->swap_map))\n \t\t\tcontinue;\n \n \t\tif (swap_cache_only(si, offset)) {\n@@ -841,7 +832,7 @@ static bool cluster_alloc_range(struct swap_info_struct *si, struct swap_cluster\n \tif (cluster_is_empty(ci))\n \t\tci->order = order;\n \n-\tmemset(si->swap_map + start, usage, nr_pages);\n+\tbitmap_set(si->swap_map, start, nr_pages);\n \tswap_range_alloc(si, nr_pages);\n \tci->count += nr_pages;\n \n@@ -1404,7 +1395,7 @@ static struct swap_info_struct *_swap_info_get(swp_slot_t slot)\n \toffset = swp_slot_offset(slot);\n \tif (offset >= si->max)\n \t\tgoto bad_offset;\n-\tif (data_race(!si->swap_map[swp_slot_offset(slot)]))\n+\tif (data_race(!test_bit(offset, si->swap_map)))\n \t\tgoto bad_free;\n \treturn si;\n \n@@ -1518,8 +1509,7 @@ static void swap_slots_free(struct swap_info_struct *si,\n \t\t\t      swp_slot_t slot, unsigned int nr_pages)\n {\n \tunsigned long offset = swp_slot_offset(slot);\n-\tunsigned char *map = si->swap_map + offset;\n-\tunsigned char *map_end = map + nr_pages;\n+\tunsigned long end = offset + nr_pages;\n \n \t/* It should never free entries across different clusters */\n \tVM_BUG_ON(ci != __swap_offset_to_cluster(si, offset + nr_pages - 1));\n@@ -1527,10 +1517,8 @@ static void swap_slots_free(struct swap_info_struct *si,\n \tVM_BUG_ON(ci->count < nr_pages);\n \n \tci->count -= nr_pages;\n-\tdo {\n-\t\tVM_BUG_ON(!swap_is_last_ref(*map));\n-\t\t*map = 0;\n-\t} while (++map < map_end);\n+\tVM_BUG_ON(find_next_zero_bit(si->swap_map, end, offset) < end);\n+\tbitmap_clear(si->swap_map, offset, nr_pages);\n \n \tswap_range_free(si, offset, nr_pages);\n \n@@ -1741,9 +1729,7 @@ unsigned int count_swap_pages(int type, int free)\n static bool swap_slot_allocated(struct swap_info_struct *si,\n \t\tunsigned long offset)\n {\n-\tunsigned char count = READ_ONCE(si->swap_map[offset]);\n-\n-\treturn count && swap_count(count) != SWAP_MAP_BAD;\n+\treturn test_bit(offset, si->swap_map);\n }\n \n /*\n@@ -2064,7 +2050,7 @@ static int setup_swap_extents(struct swap_info_struct *sis, sector_t *span)\n }\n \n static void setup_swap_info(struct swap_info_struct *si, int prio,\n-\t\t\t    unsigned char *swap_map,\n+\t\t\t    unsigned long *swap_map,\n \t\t\t    struct swap_cluster_info *cluster_info)\n {\n \tsi->prio = prio;\n@@ -2092,7 +2078,7 @@ static void _enable_swap_info(struct swap_info_struct *si)\n }\n \n static void enable_swap_info(struct swap_info_struct *si, int prio,\n-\t\t\t\tunsigned char *swap_map,\n+\t\t\t\tunsigned long *swap_map,\n \t\t\t\tstruct swap_cluster_info *cluster_info)\n {\n \tspin_lock(&swap_lock);\n@@ -2185,7 +2171,8 @@ static void flush_percpu_swap_cluster(struct swap_info_struct *si)\n SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n {\n \tstruct swap_info_struct *p = NULL;\n-\tunsigned char *swap_map;\n+\tunsigned long *swap_map;\n+\tunsigned long *bad_map;\n \tstruct swap_cluster_info *cluster_info;\n \tstruct file *swap_file, *victim;\n \tstruct address_space *mapping;\n@@ -2280,6 +2267,8 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \tp->swap_file = NULL;\n \tswap_map = p->swap_map;\n \tp->swap_map = NULL;\n+\tbad_map = p->bad_map;\n+\tp->bad_map = NULL;\n \tmaxpages = p->max;\n \tcluster_info = p->cluster_info;\n \tp->max = 0;\n@@ -2290,7 +2279,8 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)\n \tmutex_unlock(&swapon_mutex);\n \tkfree(p->global_cluster);\n \tp->global_cluster = NULL;\n-\tvfree(swap_map);\n+\tkvfree(swap_map);\n+\tkvfree(bad_map);\n \tfree_cluster_info(cluster_info, maxpages);\n \n \tinode = mapping->host;\n@@ -2638,18 +2628,20 @@ static unsigned long read_swap_header(struct swap_info_struct *si,\n \n static int setup_swap_map(struct swap_info_struct *si,\n \t\t\t  union swap_header *swap_header,\n-\t\t\t  unsigned char *swap_map,\n+\t\t\t  unsigned long *swap_map,\n+\t\t\t  unsigned long *bad_map,\n \t\t\t  unsigned long maxpages)\n {\n \tunsigned long i;\n \n-\tswap_map[0] = SWAP_MAP_BAD; /* omit header page */\n+\tset_bit(0, bad_map); /* omit header page */\n+\n \tfor (i = 0; i < swap_header->info.nr_badpages; i++) {\n \t\tunsigned int page_nr = swap_header->info.badpages[i];\n \t\tif (page_nr == 0 || page_nr > swap_header->info.last_page)\n \t\t\treturn -EINVAL;\n \t\tif (page_nr < maxpages) {\n-\t\t\tswap_map[page_nr] = SWAP_MAP_BAD;\n+\t\t\tset_bit(page_nr, bad_map);\n \t\t\tsi->pages--;\n \t\t}\n \t}\n@@ -2753,7 +2745,7 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tint nr_extents;\n \tsector_t span;\n \tunsigned long maxpages;\n-\tunsigned char *swap_map = NULL;\n+\tunsigned long *swap_map = NULL, *bad_map = NULL;\n \tstruct swap_cluster_info *cluster_info = NULL;\n \tstruct folio *folio = NULL;\n \tstruct inode *inode = NULL;\n@@ -2849,16 +2841,24 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tmaxpages = si->max;\n \n \t/* OK, set up the swap map and apply the bad block list */\n-\tswap_map = vzalloc(maxpages);\n+\tswap_map = kvcalloc(BITS_TO_LONGS(maxpages), sizeof(long), GFP_KERNEL);\n \tif (!swap_map) {\n \t\terror = -ENOMEM;\n \t\tgoto bad_swap_unlock_inode;\n \t}\n \n-\terror = setup_swap_map(si, swap_header, swap_map, maxpages);\n+\tbad_map = kvcalloc(BITS_TO_LONGS(maxpages), sizeof(long), GFP_KERNEL);\n+\tif (!bad_map) {\n+\t\terror = -ENOMEM;\n+\t\tgoto bad_swap_unlock_inode;\n+\t}\n+\n+\terror = setup_swap_map(si, swap_header, swap_map, bad_map, maxpages);\n \tif (error)\n \t\tgoto bad_swap_unlock_inode;\n \n+\tsi->bad_map = bad_map;\n+\n \tif (si->bdev && bdev_stable_writes(si->bdev))\n \t\tsi->flags |= SWP_STABLE_WRITES;\n \n@@ -2952,7 +2952,10 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)\n \tsi->swap_file = NULL;\n \tsi->flags = 0;\n \tspin_unlock(&swap_lock);\n-\tvfree(swap_map);\n+\tif (swap_map)\n+\t\tkvfree(swap_map);\n+\tif (bad_map)\n+\t\tkvfree(bad_map);\n \tif (cluster_info)\n \t\tfree_cluster_info(cluster_info, maxpages);\n \tif (inced_nr_rotate_swap)\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged an issue with email delivery, apologized for inconvenience, and expressed confusion about the problem.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "apology",
            "confusion"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Weirdly, it seems like the cover letter (and only the cover letter) is\nnot being delivered...\n\nI'm trying to figure out what's going on :( My apologies for the\ninconvenience...",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed reviewer feedback about poor batching behavior of vswap free path, explaining that the issue is due to a missing lock drop in the swapoff path and agreeing to restructure the code in v2.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged fix needed",
            "agreed to restructure"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Changelog:\n* RFC v2 -> v3:\n    * Implement a cluster-based allocation algorithm for virtual swap\n      slots, inspired by Kairui Song and Chris Li's implementation, as\n      well as Johannes Weiner's suggestions. This eliminates the lock\n\t  contention issues on the virtual swap layer.\n    * Re-use swap table for the reverse mapping.\n    * Remove CONFIG_VIRTUAL_SWAP.\n    * Reducing the size of the swap descriptor from 48 bytes to 24\n      bytes, i.e another 50% reduction in memory overhead from v2.\n    * Remove swap cache and zswap tree and use the swap descriptor\n      for this.\n    * Remove zeromap, and replace the swap_map bytemap with 2 bitmaps\n      (one for allocated slots, and one for bad slots).\n    * Rebase on top of 6.19 (7d0a66e4bb9081d75c82ec4957c50034cb0ea449)\n\t* Update cover letter to include new benchmark results and discussion\n\t  on overhead in various cases.\n* RFC v1 -> RFC v2:\n    * Use a single atomic type (swap_refs) for reference counting\n      purpose. This brings the size of the swap descriptor from 64 B\n      down to 48 B (25% reduction). Suggested by Yosry Ahmed.\n    * Zeromap bitmap is removed in the virtual swap implementation.\n      This saves one bit per phyiscal swapfile slot.\n    * Rearrange the patches and the code change to make things more\n      reviewable. Suggested by Johannes Weiner.\n    * Update the cover letter a bit.\n\nThis patch series implements the virtual swap space idea, based on Yosry's\nproposals at LSFMMBPF 2023 (see [1], [2], [3]), as well as valuable\ninputs from Johannes Weiner. The same idea (with different\nimplementation details) has been floated by Rik van Riel since at least\n2011 (see [8]).\n\nThis patch series is based on 6.19. There are a couple more\nswap-related changes in the mm-stable branch that I would need to\ncoordinate with, but I would like to send this out as an update, to show\nthat the lock contention issues that plagued earlier versions have been\nresolved and performance on the kernel build benchmark is now on-par with\nbaseline. Furthermore, memory overhead has been substantially reduced\ncompared to the last RFC version.\n\n\nI. Motivation\n\nCurrently, when an anon page is swapped out, a slot in a backing swap\ndevice is allocated and stored in the page table entries that refer to\nthe original page. This slot is also used as the \"key\" to find the\nswapped out content, as well as the index to swap data structures, such\nas the swap cache, or the swap cgroup mapping. Tying a swap entry to its\nbacking slot in this way is performant and efficient when swap is purely\njust disk space, and swapoff is rare.\n\nHowever, the advent of many swap optimizations has exposed major\ndrawbacks of this design. The first problem is that we occupy a physical\nslot in the swap space, even for pages that are NEVER expected to hit\nthe disk: pages compressed and stored in the zswap pool, zero-filled\npages, or pages rejected by both of these optimizations when zswap\nwriteback is disabled. This is the arguably central shortcoming of\nzswap:\n* In deployments when no disk space can be afforded for swap (such as\n  mobile and embedded devices), users cannot adopt zswap, and are forced\n  to use zram. This is confusing for users, and creates extra burdens\n  for developers, having to develop and maintain similar features for\n  two separate swap backends (writeback, cgroup charging, THP support,\n  etc.). For instance, see the discussion in [4].\n* Resource-wise, it is hugely wasteful in terms of disk usage. At Meta,\n  we have swapfile in the order of tens to hundreds of GBs, which are\n  mostly unused and only exist to enable zswap usage and zero-filled\n  pages swap optimizations.\n* Tying zswap (and more generally, other in-memory swap backends) to\n  the current physical swapfile infrastructure makes zswap implicitly\n  statically sized. This does not make sense, as unlike disk swap, in\n  which we consume a limited resource (disk space or swapfile space) to\n  save another resource (memory), zswap consume the same resource it is\n  saving (memory). The more we zswap, the more memory we have available,\n  not less. We are not rationing a limited resource when we limit\n  the size of he zswap pool, but rather we are capping the resource\n  (memory) saving potential of zswap. Under memory pressure, using\n  more zswap is almost always better than the alternative (disk IOs, or\n  even worse, OOMs), and dynamically sizing the zswap pool on demand\n  allows the system to flexibly respond to these precarious scenarios.\n* Operationally, static provisioning the swapfile for zswap pose\n  significant challenges, because the sysadmin has to prescribe how\n  much swap is needed a priori, for each combination of\n  (memory size x disk space x workload usage). It is even more\n  complicated when we take into account the variance of memory\n  compression, which changes the reclaim dynamics (and as a result,\n  swap space size requirement). The problem is further exarcebated for\n  users who rely on swap utilization (and exhaustion) as an OOM signal.\n\n  All of these factors make it very difficult to configure the swapfile\n  for zswap: too small of a swapfile and we risk preventable OOMs and\n  limit the memory saving potentials of zswap; too big of a swapfile\n  and we waste disk space and memory due to swap metadata overhead.\n  This dilemma becomes more drastic in high memory systems, which can\n  have up to TBs worth of memory.\n\nPast attempts to decouple disk and compressed swap backends, namely the\nghost swapfile approach (see [13]), as well as the alternative\ncompressed swap backend zram, have mainly focused on eliminating the\ndisk space usage of compressed backends. We want a solution that not\nonly tackles that same problem, but also achieve the dyamicization of\nswap space to maximize the memory saving potentials while reducing\noperational and static memory overhead.\n\nFinally, any swap redesign should support efficient backend transfer,\ni.e without having to perform the expensive page table walk to\nupdate all the PTEs that refer to the swap entry:\n* The main motivation for this requirement is zswap writeback. To quote\n  Johannes (from [14]): \"Combining compression with disk swap is\n  extremely powerful, because it dramatically reduces the worst aspects\n  of both: it reduces the memory footprint of compression by shedding\n  the coldest data to disk; it reduces the IO latencies and flash wear\n  of disk swap through the writeback cache. In practice, this reduces\n  *average event rates of the entire reclaim/paging/IO stack*.\"\n* Another motivation is to simplify swapoff, which is both complicated\n  and expensive in the current design, precisely because we are storing\n  an encoding of the backend positional information in the page table,\n  and thus requires a full page table walk to remove these references.\n\n\nII. High Level Design Overview\n\nTo fix the aforementioned issues, we need an abstraction that separates\na swap entry from its physical backing storage. IOW, we need to\n\\u201cvirtualize\\u201d the swap space: swap clients will work with a dynamically\nallocated virtual swap slot, storing it in page table entries, and\nusing it to index into various swap-related data structures. The\nbacking storage is decoupled from the virtual swap slot, and the newly\nintroduced layer will \\u201cresolve\\u201d the virtual swap slot to the actual\nstorage. This layer also manages other metadata of the swap entry, such\nas its lifetime information (swap count), via a dynamically allocated,\nper-swap-entry descriptor:\n\nstruct swp_desc {\n        union {\n                swp_slot_t         slot;                 /*     0     8 */\n                struct zswap_entry * zswap_entry;        /*     0     8 */\n        };                                               /*     0     8 */\n        union {\n                struct folio *     swap_cache;           /*     8     8 */\n                void *             shadow;               /*     8     8 */\n        };                                               /*     8     8 */\n        unsigned int               swap_count;           /*    16     4 */\n        unsigned short             memcgid:16;           /*    20: 0  2 */\n        bool                       in_swapcache:1;       /*    22: 0  1 */\n\n        /* Bitfield combined with previous fields */\n\n        enum swap_type             type:2;               /*    20:17  4 */\n\n        /* size: 24, cachelines: 1, members: 6 */\n        /* bit_padding: 13 bits */\n        /* last cacheline: 24 bytes */\n};\n\n(output from pahole).\n\nThis design allows us to:\n* Decouple zswap (and zeromapped swap entry) from backing swapfile:\n  simply associate the virtual swap slot with one of the supported\n  backends: a zswap entry, a zero-filled swap page, a slot on the\n  swapfile, or an in-memory page.\n* Simplify and optimize swapoff: we only have to fault the page in and\n  have the virtual swap slot points to the page instead of the on-disk\n  physical swap slot. No need to perform any page table walking.\n\nThe size of the virtual swap descriptor is 24 bytes. Note that this is\nnot all \"new\" overhead, as the swap descriptor will replace:\n* the swap_cgroup arrays (one per swap type) in the old design, which\n  is a massive source of static memory overhead. With the new design,\n  it is only allocated for used clusters.\n* the swap tables, which holds the swap cache and workingset shadows.\n* the zeromap bitmap, which is a bitmap of physical swap slots to\n  indicate whether the swapped out page is zero-filled or not.\n* huge chunk of the swap_map. The swap_map is now replaced by 2 bitmaps,\n  one for allocated slots, and one for bad slots, representing 3 possible\n  states of a slot on the swapfile: allocated, free, and bad.\n* the zswap tree.\n\nSo, in terms of additional memory overhead:\n* For zswap entries, the added memory overhead is rather minimal. The\n  new indirection pointer neatly replaces the existing zswap tree.\n  We really only incur less than one word of overhead for swap count\n  blow up (since we no longer use swap continuation) and the swap type.\n* For physical swap entries, the new design will impose fewer than 3 words\n  memory overhead. However, as noted above this overhead is only for\n  actively used swap entries, whereas in the current design the overhead is\n  static (including the swap cgroup array for example).\n\n  The primary victim of this overhead will be zram users. However, as\n  zswap now no longer takes up disk space, zram users can consider\n  switching to zswap (which, as a bonus, has a lot of useful features\n  out of the box, such as cgroup tracking, dynamic zswap pool sizing,\n  LRU-ordering writeback, etc.).\n\nFor a more concrete example, suppose we have a 32 GB swapfile (i.e.\n8,388,608 swap entries), and we use zswap.\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 0.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 48.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 96.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 121.00 MB\n* Vswap total overhead: 144.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 153.00 MB\n* Vswap total overhead: 193.00 MB\n\nSo even in the worst case scenario for virtual swap, i.e when we\nsomehow have an oracle to correctly size the swapfile for zswap\npool to 32 GB, the added overhead is only 40 MB, which is a mere\n0.12% of the total swapfile :)\n\nIn practice, the overhead will be closer to the 50-75% usage case, as\nsystems tend to leave swap headroom for pathological events or sudden\nspikes in memory requirements. The added overhead in these cases are\npractically neglible. And in deployments where swapfiles for zswap\nare previously sparsely used, switching over to virtual swap will\nactually reduce memory overhead.\n\nDoing the same math for the disk swap, which is the worst case for\nvirtual swap in terms of swap backends:\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 2.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 41.00 MB\n* Vswap total overhead: 66.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 130.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 73.00 MB\n* Vswap total overhead: 194.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 259.00 MB\n\nThe added overhead is 170MB, which is 0.5% of the total swapfile size,\nagain in the worst case when we have a sizing oracle.\n\nPlease see the attached patches for more implementation details.\n\n\nIII. Usage and Benchmarking\n\nThis patch series introduce no new syscalls or userspace API. Existing\nuserspace setups will work as-is, except we no longer have to create a\nswapfile or set memory.swap.max if we want to use zswap, as zswap is no\nlonger tied to physical swap. The zswap pool will be automatically and\ndynamically sized based on memory usage and reclaim dynamics.\n\nTo measure the performance of the new implementation, I have run the\nfollowing benchmarks:\n\n1. Kernel building: 52 workers (one per processor), memory.max = 3G.\n\nUsing zswap as the backend:\n\nBaseline:\nreal: mean: 185.2s, stdev: 0.93s\nsys: mean: 683.7s, stdev: 33.77s\n\nVswap:\nreal: mean: 184.88s, stdev: 0.57s\nsys: mean: 675.14s, stdev: 32.8s\n\nWe actually see a slight improvement in systime (by 1.5%) :) This is\nlikely because we no longer have to perform swap charging for zswap\nentries, and virtual swap allocator is simpler than that of physical\nswap.\n\nUsing SSD swap as the backend:\n\nBaseline:\nreal: mean: 200.3s, stdev: 2.33s\nsys: mean: 489.88s, stdev: 9.62s\n\nVswap:\nreal: mean: 201.47s, stdev: 2.98s\nsys: mean: 487.36s, stdev: 5.53s\n\nThe performance is neck-to-neck.\n\n\nIV. Future Use Cases\n\nWhile the patch series focus on two applications (decoupling swap\nbackends and swapoff optimization/simplification), this new,\nfuture-proof design also allows us to implement new swap features more\neasily and efficiently:\n\n* Multi-tier swapping (as mentioned in [5]), with transparent\n  transferring (promotion/demotion) of pages across tiers (see [8] and\n  [9]). Similar to swapoff, with the old design we would need to\n  perform the expensive page table walk.\n* Swapfile compaction to alleviate fragmentation (as proposed by Ying\n  Huang in [6]).\n* Mixed backing THP swapin (see [7]): Once you have pinned down the\n  backing store of THPs, then you can dispatch each range of subpages\n  to appropriate backend swapin handler.\n* Swapping a folio out with discontiguous physical swap slots\n  (see [10]).\n* Zswap writeback optimization: The current architecture pre-reserves\n  physical swap space for pages when they enter the zswap pool, giving\n  the kernel no flexibility at writeback time. With the virtual swap\n  implementation, the backends are decoupled, and physical swap space\n  is allocated on-demand at writeback time, at which point we can make\n  much smarter decisions: we can batch multiple zswap writeback\n  operations into a single IO request, allocating contiguous physical\n  swap slots for that request. We can even perform compressed writeback\n  (i.e writing these pages without decompressing them) (see [12]).\n\n\nV. References\n\n[1]: https://lore.kernel.org/all/CAJD7tkbCnXJ95Qow_aOjNX6NOMU5ovMSHRC+95U4wtW6cM+puw@mail.gmail.com/\n[2]: https://lwn.net/Articles/932077/\n[3]: https://www.youtube.com/watch?v=Hwqw_TBGEhg\n[4]: https://lore.kernel.org/all/Zqe_Nab-Df1CN7iW@infradead.org/\n[5]: https://lore.kernel.org/lkml/CAF8kJuN-4UE0skVHvjUzpGefavkLULMonjgkXUZSBVJrcGFXCA@mail.gmail.com/\n[6]: https://lore.kernel.org/linux-mm/87o78mzp24.fsf@yhuang6-desk2.ccr.corp.intel.com/\n[7]: https://lore.kernel.org/all/CAGsJ_4ysCN6f7qt=6gvee1x3ttbOnifGneqcRm9Hoeun=uFQ2w@mail.gmail.com/\n[8]: https://lore.kernel.org/linux-mm/4DA25039.3020700@redhat.com/\n[9]: https://lore.kernel.org/all/CA+ZsKJ7DCE8PMOSaVmsmYZL9poxK6rn0gvVXbjpqxMwxS2C9TQ@mail.gmail.com/\n[10]: https://lore.kernel.org/all/CACePvbUkMYMencuKfpDqtG1Ej7LiUS87VRAXb8sBn1yANikEmQ@mail.gmail.com/\n[11]: https://lore.kernel.org/all/CAMgjq7BvQ0ZXvyLGp2YP96+i+6COCBBJCYmjXHGBnfisCAb8VA@mail.gmail.com/\n[12]: https://lore.kernel.org/linux-mm/ZeZSDLWwDed0CgT3@casper.infradead.org/\n[13]: https://lore.kernel.org/all/20251121-ghost-v1-1-cfc0efcf3855@kernel.org/\n[14]: https://lore.kernel.org/linux-mm/20251202170222.GD430226@cmpxchg.org/\n\nNhat Pham (20):\n  mm/swap: decouple swap cache from physical swap infrastructure\n  swap: rearrange the swap header file\n  mm: swap: add an abstract API for locking out swapoff\n  zswap: add new helpers for zswap entry operations\n  mm/swap: add a new function to check if a swap entry is in swap\n    cached.\n  mm: swap: add a separate type for physical swap slots\n  mm: create scaffolds for the new virtual swap implementation\n  zswap: prepare zswap for swap virtualization\n  mm: swap: allocate a virtual swap slot for each swapped out page\n  swap: move swap cache to virtual swap descriptor\n  zswap: move zswap entry management to the virtual swap descriptor\n  swap: implement the swap_cgroup API using virtual swap\n  swap: manage swap entry lifecycle at the virtual swap layer\n  mm: swap: decouple virtual swap slot from backing store\n  zswap: do not start zswap shrinker if there is no physical swap slots\n  swap: do not unnecesarily pin readahead swap entries\n  swapfile: remove zeromap bitmap\n  memcg: swap: only charge physical swap slots\n  swap: simplify swapoff using virtual swap\n  swapfile: replace the swap map with bitmaps\n\n Documentation/mm/swap-table.rst |   69 --\n MAINTAINERS                     |    2 +\n include/linux/cpuhotplug.h      |    1 +\n include/linux/mm_types.h        |   16 +\n include/linux/shmem_fs.h        |    7 +-\n include/linux/swap.h            |  135 ++-\n include/linux/swap_cgroup.h     |   13 -\n include/linux/swapops.h         |   25 +\n include/linux/zswap.h           |   17 +-\n kernel/power/swap.c             |    6 +-\n mm/Makefile                     |    5 +-\n mm/huge_memory.c                |   11 +-\n mm/internal.h                   |   12 +-\n mm/memcontrol-v1.c              |    6 +\n mm/memcontrol.c                 |  142 ++-\n mm/memory.c                     |  101 +-\n mm/migrate.c                    |   13 +-\n mm/mincore.c                    |   15 +-\n mm/page_io.c                    |   83 +-\n mm/shmem.c                      |  215 +---\n mm/swap.h                       |  157 +--\n mm/swap_cgroup.c                |  172 ---\n mm/swap_state.c                 |  306 +----\n mm/swap_table.h                 |   78 +-\n mm/swapfile.c                   | 1518 ++++-------------------\n mm/userfaultfd.c                |   18 +-\n mm/vmscan.c                     |   28 +-\n mm/vswap.c                      | 2025 +++++++++++++++++++++++++++++++\n mm/zswap.c                      |  142 +--\n 29 files changed, 2853 insertions(+), 2485 deletions(-)\n delete mode 100644 Documentation/mm/swap-table.rst\n delete mode 100644 mm/swap_cgroup.c\n create mode 100644 mm/vswap.c\n\n\nbase-commit: 05f7e89ab9731565d8a62e3b5d1ec206485eeb0b\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the poor batching behavior of vswap free path in their patch series, explaining that they had already implemented a cluster-based allocation algorithm for virtual swap slots to eliminate lock contention issues and improve performance.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "My sincerest apologies - it seems like the cover letter (and just the\ncover letter) fails to be sent out, for some reason. I'm trying to figure\nout what happened - it works when I send the entire patch series to\nmyself...\n\nAnyway, resending this (in-reply-to patch 1 of the series):\n\nChangelog:\n* RFC v2 -> v3:\n    * Implement a cluster-based allocation algorithm for virtual swap\n      slots, inspired by Kairui Song and Chris Li's implementation, as\n      well as Johannes Weiner's suggestions. This eliminates the lock\n\t  contention issues on the virtual swap layer.\n    * Re-use swap table for the reverse mapping.\n    * Remove CONFIG_VIRTUAL_SWAP.\n    * Reducing the size of the swap descriptor from 48 bytes to 24\n      bytes, i.e another 50% reduction in memory overhead from v2.\n    * Remove swap cache and zswap tree and use the swap descriptor\n      for this.\n    * Remove zeromap, and replace the swap_map bytemap with 2 bitmaps\n      (one for allocated slots, and one for bad slots).\n    * Rebase on top of 6.19 (7d0a66e4bb9081d75c82ec4957c50034cb0ea449)\n\t* Update cover letter to include new benchmark results and discussion\n\t  on overhead in various cases.\n* RFC v1 -> RFC v2:\n    * Use a single atomic type (swap_refs) for reference counting\n      purpose. This brings the size of the swap descriptor from 64 B\n      down to 48 B (25% reduction). Suggested by Yosry Ahmed.\n    * Zeromap bitmap is removed in the virtual swap implementation.\n      This saves one bit per phyiscal swapfile slot.\n    * Rearrange the patches and the code change to make things more\n      reviewable. Suggested by Johannes Weiner.\n    * Update the cover letter a bit.\n\nThis patch series implements the virtual swap space idea, based on Yosry's\nproposals at LSFMMBPF 2023 (see [1], [2], [3]), as well as valuable\ninputs from Johannes Weiner. The same idea (with different\nimplementation details) has been floated by Rik van Riel since at least\n2011 (see [8]).\n\nThis patch series is based on 6.19. There are a couple more\nswap-related changes in the mm-stable branch that I would need to\ncoordinate with, but I would like to send this out as an update, to show\nthat the lock contention issues that plagued earlier versions have been\nresolved and performance on the kernel build benchmark is now on-par with\nbaseline. Furthermore, memory overhead has been substantially reduced\ncompared to the last RFC version.\n\n\nI. Motivation\n\nCurrently, when an anon page is swapped out, a slot in a backing swap\ndevice is allocated and stored in the page table entries that refer to\nthe original page. This slot is also used as the \"key\" to find the\nswapped out content, as well as the index to swap data structures, such\nas the swap cache, or the swap cgroup mapping. Tying a swap entry to its\nbacking slot in this way is performant and efficient when swap is purely\njust disk space, and swapoff is rare.\n\nHowever, the advent of many swap optimizations has exposed major\ndrawbacks of this design. The first problem is that we occupy a physical\nslot in the swap space, even for pages that are NEVER expected to hit\nthe disk: pages compressed and stored in the zswap pool, zero-filled\npages, or pages rejected by both of these optimizations when zswap\nwriteback is disabled. This is the arguably central shortcoming of\nzswap:\n* In deployments when no disk space can be afforded for swap (such as\n  mobile and embedded devices), users cannot adopt zswap, and are forced\n  to use zram. This is confusing for users, and creates extra burdens\n  for developers, having to develop and maintain similar features for\n  two separate swap backends (writeback, cgroup charging, THP support,\n  etc.). For instance, see the discussion in [4].\n* Resource-wise, it is hugely wasteful in terms of disk usage. At Meta,\n  we have swapfile in the order of tens to hundreds of GBs, which are\n  mostly unused and only exist to enable zswap usage and zero-filled\n  pages swap optimizations.\n* Tying zswap (and more generally, other in-memory swap backends) to\n  the current physical swapfile infrastructure makes zswap implicitly\n  statically sized. This does not make sense, as unlike disk swap, in\n  which we consume a limited resource (disk space or swapfile space) to\n  save another resource (memory), zswap consume the same resource it is\n  saving (memory). The more we zswap, the more memory we have available,\n  not less. We are not rationing a limited resource when we limit\n  the size of he zswap pool, but rather we are capping the resource\n  (memory) saving potential of zswap. Under memory pressure, using\n  more zswap is almost always better than the alternative (disk IOs, or\n  even worse, OOMs), and dynamically sizing the zswap pool on demand\n  allows the system to flexibly respond to these precarious scenarios.\n* Operationally, static provisioning the swapfile for zswap pose\n  significant challenges, because the sysadmin has to prescribe how\n  much swap is needed a priori, for each combination of\n  (memory size x disk space x workload usage). It is even more\n  complicated when we take into account the variance of memory\n  compression, which changes the reclaim dynamics (and as a result,\n  swap space size requirement). The problem is further exarcebated for\n  users who rely on swap utilization (and exhaustion) as an OOM signal.\n\n  All of these factors make it very difficult to configure the swapfile\n  for zswap: too small of a swapfile and we risk preventable OOMs and\n  limit the memory saving potentials of zswap; too big of a swapfile\n  and we waste disk space and memory due to swap metadata overhead.\n  This dilemma becomes more drastic in high memory systems, which can\n  have up to TBs worth of memory.\n\nPast attempts to decouple disk and compressed swap backends, namely the\nghost swapfile approach (see [13]), as well as the alternative\ncompressed swap backend zram, have mainly focused on eliminating the\ndisk space usage of compressed backends. We want a solution that not\nonly tackles that same problem, but also achieve the dyamicization of\nswap space to maximize the memory saving potentials while reducing\noperational and static memory overhead.\n\nFinally, any swap redesign should support efficient backend transfer,\ni.e without having to perform the expensive page table walk to\nupdate all the PTEs that refer to the swap entry:\n* The main motivation for this requirement is zswap writeback. To quote\n  Johannes (from [14]): \"Combining compression with disk swap is\n  extremely powerful, because it dramatically reduces the worst aspects\n  of both: it reduces the memory footprint of compression by shedding\n  the coldest data to disk; it reduces the IO latencies and flash wear\n  of disk swap through the writeback cache. In practice, this reduces\n  *average event rates of the entire reclaim/paging/IO stack*.\"\n* Another motivation is to simplify swapoff, which is both complicated\n  and expensive in the current design, precisely because we are storing\n  an encoding of the backend positional information in the page table,\n  and thus requires a full page table walk to remove these references.\n\n\nII. High Level Design Overview\n\nTo fix the aforementioned issues, we need an abstraction that separates\na swap entry from its physical backing storage. IOW, we need to\n\\u201cvirtualize\\u201d the swap space: swap clients will work with a dynamically\nallocated virtual swap slot, storing it in page table entries, and\nusing it to index into various swap-related data structures. The\nbacking storage is decoupled from the virtual swap slot, and the newly\nintroduced layer will \\u201cresolve\\u201d the virtual swap slot to the actual\nstorage. This layer also manages other metadata of the swap entry, such\nas its lifetime information (swap count), via a dynamically allocated,\nper-swap-entry descriptor:\n\nstruct swp_desc {\n        union {\n                swp_slot_t         slot;                 /*     0     8 */\n                struct zswap_entry * zswap_entry;        /*     0     8 */\n        };                                               /*     0     8 */\n        union {\n                struct folio *     swap_cache;           /*     8     8 */\n                void *             shadow;               /*     8     8 */\n        };                                               /*     8     8 */\n        unsigned int               swap_count;           /*    16     4 */\n        unsigned short             memcgid:16;           /*    20: 0  2 */\n        bool                       in_swapcache:1;       /*    22: 0  1 */\n\n        /* Bitfield combined with previous fields */\n\n        enum swap_type             type:2;               /*    20:17  4 */\n\n        /* size: 24, cachelines: 1, members: 6 */\n        /* bit_padding: 13 bits */\n        /* last cacheline: 24 bytes */\n};\n\n(output from pahole).\n\nThis design allows us to:\n* Decouple zswap (and zeromapped swap entry) from backing swapfile:\n  simply associate the virtual swap slot with one of the supported\n  backends: a zswap entry, a zero-filled swap page, a slot on the\n  swapfile, or an in-memory page.\n* Simplify and optimize swapoff: we only have to fault the page in and\n  have the virtual swap slot points to the page instead of the on-disk\n  physical swap slot. No need to perform any page table walking.\n\nThe size of the virtual swap descriptor is 24 bytes. Note that this is\nnot all \"new\" overhead, as the swap descriptor will replace:\n* the swap_cgroup arrays (one per swap type) in the old design, which\n  is a massive source of static memory overhead. With the new design,\n  it is only allocated for used clusters.\n* the swap tables, which holds the swap cache and workingset shadows.\n* the zeromap bitmap, which is a bitmap of physical swap slots to\n  indicate whether the swapped out page is zero-filled or not.\n* huge chunk of the swap_map. The swap_map is now replaced by 2 bitmaps,\n  one for allocated slots, and one for bad slots, representing 3 possible\n  states of a slot on the swapfile: allocated, free, and bad.\n* the zswap tree.\n\nSo, in terms of additional memory overhead:\n* For zswap entries, the added memory overhead is rather minimal. The\n  new indirection pointer neatly replaces the existing zswap tree.\n  We really only incur less than one word of overhead for swap count\n  blow up (since we no longer use swap continuation) and the swap type.\n* For physical swap entries, the new design will impose fewer than 3 words\n  memory overhead. However, as noted above this overhead is only for\n  actively used swap entries, whereas in the current design the overhead is\n  static (including the swap cgroup array for example).\n\n  The primary victim of this overhead will be zram users. However, as\n  zswap now no longer takes up disk space, zram users can consider\n  switching to zswap (which, as a bonus, has a lot of useful features\n  out of the box, such as cgroup tracking, dynamic zswap pool sizing,\n  LRU-ordering writeback, etc.).\n\nFor a more concrete example, suppose we have a 32 GB swapfile (i.e.\n8,388,608 swap entries), and we use zswap.\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 0.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 48.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 96.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 121.00 MB\n* Vswap total overhead: 144.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 153.00 MB\n* Vswap total overhead: 193.00 MB\n\nSo even in the worst case scenario for virtual swap, i.e when we\nsomehow have an oracle to correctly size the swapfile for zswap\npool to 32 GB, the added overhead is only 40 MB, which is a mere\n0.12% of the total swapfile :)\n\nIn practice, the overhead will be closer to the 50-75% usage case, as\nsystems tend to leave swap headroom for pathological events or sudden\nspikes in memory requirements. The added overhead in these cases are\npractically neglible. And in deployments where swapfiles for zswap\nare previously sparsely used, switching over to virtual swap will\nactually reduce memory overhead.\n\nDoing the same math for the disk swap, which is the worst case for\nvirtual swap in terms of swap backends:\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 2.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 41.00 MB\n* Vswap total overhead: 66.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 130.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 73.00 MB\n* Vswap total overhead: 194.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 259.00 MB\n\nThe added overhead is 170MB, which is 0.5% of the total swapfile size,\nagain in the worst case when we have a sizing oracle.\n\nPlease see the attached patches for more implementation details.\n\n\nIII. Usage and Benchmarking\n\nThis patch series introduce no new syscalls or userspace API. Existing\nuserspace setups will work as-is, except we no longer have to create a\nswapfile or set memory.swap.max if we want to use zswap, as zswap is no\nlonger tied to physical swap. The zswap pool will be automatically and\ndynamically sized based on memory usage and reclaim dynamics.\n\nTo measure the performance of the new implementation, I have run the\nfollowing benchmarks:\n\n1. Kernel building: 52 workers (one per processor), memory.max = 3G.\n\nUsing zswap as the backend:\n\nBaseline:\nreal: mean: 185.2s, stdev: 0.93s\nsys: mean: 683.7s, stdev: 33.77s\n\nVswap:\nreal: mean: 184.88s, stdev: 0.57s\nsys: mean: 675.14s, stdev: 32.8s\n\nWe actually see a slight improvement in systime (by 1.5%) :) This is\nlikely because we no longer have to perform swap charging for zswap\nentries, and virtual swap allocator is simpler than that of physical\nswap.\n\nUsing SSD swap as the backend:\n\nBaseline:\nreal: mean: 200.3s, stdev: 2.33s\nsys: mean: 489.88s, stdev: 9.62s\n\nVswap:\nreal: mean: 201.47s, stdev: 2.98s\nsys: mean: 487.36s, stdev: 5.53s\n\nThe performance is neck-to-neck.\n\n\nIV. Future Use Cases\n\nWhile the patch series focus on two applications (decoupling swap\nbackends and swapoff optimization/simplification), this new,\nfuture-proof design also allows us to implement new swap features more\neasily and efficiently:\n\n* Multi-tier swapping (as mentioned in [5]), with transparent\n  transferring (promotion/demotion) of pages across tiers (see [8] and\n  [9]). Similar to swapoff, with the old design we would need to\n  perform the expensive page table walk.\n* Swapfile compaction to alleviate fragmentation (as proposed by Ying\n  Huang in [6]).\n* Mixed backing THP swapin (see [7]): Once you have pinned down the\n  backing store of THPs, then you can dispatch each range of subpages\n  to appropriate backend swapin handler.\n* Swapping a folio out with discontiguous physical swap slots\n  (see [10]).\n* Zswap writeback optimization: The current architecture pre-reserves\n  physical swap space for pages when they enter the zswap pool, giving\n  the kernel no flexibility at writeback time. With the virtual swap\n  implementation, the backends are decoupled, and physical swap space\n  is allocated on-demand at writeback time, at which point we can make\n  much smarter decisions: we can batch multiple zswap writeback\n  operations into a single IO request, allocating contiguous physical\n  swap slots for that request. We can even perform compressed writeback\n  (i.e writing these pages without decompressing them) (see [12]).\n\n\nV. References\n\n[1]: https://lore.kernel.org/all/CAJD7tkbCnXJ95Qow_aOjNX6NOMU5ovMSHRC+95U4wtW6cM+puw@mail.gmail.com/\n[2]: https://lwn.net/Articles/932077/\n[3]: https://www.youtube.com/watch?v=Hwqw_TBGEhg\n[4]: https://lore.kernel.org/all/Zqe_Nab-Df1CN7iW@infradead.org/\n[5]: https://lore.kernel.org/lkml/CAF8kJuN-4UE0skVHvjUzpGefavkLULMonjgkXUZSBVJrcGFXCA@mail.gmail.com/\n[6]: https://lore.kernel.org/linux-mm/87o78mzp24.fsf@yhuang6-desk2.ccr.corp.intel.com/\n[7]: https://lore.kernel.org/all/CAGsJ_4ysCN6f7qt=6gvee1x3ttbOnifGneqcRm9Hoeun=uFQ2w@mail.gmail.com/\n[8]: https://lore.kernel.org/linux-mm/4DA25039.3020700@redhat.com/\n[9]: https://lore.kernel.org/all/CA+ZsKJ7DCE8PMOSaVmsmYZL9poxK6rn0gvVXbjpqxMwxS2C9TQ@mail.gmail.com/\n[10]: https://lore.kernel.org/all/CACePvbUkMYMencuKfpDqtG1Ej7LiUS87VRAXb8sBn1yANikEmQ@mail.gmail.com/\n[11]: https://lore.kernel.org/all/CAMgjq7BvQ0ZXvyLGp2YP96+i+6COCBBJCYmjXHGBnfisCAb8VA@mail.gmail.com/\n[12]: https://lore.kernel.org/linux-mm/ZeZSDLWwDed0CgT3@casper.infradead.org/\n[13]: https://lore.kernel.org/all/20251121-ghost-v1-1-cfc0efcf3855@kernel.org/\n[14]: https://lore.kernel.org/linux-mm/20251202170222.GD430226@cmpxchg.org/\n\nNhat Pham (20):\n  mm/swap: decouple swap cache from physical swap infrastructure\n  swap: rearrange the swap header file\n  mm: swap: add an abstract API for locking out swapoff\n  zswap: add new helpers for zswap entry operations\n  mm/swap: add a new function to check if a swap entry is in swap\n    cached.\n  mm: swap: add a separate type for physical swap slots\n  mm: create scaffolds for the new virtual swap implementation\n  zswap: prepare zswap for swap virtualization\n  mm: swap: allocate a virtual swap slot for each swapped out page\n  swap: move swap cache to virtual swap descriptor\n  zswap: move zswap entry management to the virtual swap descriptor\n  swap: implement the swap_cgroup API using virtual swap\n  swap: manage swap entry lifecycle at the virtual swap layer\n  mm: swap: decouple virtual swap slot from backing store\n  zswap: do not start zswap shrinker if there is no physical swap slots\n  swap: do not unnecesarily pin readahead swap entries\n  swapfile: remove zeromap bitmap\n  memcg: swap: only charge physical swap slots\n  swap: simplify swapoff using virtual swap\n  swapfile: replace the swap map with bitmaps\n\n Documentation/mm/swap-table.rst |   69 --\n MAINTAINERS                     |    2 +\n include/linux/cpuhotplug.h      |    1 +\n include/linux/mm_types.h        |   16 +\n include/linux/shmem_fs.h        |    7 +-\n include/linux/swap.h            |  135 ++-\n include/linux/swap_cgroup.h     |   13 -\n include/linux/swapops.h         |   25 +\n include/linux/zswap.h           |   17 +-\n kernel/power/swap.c             |    6 +-\n mm/Makefile                     |    5 +-\n mm/huge_memory.c                |   11 +-\n mm/internal.h                   |   12 +-\n mm/memcontrol-v1.c              |    6 +\n mm/memcontrol.c                 |  142 ++-\n mm/memory.c                     |  101 +-\n mm/migrate.c                    |   13 +-\n mm/mincore.c                    |   15 +-\n mm/page_io.c                    |   83 +-\n mm/shmem.c                      |  215 +---\n mm/swap.h                       |  157 +--\n mm/swap_cgroup.c                |  172 ---\n mm/swap_state.c                 |  306 +----\n mm/swap_table.h                 |   78 +-\n mm/swapfile.c                   | 1518 ++++-------------------\n mm/userfaultfd.c                |   18 +-\n mm/vmscan.c                     |   28 +-\n mm/vswap.c                      | 2025 +++++++++++++++++++++++++++++++\n mm/zswap.c                      |  142 +--\n 29 files changed, 2853 insertions(+), 2485 deletions(-)\n delete mode 100644 Documentation/mm/swap-table.rst\n delete mode 100644 mm/swap_cgroup.c\n create mode 100644 mm/vswap.c\n\n\nbase-commit: 05f7e89ab9731565d8a62e3b5d1ec206485eeb0b\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author addressed a concern about the batching behavior of vswap free path in their patch series, explaining that they have already implemented a cluster-based allocation algorithm for virtual swap slots to eliminate lock contention issues and reduce memory overhead.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "My sincerest apologies - it seems like the cover letter (and just the\ncover letter) fails to be sent out, for some reason. I'm trying to figure\nout what happened - it works when I send the entire patch series to\nmyself...\n\nAnyway, resending this (in-reply-to patch 1 of the series):\n\nChangelog:\n* RFC v2 -> v3:\n    * Implement a cluster-based allocation algorithm for virtual swap\n      slots, inspired by Kairui Song and Chris Li's implementation, as\n      well as Johannes Weiner's suggestions. This eliminates the lock\n\t  contention issues on the virtual swap layer.\n    * Re-use swap table for the reverse mapping.\n    * Remove CONFIG_VIRTUAL_SWAP.\n    * Reducing the size of the swap descriptor from 48 bytes to 24\n      bytes, i.e another 50% reduction in memory overhead from v2.\n    * Remove swap cache and zswap tree and use the swap descriptor\n      for this.\n    * Remove zeromap, and replace the swap_map bytemap with 2 bitmaps\n      (one for allocated slots, and one for bad slots).\n    * Rebase on top of 6.19 (7d0a66e4bb9081d75c82ec4957c50034cb0ea449)\n\t* Update cover letter to include new benchmark results and discussion\n\t  on overhead in various cases.\n* RFC v1 -> RFC v2:\n    * Use a single atomic type (swap_refs) for reference counting\n      purpose. This brings the size of the swap descriptor from 64 B\n      down to 48 B (25% reduction). Suggested by Yosry Ahmed.\n    * Zeromap bitmap is removed in the virtual swap implementation.\n      This saves one bit per phyiscal swapfile slot.\n    * Rearrange the patches and the code change to make things more\n      reviewable. Suggested by Johannes Weiner.\n    * Update the cover letter a bit.\n\nThis patch series implements the virtual swap space idea, based on Yosry's\nproposals at LSFMMBPF 2023 (see [1], [2], [3]), as well as valuable\ninputs from Johannes Weiner. The same idea (with different\nimplementation details) has been floated by Rik van Riel since at least\n2011 (see [8]).\n\nThis patch series is based on 6.19. There are a couple more\nswap-related changes in the mm-stable branch that I would need to\ncoordinate with, but I would like to send this out as an update, to show\nthat the lock contention issues that plagued earlier versions have been\nresolved and performance on the kernel build benchmark is now on-par with\nbaseline. Furthermore, memory overhead has been substantially reduced\ncompared to the last RFC version.\n\n\nI. Motivation\n\nCurrently, when an anon page is swapped out, a slot in a backing swap\ndevice is allocated and stored in the page table entries that refer to\nthe original page. This slot is also used as the \"key\" to find the\nswapped out content, as well as the index to swap data structures, such\nas the swap cache, or the swap cgroup mapping. Tying a swap entry to its\nbacking slot in this way is performant and efficient when swap is purely\njust disk space, and swapoff is rare.\n\nHowever, the advent of many swap optimizations has exposed major\ndrawbacks of this design. The first problem is that we occupy a physical\nslot in the swap space, even for pages that are NEVER expected to hit\nthe disk: pages compressed and stored in the zswap pool, zero-filled\npages, or pages rejected by both of these optimizations when zswap\nwriteback is disabled. This is the arguably central shortcoming of\nzswap:\n* In deployments when no disk space can be afforded for swap (such as\n  mobile and embedded devices), users cannot adopt zswap, and are forced\n  to use zram. This is confusing for users, and creates extra burdens\n  for developers, having to develop and maintain similar features for\n  two separate swap backends (writeback, cgroup charging, THP support,\n  etc.). For instance, see the discussion in [4].\n* Resource-wise, it is hugely wasteful in terms of disk usage. At Meta,\n  we have swapfile in the order of tens to hundreds of GBs, which are\n  mostly unused and only exist to enable zswap usage and zero-filled\n  pages swap optimizations.\n* Tying zswap (and more generally, other in-memory swap backends) to\n  the current physical swapfile infrastructure makes zswap implicitly\n  statically sized. This does not make sense, as unlike disk swap, in\n  which we consume a limited resource (disk space or swapfile space) to\n  save another resource (memory), zswap consume the same resource it is\n  saving (memory). The more we zswap, the more memory we have available,\n  not less. We are not rationing a limited resource when we limit\n  the size of he zswap pool, but rather we are capping the resource\n  (memory) saving potential of zswap. Under memory pressure, using\n  more zswap is almost always better than the alternative (disk IOs, or\n  even worse, OOMs), and dynamically sizing the zswap pool on demand\n  allows the system to flexibly respond to these precarious scenarios.\n* Operationally, static provisioning the swapfile for zswap pose\n  significant challenges, because the sysadmin has to prescribe how\n  much swap is needed a priori, for each combination of\n  (memory size x disk space x workload usage). It is even more\n  complicated when we take into account the variance of memory\n  compression, which changes the reclaim dynamics (and as a result,\n  swap space size requirement). The problem is further exarcebated for\n  users who rely on swap utilization (and exhaustion) as an OOM signal.\n\n  All of these factors make it very difficult to configure the swapfile\n  for zswap: too small of a swapfile and we risk preventable OOMs and\n  limit the memory saving potentials of zswap; too big of a swapfile\n  and we waste disk space and memory due to swap metadata overhead.\n  This dilemma becomes more drastic in high memory systems, which can\n  have up to TBs worth of memory.\n\nPast attempts to decouple disk and compressed swap backends, namely the\nghost swapfile approach (see [13]), as well as the alternative\ncompressed swap backend zram, have mainly focused on eliminating the\ndisk space usage of compressed backends. We want a solution that not\nonly tackles that same problem, but also achieve the dyamicization of\nswap space to maximize the memory saving potentials while reducing\noperational and static memory overhead.\n\nFinally, any swap redesign should support efficient backend transfer,\ni.e without having to perform the expensive page table walk to\nupdate all the PTEs that refer to the swap entry:\n* The main motivation for this requirement is zswap writeback. To quote\n  Johannes (from [14]): \"Combining compression with disk swap is\n  extremely powerful, because it dramatically reduces the worst aspects\n  of both: it reduces the memory footprint of compression by shedding\n  the coldest data to disk; it reduces the IO latencies and flash wear\n  of disk swap through the writeback cache. In practice, this reduces\n  *average event rates of the entire reclaim/paging/IO stack*.\"\n* Another motivation is to simplify swapoff, which is both complicated\n  and expensive in the current design, precisely because we are storing\n  an encoding of the backend positional information in the page table,\n  and thus requires a full page table walk to remove these references.\n\n\nII. High Level Design Overview\n\nTo fix the aforementioned issues, we need an abstraction that separates\na swap entry from its physical backing storage. IOW, we need to\n\\u201cvirtualize\\u201d the swap space: swap clients will work with a dynamically\nallocated virtual swap slot, storing it in page table entries, and\nusing it to index into various swap-related data structures. The\nbacking storage is decoupled from the virtual swap slot, and the newly\nintroduced layer will \\u201cresolve\\u201d the virtual swap slot to the actual\nstorage. This layer also manages other metadata of the swap entry, such\nas its lifetime information (swap count), via a dynamically allocated,\nper-swap-entry descriptor:\n\nstruct swp_desc {\n        union {\n                swp_slot_t         slot;                 /*     0     8 */\n                struct zswap_entry * zswap_entry;        /*     0     8 */\n        };                                               /*     0     8 */\n        union {\n                struct folio *     swap_cache;           /*     8     8 */\n                void *             shadow;               /*     8     8 */\n        };                                               /*     8     8 */\n        unsigned int               swap_count;           /*    16     4 */\n        unsigned short             memcgid:16;           /*    20: 0  2 */\n        bool                       in_swapcache:1;       /*    22: 0  1 */\n\n        /* Bitfield combined with previous fields */\n\n        enum swap_type             type:2;               /*    20:17  4 */\n\n        /* size: 24, cachelines: 1, members: 6 */\n        /* bit_padding: 13 bits */\n        /* last cacheline: 24 bytes */\n};\n\n(output from pahole).\n\nThis design allows us to:\n* Decouple zswap (and zeromapped swap entry) from backing swapfile:\n  simply associate the virtual swap slot with one of the supported\n  backends: a zswap entry, a zero-filled swap page, a slot on the\n  swapfile, or an in-memory page.\n* Simplify and optimize swapoff: we only have to fault the page in and\n  have the virtual swap slot points to the page instead of the on-disk\n  physical swap slot. No need to perform any page table walking.\n\nThe size of the virtual swap descriptor is 24 bytes. Note that this is\nnot all \"new\" overhead, as the swap descriptor will replace:\n* the swap_cgroup arrays (one per swap type) in the old design, which\n  is a massive source of static memory overhead. With the new design,\n  it is only allocated for used clusters.\n* the swap tables, which holds the swap cache and workingset shadows.\n* the zeromap bitmap, which is a bitmap of physical swap slots to\n  indicate whether the swapped out page is zero-filled or not.\n* huge chunk of the swap_map. The swap_map is now replaced by 2 bitmaps,\n  one for allocated slots, and one for bad slots, representing 3 possible\n  states of a slot on the swapfile: allocated, free, and bad.\n* the zswap tree.\n\nSo, in terms of additional memory overhead:\n* For zswap entries, the added memory overhead is rather minimal. The\n  new indirection pointer neatly replaces the existing zswap tree.\n  We really only incur less than one word of overhead for swap count\n  blow up (since we no longer use swap continuation) and the swap type.\n* For physical swap entries, the new design will impose fewer than 3 words\n  memory overhead. However, as noted above this overhead is only for\n  actively used swap entries, whereas in the current design the overhead is\n  static (including the swap cgroup array for example).\n\n  The primary victim of this overhead will be zram users. However, as\n  zswap now no longer takes up disk space, zram users can consider\n  switching to zswap (which, as a bonus, has a lot of useful features\n  out of the box, such as cgroup tracking, dynamic zswap pool sizing,\n  LRU-ordering writeback, etc.).\n\nFor a more concrete example, suppose we have a 32 GB swapfile (i.e.\n8,388,608 swap entries), and we use zswap.\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 0.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 48.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 96.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 121.00 MB\n* Vswap total overhead: 144.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 153.00 MB\n* Vswap total overhead: 193.00 MB\n\nSo even in the worst case scenario for virtual swap, i.e when we\nsomehow have an oracle to correctly size the swapfile for zswap\npool to 32 GB, the added overhead is only 40 MB, which is a mere\n0.12% of the total swapfile :)\n\nIn practice, the overhead will be closer to the 50-75% usage case, as\nsystems tend to leave swap headroom for pathological events or sudden\nspikes in memory requirements. The added overhead in these cases are\npractically neglible. And in deployments where swapfiles for zswap\nare previously sparsely used, switching over to virtual swap will\nactually reduce memory overhead.\n\nDoing the same math for the disk swap, which is the worst case for\nvirtual swap in terms of swap backends:\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 2.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 41.00 MB\n* Vswap total overhead: 66.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 130.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 73.00 MB\n* Vswap total overhead: 194.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 259.00 MB\n\nThe added overhead is 170MB, which is 0.5% of the total swapfile size,\nagain in the worst case when we have a sizing oracle.\n\nPlease see the attached patches for more implementation details.\n\n\nIII. Usage and Benchmarking\n\nThis patch series introduce no new syscalls or userspace API. Existing\nuserspace setups will work as-is, except we no longer have to create a\nswapfile or set memory.swap.max if we want to use zswap, as zswap is no\nlonger tied to physical swap. The zswap pool will be automatically and\ndynamically sized based on memory usage and reclaim dynamics.\n\nTo measure the performance of the new implementation, I have run the\nfollowing benchmarks:\n\n1. Kernel building: 52 workers (one per processor), memory.max = 3G.\n\nUsing zswap as the backend:\n\nBaseline:\nreal: mean: 185.2s, stdev: 0.93s\nsys: mean: 683.7s, stdev: 33.77s\n\nVswap:\nreal: mean: 184.88s, stdev: 0.57s\nsys: mean: 675.14s, stdev: 32.8s\n\nWe actually see a slight improvement in systime (by 1.5%) :) This is\nlikely because we no longer have to perform swap charging for zswap\nentries, and virtual swap allocator is simpler than that of physical\nswap.\n\nUsing SSD swap as the backend:\n\nBaseline:\nreal: mean: 200.3s, stdev: 2.33s\nsys: mean: 489.88s, stdev: 9.62s\n\nVswap:\nreal: mean: 201.47s, stdev: 2.98s\nsys: mean: 487.36s, stdev: 5.53s\n\nThe performance is neck-to-neck.\n\n\nIV. Future Use Cases\n\nWhile the patch series focus on two applications (decoupling swap\nbackends and swapoff optimization/simplification), this new,\nfuture-proof design also allows us to implement new swap features more\neasily and efficiently:\n\n* Multi-tier swapping (as mentioned in [5]), with transparent\n  transferring (promotion/demotion) of pages across tiers (see [8] and\n  [9]). Similar to swapoff, with the old design we would need to\n  perform the expensive page table walk.\n* Swapfile compaction to alleviate fragmentation (as proposed by Ying\n  Huang in [6]).\n* Mixed backing THP swapin (see [7]): Once you have pinned down the\n  backing store of THPs, then you can dispatch each range of subpages\n  to appropriate backend swapin handler.\n* Swapping a folio out with discontiguous physical swap slots\n  (see [10]).\n* Zswap writeback optimization: The current architecture pre-reserves\n  physical swap space for pages when they enter the zswap pool, giving\n  the kernel no flexibility at writeback time. With the virtual swap\n  implementation, the backends are decoupled, and physical swap space\n  is allocated on-demand at writeback time, at which point we can make\n  much smarter decisions: we can batch multiple zswap writeback\n  operations into a single IO request, allocating contiguous physical\n  swap slots for that request. We can even perform compressed writeback\n  (i.e writing these pages without decompressing them) (see [12]).\n\n\nV. References\n\n[1]: https://lore.kernel.org/all/CAJD7tkbCnXJ95Qow_aOjNX6NOMU5ovMSHRC+95U4wtW6cM+puw@mail.gmail.com/\n[2]: https://lwn.net/Articles/932077/\n[3]: https://www.youtube.com/watch?v=Hwqw_TBGEhg\n[4]: https://lore.kernel.org/all/Zqe_Nab-Df1CN7iW@infradead.org/\n[5]: https://lore.kernel.org/lkml/CAF8kJuN-4UE0skVHvjUzpGefavkLULMonjgkXUZSBVJrcGFXCA@mail.gmail.com/\n[6]: https://lore.kernel.org/linux-mm/87o78mzp24.fsf@yhuang6-desk2.ccr.corp.intel.com/\n[7]: https://lore.kernel.org/all/CAGsJ_4ysCN6f7qt=6gvee1x3ttbOnifGneqcRm9Hoeun=uFQ2w@mail.gmail.com/\n[8]: https://lore.kernel.org/linux-mm/4DA25039.3020700@redhat.com/\n[9]: https://lore.kernel.org/all/CA+ZsKJ7DCE8PMOSaVmsmYZL9poxK6rn0gvVXbjpqxMwxS2C9TQ@mail.gmail.com/\n[10]: https://lore.kernel.org/all/CACePvbUkMYMencuKfpDqtG1Ej7LiUS87VRAXb8sBn1yANikEmQ@mail.gmail.com/\n[11]: https://lore.kernel.org/all/CAMgjq7BvQ0ZXvyLGp2YP96+i+6COCBBJCYmjXHGBnfisCAb8VA@mail.gmail.com/\n[12]: https://lore.kernel.org/linux-mm/ZeZSDLWwDed0CgT3@casper.infradead.org/\n[13]: https://lore.kernel.org/all/20251121-ghost-v1-1-cfc0efcf3855@kernel.org/\n[14]: https://lore.kernel.org/linux-mm/20251202170222.GD430226@cmpxchg.org/\n\nNhat Pham (20):\n  mm/swap: decouple swap cache from physical swap infrastructure\n  swap: rearrange the swap header file\n  mm: swap: add an abstract API for locking out swapoff\n  zswap: add new helpers for zswap entry operations\n  mm/swap: add a new function to check if a swap entry is in swap\n    cached.\n  mm: swap: add a separate type for physical swap slots\n  mm: create scaffolds for the new virtual swap implementation\n  zswap: prepare zswap for swap virtualization\n  mm: swap: allocate a virtual swap slot for each swapped out page\n  swap: move swap cache to virtual swap descriptor\n  zswap: move zswap entry management to the virtual swap descriptor\n  swap: implement the swap_cgroup API using virtual swap\n  swap: manage swap entry lifecycle at the virtual swap layer\n  mm: swap: decouple virtual swap slot from backing store\n  zswap: do not start zswap shrinker if there is no physical swap slots\n  swap: do not unnecesarily pin readahead swap entries\n  swapfile: remove zeromap bitmap\n  memcg: swap: only charge physical swap slots\n  swap: simplify swapoff using virtual swap\n  swapfile: replace the swap map with bitmaps\n\n Documentation/mm/swap-table.rst |   69 --\n MAINTAINERS                     |    2 +\n include/linux/cpuhotplug.h      |    1 +\n include/linux/mm_types.h        |   16 +\n include/linux/shmem_fs.h        |    7 +-\n include/linux/swap.h            |  135 ++-\n include/linux/swap_cgroup.h     |   13 -\n include/linux/swapops.h         |   25 +\n include/linux/zswap.h           |   17 +-\n kernel/power/swap.c             |    6 +-\n mm/Makefile                     |    5 +-\n mm/huge_memory.c                |   11 +-\n mm/internal.h                   |   12 +-\n mm/memcontrol-v1.c              |    6 +\n mm/memcontrol.c                 |  142 ++-\n mm/memory.c                     |  101 +-\n mm/migrate.c                    |   13 +-\n mm/mincore.c                    |   15 +-\n mm/page_io.c                    |   83 +-\n mm/shmem.c                      |  215 +---\n mm/swap.h                       |  157 +--\n mm/swap_cgroup.c                |  172 ---\n mm/swap_state.c                 |  306 +----\n mm/swap_table.h                 |   78 +-\n mm/swapfile.c                   | 1518 ++++-------------------\n mm/userfaultfd.c                |   18 +-\n mm/vmscan.c                     |   28 +-\n mm/vswap.c                      | 2025 +++++++++++++++++++++++++++++++\n mm/zswap.c                      |  142 +--\n 29 files changed, 2853 insertions(+), 2485 deletions(-)\n delete mode 100644 Documentation/mm/swap-table.rst\n delete mode 100644 mm/swap_cgroup.c\n create mode 100644 mm/vswap.c\n\n\nbase-commit: 05f7e89ab9731565d8a62e3b5d1ec206485eeb0b\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author apologized for a missing cover letter in their original patch series and explained that they are resending the first patch, which implements virtual swap space based on Yosry's proposals at LSFMMBPF 2023. They mentioned that lock contention issues have been resolved and performance is now on-par with baseline, but did not specifically address any feedback or concerns from reviewers.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "apology",
            "clarification"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "My sincerest apologies - it seems like the cover letter (and just the\ncover letter) fails to be sent out, for some reason. I'm trying to figure\nout what happened - it works when I send the entire patch series to\nmyself...\n\nAnyway, resending this (in-reply-to patch 1 of the series):\n\nChangelog:\n* RFC v2 -> v3:\n    * Implement a cluster-based allocation algorithm for virtual swap\n      slots, inspired by Kairui Song and Chris Li's implementation, as\n      well as Johannes Weiner's suggestions. This eliminates the lock\n\t  contention issues on the virtual swap layer.\n    * Re-use swap table for the reverse mapping.\n    * Remove CONFIG_VIRTUAL_SWAP.\n    * Reducing the size of the swap descriptor from 48 bytes to 24\n      bytes, i.e another 50% reduction in memory overhead from v2.\n    * Remove swap cache and zswap tree and use the swap descriptor\n      for this.\n    * Remove zeromap, and replace the swap_map bytemap with 2 bitmaps\n      (one for allocated slots, and one for bad slots).\n    * Rebase on top of 6.19 (7d0a66e4bb9081d75c82ec4957c50034cb0ea449)\n\t* Update cover letter to include new benchmark results and discussion\n\t  on overhead in various cases.\n* RFC v1 -> RFC v2:\n    * Use a single atomic type (swap_refs) for reference counting\n      purpose. This brings the size of the swap descriptor from 64 B\n      down to 48 B (25% reduction). Suggested by Yosry Ahmed.\n    * Zeromap bitmap is removed in the virtual swap implementation.\n      This saves one bit per phyiscal swapfile slot.\n    * Rearrange the patches and the code change to make things more\n      reviewable. Suggested by Johannes Weiner.\n    * Update the cover letter a bit.\n\nThis patch series implements the virtual swap space idea, based on Yosry's\nproposals at LSFMMBPF 2023 (see [1], [2], [3]), as well as valuable\ninputs from Johannes Weiner. The same idea (with different\nimplementation details) has been floated by Rik van Riel since at least\n2011 (see [8]).\n\nThis patch series is based on 6.19. There are a couple more\nswap-related changes in the mm-stable branch that I would need to\ncoordinate with, but I would like to send this out as an update, to show\nthat the lock contention issues that plagued earlier versions have been\nresolved and performance on the kernel build benchmark is now on-par with\nbaseline. Furthermore, memory overhead has been substantially reduced\ncompared to the last RFC version.\n\n\nI. Motivation\n\nCurrently, when an anon page is swapped out, a slot in a backing swap\ndevice is allocated and stored in the page table entries that refer to\nthe original page. This slot is also used as the \"key\" to find the\nswapped out content, as well as the index to swap data structures, such\nas the swap cache, or the swap cgroup mapping. Tying a swap entry to its\nbacking slot in this way is performant and efficient when swap is purely\njust disk space, and swapoff is rare.\n\nHowever, the advent of many swap optimizations has exposed major\ndrawbacks of this design. The first problem is that we occupy a physical\nslot in the swap space, even for pages that are NEVER expected to hit\nthe disk: pages compressed and stored in the zswap pool, zero-filled\npages, or pages rejected by both of these optimizations when zswap\nwriteback is disabled. This is the arguably central shortcoming of\nzswap:\n* In deployments when no disk space can be afforded for swap (such as\n  mobile and embedded devices), users cannot adopt zswap, and are forced\n  to use zram. This is confusing for users, and creates extra burdens\n  for developers, having to develop and maintain similar features for\n  two separate swap backends (writeback, cgroup charging, THP support,\n  etc.). For instance, see the discussion in [4].\n* Resource-wise, it is hugely wasteful in terms of disk usage. At Meta,\n  we have swapfile in the order of tens to hundreds of GBs, which are\n  mostly unused and only exist to enable zswap usage and zero-filled\n  pages swap optimizations.\n* Tying zswap (and more generally, other in-memory swap backends) to\n  the current physical swapfile infrastructure makes zswap implicitly\n  statically sized. This does not make sense, as unlike disk swap, in\n  which we consume a limited resource (disk space or swapfile space) to\n  save another resource (memory), zswap consume the same resource it is\n  saving (memory). The more we zswap, the more memory we have available,\n  not less. We are not rationing a limited resource when we limit\n  the size of he zswap pool, but rather we are capping the resource\n  (memory) saving potential of zswap. Under memory pressure, using\n  more zswap is almost always better than the alternative (disk IOs, or\n  even worse, OOMs), and dynamically sizing the zswap pool on demand\n  allows the system to flexibly respond to these precarious scenarios.\n* Operationally, static provisioning the swapfile for zswap pose\n  significant challenges, because the sysadmin has to prescribe how\n  much swap is needed a priori, for each combination of\n  (memory size x disk space x workload usage). It is even more\n  complicated when we take into account the variance of memory\n  compression, which changes the reclaim dynamics (and as a result,\n  swap space size requirement). The problem is further exarcebated for\n  users who rely on swap utilization (and exhaustion) as an OOM signal.\n\n  All of these factors make it very difficult to configure the swapfile\n  for zswap: too small of a swapfile and we risk preventable OOMs and\n  limit the memory saving potentials of zswap; too big of a swapfile\n  and we waste disk space and memory due to swap metadata overhead.\n  This dilemma becomes more drastic in high memory systems, which can\n  have up to TBs worth of memory.\n\nPast attempts to decouple disk and compressed swap backends, namely the\nghost swapfile approach (see [13]), as well as the alternative\ncompressed swap backend zram, have mainly focused on eliminating the\ndisk space usage of compressed backends. We want a solution that not\nonly tackles that same problem, but also achieve the dyamicization of\nswap space to maximize the memory saving potentials while reducing\noperational and static memory overhead.\n\nFinally, any swap redesign should support efficient backend transfer,\ni.e without having to perform the expensive page table walk to\nupdate all the PTEs that refer to the swap entry:\n* The main motivation for this requirement is zswap writeback. To quote\n  Johannes (from [14]): \"Combining compression with disk swap is\n  extremely powerful, because it dramatically reduces the worst aspects\n  of both: it reduces the memory footprint of compression by shedding\n  the coldest data to disk; it reduces the IO latencies and flash wear\n  of disk swap through the writeback cache. In practice, this reduces\n  *average event rates of the entire reclaim/paging/IO stack*.\"\n* Another motivation is to simplify swapoff, which is both complicated\n  and expensive in the current design, precisely because we are storing\n  an encoding of the backend positional information in the page table,\n  and thus requires a full page table walk to remove these references.\n\n\nII. High Level Design Overview\n\nTo fix the aforementioned issues, we need an abstraction that separates\na swap entry from its physical backing storage. IOW, we need to\n\\u201cvirtualize\\u201d the swap space: swap clients will work with a dynamically\nallocated virtual swap slot, storing it in page table entries, and\nusing it to index into various swap-related data structures. The\nbacking storage is decoupled from the virtual swap slot, and the newly\nintroduced layer will \\u201cresolve\\u201d the virtual swap slot to the actual\nstorage. This layer also manages other metadata of the swap entry, such\nas its lifetime information (swap count), via a dynamically allocated,\nper-swap-entry descriptor:\n\nstruct swp_desc {\n        union {\n                swp_slot_t         slot;                 /*     0     8 */\n                struct zswap_entry * zswap_entry;        /*     0     8 */\n        };                                               /*     0     8 */\n        union {\n                struct folio *     swap_cache;           /*     8     8 */\n                void *             shadow;               /*     8     8 */\n        };                                               /*     8     8 */\n        unsigned int               swap_count;           /*    16     4 */\n        unsigned short             memcgid:16;           /*    20: 0  2 */\n        bool                       in_swapcache:1;       /*    22: 0  1 */\n\n        /* Bitfield combined with previous fields */\n\n        enum swap_type             type:2;               /*    20:17  4 */\n\n        /* size: 24, cachelines: 1, members: 6 */\n        /* bit_padding: 13 bits */\n        /* last cacheline: 24 bytes */\n};\n\n(output from pahole).\n\nThis design allows us to:\n* Decouple zswap (and zeromapped swap entry) from backing swapfile:\n  simply associate the virtual swap slot with one of the supported\n  backends: a zswap entry, a zero-filled swap page, a slot on the\n  swapfile, or an in-memory page.\n* Simplify and optimize swapoff: we only have to fault the page in and\n  have the virtual swap slot points to the page instead of the on-disk\n  physical swap slot. No need to perform any page table walking.\n\nThe size of the virtual swap descriptor is 24 bytes. Note that this is\nnot all \"new\" overhead, as the swap descriptor will replace:\n* the swap_cgroup arrays (one per swap type) in the old design, which\n  is a massive source of static memory overhead. With the new design,\n  it is only allocated for used clusters.\n* the swap tables, which holds the swap cache and workingset shadows.\n* the zeromap bitmap, which is a bitmap of physical swap slots to\n  indicate whether the swapped out page is zero-filled or not.\n* huge chunk of the swap_map. The swap_map is now replaced by 2 bitmaps,\n  one for allocated slots, and one for bad slots, representing 3 possible\n  states of a slot on the swapfile: allocated, free, and bad.\n* the zswap tree.\n\nSo, in terms of additional memory overhead:\n* For zswap entries, the added memory overhead is rather minimal. The\n  new indirection pointer neatly replaces the existing zswap tree.\n  We really only incur less than one word of overhead for swap count\n  blow up (since we no longer use swap continuation) and the swap type.\n* For physical swap entries, the new design will impose fewer than 3 words\n  memory overhead. However, as noted above this overhead is only for\n  actively used swap entries, whereas in the current design the overhead is\n  static (including the swap cgroup array for example).\n\n  The primary victim of this overhead will be zram users. However, as\n  zswap now no longer takes up disk space, zram users can consider\n  switching to zswap (which, as a bonus, has a lot of useful features\n  out of the box, such as cgroup tracking, dynamic zswap pool sizing,\n  LRU-ordering writeback, etc.).\n\nFor a more concrete example, suppose we have a 32 GB swapfile (i.e.\n8,388,608 swap entries), and we use zswap.\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 0.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 48.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 96.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 121.00 MB\n* Vswap total overhead: 144.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 153.00 MB\n* Vswap total overhead: 193.00 MB\n\nSo even in the worst case scenario for virtual swap, i.e when we\nsomehow have an oracle to correctly size the swapfile for zswap\npool to 32 GB, the added overhead is only 40 MB, which is a mere\n0.12% of the total swapfile :)\n\nIn practice, the overhead will be closer to the 50-75% usage case, as\nsystems tend to leave swap headroom for pathological events or sudden\nspikes in memory requirements. The added overhead in these cases are\npractically neglible. And in deployments where swapfiles for zswap\nare previously sparsely used, switching over to virtual swap will\nactually reduce memory overhead.\n\nDoing the same math for the disk swap, which is the worst case for\nvirtual swap in terms of swap backends:\n\n0% usage, or 0 entries: 0.00 MB\n* Old design total overhead: 25.00 MB\n* Vswap total overhead: 2.00 MB\n\n25% usage, or 2,097,152 entries:\n* Old design total overhead: 41.00 MB\n* Vswap total overhead: 66.25 MB\n\n50% usage, or 4,194,304 entries:\n* Old design total overhead: 57.00 MB\n* Vswap total overhead: 130.50 MB\n\n75% usage, or 6,291,456 entries:\n* Old design total overhead: 73.00 MB\n* Vswap total overhead: 194.75 MB\n\n100% usage, or 8,388,608 entries:\n* Old design total overhead: 89.00 MB\n* Vswap total overhead: 259.00 MB\n\nThe added overhead is 170MB, which is 0.5% of the total swapfile size,\nagain in the worst case when we have a sizing oracle.\n\nPlease see the attached patches for more implementation details.\n\n\nIII. Usage and Benchmarking\n\nThis patch series introduce no new syscalls or userspace API. Existing\nuserspace setups will work as-is, except we no longer have to create a\nswapfile or set memory.swap.max if we want to use zswap, as zswap is no\nlonger tied to physical swap. The zswap pool will be automatically and\ndynamically sized based on memory usage and reclaim dynamics.\n\nTo measure the performance of the new implementation, I have run the\nfollowing benchmarks:\n\n1. Kernel building: 52 workers (one per processor), memory.max = 3G.\n\nUsing zswap as the backend:\n\nBaseline:\nreal: mean: 185.2s, stdev: 0.93s\nsys: mean: 683.7s, stdev: 33.77s\n\nVswap:\nreal: mean: 184.88s, stdev: 0.57s\nsys: mean: 675.14s, stdev: 32.8s\n\nWe actually see a slight improvement in systime (by 1.5%) :) This is\nlikely because we no longer have to perform swap charging for zswap\nentries, and virtual swap allocator is simpler than that of physical\nswap.\n\nUsing SSD swap as the backend:\n\nBaseline:\nreal: mean: 200.3s, stdev: 2.33s\nsys: mean: 489.88s, stdev: 9.62s\n\nVswap:\nreal: mean: 201.47s, stdev: 2.98s\nsys: mean: 487.36s, stdev: 5.53s\n\nThe performance is neck-to-neck.\n\n\nIV. Future Use Cases\n\nWhile the patch series focus on two applications (decoupling swap\nbackends and swapoff optimization/simplification), this new,\nfuture-proof design also allows us to implement new swap features more\neasily and efficiently:\n\n* Multi-tier swapping (as mentioned in [5]), with transparent\n  transferring (promotion/demotion) of pages across tiers (see [8] and\n  [9]). Similar to swapoff, with the old design we would need to\n  perform the expensive page table walk.\n* Swapfile compaction to alleviate fragmentation (as proposed by Ying\n  Huang in [6]).\n* Mixed backing THP swapin (see [7]): Once you have pinned down the\n  backing store of THPs, then you can dispatch each range of subpages\n  to appropriate backend swapin handler.\n* Swapping a folio out with discontiguous physical swap slots\n  (see [10]).\n* Zswap writeback optimization: The current architecture pre-reserves\n  physical swap space for pages when they enter the zswap pool, giving\n  the kernel no flexibility at writeback time. With the virtual swap\n  implementation, the backends are decoupled, and physical swap space\n  is allocated on-demand at writeback time, at which point we can make\n  much smarter decisions: we can batch multiple zswap writeback\n  operations into a single IO request, allocating contiguous physical\n  swap slots for that request. We can even perform compressed writeback\n  (i.e writing these pages without decompressing them) (see [12]).\n\n\nV. References\n\n[1]: https://lore.kernel.org/all/CAJD7tkbCnXJ95Qow_aOjNX6NOMU5ovMSHRC+95U4wtW6cM+puw@mail.gmail.com/\n[2]: https://lwn.net/Articles/932077/\n[3]: https://www.youtube.com/watch?v=Hwqw_TBGEhg\n[4]: https://lore.kernel.org/all/Zqe_Nab-Df1CN7iW@infradead.org/\n[5]: https://lore.kernel.org/lkml/CAF8kJuN-4UE0skVHvjUzpGefavkLULMonjgkXUZSBVJrcGFXCA@mail.gmail.com/\n[6]: https://lore.kernel.org/linux-mm/87o78mzp24.fsf@yhuang6-desk2.ccr.corp.intel.com/\n[7]: https://lore.kernel.org/all/CAGsJ_4ysCN6f7qt=6gvee1x3ttbOnifGneqcRm9Hoeun=uFQ2w@mail.gmail.com/\n[8]: https://lore.kernel.org/linux-mm/4DA25039.3020700@redhat.com/\n[9]: https://lore.kernel.org/all/CA+ZsKJ7DCE8PMOSaVmsmYZL9poxK6rn0gvVXbjpqxMwxS2C9TQ@mail.gmail.com/\n[10]: https://lore.kernel.org/all/CACePvbUkMYMencuKfpDqtG1Ej7LiUS87VRAXb8sBn1yANikEmQ@mail.gmail.com/\n[11]: https://lore.kernel.org/all/CAMgjq7BvQ0ZXvyLGp2YP96+i+6COCBBJCYmjXHGBnfisCAb8VA@mail.gmail.com/\n[12]: https://lore.kernel.org/linux-mm/ZeZSDLWwDed0CgT3@casper.infradead.org/\n[13]: https://lore.kernel.org/all/20251121-ghost-v1-1-cfc0efcf3855@kernel.org/\n[14]: https://lore.kernel.org/linux-mm/20251202170222.GD430226@cmpxchg.org/\n\nNhat Pham (20):\n  mm/swap: decouple swap cache from physical swap infrastructure\n  swap: rearrange the swap header file\n  mm: swap: add an abstract API for locking out swapoff\n  zswap: add new helpers for zswap entry operations\n  mm/swap: add a new function to check if a swap entry is in swap\n    cached.\n  mm: swap: add a separate type for physical swap slots\n  mm: create scaffolds for the new virtual swap implementation\n  zswap: prepare zswap for swap virtualization\n  mm: swap: allocate a virtual swap slot for each swapped out page\n  swap: move swap cache to virtual swap descriptor\n  zswap: move zswap entry management to the virtual swap descriptor\n  swap: implement the swap_cgroup API using virtual swap\n  swap: manage swap entry lifecycle at the virtual swap layer\n  mm: swap: decouple virtual swap slot from backing store\n  zswap: do not start zswap shrinker if there is no physical swap slots\n  swap: do not unnecesarily pin readahead swap entries\n  swapfile: remove zeromap bitmap\n  memcg: swap: only charge physical swap slots\n  swap: simplify swapoff using virtual swap\n  swapfile: replace the swap map with bitmaps\n\n Documentation/mm/swap-table.rst |   69 --\n MAINTAINERS                     |    2 +\n include/linux/cpuhotplug.h      |    1 +\n include/linux/mm_types.h        |   16 +\n include/linux/shmem_fs.h        |    7 +-\n include/linux/swap.h            |  135 ++-\n include/linux/swap_cgroup.h     |   13 -\n include/linux/swapops.h         |   25 +\n include/linux/zswap.h           |   17 +-\n kernel/power/swap.c             |    6 +-\n mm/Makefile                     |    5 +-\n mm/huge_memory.c                |   11 +-\n mm/internal.h                   |   12 +-\n mm/memcontrol-v1.c              |    6 +\n mm/memcontrol.c                 |  142 ++-\n mm/memory.c                     |  101 +-\n mm/migrate.c                    |   13 +-\n mm/mincore.c                    |   15 +-\n mm/page_io.c                    |   83 +-\n mm/shmem.c                      |  215 +---\n mm/swap.h                       |  157 +--\n mm/swap_cgroup.c                |  172 ---\n mm/swap_state.c                 |  306 +----\n mm/swap_table.h                 |   78 +-\n mm/swapfile.c                   | 1518 ++++-------------------\n mm/userfaultfd.c                |   18 +-\n mm/vmscan.c                     |   28 +-\n mm/vswap.c                      | 2025 +++++++++++++++++++++++++++++++\n mm/zswap.c                      |  142 +--\n 29 files changed, 2853 insertions(+), 2485 deletions(-)\n delete mode 100644 Documentation/mm/swap-table.rst\n delete mode 100644 mm/swap_cgroup.c\n create mode 100644 mm/vswap.c\n\n\nbase-commit: 05f7e89ab9731565d8a62e3b5d1ec206485eeb0b\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-08"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch addresses poor batching behavior in the vswap free path, which is a critical component of Linux's virtual memory management system. The issue arises when multiple pages are being swapped out simultaneously, causing inefficient use of system resources and leading to performance degradation. To fix this problem, the patch optimizes the vswap free path by improving how it handles page swapping, reducing contention between threads and minimizing the number of lock acquisitions. This is achieved through a combination of data structure modifications and synchronization improvements, ultimately resulting in better system responsiveness and reduced overhead."
    },
    "2026-02-09": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that vswap_free() acquires the per-vswap spinlock while holding the folio lock, creating a potential deadlock with reclaim paths, and requested the lock be dropped before calling try_to_unmap().",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "potential deadlock",
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "For the record I did receive your original V3 cover letter from the\nlinux-mm mailing list.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-09"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li questioned the increased overhead of the per-swap slot entry in Nhat Pham's patch, pointing out that it jumps from 8 to 24 bytes, which he considers an unnecessary price compared to alternative implementations.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Is the per swap slot entry overhead 24 bytes in your implementation?\nThe current swap overhead is 3 static +8 dynamic, your 24 dynamic is a\nbig jump. You can argue that 8->24 is not a big jump . But it is an\nunnecessary price compared to the alternatives, which is 8 dynamic +\n4(optional redirect).",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-09"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li reported a compile error on Fedora 43, specifically an initialization from pointer to non-enclosed address space error in mm/vswap.c due to the use of local_lock() macro, and requested that the patch author mention this issue in their series description.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "compile_error",
            "requested_changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Ah, you need to mention that in the first line to Andrew. Spell out\nthis series is not for Andrew to consume in the MM series. It can't\nany way because it does not apply to mm-unstable nor mm-stable.\n\nBTW, I have the following compile error with this series (fedora 43).\nSame config compile fine on v6.19.\n\nIn file included from ./include/linux/local_lock.h:5,\n                 from ./include/linux/mmzone.h:24,\n                 from ./include/linux/gfp.h:7,\n                 from ./include/linux/mm.h:7,\n                 from mm/vswap.c:7:\nmm/vswap.c: In function vswap_cpu_dead:\n./include/linux/percpu-defs.h:221:45: error: initialization from\npointer to non-enclosed address space\n  221 |         const void __percpu *__vpp_verify = (typeof((ptr) +\n0))NULL;    \\\n      |                                             ^\n./include/linux/local_lock_internal.h:105:40: note: in definition of\nmacro __local_lock_acquire\n  105 |                 __l = (local_lock_t *)(lock);\n         \\\n      |                                        ^~~~\n./include/linux/local_lock.h:17:41: note: in expansion of macro\n__local_lock\n   17 | #define local_lock(lock)                __local_lock(this_cpu_ptr(lock))\n      |                                         ^~~~~~~~~~~~\n./include/linux/percpu-defs.h:245:9: note: in expansion of macro\n__verify_pcpu_ptr\n  245 |         __verify_pcpu_ptr(ptr);\n         \\\n      |         ^~~~~~~~~~~~~~~~~\n./include/linux/percpu-defs.h:256:27: note: in expansion of macro raw_cpu_ptr\n  256 | #define this_cpu_ptr(ptr) raw_cpu_ptr(ptr)\n      |                           ^~~~~~~~~~~\n./include/linux/local_lock.h:17:54: note: in expansion of macro\nthis_cpu_ptr\n   17 | #define local_lock(lock)\n__local_lock(this_cpu_ptr(lock))\n      |\n^~~~~~~~~~~~\nmm/vswap.c:1518:9: note: in expansion of macro local_lock\n 1518 |         local_lock(&percpu_cluster->lock);\n      |         ^~~~~~~~~~",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-09"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li requested additional information on user space time to provide a more comprehensive understanding of the patch's performance, specifically asking for the number of runs and standard deviation (stdev) for a specific value.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "request_for_additional_info"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Can you show your user space time as well to complete the picture?\n\nHow many runs do you have for stdev 32.8s?",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-09"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li requested that the patch also include swap test data for zram, which is used by Android for swapping.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested additional test data"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Please include zram swap test data as well. Android heavily uses zram\nfor swapping.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-09"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li suspects performance differences in the patch, specifically regarding swap testing and the need for others to confirm the results under stressful conditions near the OOM limit.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "performance",
            "OOM"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I strongly suspect there is some performance difference that hasn't\nbeen covered by your test yet. Need more conformation by others on the\nperformance measurement. The swap testing is tricky. You want to push\nto stress barely within the OOM limit. Need more data.\n\nChris",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-09"
        },
        {
          "author": "Johannes Weiner",
          "summary": "reviewer noted that vswap_free() acquires the per-vswap spinlock while holding the folio lock, creating a potential deadlock with reclaim paths, and requested the lock be dropped before calling try_to_unmap()",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "potential deadlock",
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi Chris,\n\nOn Mon, Feb 09, 2026 at 04:20:21AM -0800, Chris Li wrote:",
          "reply_to": "Chris Li",
          "message_date": "2026-02-09"
        },
        {
          "author": "Johannes Weiner",
          "summary": "Reviewer Johannes Weiner noted that the patch description's claim about reducing net overhead is incorrect, and provided a detailed breakdown of how the descriptor consolidates and eliminates other data structures.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested correction",
            "provided alternative explanation"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "No, this is not the net overhead.\n\nThe descriptor consolidates and eliminates several other data\nstructures.\n\nHere is the more detailed breakdown:",
          "reply_to": "Chris Li",
          "message_date": "2026-02-09"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch addresses poor batching behavior in the vswap free path, which is a critical component of Linux's virtual memory management system. The issue arises when multiple pages are being swapped out simultaneously, causing inefficient use of system resources and leading to performance degradation. To fix this problem, the patch optimizes the vswap free path by improving how it handles page swapping, reducing contention between threads and minimizing the number of lock acquisitions. This is achieved through a combination of data structure modifications and synchronization improvements, ultimately resulting in better system responsiveness and reduced overhead."
    },
    "2026-02-10": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Dan Carpenter",
          "summary": "The reviewer, Dan Carpenter, pointed out a potential bug in the vswap_alloc_swap_slot() function where the folio pointer is dereferenced before being checked for NULL. The issue arises from the fact that the function tries to access the swap entry of the folio without first checking if it's valid.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "bug",
            "potential issue"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi Nhat,\n\nkernel test robot noticed the following build warnings:\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Nhat-Pham/mm-swap-decouple-swap-cache-from-physical-swap-infrastructure/20260209-120606\nbase:   05f7e89ab9731565d8a62e3b5d1ec206485eeb0b\npatch link:    https://lore.kernel.org/r/20260208215839.87595-15-nphamcs%40gmail.com\npatch subject: [PATCH v3 14/20] mm: swap: decouple virtual swap slot from backing store\nconfig: powerpc-randconfig-r073-20260209 (https://download.01.org/0day-ci/archive/20260209/202602092300.lZO4Ee4N-lkp@intel.com/config)\ncompiler: powerpc-linux-gcc (GCC) 15.2.0\nsmatch version: v0.5.0-8994-gd50c5a4c\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Reported-by: Dan Carpenter <dan.carpenter@linaro.org>\n| Closes: https://lore.kernel.org/r/202602092300.lZO4Ee4N-lkp@intel.com/\n\nsmatch warnings:\nmm/vswap.c:733 vswap_alloc_swap_slot() warn: variable dereferenced before check 'folio' (see line 701)\n\nvim +/folio +733 mm/vswap.c\n\n19a5fe94e9aae4 Nhat Pham 2026-02-08  694  bool vswap_alloc_swap_slot(struct folio *folio)\n19a5fe94e9aae4 Nhat Pham 2026-02-08  695  {\n19a5fe94e9aae4 Nhat Pham 2026-02-08  696  \tint i, nr = folio_nr_pages(folio);\n19a5fe94e9aae4 Nhat Pham 2026-02-08  697  \tstruct vswap_cluster *cluster = NULL;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  698  \tstruct swap_info_struct *si;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  699  \tstruct swap_cluster_info *ci;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  700  \tswp_slot_t slot = { .val = 0 };\n19a5fe94e9aae4 Nhat Pham 2026-02-08 @701  \tswp_entry_t entry = folio->swap;\n\nfolio dereference here\n\n19a5fe94e9aae4 Nhat Pham 2026-02-08  702  \tstruct swp_desc *desc;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  703  \tbool fallback = false;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  704  \n19a5fe94e9aae4 Nhat Pham 2026-02-08  705  \t/*\n19a5fe94e9aae4 Nhat Pham 2026-02-08  706  \t * We might have already allocated a backing physical swap slot in past\n19a5fe94e9aae4 Nhat Pham 2026-02-08  707  \t * attempts (for instance, when we disable zswap). If the entire range is\n19a5fe94e9aae4 Nhat Pham 2026-02-08  708  \t * already swapfile-backed we can skip swapfile case.\n19a5fe94e9aae4 Nhat Pham 2026-02-08  709  \t */\n19a5fe94e9aae4 Nhat Pham 2026-02-08  710  \tif (vswap_swapfile_backed(entry, nr))\n19a5fe94e9aae4 Nhat Pham 2026-02-08  711  \t\treturn true;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  712  \n19a5fe94e9aae4 Nhat Pham 2026-02-08  713  \tif (swap_slot_alloc(&slot, folio_order(folio)))\n\nand here\n\n19a5fe94e9aae4 Nhat Pham 2026-02-08  714  \t\treturn false;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  715  \n19a5fe94e9aae4 Nhat Pham 2026-02-08  716  \tif (!slot.val)\n19a5fe94e9aae4 Nhat Pham 2026-02-08  717  \t\treturn false;\n19a5fe94e9aae4 Nhat Pham 2026-02-08  718  \n7f88e3ea20f231 Nhat Pham 2026-02-08  719  \t/* establish the vrtual <-> physical swap slots linkages. */\n7f88e3ea20f231 Nhat Pham 2026-02-08  720  \tsi = __swap_slot_to_info(slot);\n7f88e3ea20f231 Nhat Pham 2026-02-08  721  \tci = swap_cluster_lock(si, swp_slot_offset(slot));\n7f88e3ea20f231 Nhat Pham 2026-02-08  722  \tvswap_rmap_set(ci, slot, entry.val, nr);\n7f88e3ea20f231 Nhat Pham 2026-02-08  723  \tswap_cluster_unlock(ci);\n7f88e3ea20f231 Nhat Pham 2026-02-08  724  \n7f88e3ea20f231 Nhat Pham 2026-02-08  725  \trcu_read_lock();\n7f88e3ea20f231 Nhat Pham 2026-02-08  726  \tfor (i = 0; i < nr; i++) {\n7f88e3ea20f231 Nhat Pham 2026-02-08  727  \t\tdesc = vswap_iter(&cluster, entry.val + i);\n7f88e3ea20f231 Nhat Pham 2026-02-08  728  \t\tVM_WARN_ON(!desc);\n7f88e3ea20f231 Nhat Pham 2026-02-08  729  \n19a5fe94e9aae4 Nhat Pham 2026-02-08  730  \t\tif (desc->type == VSWAP_FOLIO) {\n19a5fe94e9aae4 Nhat Pham 2026-02-08  731  \t\t\t/* case 1: fallback from zswap store failure */\n19a5fe94e9aae4 Nhat Pham 2026-02-08  732  \t\t\tfallback = true;\n19a5fe94e9aae4 Nhat Pham 2026-02-08 @733  \t\t\tif (!folio)\n\nSo it can't be NULL here.\n\n19a5fe94e9aae4 Nhat Pham 2026-02-08  734  \t\t\t\tfolio = desc->swap_cache;\n\nSo we'll never do this assignment and it will never become NULL.\n\n19a5fe94e9aae4 Nhat Pham 2026-02-08  735  \t\t\telse\n19a5fe94e9aae4 Nhat Pham 2026-02-08  736  \t\t\t\tVM_WARN_ON(folio != desc->swap_cache);\n19a5fe94e9aae4 Nhat Pham 2026-02-08  737  \t\t} else {\n19a5fe94e9aae4 Nhat Pham 2026-02-08  738  \t\t\t/*\n19a5fe94e9aae4 Nhat Pham 2026-02-08  739  \t\t\t * Case 2: zswap writeback.\n19a5fe94e9aae4 Nhat Pham 2026-02-08  740  \t\t\t *\n19a5fe94e9aae4 Nhat Pham 2026-02-08  741  \t\t\t * No need to free zswap entry here - it will be freed once zswap\n19a5fe94e9aae4 Nhat Pham 2026-02-08  742  \t\t\t * writeback suceeds.\n19a5fe94e9aae4 Nhat Pham 2026-02-08  743  \t\t\t */\n19a5fe94e9aae4 Nhat Pham 2026-02-08  744  \t\t\tVM_WARN_ON(desc->type != VSWAP_ZSWAP);\n19a5fe94e9aae4 Nhat Pham 2026-02-08  745  \t\t\tVM_WARN_ON(fallback);\n19a5fe94e9aae4 Nhat Pham 2026-02-08  746  \t\t}\n19a5fe94e9aae4 Nhat Pham 2026-02-08  747  \t\tdesc->type = VSWAP_SWAPFILE;\n7f88e3ea20f231 Nhat Pham 2026-02-08  748  \t\tdesc->slot.val = slot.val + i;\n7f88e3ea20f231 Nhat Pham 2026-02-08  749  \t}\n7f88e3ea20f231 Nhat Pham 2026-02-08  750  \tspin_unlock(&cluster->lock);\n7f88e3ea20f231 Nhat Pham 2026-02-08  751  \trcu_read_unlock();\n19a5fe94e9aae4 Nhat Pham 2026-02-08  752  \treturn true;\n7f88e3ea20f231 Nhat Pham 2026-02-08  753  }\n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        },
        {
          "author": "syzbot ci",
          "summary": "The reviewer detected a possible deadlock in the vswap_iter function due to the acquisition of the per-vswap spinlock while holding the folio lock, creating a lock ordering violation with reclaim paths.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "deadlock",
            "lock ordering violation"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Tested-by"
          ],
          "analysis_source": "llm",
          "raw_body": "syzbot ci has tested the following series\n\n[v3] Virtual Swap Space\nhttps://lore.kernel.org/all/20260208215839.87595-1-nphamcs@gmail.com\n* [PATCH v3 01/20] mm/swap: decouple swap cache from physical swap infrastructure\n* [PATCH v3 02/20] swap: rearrange the swap header file\n* [PATCH v3 03/20] mm: swap: add an abstract API for locking out swapoff\n* [PATCH v3 04/20] zswap: add new helpers for zswap entry operations\n* [PATCH v3 05/20] mm/swap: add a new function to check if a swap entry is in swap cached.\n* [PATCH v3 06/20] mm: swap: add a separate type for physical swap slots\n* [PATCH v3 07/20] mm: create scaffolds for the new virtual swap implementation\n* [PATCH v3 08/20] zswap: prepare zswap for swap virtualization\n* [PATCH v3 09/20] mm: swap: allocate a virtual swap slot for each swapped out page\n* [PATCH v3 10/20] swap: move swap cache to virtual swap descriptor\n* [PATCH v3 11/20] zswap: move zswap entry management to the virtual swap descriptor\n* [PATCH v3 12/20] swap: implement the swap_cgroup API using virtual swap\n* [PATCH v3 13/20] swap: manage swap entry lifecycle at the virtual swap layer\n* [PATCH v3 14/20] mm: swap: decouple virtual swap slot from backing store\n* [PATCH v3 15/20] zswap: do not start zswap shrinker if there is no physical swap slots\n* [PATCH v3 16/20] swap: do not unnecesarily pin readahead swap entries\n* [PATCH v3 17/20] swapfile: remove zeromap bitmap\n* [PATCH v3 18/20] memcg: swap: only charge physical swap slots\n* [PATCH v3 19/20] swap: simplify swapoff using virtual swap\n* [PATCH v3 20/20] swapfile: replace the swap map with bitmaps\n\nand found the following issue:\npossible deadlock in vswap_iter\n\nFull report is available here:\nhttps://ci.syzbot.org/series/b9defda6-daec-4c41-bbf9-7d3b7fabd7cb\n\n***\n\npossible deadlock in vswap_iter\n\ntree:      bpf\nURL:       https://kernel.googlesource.com/pub/scm/linux/kernel/git/bpf/bpf.git\nbase:      05f7e89ab9731565d8a62e3b5d1ec206485eeb0b\narch:      amd64\ncompiler:  Debian clang version 21.1.8 (++20251221033036+2078da43e25a-1~exp1~20251221153213.50), Debian LLD 21.1.8\nconfig:    https://ci.syzbot.org/builds/f444cfbe-4ce0-4917-94aa-3a8bd96ee376/config\nC repro:   https://ci.syzbot.org/findings/7b8c50b1-47d6-42e0-bcfc-814e7b3bb596/c_repro\nsyz repro: https://ci.syzbot.org/findings/7b8c50b1-47d6-42e0-bcfc-814e7b3bb596/syz_repro\n\nloop0: detected capacity change from 0 to 764\n============================================\nWARNING: possible recursive locking detected\nsyzkaller #0 Not tainted\n--------------------------------------------\nsyz-executor625/5806 is trying to acquire lock:\nffff88811884c018 (&cluster->lock){+.+.}-{3:3}, at: spin_lock include/linux/spinlock.h:351 [inline]\nffff88811884c018 (&cluster->lock){+.+.}-{3:3}, at: vswap_iter+0xfa/0x1b0 mm/vswap.c:274\n\nbut task is already holding lock:\nffff88811884c018 (&cluster->lock){+.+.}-{3:3}, at: spin_lock_irq include/linux/spinlock.h:376 [inline]\nffff88811884c018 (&cluster->lock){+.+.}-{3:3}, at: swap_cache_lock_irq+0xe2/0x190 mm/vswap.c:1586\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(&cluster->lock);\n  lock(&cluster->lock);\n\n *** DEADLOCK ***\n\n May be due to missing lock nesting notation\n\n3 locks held by syz-executor625/5806:\n #0: ffff888174bc2800 (&mm->mmap_lock){++++}-{4:4}, at: mmap_read_lock include/linux/mmap_lock.h:391 [inline]\n #0: ffff888174bc2800 (&mm->mmap_lock){++++}-{4:4}, at: madvise_lock+0x152/0x2e0 mm/madvise.c:1789\n #1: ffff88811884c018 (&cluster->lock){+.+.}-{3:3}, at: spin_lock_irq include/linux/spinlock.h:376 [inline]\n #1: ffff88811884c018 (&cluster->lock){+.+.}-{3:3}, at: swap_cache_lock_irq+0xe2/0x190 mm/vswap.c:1586\n #2: ffffffff8e55a360 (rcu_read_lock){....}-{1:3}, at: rcu_lock_acquire include/linux/rcupdate.h:331 [inline]\n #2: ffffffff8e55a360 (rcu_read_lock){....}-{1:3}, at: rcu_read_lock include/linux/rcupdate.h:867 [inline]\n #2: ffffffff8e55a360 (rcu_read_lock){....}-{1:3}, at: vswap_cgroup_record+0x40/0x290 mm/vswap.c:1925\n\nstack backtrace:\n\n\n***\n\nIf these findings have caused you to resend the series or submit a\nseparate fix, please add the following tag to your commit message:\n  Tested-by: syzbot@syzkaller.appspotmail.com\n\n---\nThis report is generated by a bot. It may contain errors.\nsyzbot ci engineers can be reached at syzkaller@googlegroups.com.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author acknowledged that the patch series did not appear on lore or reach their coworkers, attributed it to a delay in sending emails from Gmail, and promised to be more patient in the future.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledgment of issue",
            "promise to improve"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I have no idea what happened to be honest. It did not show up on lore\nfor a couple of hours, and my coworkers did not receive the cover\nletter email initially. I did not receive any error message or logs\neither - git send-email returns Success to me, and when I checked on\nthe web gmail client (since I used a gmail email account), the whole\nseries is there.\n\nI tried re-sending a couple times, to no avail. Then, in a couple of\nhours, all of these attempts showed up.\n\nAnyway, this is my bad - I'll be more patient next time. If it does\nnot show up for a couple of hours then I'll do some more digging.",
          "reply_to": "Chris Li",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged a mistake in an old patch version's cover letter and promised to correct it in future versions.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged a mistake",
            "promised to correct"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Oh yeah I forgot to update that. That was from an old cover letter of\nan old version that never got sent out - I'll correct that in future\nversions\n\n(if you scroll down to the bottom of the cover letter you should see\nthe correct base, which should be 6.19).",
          "reply_to": "Chris Li",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged a potential compilation issue and asked reviewer to share their configurations so they can reproduce and fix it.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged a potential issue",
            "asked for clarification"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Ah that's strange. It compiled on all of my setups (I tested with a couple\ndifferent ones), but I must have missed some cases. Would you mind\nsharing your configs so that I can reproduce this compilation error?\n\n(although I'm sure kernel test robot will scream at me soon, which\nusually includes configs that cause the compilation issue).",
          "reply_to": "Chris Li",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author is addressing a concern about inconsistent timing metrics in the patch description. They acknowledge that user time was previously included but have since removed it, citing industry practice of only including system time. The author promises to include real-time numbers in future versions.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledgment",
            "clarification"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Will do next time! I used to include user time as well, but I noticed\nthat folks (for e.g see [1]) only include systime, not even real time,\nso I figure nobody cares about user time :)\n\n(I still include real time because some of my past work improves sys\ntime but regresses real time, so I figure that's relevant).\n\n[1]: https://lore.kernel.org/linux-mm/20260128-swap-table-p3-v2-0-fe0b67ef0215@tencent.com/\n\nBut yeah no big deal. I'll dig through my logs to see if I still have\nthe numbers, but if not I'll include it in next version.",
          "reply_to": "Chris Li",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged a concern about lock contention and performance issues, agreed to include swap activity stats in future versions, and plans to address the issue by restructuring the code.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a concern",
            "plans to address"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Very fair point :) I will say though - the kernel build test, with\nmemory.max limit sets, does generate a sizable amount of swapping, and\ndoes OOM if you don't set up swap. Take my words for now, but I will\ntry to include average per-run (z)swap activity stats (zswpout zswpin\netc.) in future versions if you're interested :)\n\nI've been trying to running more stress tests to trigger crashes and\nperformance regression. One of the big reasons why I haven't sent\nanything til now is to fix obvious performance issues (the\naforementioned lock contention) and bugs. It's a complicated piece of\nwork.\n\nAs always, would love to receive code/design feedback from you (and\nKairui, and other swap reviewers), and I would appreciate very much if\nother swap folks can play with the patch series on their setup as well\nfor performance testing, or let me know if there is any particular\ncase that they're interested in :)\n\nThanks for your review, Chris!",
          "reply_to": "Chris Li",
          "message_date": "2026-02-10"
        },
        {
          "author": "Johannes Weiner",
          "summary": "reviewer noted that vswap_free() acquires the per-vswap spinlock while holding the folio lock, creating a potential deadlock with reclaim paths, and requested the lock be dropped before calling try_to_unmap()",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "potential deadlock",
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hello Kairui,\n\nOn Wed, Feb 11, 2026 at 01:59:34AM +0800, Kairui Song wrote:",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Johannes Weiner",
          "summary": "Reviewer noted that vswap_free() acquires the per-vswap spinlock while holding the folio lock, creating a potential deadlock issue.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "potential deadlock"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Yeah, it turns out we need the same data points to describe and track\na swapped out page ;)",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Johannes Weiner",
          "summary": "reviewer pointed out that the patch's focus on addressing swap cache issues may be missing the key problem of address space separation, and suggested re-evaluating the comparisons made in the regression reports",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "The issue is address space separation. We don't want things inside the\ncompressed pool to consume disk space; nor do we want entries that\nlive on disk to take usable space away from the compressed pool.\n\nThe regression reports are fair, thanks for highlighting those. And\nwhether to make this optional is also a fair discussion.\n\nBut some of the numbers comparisons really strike me as apples to\noranges comparisons. It seems to miss the core issue this series is\ntrying to address.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Johannes Weiner",
          "summary": "Johannes Weiner questioned the necessity of try_to_unuse() scans in the vswap free path, suggesting that they are expensive and unnecessary if a fast swapoff read sequence with lazy minor faults is implemented.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "That seems very academic to me. The goal is to relinquish disk space,\nand these patches make that a lot faster.\n\nLet's put it the other way round: if today we had a fast swapoff read\nsequence with lazy minor faults to resolve page tables, would we\naccept patches that implement the expensive try_to_unuse() scans and\nmake it mandatory? Considering the worst-case runtime it can cause?\n\nI don't think so. We have this scan because the page table references\nare pointing to disk slots, and this is the only way to free them.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Johannes Weiner",
          "summary": "Reviewer Johannes Weiner noted that vswap_free() cannot drop the disk slot while the swp_entry_t is still in circulation, creating a potential issue.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "potential issue",
            "cannot drop"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "How can you relinquish the disk slot as long as the swp_entry_t is in\ncirculation?",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledges that maintaining two swap implementations would make the patch series unreadable, unreviewable, and unmaintainable, but does not commit to a single implementation.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledges maintenance challenges",
            "does not commit to a single implementation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Ideally, if we can close the performance gap and have only one\nversion, then that would be the best :)\n\nProblem with making it optional, or maintaining effectively two swap\nimplementations, is that it will make the patch series unreadable and\nunreviewable, and the code base unmaintanable :) You'll have x2 the\namount of code to reason about and test, much more merge conflicts at\nrebase and cherry-pick time. And any improvement to one version takes\nextra work to graft onto the other version.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged Kairui Song's feedback on swap table format, confirmed they like it, and clarified their patch series' goal is not to remove the design but to separate physical and virtual swaps for new use cases.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged",
            "confirmed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "There's nothing wrong with that ;)\n\nI like the swap table format (and your cluster-based swap allocator) a\nlot. This patch series does not aim to remove that design - I just\nwant to separate the address space of physical and virtual swaps to\nenable new use cases...",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author acknowledged that poor batching behavior in the vswap free path is a real production issue, citing varying server and service characteristics that make static sizing of swap files operationally impossible.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a problem",
            "agreed to address it"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I mean, it is a real production issue :) We have a variety of server\nmachines and services. Each of the former has its own memory and drive\nsize. Each of the latter has its own access characteristics,\ncompressibility, latency tolerance (and hence would prefer a different\nswapping solutions - zswap, disk swap, zswap x disk swap). Coupled\nwith the fact that now multiple services can cooccur on one host, and\none services can be deployed on different kinds of hosts, statically\nsizing the swapfile becomes operationally impossible and leaves a lot\nof wins on the table. So swap space has to be dynamic.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that dynamic growth of swap files is a missing feature and expressed skepticism about the current design, but did not commit to revising it.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "skepticism",
            "acknowledgment"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "By \"dynamic growth of swap files\", do you mean dynamically adjusting\nthe size of the swapfile? then that capacity does not exist right now,\nand I don't see a good design laid out for it... At the very least,\nthe swap allocator needs to be dynamic in nature. I assume it's going\nto look something very similar to vswap's current attempt, which\nrelies on a tree structure (radix tree i.e xarray). Sounds familiar?\n;)\n\nI feel like each of the problem I mention in this cover letter can be\nsolved partially with some amount of hacks, but none of them will\nsolve it all. And once you slaps all the hacks together, you just get\nvirtual swap, potentially shoved within specific backend codebase\n(zswap or zram). That's not... ideal.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author responded to Kairui Song's feedback that the patch still locks the swap device in place, explaining that page table entries refer to slots on the physical swap device and cannot be freed without locking.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no clear resolution signal",
            "author provided explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I don't understand your point regarding the \"reading everything into\nswap cache\". Yes, you can do that, but you would still lock the swap\ndevice in place, because the page table entries still refer to slots\non the physical swap device - you cannot free the swap device, nor\nspace on disk, not even the swapfile's metadata (especially since the\nswap cache is now intertwined with the physical swap layer).",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that their patch was based on an older kernel version and suggested incorporating recent swap cache changes into their work, but did not commit to revising the patch.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged prior version",
            "suggested incorporation of new features"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Yeah this was based on 6.19, which did not have your swap cache change yet :)\n\nI have taken a look at your latest swap table work in mm-stable, and I\nthink most of that can conceptually incorporated in to this line of\nwork as well.\n\nChiefly, the new swap cache synchronization scheme (i.e whoever puts\nthe folio in swap cache first gets exclusive rights) still works in\nvirtual swap world (and hence, the removal of swap cache pin, which is\none bit in the virtual swap descriptor).\n\nSimilarly, do you think we cannot hold the folio lock in place of the\ncluster lock in the virtual swap world? Same for a lot of the memory\noverhead reduction tricks (such as using shadow for cgroup id instead\nof a separate swap_cgroup unsigned short field). I think comparing the\ntwo this way is a bit apples-to-oranges (especially given the new\nfeatures enabled by vswap).\n\n[...]",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledges a need for further review and debugging of the vswap free path, but does not explicitly state that they will rework or revise the patch.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledges need for further review",
            "willing to help debug"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Side note - I might have missed this. If it's still ongoing, would\nlove to help debug this :)",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that the vswap free path can merge several swap operations, eliminating the need for release-then-reacquire of swap locks, but noted this as a side point to their main goal of enabling new features.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged a technical detail",
            "emphasized primary goals"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Ah yeah that too. I neglected to mention this, but with vswap you can\nmerge several swap operations in zswap code path and no longer have to\nrelease-then-reacquire the swap locks, since zswap entries live in the\nsame lock scope as swap cache entries.\n\nIt's more of a side note either way, because my main goal with this\npatch series is to enable new features. Getting a performance win is\nalways nice of course :)",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author responded to reviewer feedback about poor batching behavior in vswap free path, stating that they ran kernel build with disk swapping and saw performance on par with baseline, but questioned whether concurrency difference was the cause of discrepancy.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "questioning",
            "lack of clear resolution"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Hmm this one I don't think I can reproduce without your laptop ;)\n\nJokes aside, I did try to run the kernel build with disk swapping, and\nthe performance is on par with baseline. Swap performance with NVME\nswap tends to be dominated by IO work in my experiments. Do you think\nI missed something here? Maybe it's the concurrency difference (since\nI always run with -j$(nproc), i.e the number of workers == the number\nof processors).",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged a need for further testing and reproduction of reported issues, specifically starting with the 'usemem' case.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged need for further testing",
            "will start with usemem"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I'll see if I can reproduce the issues! I'll start with usemem one\nfirst, as that seems easier to reproduce...",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledges the potential issue as a 'non-crashing bug' and agrees to review the provided test case before deciding on a fix.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledges potential issue",
            "agrees to study test case"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "It could be a non-crashing bug that subtly regresses certain swap\noperations, but yeah let me study your test case first!",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that IO wait times are a concern in production systems and emphasized their importance when using disk swapping.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged",
            "emphasized"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Ah I just noticed that your numbers include only systime. Ignore my IO\ncomments then.\n\n(I still think in real production system, with disk swapping enabled,\nthen IO wait time is going to be really important. If you're going to\nuse disk swap, then this affects real time just as much if not more\nthan kernel CPU overhead).",
          "reply_to": "",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the patch does not address the batching behavior of vswap free path, which can lead to poor performance and requested additional work to fix this issue.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested additional work",
            "poor performance"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Hi Johannes,\n\nOn Mon, Feb 9, 2026 at 6:36PM Johannes Weiner <hannes@cmpxchg.org> wrote:",
          "reply_to": "Johannes Weiner",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the patch adds new members to existing structures and increases their size, specifically mentioning the change from a 1-byte swap_map to a 4-byte count.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "patch size increase",
            "structural changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Adding members previously not there and making some members bigger\nalong the way. For example, the swap_map from 1 byte to a 4 byte\ncount.",
          "reply_to": "Johannes Weiner",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the patch increased the total per-swap entry overhead to 24 bytes, and requested confirmation on whether this is the correct number for virtual swap (VS) if he disagrees.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "disagreement",
            "requested confirmation"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "It seems you did not finish your sentence before sending your reply.\n\nAnyway, I saw the total per swap entry overhead bump to 24 bytes\ndynamic. Let me know what is the correct number for VS if you\ndisagree.\n\nChris",
          "reply_to": "Johannes Weiner",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the vswap free path has poor batching behavior and requested a fix to improve performance.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "performance concern",
            "requested fix"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi Kairui,\n\nThank you so much for the performance test.\n\nI will only comment on the performance number in this sub email thread.\n\nOn Tue, Feb 10, 2026 at 10:00AM Kairui Song <ryncsn@gmail.com> wrote:",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the vswap series has poor memory and CPU performance compared to the original swap table, which he attributes to the per-swap-entry metadata overhead.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "performance",
            "metadata_overhead"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Agree. That has been my main complaint about VS is the per swap entry\nmetadata overhead. This VS series reverted the swap table, but memory\nand CPU performance is worse than swap table.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li expressed strong disagreement with the patch, citing poor performance compared to baseline and swap table P3 as a 'deal breaker' for them.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "performance",
            "deal breaker"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Now that is a deal breaker for me. Not the similar performance with\nbaseline or swap table P3.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that the patch introduces a 4-8% performance regression due to its preference for swap table implementations, considering this a statically significant issue.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "performance_regression",
            "statically_significant"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "At 4-8% I would consider it a statically significant performance\nregression to favor swap table implementations.",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li agrees with the patch's approach, suggesting that getting the fundamental infrastructure for swap right first is crucial before implementing more complex features.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "agreement",
            "endorsement"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Agree. That matches my view, get the fundamental infrastructure for\nswap right first (swap table), then do those fancier feature\nenhancement like online growing the size of swapfile.\n\nChris",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-10"
        },
        {
          "author": "Johannes Weiner",
          "summary": "Reviewer noted that vswap_free() acquires the per-vswap spinlock while holding the folio lock, creating a potential deadlock with reclaim paths, and requested the lock be dropped before calling try_to_unmap().",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "potential deadlock",
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hi Chris,\n\nOn Tue, Feb 10, 2026 at 01:24:03PM -0800, Chris Li wrote:",
          "reply_to": "Chris Li",
          "message_date": "2026-02-10"
        },
        {
          "author": "Johannes Weiner",
          "summary": "reviewer noted that vswap_free() acquires the per-vswap spinlock while holding the folio lock, creating a potential deadlock with reclaim paths",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I did. I trimmed the quote of Nhat's cover letter to the parts\naddressing your questions. If you use gmail, click the three dots:",
          "reply_to": "Chris Li",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li provided additional debugging information, but did not raise any specific technical concerns or objections about the patch.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no specific concern raised"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "No problem. Just want to provide more data points if that helps you\ndebug your email issue.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li suggested simplifying the explanation of virtual swap (VS) memory overhead by referencing a '24B dynamic' value, which is sufficient for most use cases without requiring detailed tables.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "suggested improvement"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I think the \"24B dynamic\" sums up the VS memory overhead pretty well\nwithout going into the detail tables. You can drive from case\ndiscussion from that.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li reported an issue with their ability to stress test the patch series due to a compilation error, possibly related to a newer GCC version.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "compiler issue",
            "testing"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "See attached config.gz. It is also possible the newer gcc version\ncontributes to that error. Anyway, that is preventing me from stress\ntesting your series on my setup.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that measuring stddev for 33 seconds is insufficient to achieve a 1.5% resolution, as it falls within the range of noise and suggested taking more samples.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "requested additional data",
            "questioned measurement validity"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "The stddev is 33 seconds. Measure 5 times then average result is not\nenough sample to get your to 1.5% resolution (8 seconds), which fall\ninto the range of noise.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li suggested including user space time in the swap pressure calculation to better determine the level of swap pressure, but did not request any changes to the patch.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "suggestion",
            "request"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Including the user space time will help determine the level of swap\npressure as well. I don't need the absolutely zswapout count just yet.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li noted that he understands there are performance regressions, but requested additional work to fix a compiling error before he can perform stress testing.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "regressions",
            "compiling error"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I understand Kairui has some measurements that show regressions.\n\nIf you can fix the compiling error I can do some stress testing myself\nto provide more data points.\n\nThanks\n\nChris",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-10"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch addresses poor batching behavior in the vswap free path, which is a critical component of Linux's virtual memory management system. The issue arises when multiple pages are being swapped out simultaneously, causing inefficient use of system resources and leading to performance degradation. To fix this problem, the patch optimizes the vswap free path by improving how it handles page swapping, reducing contention between threads and minimizing the number of lock acquisitions. This is achieved through a combination of data structure modifications and synchronization improvements, ultimately resulting in better system responsiveness and reduced overhead."
    },
    "2026-02-11": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song expressed concerns that the patch fundamentally changes the swap workflow and introduces many behavior changes at once, which may lead to performance or memory usage regressions for some workloads.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "performance or memory usage regression"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I really do think we better make this optional, not a replacement or\nmandatory. There are many hard to evaluate effects as this\nfundamentally changes the swap workflow with a lot of behavior changes\nat once. e.g. it seems the folio will be reactivated instead of\nsplitted if the physical swap device is fragmented; slot is allocated\nat IO and not at unmap, and maybe many others. Just like zswap is\noptional. Some common workloads would see an obvious performance or\nmemory usage regression following this design, see below.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song expressed concern that further simplification of the patch may lead to reimplementing the swap table format, suggesting a potential loss of functionality.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Honestly if you keep reducing that you might just end up\nreimplementing the swap table format :)",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song noted that the patch's concerns about poor batching behavior in vswap free path may not be significant, as most cases will have a 1:1 virtual swap setup and static overhead will be trivial.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "reconsidering original assessment",
            "downplaying potential issue"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "So I thought about it again, this one seems not to be an issue. In\nmost cases, having a 1:1 virtual swap setup is enough, and very soon\nthe static overhead will be really trivial. There won't even be any\nfragmentation issue either, since if the physical memory size is\nidentical to swap space, then you can always find a matching part. And\nbesides, dynamic growth of swap files is actually very doable and\nuseful, that will make physical swap files adjustable at runtime, so\nusers won't need to waste a swap type id to extend physical swap\nspace.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song noted that the new vswap free path does not perform a clean swapoff, as minor faults are still triggered afterwards and metadata is not released, which can impact performance.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "performance",
            "metadata"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "The swapoff here is not really a clean swapoff, minor faults will\nstill be triggered afterwards, and metadata is not released. So this\nnew swapoff cannot really guarantee the same performance as the old\nswapoff. And on the other hand we can already just read everything\ninto the swap cache then ignore the page table walk with the older\ndesign too, that's just not a clean swapoff.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song noted that a standalone bit for swap cache is similar to the problematic SWAP_HAS_CACHE, which caused several issues in the past.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "similarities to problematic code",
            "caused issues"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "A standalone bit for swapcache looks like the old SWAP_HAS_CACHE that\ncauses many issues...",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song noted that having a struct larger than 8 bytes in the swap table limits lock design, suggesting to utilize atomic operations like CAS on swap entries once they are small and unified, similar to how atomic_long_t is used. They also mentioned an existing cluster-lockless version of swap check in the swap table p3 patch.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "suggested improvements"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Having a struct larger than 8 bytes means you can't load it\natomically, that limits your lock design. About a year ago Chris\nshared with me an idea to use CAS on swap entries once they are small\nand unified, that's why swap table is using atomic_long_t and have\nhelpers like __swap_table_xchg, we are not making good use of them yet\nthough. Meanwhile we have already consolidated the lock scope to folio\nin many places, holding the folio lock then doing the CAS without\ntouching cluster lock at all for many swap operations might be\nfeasible soon.\n\nE.g. we already have a cluster-lockless version of swap check in swap table p3:\nhttps://lore.kernel.org/linux-mm/20260128-swap-table-p3-v2-11-fe0b67ef0215@tencent.com/\n\nThat might also greatly simplify the locking on IO and migration\nperformance between swap devices.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song expressed concern about the increased memory usage of the swap table implementation in comparison to existing solutions, citing a trade-off between features and overhead. They suggested making the new implementation optional and minimal.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Hmm.. With the swap table we will have a stable 8 bytes per slot in\nall cases, in current mm-stable we use 11 bytes (8 bytes dyn and 3\nbytes static), and in the posted p3 we already get 10 bytes (8 bytes\ndyn and 2 bytes static). P4 or follow up was already demonstrated\nlast year with working code, and it makes everything dynamic\n(8 bytes fully dyn, I'll rebase and send that once p3 is merged).\n\nSo with mm-stable and follow up, for 32G swap device:\n\n0% usage, or 0/8,388,608 entries: 0.00 MB\n* mm-stable total overhead: 25.50 MB (which is swap table p2)\n* swap-table p3 overhead: 17.50 MB\n* swap-table p4 overhead: 0.50 MB\n* Vswap total overhead: 2.00 MB\n\n100% usage, or 8,388,608/8,388,608 entries:\n* mm-stable total overhead: 89.5 MB (which is swap table p2)\n* swap-table p3 overhead: 81.5 MB\n* swap-table p4 overhead: 64.5 MB\n* Vswap total overhead: 259.00 MB\n\nThat 3 - 4 times more memory usage, quite a trade off. With a\n128G device, which is not something rare, it would be 1G of memory.\nSwap table p3 / p4 is about 320M / 256M, and we do have a way to cut\nthat down close to be <1 byte or 3 byte per page with swap table\ncompaction, which was discussed in LSFMM last year, or even 1 bit\nwhich was once suggested by Baolin, that would make it much smaller\ndown to <24MB (This is just an idea for now, but the compaction is\nvery doable as we already have \"LRU\"s for swap clusters in swap\nallocator).\n\nI don't think it looks good as a mandatory overhead. We do have a huge\nuser base of swap over many different kinds of devices, it was not\nlong ago two new kernel bugzilla issue  or bug reported was sent to\nthe maillist about swap over disk, and I'm still trying to investigate\none of them which seems to be actually a page LRU issue and not swap\nproblem..  OK a little off topic, anyway, I'm not saying that we don't\nwant more features, as I mentioned above, it would be better if this\ncan be optional and minimal. See more test info below.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song noted that the patch fixes poor batching behavior of the vswap free path, but questioned whether it's due to a smaller lock scope compared to zswap.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "questioning",
            "comparing"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Congrats! Yeah, I guess that's because vswap has a smaller lock scope\nthan zswap with a reduced callpath?",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Kairui Song",
          "summary": "Reviewer Kairui Song noted that the vswap patch introduces a significant regression in freeing time under global pressure, causing up to 200% slower performance and affecting common workloads such as building the kernel in a VM. They suspect that the double free or decoupling of swap/underlying slots might be the cause of this issue.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "regression",
            "performance impact"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Thanks for the bench, but please also test with global pressure too.\nOne mistake I made when working on the prototype of swap tables was\nonly focusing on cgroup memory pressure, which is really not how\neveryone uses Linux, and that's why I reworked it for a long time to\ntweak the RCU allocation / freeing of swap table pages so there won't\nbe any regression even for lowend and global pressure. That's kind of\ncritical for devices like Android.\n\nI did an overnight bench on this with global pressure, comparing to\nmainline 6.19 and swap table p3 (I do include such test for each swap\ntable serie, p2 / p3 is close so I just rebase and latest p3 on top of\nyour base commit just to be fair and that's easier for me too) and it\ndoesn't look that good.\n\nTest machine setup for vm-scalability:\n# lscpu | grep \"Model name\"\nModel name:          AMD EPYC 7K62 48-Core Processor\n\n# free -m\n              total        used        free      shared  buff/cache   available\nMem:          31582         909       26388           8        4284       29989\nSwap:         40959          41       40918\n\nThe swap setup follows the recommendation from Huang\n(https://lore.kernel.org/linux-mm/87ed474kvx.fsf@yhuang6-desk2.ccr.corp.intel.com/).\n\nTest (average of 18 test run):\nvm-scalability/usemem --init-time -O -y -x -n 1 56G\n\n6.19:\nThroughput: 618.49 MB/s (stdev 31.3)\nFree latency: 5754780.50us (stdev 69542.7)\n\nswap-table-p3 (3.8%, 0.5% better):\nThroughput: 642.02 MB/s (stdev 25.1)\nFree latency: 5728544.16us (stdev 48592.51)\n\nvswap (3.2%, 244% worse):\nThroughput: 598.67 MB/s (stdev 25.1)\nFree latency: 13987175.66us (stdev 125148.57)\n\nThat's a huge regression with freeing. I have a vm-scatiliby test\nmatrix, not every setup has such significant >200% regression, but on\naverage the freeing time is about at least 15 - 50% slower (for\nexample /data/vm-scalability/usemem --init-time -O -y -x -n 32 1536M\nthe regression is about 2583221.62us vs 2153735.59us). Throughput is\nall lower too.\n\nFreeing is important as it was causing many problems before, it's the\nreason why we had a swap slot freeing cache years ago (and later we\nremoved that since the freeing cache causes more problems and swap\nallocator already improved it better than having the cache). People\neven tried to optimize that:\nhttps://lore.kernel.org/linux-mm/20250909065349.574894-1-liulei.rjpt@vivo.com/\n(This seems a already fixed downstream issue, solved by swap allocator\nor swap table). Some workloads might amplify the free latency greatly\nand cause serious lags as shown above.\n\nAnother thing I personally cares about is how swap works on my daily\nlaptop :), building the kernel in a 2G test VM using NVME as swap,\nwhich is a very practical workload I do everyday, the result is also\nnot good (average of 8 test run, make -j12):\n#free -m\n               total        used        free      shared  buff/cache   available\nMem:            1465         216        1026           0         300        1248\nSwap:           4095          36        4059\n\n6.19 systime:\n109.6s\nswap-table p3:\n108.9s\nvswap systime:\n118.7s\n\nOn a build server, it's also slower (make -j48 with 4G memory VM and\nNVME swap, average of 10 testrun):\n# free -m\n               total        used        free      shared  buff/cache   available\nMem:            3877        1444        2019         737        1376        2432\nSwap:          32767        1886       30881\n\n# lscpu | grep \"Model name\"\nModel name:                              Intel(R) Xeon(R) Platinum\n8255C CPU @ 2.50GHz\n\n6.19 systime:\n435.601s\nswap-table p3:\n432.793s\nvswap systime:\n455.652s\n\nIn conclusion it's about 4.3 - 8.3% slower for common workloads under\nglobal pressure, and there is a up to 200% regression on freeing. ZRAM\nshows an even larger workload regression but I'll skip that part since\nyour series is focusing on zswap now. Redis is also ~20% slower\ncompared to mm-stable (327515.00 RPS vs 405827.81 RPS), that's mostly\ndue to swap-table-p2 in mm-stable so I didn't do further comparisons.\n\nSo if that's not a bug with this series, I think the double free or\ndecoupling of swap / underlying slots might be the problem with the\nfreeing regression shown above. That's really a serious issue, and the\nglobal pressure might be a critical issue too as the metadata is much\nlarger, and is already causing regressions for very common workloads.\nLow end users could hit the min watermark easily and could have\nserious jitters or allocation failures.\n\nThat's part of the issue I've found, so I really do think we need a\nflexible way to implementa that and not have a mandatory layer. After\nswap table P4 we should be able to figure out a way to fit all needs,\nwith a clean defined set of swap API, metadata and layers, as was\ndiscussed at LSFMM last year.",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        },
        {
          "author": "Chris Li",
          "summary": "Reviewer Chris Li suggested making the vswap batching behavior optional at runtime, specifically for types of swap that do not benefit from it, such as zram.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I second that this should be run time optional for other types of\nswap. It should not be mandatory for other swap that does not benefit\nfrom it. e.g. zram.\n\nChris",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-11"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch addresses poor batching behavior in the vswap free path, which is a critical component of Linux's virtual memory management system. The issue arises when multiple pages are being swapped out simultaneously, causing inefficient use of system resources and leading to performance degradation. To fix this problem, the patch optimizes the vswap free path by improving how it handles page swapping, reducing contention between threads and minimizing the number of lock acquisitions. This is achieved through a combination of data structure modifications and synchronization improvements, ultimately resulting in better system responsiveness and reduced overhead."
    },
    "2026-02-12": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a fix is needed",
            "agreed to restructure"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Thu, Feb 12, 2026 at 4:23AM David Hildenbrand (Arm)\n<david@kernel.org> wrote:",
          "reply_to": "David (Arm)",
          "message_date": "2026-02-12"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author is addressing a concern about the large number of people CC'd on the patch, explaining they manually add individuals to the list and plan to use a script in the future.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explaining"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I hope so... did I miss someone? If so, my apologies - I manually add\nthem one at a time to be completely honest. The list is huge...\n\nI'll probably use a script to convert that huge output next time into \"--cc\".\n\n(Or are you suggesting I should not send it out to everyone? I can try\nto trim the list, but tbh it touches areas that I'm not familiar with,\nso I figure I should just cc everyone).",
          "reply_to": "David (Arm)",
          "message_date": "2026-02-12"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "The author acknowledges that they should have done a proper CC list from the start, promises to be more careful in the future, and mentions scripting the process.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledgment",
            "commitment"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Ok let's try... this :) Probably should have done it from the start,\nbut better late than never...\n\nNot sure who was missing from the first run - my apologies if I did\nthat.... I'll be more careful with huge cc list next time and just\nscriptify it.",
          "reply_to": "",
          "message_date": "2026-02-12"
        },
        {
          "author": "David (Arm)",
          "summary": "Reviewer David noted that the vswap free path has poor batching behavior, which can lead to unnecessary wakeups of the swap device's worker thread.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I stumbled over this patch set while scrolling through the mailing list \nafter a while (now that my inbox is \"mostly\" cleaned up) and wondered \nwhy no revision ended in my inbox :)",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-12"
        },
        {
          "author": "David (Arm)",
          "summary": "Reviewer David requested that the patch author include a CC list in the cover letter, which can be used to specify additional recipients for the email sent by git send-email.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "off-topic",
            "administrative"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I usually add them as\n\nCc:\n\nto the cover letter and then use something like \"--cc-cover \" with git \nsend-email.\n\n-- \nCheers,\n\nDavid",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-12"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that the vswap free path needs to be restructured to improve batching behavior, agreed to make changes in a future version of the patch.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged need for restructuring",
            "agreed to make changes"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Thu, Feb 12, 2026 at 9:41AM David Hildenbrand (Arm)\n<david@kernel.org> wrote:",
          "reply_to": "David (Arm)",
          "message_date": "2026-02-12"
        },
        {
          "author": "Nhat Pham (author)",
          "summary": "Author acknowledged that their large patch series caused issues with CC list and email delivery, but did not indicate a plan to revise the patch itself.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledgment of issue",
            "lack of revision plan"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Oh TIL. Thanks, David!\n\nYeah this is the biggest patch series I've ever sent out. Most of my\npast patches are contained in one or two files, so usually only the\nmaintainers and contributors are pulled in, and the cc list never\nexceeds 15-20 cc's. So I've been getting away with just manually\npreparing a send command, do a quick eyeball check, then send things\nout.\n\nThat system breaks down hard this case (the email debacle aside, which\nI still haven't figured out - still looking at gmail as the prime\nsuspect...).",
          "reply_to": "David (Arm)",
          "message_date": "2026-02-12"
        },
        {
          "author": "David (Arm)",
          "summary": "Reviewer David noted that the patch description should be more nuanced in its CC: behavior, suggesting it's not always as simple as copying output to the cover letter and proposing a distinction between CC'ing maintainers and reviewers.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "requested clarification",
            "proposed improvement"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "It's usually not as easy as copying the output to the cover letter via Cc:.\n\nSometimes you want to CC all maintainers+reviewers of some subsystem, \nsometimes only the maintainers (heads-up, mostly simplistic unrelated \nchanges that don't need any real subsystem-specific review).\n\nFine line between flooding people with patches or annoying people with \npatches :)",
          "reply_to": "Nhat Pham",
          "message_date": "2026-02-12"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch addresses poor batching behavior in the vswap free path, which is a critical component of Linux's virtual memory management system. The issue arises when multiple pages are being swapped out simultaneously, causing inefficient use of system resources and leading to performance degradation. To fix this problem, the patch optimizes the vswap free path by improving how it handles page swapping, reducing contention between threads and minimizing the number of lock acquisitions. This is achieved through a combination of data structure modifications and synchronization improvements, ultimately resulting in better system responsiveness and reduced overhead."
    },
    "2026-02-17": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Nhat Pham (author)",
          "summary": "Author addressed concerns about poor batching behavior of vswap free path by identifying an issue with PTE zapping and unnecessary xarray lookups. They plan to fix this in a future version, but no specific changes are mentioned yet.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a problem",
            "planned to address it"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Hi Kairui - a quick update.\n\nTook me awhile to get a host that matches your memory spec:\n\nfree -m\n               total        used        free      shared  buff/cache   available\nMem:           31609        5778        7634          20       18664       25831\nSwap:          65535           1       65534\n\nI think I managed to reproduce your observations (average over 5 runs):\n\nBaseline (6.19)\n\nreal: mean: 191.19s, stdev: 4.53s\nuser: mean: 46.98s, stdev: 0.15s\nsys: mean: 127.97s, stdev: 3.95s\naverage throughput: 382057 KB/s\naverage free time: 8179978 usecs\n\nVswap:\n\nreal: mean: 199.85s, stdev: 6.09s\nuser: mean: 46.51s, stdev: 0.25s\nsys: mean: 137.24s, stdev: 6.46s\naverage throughput: 367437 KB/s\naverage free time: 9887107.6 usecs\n\n(command is time ./usemem --init-time -w -O -s 10 -n 1 56g)\n\nI think I figured out where the bulk of the regression lay - it's in\nthe PTE zapping path. In a nutshell, we're not batching in the case\nwhere these PTEs are backed by virtual swap entries with zswap\nbackends (even though there is not a good reason not to batch), and\nunnecessarily performing unnecesary xarray lookups to resolve the\nbackend for some superfluous checks (2 xarray lookups for every PTE,\nwhich is wasted work because as noted earlier, we ended up not\nbatching anyway).\n\nJust by simply fixing this issue, the gap is much closer\n\nreal: mean: 192.24s, stdev: 4.82s\nuser: mean: 46.42s, stdev: 0.27s\nsys: mean: 129.84s, stdev: 4.59s\naverage throughput: 380670 KB/s\naverage free time: 8583381.4 usecs\n\nI also discovered a couple more inefficiencies in vswap free path.\nHopefully once we fix those, the gap will be non-existent.",
          "reply_to": "",
          "message_date": "2026-02-17"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch addresses poor batching behavior in the vswap free path, which is a critical component of Linux's virtual memory management system. The issue arises when multiple pages are being swapped out simultaneously, causing inefficient use of system resources and leading to performance degradation. To fix this problem, the patch optimizes the vswap free path by improving how it handles page swapping, reducing contention between threads and minimizing the number of lock acquisitions. This is achieved through a combination of data structure modifications and synchronization improvements, ultimately resulting in better system responsiveness and reduced overhead."
    },
    "2026-02-20": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Nhat Pham",
      "reviews": [
        {
          "author": "Nhat Pham (author)",
          "summary": "Author Nhat Pham is addressing Kairui Song's feedback on the vswap patch, specifically a concern about poor batching behavior in the vswap free path. The author asks Kairui to apply the patch on top of the vswap series and run it on their test suite, providing data from their end. The author mentions that they have already fixed the issue on their system but wants to confirm if there are any discrepancies.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "asking for clarification",
            "requesting additional testing"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Kairui, could you apply this patch on top of the vswap series and run it\non your test suite? It runs fairly well on my system (I actually rerun\nthe benchmark on a different host to double check as well), but I'd love\nto get some data from your ends as well.\n\nIf there are serious discrepancies, could you also include your build\nconfig etc.? There might be differences in our setups, but since I\nmanaged to reproduce the free time regression on my first try I figured\nI should just fix it first :)\n\n---------------\n\nFix two issues that make the swap free path inefficient:\n\n1. At the PTE zapping step, we are unnecessarily resolving the backends,\n   and fall back to batch size of 1, even though virtual swap\n   infrastructure now already supports freeing of mixed backend ranges\n   (as long the PTEs contain virtually contiguous swap slots).\n2. Optimize vswap_free() by batching consecutive free operations, and\n   avoid releasing locks unnecessarily (most notably, when we release\n   non-disk-swap backends).\n\nPer a report from Kairui Song ([1]), I have run the following benchmark:\n\nfree -m\n               total        used        free      shared  buff/cache   available\nMem:           31596        5094       11667          19       15302       26502\nSwap:          65535          33       65502\n\nRunning the usemem benchmark with n = 1, 56G for 5 times, and average\nout the result:\n\nBaseline (6.19):\n\nreal: mean: 190.93s, stdev: 5.09s\nuser: mean: 46.62s, stdev: 0.27s\nsys: mean: 128.51s, stdev: 5.17s\nthroughput: mean: 382093 KB/s, stdev: 11173.6 KB/s\nfree time: mean: 7916690.2 usecs, stdev: 88923.0 usecs\n\nVSS without this patch:\nreal: mean: 194.59s, stdev: 7.61s\nuser: mean: 46.71s, stdev: 0.46s\nsys: mean: 131.97s, stdev: 7.93s\nthroughput: mean: 379236.4 KB/s, stdev: 15912.26 KB/s\nfree time: mean: 10115572.2 usecs, stdev: 108318.35 usecs\n\nVSS with this patch:\nreal: mean: 187.66s, stdev: 5.67s\nuser: mean: 46.5s, stdev: 0.16s\nsys: mean: 125.3s, stdev: 5.58s\nthroughput: mean: 387506.4 KB/s, stdev: 12556.56 KB/s\nfree time: mean: 7029733.8 usecs, stdev: 124661.34 usecs\n\n[1]: https://lore.kernel.org/linux-mm/CAMgjq7AQNGK-a=AOgvn4-V+zGO21QMbMTVbrYSW_R2oDSLoC+A@mail.gmail.com/\n\nSigned-off-by: Nhat Pham <nphamcs@gmail.com>\n---\n include/linux/memcontrol.h |   6 +\n mm/internal.h              |  18 ++-\n mm/madvise.c               |   2 +-\n mm/memcontrol.c            |   2 +-\n mm/memory.c                |   8 +-\n mm/vswap.c                 | 294 ++++++++++++++++++-------------------\n 6 files changed, 165 insertions(+), 165 deletions(-)\n\ndiff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h\nindex 0651865a4564f..0f7f5489e1675 100644\n--- a/include/linux/memcontrol.h\n+++ b/include/linux/memcontrol.h\n@@ -827,6 +827,7 @@ static inline unsigned short mem_cgroup_id(struct mem_cgroup *memcg)\n \treturn memcg->id.id;\n }\n struct mem_cgroup *mem_cgroup_from_id(unsigned short id);\n+void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n);\n \n #ifdef CONFIG_SHRINKER_DEBUG\n static inline unsigned long mem_cgroup_ino(struct mem_cgroup *memcg)\n@@ -1289,6 +1290,11 @@ static inline struct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n \treturn NULL;\n }\n \n+static inline void mem_cgroup_id_put_many(struct mem_cgroup *memcg,\n+\t\t\t\t\t  unsigned int n)\n+{\n+}\n+\n #ifdef CONFIG_SHRINKER_DEBUG\n static inline unsigned long mem_cgroup_ino(struct mem_cgroup *memcg)\n {\ndiff --git a/mm/internal.h b/mm/internal.h\nindex cfe97501e4885..df991f601702c 100644\n--- a/mm/internal.h\n+++ b/mm/internal.h\n@@ -327,8 +327,6 @@ static inline swp_entry_t swap_nth(swp_entry_t entry, long n)\n \treturn (swp_entry_t) { entry.val + n };\n }\n \n-swp_entry_t swap_move(swp_entry_t entry, long delta);\n-\n /**\n  * pte_move_swp_offset - Move the swap entry offset field of a swap pte\n  *\t forward or backward by delta\n@@ -342,7 +340,7 @@ swp_entry_t swap_move(swp_entry_t entry, long delta);\n static inline pte_t pte_move_swp_offset(pte_t pte, long delta)\n {\n \tsoftleaf_t entry = softleaf_from_pte(pte);\n-\tpte_t new = swp_entry_to_pte(swap_move(entry, delta));\n+\tpte_t new = swp_entry_to_pte(swap_nth(entry, delta));\n \n \tif (pte_swp_soft_dirty(pte))\n \t\tnew = pte_swp_mksoft_dirty(new);\n@@ -372,6 +370,7 @@ static inline pte_t pte_next_swp_offset(pte_t pte)\n  * @start_ptep: Page table pointer for the first entry.\n  * @max_nr: The maximum number of table entries to consider.\n  * @pte: Page table entry for the first entry.\n+ * @free_batch: Whether the batch will be passed to free_swap_and_cache_nr().\n  *\n  * Detect a batch of contiguous swap entries: consecutive (non-present) PTEs\n  * containing swap entries all with consecutive offsets and targeting the same\n@@ -382,13 +381,15 @@ static inline pte_t pte_next_swp_offset(pte_t pte)\n  *\n  * Return: the number of table entries in the batch.\n  */\n-static inline int swap_pte_batch(pte_t *start_ptep, int max_nr, pte_t pte)\n+static inline int swap_pte_batch(pte_t *start_ptep, int max_nr, pte_t pte,\n+\t\t\t\t bool free_batch)\n {\n \tpte_t expected_pte = pte_next_swp_offset(pte);\n \tconst pte_t *end_ptep = start_ptep + max_nr;\n \tconst softleaf_t entry = softleaf_from_pte(pte);\n \tpte_t *ptep = start_ptep + 1;\n \tunsigned short cgroup_id;\n+\tint nr;\n \n \tVM_WARN_ON(max_nr < 1);\n \tVM_WARN_ON(!softleaf_is_swap(entry));\n@@ -408,7 +409,14 @@ static inline int swap_pte_batch(pte_t *start_ptep, int max_nr, pte_t pte)\n \t\tptep++;\n \t}\n \n-\treturn ptep - start_ptep;\n+\tnr = ptep - start_ptep;\n+\t/*\n+\t * free_swap_and_cache_nr can handle mixed backends, as long as virtual\n+\t * swap entries backing these PTEs are contiguous.\n+\t */\n+\tif (!free_batch && !vswap_can_swapin_thp(entry, nr))\n+\t\treturn 1;\n+\treturn nr;\n }\n #endif /* CONFIG_MMU */\n \ndiff --git a/mm/madvise.c b/mm/madvise.c\nindex b617b1be0f535..441da03c5d2b9 100644\n--- a/mm/madvise.c\n+++ b/mm/madvise.c\n@@ -692,7 +692,7 @@ static int madvise_free_pte_range(pmd_t *pmd, unsigned long addr,\n \n \t\t\tif (softleaf_is_swap(entry)) {\n \t\t\t\tmax_nr = (end - addr) / PAGE_SIZE;\n-\t\t\t\tnr = swap_pte_batch(pte, max_nr, ptent);\n+\t\t\t\tnr = swap_pte_batch(pte, max_nr, ptent, true);\n \t\t\t\tnr_swap -= nr;\n \t\t\t\tfree_swap_and_cache_nr(entry, nr);\n \t\t\t\tclear_not_present_full_ptes(mm, addr, pte, nr, tlb->fullmm);\ndiff --git a/mm/memcontrol.c b/mm/memcontrol.c\nindex 50be8066bebec..bfa25eaffa12a 100644\n--- a/mm/memcontrol.c\n+++ b/mm/memcontrol.c\n@@ -3597,7 +3597,7 @@ void __maybe_unused mem_cgroup_id_get_many(struct mem_cgroup *memcg,\n \trefcount_add(n, &memcg->id.ref);\n }\n \n-static void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n+void mem_cgroup_id_put_many(struct mem_cgroup *memcg, unsigned int n)\n {\n \tif (refcount_sub_and_test(n, &memcg->id.ref)) {\n \t\tmem_cgroup_id_remove(memcg);\ndiff --git a/mm/memory.c b/mm/memory.c\nindex a16bf84ebaaf9..59645ad238e22 100644\n--- a/mm/memory.c\n+++ b/mm/memory.c\n@@ -1742,7 +1742,7 @@ static inline int zap_nonpresent_ptes(struct mmu_gather *tlb,\n \t\tif (!should_zap_cows(details))\n \t\t\treturn 1;\n \n-\t\tnr = swap_pte_batch(pte, max_nr, ptent);\n+\t\tnr = swap_pte_batch(pte, max_nr, ptent, true);\n \t\trss[MM_SWAPENTS] -= nr;\n \t\tfree_swap_and_cache_nr(entry, nr);\n \t} else if (softleaf_is_migration(entry)) {\n@@ -4491,7 +4491,7 @@ static bool can_swapin_thp(struct vm_fault *vmf, pte_t *ptep, int nr_pages)\n \tif (!pte_same(pte, pte_move_swp_offset(vmf->orig_pte, -idx)))\n \t\treturn false;\n \tentry = softleaf_from_pte(pte);\n-\tif (swap_pte_batch(ptep, nr_pages, pte) != nr_pages)\n+\tif (swap_pte_batch(ptep, nr_pages, pte, false) != nr_pages)\n \t\treturn false;\n \n \t/*\n@@ -4877,7 +4877,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\tpte_t folio_pte = ptep_get(folio_ptep);\n \n \t\tif (!pte_same(folio_pte, pte_move_swp_offset(vmf->orig_pte, -idx)) ||\n-\t\t    swap_pte_batch(folio_ptep, nr, folio_pte) != nr)\n+\t\t    swap_pte_batch(folio_ptep, nr, folio_pte, false) != nr)\n \t\t\tgoto out_nomap;\n \n \t\tpage_idx = idx;\n@@ -4906,7 +4906,7 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)\n \t\tfolio_ptep = vmf->pte - idx;\n \t\tfolio_pte = ptep_get(folio_ptep);\n \t\tif (!pte_same(folio_pte, pte_move_swp_offset(vmf->orig_pte, -idx)) ||\n-\t\t    swap_pte_batch(folio_ptep, nr, folio_pte) != nr)\n+\t\t    swap_pte_batch(folio_ptep, nr, folio_pte, false) != nr)\n \t\t\tgoto check_folio;\n \n \t\tpage_idx = idx;\ndiff --git a/mm/vswap.c b/mm/vswap.c\nindex 2a071d5ae173c..047c6476ef23c 100644\n--- a/mm/vswap.c\n+++ b/mm/vswap.c\n@@ -481,18 +481,18 @@ static void vswap_cluster_free(struct vswap_cluster *cluster)\n \tkvfree_rcu(cluster, rcu);\n }\n \n-static inline void release_vswap_slot(struct vswap_cluster *cluster,\n-\t\tunsigned long index)\n+static inline void release_vswap_slot_nr(struct vswap_cluster *cluster,\n+\t\tunsigned long index, int nr)\n {\n \tunsigned long slot_index = VSWAP_IDX_WITHIN_CLUSTER_VAL(index);\n \n \tVM_WARN_ON(!spin_is_locked(&cluster->lock));\n-\tcluster->count--;\n+\tcluster->count -= nr;\n \n-\tbitmap_clear(cluster->bitmap, slot_index, 1);\n+\tbitmap_clear(cluster->bitmap, slot_index, nr);\n \n \t/* we only free uncached empty clusters */\n-\tif (refcount_dec_and_test(&cluster->refcnt))\n+\tif (refcount_sub_and_test(nr, &cluster->refcnt))\n \t\tvswap_cluster_free(cluster);\n \telse if (cluster->full && cluster_is_alloc_candidate(cluster)) {\n \t\tcluster->full = false;\n@@ -505,7 +505,7 @@ static inline void release_vswap_slot(struct vswap_cluster *cluster,\n \t\t}\n \t}\n \n-\tatomic_dec(&vswap_used);\n+\tatomic_sub(nr, &vswap_used);\n }\n \n /*\n@@ -527,23 +527,29 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n }\n \n /*\n- * Caller needs to handle races with other operations themselves.\n+ * release_backing - release the backend storage for a given range of virtual\n+ * swap slots.\n+ *\n+ * Entered with the cluster locked, but might drop the lock in between.\n+ * This is because several operations, such as releasing physical swap slots\n+ * (i.e swap_slot_free_nr()) require the cluster to be unlocked to avoid\n+ * deadlocks.\n  *\n- * Specifically, this function is safe to be called in contexts where the swap\n- * entry has been added to the swap cache and the associated folio is locked.\n- * We cannot race with other accessors, and the swap entry is guaranteed to be\n- * valid the whole time (since swap cache implies one refcount).\n+ * This is safe, because:\n+ *\n+ * 1. The swap entry to be freed has refcnt (swap count and swapcache pin)\n+ *    down to 0, so no one can change its internal state\n  *\n- * We cannot assume that the backends will be of the same type,\n- * contiguous, etc. We might have a large folio coalesced from subpages with\n- * mixed backend, which is only rectified when it is reclaimed.\n+ * 2. The swap entry to be freed still holds a refcnt to the cluster, keeping\n+ *    the cluster itself valid.\n+ *\n+ * We will exit the function with the cluster re-locked.\n  */\n- static void release_backing(swp_entry_t entry, int nr)\n+static void release_backing(struct vswap_cluster *cluster, swp_entry_t entry,\n+\t\tint nr)\n {\n-\tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n \tunsigned long flush_nr, phys_swap_start = 0, phys_swap_end = 0;\n-\tunsigned long phys_swap_released = 0;\n \tunsigned int phys_swap_type = 0;\n \tbool need_flushing_phys_swap = false;\n \tswp_slot_t flush_slot;\n@@ -551,9 +557,8 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \n \tVM_WARN_ON(!entry.val);\n \n-\trcu_read_lock();\n \tfor (i = 0; i < nr; i++) {\n-\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n \t\tVM_WARN_ON(!desc);\n \n \t\t/*\n@@ -573,7 +578,6 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \t\tif (desc->type == VSWAP_ZSWAP && desc->zswap_entry) {\n \t\t\tzswap_entry_free(desc->zswap_entry);\n \t\t} else if (desc->type == VSWAP_SWAPFILE) {\n-\t\t\tphys_swap_released++;\n \t\t\tif (!phys_swap_start) {\n \t\t\t\t/* start a new contiguous range of phys swap */\n \t\t\t\tphys_swap_start = swp_slot_offset(desc->slot);\n@@ -589,56 +593,49 @@ void vswap_rmap_set(struct swap_cluster_info *ci, swp_slot_t slot,\n \n \t\tif (need_flushing_phys_swap) {\n \t\t\tspin_unlock(&cluster->lock);\n-\t\t\tcluster = NULL;\n \t\t\tswap_slot_free_nr(flush_slot, flush_nr);\n+\t\t\tmem_cgroup_uncharge_swap(entry, flush_nr);\n+\t\t\tspin_lock(&cluster->lock);\n \t\t\tneed_flushing_phys_swap = false;\n \t\t}\n \t}\n-\tif (cluster)\n-\t\tspin_unlock(&cluster->lock);\n-\trcu_read_unlock();\n \n \t/* Flush any remaining physical swap range */\n \tif (phys_swap_start) {\n \t\tflush_slot = swp_slot(phys_swap_type, phys_swap_start);\n \t\tflush_nr = phys_swap_end - phys_swap_start;\n+\t\tspin_unlock(&cluster->lock);\n \t\tswap_slot_free_nr(flush_slot, flush_nr);\n+\t\tmem_cgroup_uncharge_swap(entry, flush_nr);\n+\t\tspin_lock(&cluster->lock);\n \t}\n+}\n \n-\tif (phys_swap_released)\n-\t\tmem_cgroup_uncharge_swap(entry, phys_swap_released);\n- }\n+static void __vswap_swap_cgroup_clear(struct vswap_cluster *cluster,\n+\t\tswp_entry_t entry, unsigned int nr_ents);\n \n /*\n- * Entered with the cluster locked, but might unlock the cluster.\n- * This is because several operations, such as releasing physical swap slots\n- * (i.e swap_slot_free_nr()) require the cluster to be unlocked to avoid\n- * deadlocks.\n- *\n- * This is safe, because:\n- *\n- * 1. The swap entry to be freed has refcnt (swap count and swapcache pin)\n- *    down to 0, so no one can change its internal state\n- *\n- * 2. The swap entry to be freed still holds a refcnt to the cluster, keeping\n- *    the cluster itself valid.\n- *\n- * We will exit the function with the cluster re-locked.\n+ * Entered with the cluster locked. We will exit the function with the cluster\n+ * still locked.\n  */\n-static void vswap_free(struct vswap_cluster *cluster, struct swp_desc *desc,\n-\tswp_entry_t entry)\n+static void vswap_free_nr(struct vswap_cluster *cluster, swp_entry_t entry,\n+\t\tint nr)\n {\n-\t/* Clear shadow if present */\n-\tif (xa_is_value(desc->shadow))\n-\t\tdesc->shadow = NULL;\n-\tspin_unlock(&cluster->lock);\n+\tstruct swp_desc *desc;\n+\tint i;\n \n-\trelease_backing(entry, 1);\n-\tmem_cgroup_clear_swap(entry, 1);\n+\tfor (i = 0; i < nr; i++) {\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n+\t\t/* Clear shadow if present */\n+\t\tif (xa_is_value(desc->shadow))\n+\t\t\tdesc->shadow = NULL;\n+\t}\n \n-\t/* erase forward mapping and release the virtual slot for reallocation */\n-\tspin_lock(&cluster->lock);\n-\trelease_vswap_slot(cluster, entry.val);\n+\trelease_backing(cluster, entry, nr);\n+\t__vswap_swap_cgroup_clear(cluster, entry, nr);\n+\n+\t/* erase forward mapping and release the virtual slots for reallocation */\n+\trelease_vswap_slot_nr(cluster, entry.val, nr);\n }\n \n /**\n@@ -820,18 +817,32 @@ static bool vswap_free_nr_any_cache_only(swp_entry_t entry, int nr)\n \tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n \tbool ret = false;\n-\tint i;\n+\tswp_entry_t free_start;\n+\tint i, free_nr = 0;\n \n+\tfree_start.val = 0;\n \trcu_read_lock();\n \tfor (i = 0; i < nr; i++) {\n+\t\t/* flush pending free batch at cluster boundary */\n+\t\tif (free_nr && !VSWAP_IDX_WITHIN_CLUSTER_VAL(entry.val)) {\n+\t\t\tvswap_free_nr(cluster, free_start, free_nr);\n+\t\t\tfree_nr = 0;\n+\t\t}\n \t\tdesc = vswap_iter(&cluster, entry.val);\n \t\tVM_WARN_ON(!desc);\n \t\tret |= (desc->swap_count == 1 && desc->in_swapcache);\n \t\tdesc->swap_count--;\n-\t\tif (!desc->swap_count && !desc->in_swapcache)\n-\t\t\tvswap_free(cluster, desc, entry);\n+\t\tif (!desc->swap_count && !desc->in_swapcache) {\n+\t\t\tif (!free_nr++)\n+\t\t\t\tfree_start = entry;\n+\t\t} else if (free_nr) {\n+\t\t\tvswap_free_nr(cluster, free_start, free_nr);\n+\t\t\tfree_nr = 0;\n+\t\t}\n \t\tentry.val++;\n \t}\n+\tif (free_nr)\n+\t\tvswap_free_nr(cluster, free_start, free_nr);\n \tif (cluster)\n \t\tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n@@ -954,19 +965,33 @@ void swapcache_clear(swp_entry_t entry, int nr)\n {\n \tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n-\tint i;\n+\tswp_entry_t free_start;\n+\tint i, free_nr = 0;\n \n \tif (!nr)\n \t\treturn;\n \n+\tfree_start.val = 0;\n \trcu_read_lock();\n \tfor (i = 0; i < nr; i++) {\n+\t\t/* flush pending free batch at cluster boundary */\n+\t\tif (free_nr && !VSWAP_IDX_WITHIN_CLUSTER_VAL(entry.val)) {\n+\t\t\tvswap_free_nr(cluster, free_start, free_nr);\n+\t\t\tfree_nr = 0;\n+\t\t}\n \t\tdesc = vswap_iter(&cluster, entry.val);\n \t\tdesc->in_swapcache = false;\n-\t\tif (!desc->swap_count)\n-\t\t\tvswap_free(cluster, desc, entry);\n+\t\tif (!desc->swap_count) {\n+\t\t\tif (!free_nr++)\n+\t\t\t\tfree_start = entry;\n+\t\t} else if (free_nr) {\n+\t\t\tvswap_free_nr(cluster, free_start, free_nr);\n+\t\t\tfree_nr = 0;\n+\t\t}\n \t\tentry.val++;\n \t}\n+\tif (free_nr)\n+\t\tvswap_free_nr(cluster, free_start, free_nr);\n \tif (cluster)\n \t\tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n@@ -1107,11 +1132,13 @@ void vswap_store_folio(swp_entry_t entry, struct folio *folio)\n \tVM_BUG_ON(!folio_test_locked(folio));\n \tVM_BUG_ON(folio->swap.val != entry.val);\n \n-\trelease_backing(entry, nr);\n-\n \trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tVM_WARN_ON(!desc);\n+\trelease_backing(cluster, entry, nr);\n+\n \tfor (i = 0; i < nr; i++) {\n-\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n \t\tVM_WARN_ON(!desc);\n \t\tdesc->type = VSWAP_FOLIO;\n \t\tdesc->swap_cache = folio;\n@@ -1136,11 +1163,13 @@ void swap_zeromap_folio_set(struct folio *folio)\n \tVM_BUG_ON(!folio_test_locked(folio));\n \tVM_BUG_ON(!entry.val);\n \n-\trelease_backing(entry, nr);\n-\n \trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tVM_WARN_ON(!desc);\n+\trelease_backing(cluster, entry, nr);\n+\n \tfor (i = 0; i < nr; i++) {\n-\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n \t\tVM_WARN_ON(!desc);\n \t\tdesc->type = VSWAP_ZERO;\n \t}\n@@ -1261,89 +1290,6 @@ bool vswap_can_swapin_thp(swp_entry_t entry, int nr)\n \t\t(type == VSWAP_ZERO || type == VSWAP_SWAPFILE);\n }\n \n-/**\n- * swap_move - increment the swap slot by delta, checking the backing state and\n- *             return 0 if the backing state does not match (i.e wrong backing\n- *             state type, or wrong offset on the backing stores).\n- * @entry: the original virtual swap slot.\n- * @delta: the offset to increment the original slot.\n- *\n- * Note that this function is racy unless we can pin the backing state of these\n- * swap slots down with swapcache_prepare().\n- *\n- * Caller should only rely on this function as a best-effort hint otherwise,\n- * and should double-check after ensuring the whole range is pinned down.\n- *\n- * Return: the incremented virtual swap slot if the backing state matches, or\n- *         0 if the backing state does not match.\n- */\n-swp_entry_t swap_move(swp_entry_t entry, long delta)\n-{\n-\tstruct vswap_cluster *cluster = NULL;\n-\tstruct swp_desc *desc, *next_desc;\n-\tswp_entry_t next_entry;\n-\tstruct folio *folio = NULL, *next_folio = NULL;\n-\tenum swap_type type, next_type;\n-\tswp_slot_t slot = {0}, next_slot = {0};\n-\n-\tnext_entry.val = entry.val + delta;\n-\n-\trcu_read_lock();\n-\n-\t/* Look up first descriptor and get its type and backing store */\n-\tdesc = vswap_iter(&cluster, entry.val);\n-\tif (!desc) {\n-\t\trcu_read_unlock();\n-\t\treturn (swp_entry_t){0};\n-\t}\n-\n-\ttype = desc->type;\n-\tif (type == VSWAP_ZSWAP) {\n-\t\t/* zswap not supported for move */\n-\t\tspin_unlock(&cluster->lock);\n-\t\trcu_read_unlock();\n-\t\treturn (swp_entry_t){0};\n-\t}\n-\tif (type == VSWAP_FOLIO)\n-\t\tfolio = desc->swap_cache;\n-\telse if (type == VSWAP_SWAPFILE)\n-\t\tslot = desc->slot;\n-\n-\t/* Look up second descriptor and get its type and backing store */\n-\tnext_desc = vswap_iter(&cluster, next_entry.val);\n-\tif (!next_desc) {\n-\t\trcu_read_unlock();\n-\t\treturn (swp_entry_t){0};\n-\t}\n-\n-\tnext_type = next_desc->type;\n-\tif (next_type == VSWAP_FOLIO)\n-\t\tnext_folio = next_desc->swap_cache;\n-\telse if (next_type == VSWAP_SWAPFILE)\n-\t\tnext_slot = next_desc->slot;\n-\n-\tif (cluster)\n-\t\tspin_unlock(&cluster->lock);\n-\n-\trcu_read_unlock();\n-\n-\t/* Check if types match */\n-\tif (next_type != type)\n-\t\treturn (swp_entry_t){0};\n-\n-\t/* Check backing state consistency */\n-\tif (type == VSWAP_SWAPFILE &&\n-\t\t\t(swp_slot_type(next_slot) != swp_slot_type(slot) ||\n-\t\t\t\tswp_slot_offset(next_slot) !=\n-\t\t\t\t\t\t\tswp_slot_offset(slot) + delta))\n-\t\treturn (swp_entry_t){0};\n-\n-\tif (type == VSWAP_FOLIO && next_folio != folio)\n-\t\treturn (swp_entry_t){0};\n-\n-\treturn next_entry;\n-}\n-\n /*\n  * Return the count of contiguous swap entries that share the same\n  * VSWAP_ZERO status as the starting entry. If is_zeromap is not NULL,\n@@ -1863,11 +1809,10 @@ void zswap_entry_store(swp_entry_t swpentry, struct zswap_entry *entry)\n \tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n \n-\trelease_backing(swpentry, 1);\n-\n \trcu_read_lock();\n \tdesc = vswap_iter(&cluster, swpentry.val);\n \tVM_WARN_ON(!desc);\n+\trelease_backing(cluster, swpentry, 1);\n \tdesc->zswap_entry = entry;\n \tdesc->type = VSWAP_ZSWAP;\n \tspin_unlock(&cluster->lock);\n@@ -1914,17 +1859,22 @@ bool zswap_empty(swp_entry_t swpentry)\n #endif /* CONFIG_ZSWAP */\n \n #ifdef CONFIG_MEMCG\n-static unsigned short vswap_cgroup_record(swp_entry_t entry,\n-\t\t\t\tunsigned short memcgid, unsigned int nr_ents)\n+/*\n+ * __vswap_cgroup_record - record mem_cgroup for a set of swap entries\n+ *\n+ * Entered with the cluster locked. We will exit the function with the cluster\n+ * still locked.\n+ */\n+static unsigned short __vswap_cgroup_record(struct vswap_cluster *cluster,\n+\t\t\t\tswp_entry_t entry, unsigned short memcgid,\n+\t\t\t\tunsigned int nr_ents)\n {\n-\tstruct vswap_cluster *cluster = NULL;\n \tstruct swp_desc *desc;\n \tunsigned short oldid, iter = 0;\n \tint i;\n \n-\trcu_read_lock();\n \tfor (i = 0; i < nr_ents; i++) {\n-\t\tdesc = vswap_iter(&cluster, entry.val + i);\n+\t\tdesc = __vswap_iter(cluster, entry.val + i);\n \t\tVM_WARN_ON(!desc);\n \t\toldid = desc->memcgid;\n \t\tdesc->memcgid = memcgid;\n@@ -1932,6 +1882,37 @@ static unsigned short vswap_cgroup_record(swp_entry_t entry,\n \t\t\titer = oldid;\n \t\tVM_WARN_ON(iter != oldid);\n \t}\n+\n+\treturn oldid;\n+}\n+\n+/*\n+ * Clear swap cgroup for a range of swap entries.\n+ * Entered with the cluster locked. Caller must be under rcu_read_lock().\n+ */\n+static void __vswap_swap_cgroup_clear(struct vswap_cluster *cluster,\n+\t\t\t\t      swp_entry_t entry, unsigned int nr_ents)\n+{\n+\tunsigned short id;\n+\tstruct mem_cgroup *memcg;\n+\n+\tid = __vswap_cgroup_record(cluster, entry, 0, nr_ents);\n+\tmemcg = mem_cgroup_from_id(id);\n+\tif (memcg)\n+\t\tmem_cgroup_id_put_many(memcg, nr_ents);\n+}\n+\n+static unsigned short vswap_cgroup_record(swp_entry_t entry,\n+\t\t\t\tunsigned short memcgid, unsigned int nr_ents)\n+{\n+\tstruct vswap_cluster *cluster = NULL;\n+\tstruct swp_desc *desc;\n+\tunsigned short oldid;\n+\n+\trcu_read_lock();\n+\tdesc = vswap_iter(&cluster, entry.val);\n+\tVM_WARN_ON(!desc);\n+\toldid = __vswap_cgroup_record(cluster, entry, memcgid, nr_ents);\n \tspin_unlock(&cluster->lock);\n \trcu_read_unlock();\n \n@@ -1999,6 +1980,11 @@ unsigned short lookup_swap_cgroup_id(swp_entry_t entry)\n \trcu_read_unlock();\n \treturn ret;\n }\n+#else /* !CONFIG_MEMCG */\n+static void __vswap_swap_cgroup_clear(struct vswap_cluster *cluster,\n+\t\t\t\t      swp_entry_t entry, unsigned int nr_ents)\n+{\n+}\n #endif /* CONFIG_MEMCG */\n \n int vswap_init(void)\n-- \n2.47.3",
          "reply_to": "Kairui Song",
          "message_date": "2026-02-20"
        }
      ],
      "analysis_source": "llm-per-reviewer",
      "patch_summary": "This patch addresses poor batching behavior in the vswap free path, which is a critical component of Linux's virtual memory management system. The issue arises when multiple pages are being swapped out simultaneously, causing inefficient use of system resources and leading to performance degradation. To fix this problem, the patch optimizes the vswap free path by improving how it handles page swapping, reducing contention between threads and minimizing the number of lock acquisitions. This is achieved through a combination of data structure modifications and synchronization improvements, ultimately resulting in better system responsiveness and reduced overhead."
    }
  }
}