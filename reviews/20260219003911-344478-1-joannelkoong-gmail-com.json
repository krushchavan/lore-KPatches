{
  "thread_id": "20260219003911.344478-1-joannelkoong@gmail.com",
  "subject": "[PATCH v1 0/1] iomap: don't mark folio uptodate if read IO has bytes pending",
  "url": "https://lore.kernel.org/all/20260219003911.344478-1-joannelkoong@gmail.com/",
  "dates": {
    "2026-02-19": {
      "report_file": "2026-02-19_ollama_llama3.1-8b.html",
      "developer": "Joanne Koong",
      "reviews": [
        {
          "author": "Joanne Koong (author)",
          "summary": "Joanne Koong raised a technical concern that the patch may cause issues when a folio is partially read through an async IO helper and then post-EOF zeroing or inline data, leading to incorrect uptodate state.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "technical concern",
            "potential bug"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "If a folio has ifs metadata attached to it and the folio is partially\nread in through an async IO helper with the rest of it then being read\nin through post-EOF zeroing or as inline data, and the helper\nsuccessfully finishes the read first, then post-EOF zeroing / reading\ninline will mark the folio as uptodate in iomap_set_range_uptodate().\n\nThis is a problem because when the read completion path later calls\niomap_read_end(), it will call folio_end_read(), which sets the uptodate\nbit using XOR semantics. Calling folio_end_read() on a folio that was\nalready marked uptodate clears the uptodate bit.\n\nFix this by not marking the folio as uptodate if the read IO has bytes\npending. The folio uptodate state will be set in the read completion\npath through iomap_end_read() -> folio_end_read().\n\nReported-by: Wei Gao <wegao@suse.com>\nSuggested-by: Sasha Levin <sashal@kernel.org>\nTested-by: Wei Gao <wegao@suse.com>\nSigned-off-by: Joanne Koong <joannelkoong@gmail.com>\nFixes: b2f35ac4146d (\"iomap: add caller-provided callbacks for read and readahead\")\n---\n fs/iomap/buffered-io.c | 15 ++++++++++++---\n 1 file changed, 12 insertions(+), 3 deletions(-)\n\ndiff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c\nindex 58887513b894..4fc5ce963feb 100644\n--- a/fs/iomap/buffered-io.c\n+++ b/fs/iomap/buffered-io.c\n@@ -80,18 +80,27 @@ static void iomap_set_range_uptodate(struct folio *folio, size_t off,\n {\n \tstruct iomap_folio_state *ifs = folio->private;\n \tunsigned long flags;\n-\tbool uptodate = true;\n+\tbool mark_uptodate = true;\n \n \tif (folio_test_uptodate(folio))\n \t\treturn;\n \n \tif (ifs) {\n \t\tspin_lock_irqsave(&ifs->state_lock, flags);\n-\t\tuptodate = ifs_set_range_uptodate(folio, ifs, off, len);\n+\t\t/*\n+\t\t * If a read with bytes pending is in progress, we must not call\n+\t\t * folio_mark_uptodate(). The read completion path\n+\t\t * (iomap_read_end()) will call folio_end_read(), which uses XOR\n+\t\t * semantics to set the uptodate bit. If we set it here, the XOR\n+\t\t * in folio_end_read() will clear it, leaving the folio not\n+\t\t * uptodate.\n+\t\t */\n+\t\tmark_uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &&\n+\t\t\t\t!ifs->read_bytes_pending;\n \t\tspin_unlock_irqrestore(&ifs->state_lock, flags);\n \t}\n \n-\tif (uptodate)\n+\tif (mark_uptodate)\n \t\tfolio_mark_uptodate(folio);\n }\n \n-- \n2.47.3\n\n",
          "reply_to": ""
        },
        {
          "author": "Darrick Wong",
          "summary": "Reviewer Darrick Wong raised no technical concerns, but instead asked about the difficulty of writing an fstest for this patch and provided a Reviewed-by tag.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no technical concerns raised"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Wed, Feb 18, 2026 at 04:39:11PM -0800, Joanne Koong wrote:\n> If a folio has ifs metadata attached to it and the folio is partially\n> read in through an async IO helper with the rest of it then being read\n> in through post-EOF zeroing or as inline data, and the helper\n> successfully finishes the read first, then post-EOF zeroing / reading\n> inline will mark the folio as uptodate in iomap_set_range_uptodate().\n> \n> This is a problem because when the read completion path later calls\n> iomap_read_end(), it will call folio_end_read(), which sets the uptodate\n> bit using XOR semantics. Calling folio_end_read() on a folio that was\n> already marked uptodate clears the uptodate bit.\n\nAha, I wondered if that xor thing was going to come back to bite us.\n\n> Fix this by not marking the folio as uptodate if the read IO has bytes\n> pending. The folio uptodate state will be set in the read completion\n> path through iomap_end_read() -> folio_end_read().\n> \n> Reported-by: Wei Gao <wegao@suse.com>\n> Suggested-by: Sasha Levin <sashal@kernel.org>\n> Tested-by: Wei Gao <wegao@suse.com>\n> Signed-off-by: Joanne Koong <joannelkoong@gmail.com>\n> Fixes: b2f35ac4146d (\"iomap: add caller-provided callbacks for read and readahead\")\n\nI would add:\n\nLink: https://lore.kernel.org/linux-fsdevel/aYbmy8JdgXwsGaPP@autotest-wegao.qe.prg2.suse.org/\nCc: <stable@vger.kernel.org> # v6.19\n\nsince the recent discussion around this was sort of buried in a\ndifferent thread, and the original patch is now in a released kernel.\n\n> ---\n>  fs/iomap/buffered-io.c | 15 ++++++++++++---\n>  1 file changed, 12 insertions(+), 3 deletions(-)\n> \n> diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c\n> index 58887513b894..4fc5ce963feb 100644\n> --- a/fs/iomap/buffered-io.c\n> +++ b/fs/iomap/buffered-io.c\n> @@ -80,18 +80,27 @@ static void iomap_set_range_uptodate(struct folio *folio, size_t off,\n>  {\n>  \tstruct iomap_folio_state *ifs = folio->private;\n>  \tunsigned long flags;\n> -\tbool uptodate = true;\n> +\tbool mark_uptodate = true;\n>  \n>  \tif (folio_test_uptodate(folio))\n>  \t\treturn;\n>  \n>  \tif (ifs) {\n>  \t\tspin_lock_irqsave(&ifs->state_lock, flags);\n> -\t\tuptodate = ifs_set_range_uptodate(folio, ifs, off, len);\n> +\t\t/*\n> +\t\t * If a read with bytes pending is in progress, we must not call\n> +\t\t * folio_mark_uptodate(). The read completion path\n> +\t\t * (iomap_read_end()) will call folio_end_read(), which uses XOR\n> +\t\t * semantics to set the uptodate bit. If we set it here, the XOR\n> +\t\t * in folio_end_read() will clear it, leaving the folio not\n> +\t\t * uptodate.\n\nYeah, that makes sense.  How difficult is this to write up as an fstest?\n\nReviewed-by: \"Darrick J. Wong\" <djwong@kernel.org>\n\n--D\n\n> +\t\t */\n> +\t\tmark_uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &&\n> +\t\t\t\t!ifs->read_bytes_pending;\n>  \t\tspin_unlock_irqrestore(&ifs->state_lock, flags);\n>  \t}\n>  \n> -\tif (uptodate)\n> +\tif (mark_uptodate)\n>  \t\tfolio_mark_uptodate(folio);\n>  }\n>  \n> -- \n> 2.47.3\n> \n> \n\n\n---\n\nOn Thu, Feb 19, 2026 at 04:23:23AM +0000, Matthew Wilcox wrote:\n> On Wed, Feb 18, 2026 at 06:45:34PM -0800, Darrick J. Wong wrote:\n> > On Wed, Feb 18, 2026 at 04:39:11PM -0800, Joanne Koong wrote:\n> > > If a folio has ifs metadata attached to it and the folio is partially\n> > > read in through an async IO helper with the rest of it then being read\n> > > in through post-EOF zeroing or as inline data, and the helper\n> > > successfully finishes the read first, then post-EOF zeroing / reading\n> > > inline will mark the folio as uptodate in iomap_set_range_uptodate().\n> > > \n> > > This is a problem because when the read completion path later calls\n> > > iomap_read_end(), it will call folio_end_read(), which sets the uptodate\n> > > bit using XOR semantics. Calling folio_end_read() on a folio that was\n> > > already marked uptodate clears the uptodate bit.\n> > \n> > Aha, I wondered if that xor thing was going to come back to bite us.\n> \n> This isn't \"the xor thing has come back to bite us\".  This is \"the iomap\n> code is now too complicated and I cannot figure out how to explain to\n> Joanne that there's really a simple way to do this\".\n> \n> I'm going to have to set aside my current projects and redo the iomap\n> readahead/read_folio code myself, aren't I?\n\nWell you could try explaining to me what that simpler way is?\n\n/me gets the sense he's missing a discussion somewhere...\n\n--D\n",
          "reply_to": ""
        },
        {
          "author": "Matthew Wilcox",
          "summary": "Matthew Wilcox expressed frustration with the complexity of the iomap code and implied that he needs to rework it himself.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "frustration",
            "implied need for rework"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Wed, Feb 18, 2026 at 06:45:34PM -0800, Darrick J. Wong wrote:\n> On Wed, Feb 18, 2026 at 04:39:11PM -0800, Joanne Koong wrote:\n> > If a folio has ifs metadata attached to it and the folio is partially\n> > read in through an async IO helper with the rest of it then being read\n> > in through post-EOF zeroing or as inline data, and the helper\n> > successfully finishes the read first, then post-EOF zeroing / reading\n> > inline will mark the folio as uptodate in iomap_set_range_uptodate().\n> > \n> > This is a problem because when the read completion path later calls\n> > iomap_read_end(), it will call folio_end_read(), which sets the uptodate\n> > bit using XOR semantics. Calling folio_end_read() on a folio that was\n> > already marked uptodate clears the uptodate bit.\n> \n> Aha, I wondered if that xor thing was going to come back to bite us.\n\nThis isn't \"the xor thing has come back to bite us\".  This is \"the iomap\ncode is now too complicated and I cannot figure out how to explain to\nJoanne that there's really a simple way to do this\".\n\nI'm going to have to set aside my current projects and redo the iomap\nreadahead/read_folio code myself, aren't I?\n",
          "reply_to": ""
        },
        {
          "author": "Christoph Hellwig",
          "summary": "Christoph Hellwig raised no specific technical concerns or objections to the patch, but instead simply repeated 'same' without any context.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "lack of clear signal",
            "no technical discussion"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Wed, Feb 18, 2026 at 10:11:01PM -0800, Darrick J. Wong wrote:\n> > This isn't \"the xor thing has come back to bite us\".  This is \"the iomap\n> > code is now too complicated and I cannot figure out how to explain to\n> > Joanne that there's really a simple way to do this\".\n> > \n> > I'm going to have to set aside my current projects and redo the iomap\n> > readahead/read_folio code myself, aren't I?\n> \n> Well you could try explaining to me what that simpler way is?\n> \n> /me gets the sense he's missing a discussion somewhere...\n\nSame.\n\n\n",
          "reply_to": ""
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "This patch prevents marking a folio as uptodate if there are still bytes pending from a read IO operation, which can lead to incorrect behavior when the remaining bytes are processed."
    }
  }
}