{
  "thread_id": "19c990e9bf42cdc9c7b9bef5f4407fce30d35e54.camel@kernel.org",
  "subject": "Re: [PATCH v3 1/4] open: new O_REGULAR flag support",
  "url": "https://lore.kernel.org/all/19c990e9bf42cdc9c7b9bef5f4407fce30d35e54.camel@kernel.org/",
  "dates": {
    "2026-02-18": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton noted that nfs_atomic_open() might not work efficiently with the new O_REGULAR flag, but after reevaluating, he thinks it will work without changes; however, he suggested an optimization opportunity where if open_context() returns -EISDIR or similar, the function can immediately return an error when O_REGULAR is set",
          "sentiment": "neutral",
          "sentiment_signals": [
            "requested optimization",
            "potential inefficiency"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I was thinking nfs_atomic_open().\n\nLooking now, I think it might actually work OK without changes. It just\nmight not be terribly efficient about it.\n\nIf the open_context() call returns -EISDIR or similar, then you really\ndon't need to do the call to nfs_lookup() and the like. You can just\nreturn an immediate error when O_REGULAR is set since you know it's not\nsuitable to be opened.",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that while most cases will fall back to finish_no_open(), there may be opportunities for optimization, similar to how he mentioned optimizing NFS, and requested a deeper dive and testing of these cases.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "optimization",
            "deeper dive"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Note that this was just a cursory look. Someone will need to do a\ndeeper dive and test these cases.\n\nI think most will end up working ok, since most fall back to doing a\nfinish_no_open(). There may be opportunities to optimize some of these\ncases though (similarly to how I mentioned with NFS).\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton noted that POSIX flags like O_REGULAR should not be sent in NFSv4 requests, as they have their own set of flags and O_REGULAR is already implied in an OPEN call on the wire.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "flag",
            "NFSv4"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "You shouldn't. We don't send POSIX flags in NFSv4 requests. It has its\nown set of flags. In the case of NFSv4, O_REGULAR is already implied in\nan OPEN call on the wire. OPEN only operates on regular files.",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that when a valid dentry exists, the O_REGULAR flag can be checked without calling ->open(), and suggested re-evaluating the code to avoid unnecessary calls.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Probably not.\n\nThe main thing to keep in mind is that ->open is used when we already\nhave a dentry for the target of the open. ->atomic_open is used when we\ndon't have one yet or the one we have has failed revalidation.\n\nIf you have a valid dentry, then you should be able to satisfy the\nO_REGULAR check without having to call into ->open at all.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-02-18"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-01-28": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer suggested including information about the UAPI group's request and past discussion at LPC in the commit message, specifically recommending a link to the relevant kernel feature documentation.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "As you mention in your cover letter, this is something that the UAPI\ngroup has asked for in the past[1] and was even discussed at a recent\nLPC (maybe LPC 2024?) -- thanks for the patch!\n\nIn the next posting of this patchset, I would suggest including this\ninformation in the *commit message* with a link (commit messages end up\nin the git history, cover letters are a little harder to search for when\ndoing \"git blame\").\n\n[1]: https://uapi-group.org/kernel-features/#ability-to-only-open-regular-files",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer noted that using the O_REGULAR flag with O_PATH is unnecessary because O_PATH file descriptors do not risk opening device inodes, and suggested an alternative method of safely opening files by first checking if they are regular files using fstat(2) on an O_PATH descriptor.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "It doesn't really make sense to use this flag with O_PATH -- O_PATH file\ndescriptors do not actually open the target inode and so there is no\nrisk to doing this.\n\nIn fact the method of safely opening files while avoiding device inodes\non Linux today is to open an O_PATH, then use fstat(2) to check whether\nit is a regular file, and then re-open the file descriptor through\n/proc/self/fd/$n. (This is totally race-safe.)\n\nMy main reason for pushing back against this it's really quite\npreferable to avoid expanding the set of O_* flags which work with\nO_PATH if they don't add much -- O_PATH has really unfortunate behaviour\nwith ignoring other flags and openat2(2) finally fixed that by blocking\nignored flag combinations.",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer noted that legacy open(2)/openat(2) do not reject invalid flag arguments, making it difficult to add a new security-critical flag like O_REGULAR without breaking userspace or relying on caching issues; suggested using openat2(2)-only API and adding a rejection mask in struct open_how instead of burning another O_* flag bit.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Legacy open(2)/openat(2) do not reject invalid flag arguments, which\nmeans that you cannot trivially add a new security-critical flag to them\nfor two reasons:\n\n * You cannot easily rely on them because old kernels will not return\n   -EINVAL, meaning you cannot be sure that the flag is supported. You\n   can try to test-run it, but the operation needs to be a non-dangerous\n   operation to try (and caching this has its own issues, such as with\n   programs that apply seccomp filters later).\n\n   To be fair, since you reject O_DIRECTORY|O_REGULAR there is a\n   relatively easy way to detect this, but the caveats about problems\n   with caching still apply.\n\n * Old programs might pass garbage bits that have been ignored thus far,\n   which means that making them have meaning can break userspace. Given\n   the age of open(2) this is a very hard thing to guarantee and is one\n   of many reasons I wrote openat2(2) and finally added proper flag\n   checking.\n\n   This is something your patch doesn't deal with and I don't think can\n   be done in a satisfactory way (because the behaviour relies on more\n   than just the arguments).\n\nFor reference, this is why O_TMPFILE includes O_DIRECTORY and requires\nan O_ACCMODE with write bits -- this combination will fail on old\nkernels, which allows you to rely on it and also guarantees that no\nexisting older programs passed that flag combination already and\nhappened to work on older kernels. This kind of trick won't work for\nO_REGULAR, unfortunately.\n\nIn my view, this should be an openat2(2)-only API. In addition, I would\npropose that (instead of burning another O_* flag bit for this as a\nspecial-purpose API just for regular files) you could have a mask of\nwhich S_IFMT bits should be rejected as a new field in \"struct\nopen_how\". This would let you reject sockets or device inodes but permit\nFIFOs and regular files or directories, for instance. This could even be\ndone without a new O_* flag at all (the zero-value how->sfmt_mask would\nallow everything and so would work well with extensible structs), but we\ncould add an O2_* flag anyway.",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer suggested adding a description in the commit or cover letter explaining why a new errno is needed, specifically recommending ENXIO or EPROTONOSUPPORT/EPROTOTYPE as alternatives to ENOTREG.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "suggested improvements"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "We are probably a little too reticent to add new errnos, but in this\ncase I think that there should be some description in the commit or\ncover letter about why a new errno is needed. ENXIO or\nEPROTONOSUPPORT/EPROTOTYPE is what you would typically use (yes, they\naren't a _perfect_ match but one of the common occurrences in syscall\ndesign is to read through errno(7) and figure out what errnos kind of\nfit what you need to express).\n\nThen to be fair, the existence of ENOTBLK, ENOTDIR, ENOTSOCK, etc. kind\nof justify the existence of ENOTREG too. Unfortunately, you won't be\nable to use ENOTREG if you go with my idea of having mask bits in\nopen_how... (And what errno should we use then...? Hm.)\n\n-- \nAleksa Sarai\nhttps://www.cyphar.com/",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-01-28"
        },
        {
          "author": "Mateusz Guzik",
          "summary": "Reviewer Mateusz Guzik expressed concerns about the O_ flag namespace being reused by openat2 syscall, which may lead to confusion and incorrect assumptions when passing flags to open and openat functions.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "concerns",
            "confusion"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "fwiw +1 from me, the O_ flag situation is already terrible even without\nthe validation woes.\n\nI find it most unfortunate the openat2 syscall reuses the O_ namespace.\nFor my taste it would be best closed for business, with all new flag\nadditions using a different space.\n\nI can easily see people passing O_WHATEVER to open and openat by blindly\nassuming they are supported just based on the name.\n\nthat's a side mini-rant, too late to do anything here now",
          "reply_to": "Aleksa Sarai",
          "message_date": "2026-01-28"
        },
        {
          "author": "Mateusz Guzik",
          "summary": "Reviewer Mateusz Guzik noted that the current implementation of O_REGULAR flag using bitmasks has overlapping bits with existing file type definitions (S_IFBLK and S_IFDIR), making it impossible to select specific types, and suggested providing new defines with unique bits or modifying semantics to only allow desired bits.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "overlapping_bits",
            "semantics_mismatch"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I don't think this works because the vars have overlapping bits:\n  #define S_IFBLK  0060000\n  #define S_IFDIR  0040000\n\nSo you very much can't select what you want off of a bitmask.\n\nAt best the field could be used to select the one type you are fine with.\n\nIf one was to pursue the idea, some other defines with unique bits would\nneed to be provided. But even then, semantics should be to only *allow*\nthe bits you are fine with and reject the rest.\n\nBut I'm not at all confident this is worth any effort -- with\nO_DIRECTORY already being there and O_REGULAR proposed, is there a use\ncase which wants something else?",
          "reply_to": "Aleksa Sarai",
          "message_date": "2026-01-28"
        },
        {
          "author": "Mateusz Guzik",
          "summary": "Reviewer Mateusz Guzik suggested adding specific error numbers to indicate the type of file that cannot be opened with O_REGULAR flag, such as EPIPE for pipes or EBADTYPE for other types",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "The most useful behavior would indicate what was found (e.g., a pipe).\n\nThe easiest way to do it would create errnos for all types (EISDIR\nalready exists for one), but I can't seriously propose that.\n\nGoing the other way, EBADTYPE or something else reusable would be my\nidea.",
          "reply_to": "Aleksa Sarai",
          "message_date": "2026-01-28"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author responded to feedback about the behavior of O_REGULAR flag in atomic_open by asking for clarification on where and what needs to be fixed, indicating uncertainty about the expected behavior when using O_CREAT | O_REGULAR.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "uncertainty",
            "request for clarification"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Thank you for the feedback. I don't quite understand what I need to\nfix. I thought open system calls always create regular files, so\natomic_open probably always creates regular files? Can you please give\nme some more details as to where I need to fix this and what the\nactual bug here is that is related to atomic_open?  I think I had done\nsome normal testing and when using O_CREAT | O_REGULAR, if the file\ndoesn't exist, the file gets created and the file that gets created is\na regular file, so it probably makes sense? Or should the behavior be\nthat if file doesn't exist, -EINVAL is returned and if file exists it\nis opened if regular, otherwise -ENOTREG is returned?\n\nRegards,\nDorjoy",
          "reply_to": "Jeff Layton",
          "message_date": "2026-01-28"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that atomic_open() is a separate codepath for network filesystems, which doesn't call the normal open codepath and may ignore O_REGULAR flag, suggesting an interim step to return -EINVAL in atomic_open operations when O_DIRECTORY is set.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "interim solution"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "atomic_open() is a combination lookup+open for when the dentry isn't\npresent in the dcache. The normal open codepath that you're patching\ndoes not get called in this case when ->atomic_open is set for the\nfilesystem. It's mostly used by network filesystems that need to\noptimize away the lookup since it's wasted round trip, and is often\nracy anyway. Your patchset doesn't address those filesystems. They will\nlikely end up ignoring O_REGULAR in that case, which is not what you\nwant.\n\nWhat I was suggesting is that, as an interim step, you find all of the\natomic_open operations in the kernel (there are maybe a dozen or so),\nand just make them return -EINVAL if someone sets O_DIRECTORY. Later,\nyou or someone else can then go back and do a proper implementation of\nO_REGULAR handling on those filesystems, at least on the ones where\nit's possible. You will probably also need to similarly patch the\nopen() routines for those filesystems too. Otherwise you'll get\ninconsistent behavior vs. when the dentry is in the cache.\n\nOne note: I think NFS probably can support O_DIRECTORY, since its OPEN\ncall only works on files. We'll need to change how we handle errors\nfrom the server when it's set though.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-01-28"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "The author is clarifying the intention behind returning -EINVAL when both O_REGULAR and O_DIRECTORY flags are set, pointing out that they already handle this case in the build_open_flags function and questioning whether additional checks are needed in atomic_open implementations.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "questioning"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Sorry, I am just trying to fully understand this. Do you mean to\nreturn -EINVAL from all atomic_open implementations in the kernel if\nboth O_REGULAR and O_DIRECTORY are set (or just only if O_REGULAR is\nset, we need to return -EINVAL)? I am already returning -EINVAL when\nboth these are set from the build_open_flags function, so that should\nalready handle the cases, right? I think after atomic_open get called,\nall code paths eventually go through the do_open function where I have\nthis check \"if ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\nreturn -ENOTREG\". This is right before if ((nd->flags &\nLOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry)) return -ENOTDIR;\nwhich I had initially followed. So should I just return -EINVAL from\nthe atomic_open functions too if both O_REGULAR and O_DIRECTORY are\nset? Sorry if I am misunderstanding this.\n\nRegards,\nDorjoy",
          "reply_to": "Jeff Layton",
          "message_date": "2026-01-28"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author is considering renaming the O_REGULAR flag to O2_REGULAR, creating a new flag set for openat2 flags, and removing the sfmt_mask handling code.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "considering alternative approach",
            "open to suggestions"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Good discussion. So should I just rename the O_REGULAR to O2_REGULAR\nand create a VALID_OPENAT2_FLAGS and no need to do how->sfmt_mask\nstuff?",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author acknowledges that ENOTREG might be an acceptable error code, but no clear resolution or agreement on the specific error code to use.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledges feedback",
            "no clear resolution"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Good point. Maybe ENOTREG is acceptable too?\n\nRegards,\nDorjoy",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer suggested that new flag additions, like O_REGULAR, should follow the naming convention of being prefixed with 'O2_' or 'OEXT_', instead of just 'O_'.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "convention",
            "naming"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "We don't have any openat2(2)-only O_* flags yet, I agree that new flag\nadditions (except for very rare cases where you can make them backward\ncompatible -- such as a hypothetical O_EMPTYPATH) should be O2_* or\nOEXT_* or something.",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer noted that the new O_REGULAR flag should be placed in the 64-bit flag space, exclusive to openat2(2), to avoid confusion and potential conflicts with existing flags.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Yeah, if we don't do that it'll lead to confusion. openat2(2) has\nexclusive rights to the 64-bit flag bits so we could start with those\nbefore we need to cross with the O_* flag space.",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer noted that the O_REGULAR flag has an unfortunate overlap with block/char devices and directories, suggesting filtering on S_IFCHR to block both types of devices",
          "sentiment": "neutral",
          "sentiment_signals": [
            "overlap",
            "unfortunate"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Well, you can filter on S_IFCHR if you want to block both block/char\ndevices, but yeah the overlap is quite unfortunate... (That would also\nmean blocking directories would also block S_IFBLK -- I remembered there\nwas an overlap but I forgot it coincided with S_IFDIR... Damn wacky\nAPIs.)",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer noted that the current flags (O_REGULAR, O_DIRECTORY, and O_NOFOLLOW) do not cover all possible use cases, specifically allowing FIFOs, regular files, and directories while blocking everything else.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "There's also O_NOFOLLOW in a similar vein.\n\nI can see someone wanting to permit FIFOs, regular files, and\ndirectories being fine but blocking everything else. None of O_REGULAR,\nO_DIRECTORY, nor O_NOFOLLOW provide that.",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer noted that using three to five error numbers (errnos) for the O_REGULAR flag would be wasteful, given that there are already four existing errnos that are logical inverses.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "wasteful use of resources"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "It might be kinda neat from a potential re-use perspective in other APIs\nbut yeah it would be quite wasteful to burn 3-5 errnos for this when we\nalready have ~4 that are logical inverses.",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer suggested reusing the existing ENOTREG error code and wording its message to make it applicable for other places in the kernel.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "suggested improvement"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I think that would be reasonable and if you word the error message\ncarefully you can even see it being a fairly generic errno for other\nplaces to use.\n\n-- \nAleksa Sarai\nhttps://www.cyphar.com/",
          "reply_to": "Mateusz Guzik",
          "message_date": "2026-01-28"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-01-27": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "The author is addressing concerns about the O_REGULAR flag's behavior when used in combination with other flags like O_CREAT and O_DIRECTORY. They explained that either a regular file is created or if the path already exists, it is opened if it's a regular file; otherwise, -ENOTREG is returned. The author also clarified that -EINVAL is returned when O_REGULAR is combined with O_DIRECTORY because it doesn't make sense to open a path that is both a directory and a regular file.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "This flag indicates the path should be opened if it's a regular file.\nThis is useful to write secure programs that want to avoid being tricked\ninto opening device nodes with special semantics while thinking they\noperate on regular files.\n\nA corresponding error code ENOTREG has been introduced. For example, if\nopen is called on path /dev/null with O_REGULAR in the flag param, it\nwill return -ENOTREG.\n\nWhen used in combination with O_CREAT, either the regular file is\ncreated, or if the path already exists, it is opened if it's a regular\nfile. Otherwise, -ENOTREG is returned.\n\n-EINVAL is returned when O_REGULAR is combined with O_DIRECTORY (not\npart of O_TMPFILE) because it doesn't make sense to open a path that\nis both a directory and a regular file.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n arch/alpha/include/uapi/asm/errno.h        | 2 ++\n arch/alpha/include/uapi/asm/fcntl.h        | 1 +\n arch/mips/include/uapi/asm/errno.h         | 2 ++\n arch/parisc/include/uapi/asm/errno.h       | 2 ++\n arch/parisc/include/uapi/asm/fcntl.h       | 1 +\n arch/sparc/include/uapi/asm/errno.h        | 2 ++\n arch/sparc/include/uapi/asm/fcntl.h        | 1 +\n fs/fcntl.c                                 | 2 +-\n fs/namei.c                                 | 6 ++++++\n fs/open.c                                  | 4 +++-\n include/linux/fcntl.h                      | 2 +-\n include/uapi/asm-generic/errno.h           | 2 ++\n include/uapi/asm-generic/fcntl.h           | 4 ++++\n tools/arch/alpha/include/uapi/asm/errno.h  | 2 ++\n tools/arch/mips/include/uapi/asm/errno.h   | 2 ++\n tools/arch/parisc/include/uapi/asm/errno.h | 2 ++\n tools/arch/sparc/include/uapi/asm/errno.h  | 2 ++\n tools/include/uapi/asm-generic/errno.h     | 2 ++\n 18 files changed, 38 insertions(+), 3 deletions(-)\n\ndiff --git a/arch/alpha/include/uapi/asm/errno.h b/arch/alpha/include/uapi/asm/errno.h\nindex 6791f6508632..8bbcaa9024f9 100644\n--- a/arch/alpha/include/uapi/asm/errno.h\n+++ b/arch/alpha/include/uapi/asm/errno.h\n@@ -127,4 +127,6 @@\n \n #define EHWPOISON\t139\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t140\t/* Not a regular file */\n+\n #endif\ndiff --git a/arch/alpha/include/uapi/asm/fcntl.h b/arch/alpha/include/uapi/asm/fcntl.h\nindex 50bdc8e8a271..4da5a64c23bd 100644\n--- a/arch/alpha/include/uapi/asm/fcntl.h\n+++ b/arch/alpha/include/uapi/asm/fcntl.h\n@@ -34,6 +34,7 @@\n \n #define O_PATH\t\t040000000\n #define __O_TMPFILE\t0100000000\n+#define O_REGULAR\t0200000000\n \n #define F_GETLK\t\t7\n #define F_SETLK\t\t8\ndiff --git a/arch/mips/include/uapi/asm/errno.h b/arch/mips/include/uapi/asm/errno.h\nindex c01ed91b1ef4..293c78777254 100644\n--- a/arch/mips/include/uapi/asm/errno.h\n+++ b/arch/mips/include/uapi/asm/errno.h\n@@ -126,6 +126,8 @@\n \n #define EHWPOISON\t168\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t169\t/* Not a regular file */\n+\n #define EDQUOT\t\t1133\t/* Quota exceeded */\n \n \ndiff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h\nindex 8cbc07c1903e..442917484f99 100644\n--- a/arch/parisc/include/uapi/asm/errno.h\n+++ b/arch/parisc/include/uapi/asm/errno.h\n@@ -124,4 +124,6 @@\n \n #define EHWPOISON\t257\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t258\t/* Not a regular file */\n+\n #endif\ndiff --git a/arch/parisc/include/uapi/asm/fcntl.h b/arch/parisc/include/uapi/asm/fcntl.h\nindex 03dee816cb13..0cc3320fe326 100644\n--- a/arch/parisc/include/uapi/asm/fcntl.h\n+++ b/arch/parisc/include/uapi/asm/fcntl.h\n@@ -19,6 +19,7 @@\n \n #define O_PATH\t\t020000000\n #define __O_TMPFILE\t040000000\n+#define O_REGULAR\t0100000000\n \n #define F_GETLK64\t8\n #define F_SETLK64\t9\ndiff --git a/arch/sparc/include/uapi/asm/errno.h b/arch/sparc/include/uapi/asm/errno.h\nindex 4a41e7835fd5..8dce0bfeab74 100644\n--- a/arch/sparc/include/uapi/asm/errno.h\n+++ b/arch/sparc/include/uapi/asm/errno.h\n@@ -117,4 +117,6 @@\n \n #define EHWPOISON\t135\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t136\t/* Not a regular file */\n+\n #endif\ndiff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\nindex 67dae75e5274..a93d18d2c23e 100644\n--- a/arch/sparc/include/uapi/asm/fcntl.h\n+++ b/arch/sparc/include/uapi/asm/fcntl.h\n@@ -37,6 +37,7 @@\n \n #define O_PATH\t\t0x1000000\n #define __O_TMPFILE\t0x2000000\n+#define O_REGULAR\t0x4000000\n \n #define F_GETOWN\t5\t/*  for sockets. */\n #define F_SETOWN\t6\t/*  for sockets. */\ndiff --git a/fs/fcntl.c b/fs/fcntl.c\nindex f93dbca08435..62ab4ad2b6f5 100644\n--- a/fs/fcntl.c\n+++ b/fs/fcntl.c\n@@ -1169,7 +1169,7 @@ static int __init fcntl_init(void)\n \t * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY\n \t * is defined as O_NONBLOCK on some platforms and not on others.\n \t */\n-\tBUILD_BUG_ON(20 - 1 /* for O_RDONLY being 0 */ !=\n+\tBUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=\n \t\tHWEIGHT32(\n \t\t\t(VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n \t\t\t__FMODE_EXEC));\ndiff --git a/fs/namei.c b/fs/namei.c\nindex b28ecb699f32..f5504ae4b03c 100644\n--- a/fs/namei.c\n+++ b/fs/namei.c\n@@ -4616,6 +4616,10 @@ static int do_open(struct nameidata *nd,\n \t\tif (unlikely(error))\n \t\t\treturn error;\n \t}\n+\n+\tif ((open_flag & O_REGULAR) && !d_is_reg(nd->path.dentry))\n+\t\treturn -ENOTREG;\n+\n \tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n \t\treturn -ENOTDIR;\n \n@@ -4765,6 +4769,8 @@ static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n \tstruct path path;\n \tint error = path_lookupat(nd, flags, &path);\n \tif (!error) {\n+\t\tif ((file->f_flags & O_REGULAR) && !d_is_reg(path.dentry))\n+\t\t\treturn -ENOTREG;\n \t\taudit_inode(nd->name, path.dentry, 0);\n \t\terror = vfs_open(&path, file);\n \t\tpath_put(&path);\ndiff --git a/fs/open.c b/fs/open.c\nindex 74c4c1462b3e..82153e21907e 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -1173,7 +1173,7 @@ struct file *kernel_file_open(const struct path *path, int flags,\n EXPORT_SYMBOL_GPL(kernel_file_open);\n \n #define WILL_CREATE(flags)\t(flags & (O_CREAT | __O_TMPFILE))\n-#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC)\n+#define O_PATH_FLAGS\t\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC | O_REGULAR)\n \n inline struct open_how build_open_how(int flags, umode_t mode)\n {\n@@ -1250,6 +1250,8 @@ inline int build_open_flags(const struct open_how *how, struct open_flags *op)\n \t\t\treturn -EINVAL;\n \t\tif (!(acc_mode & MAY_WRITE))\n \t\t\treturn -EINVAL;\n+\t} else if ((flags & O_DIRECTORY) && (flags & O_REGULAR)) {\n+\t\treturn -EINVAL;\n \t}\n \tif (flags & O_PATH) {\n \t\t/* O_PATH only permits certain other flags to be set. */\ndiff --git a/include/linux/fcntl.h b/include/linux/fcntl.h\nindex a332e79b3207..4fd07b0e0a17 100644\n--- a/include/linux/fcntl.h\n+++ b/include/linux/fcntl.h\n@@ -10,7 +10,7 @@\n \t(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \\\n \t O_APPEND | O_NDELAY | O_NONBLOCK | __O_SYNC | O_DSYNC | \\\n \t FASYNC\t| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \\\n-\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)\n+\t O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_REGULAR)\n \n /* List of all valid flags for the how->resolve argument: */\n #define VALID_RESOLVE_FLAGS \\\ndiff --git a/include/uapi/asm-generic/errno.h b/include/uapi/asm-generic/errno.h\nindex 92e7ae493ee3..2216ab9aa32e 100644\n--- a/include/uapi/asm-generic/errno.h\n+++ b/include/uapi/asm-generic/errno.h\n@@ -122,4 +122,6 @@\n \n #define EHWPOISON\t133\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t134\t/* Not a regular file */\n+\n #endif\ndiff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h\nindex 613475285643..3468b352a575 100644\n--- a/include/uapi/asm-generic/fcntl.h\n+++ b/include/uapi/asm-generic/fcntl.h\n@@ -88,6 +88,10 @@\n #define __O_TMPFILE\t020000000\n #endif\n \n+#ifndef O_REGULAR\n+#define O_REGULAR\t040000000\n+#endif\n+\n /* a horrid kludge trying to make sure that this will fail on old kernels */\n #define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)\n \ndiff --git a/tools/arch/alpha/include/uapi/asm/errno.h b/tools/arch/alpha/include/uapi/asm/errno.h\nindex 6791f6508632..8bbcaa9024f9 100644\n--- a/tools/arch/alpha/include/uapi/asm/errno.h\n+++ b/tools/arch/alpha/include/uapi/asm/errno.h\n@@ -127,4 +127,6 @@\n \n #define EHWPOISON\t139\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t140\t/* Not a regular file */\n+\n #endif\ndiff --git a/tools/arch/mips/include/uapi/asm/errno.h b/tools/arch/mips/include/uapi/asm/errno.h\nindex c01ed91b1ef4..293c78777254 100644\n--- a/tools/arch/mips/include/uapi/asm/errno.h\n+++ b/tools/arch/mips/include/uapi/asm/errno.h\n@@ -126,6 +126,8 @@\n \n #define EHWPOISON\t168\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t169\t/* Not a regular file */\n+\n #define EDQUOT\t\t1133\t/* Quota exceeded */\n \n \ndiff --git a/tools/arch/parisc/include/uapi/asm/errno.h b/tools/arch/parisc/include/uapi/asm/errno.h\nindex 8cbc07c1903e..442917484f99 100644\n--- a/tools/arch/parisc/include/uapi/asm/errno.h\n+++ b/tools/arch/parisc/include/uapi/asm/errno.h\n@@ -124,4 +124,6 @@\n \n #define EHWPOISON\t257\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t258\t/* Not a regular file */\n+\n #endif\ndiff --git a/tools/arch/sparc/include/uapi/asm/errno.h b/tools/arch/sparc/include/uapi/asm/errno.h\nindex 4a41e7835fd5..8dce0bfeab74 100644\n--- a/tools/arch/sparc/include/uapi/asm/errno.h\n+++ b/tools/arch/sparc/include/uapi/asm/errno.h\n@@ -117,4 +117,6 @@\n \n #define EHWPOISON\t135\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t136\t/* Not a regular file */\n+\n #endif\ndiff --git a/tools/include/uapi/asm-generic/errno.h b/tools/include/uapi/asm-generic/errno.h\nindex 92e7ae493ee3..2216ab9aa32e 100644\n--- a/tools/include/uapi/asm-generic/errno.h\n+++ b/tools/include/uapi/asm-generic/errno.h\n@@ -122,4 +122,6 @@\n \n #define EHWPOISON\t133\t/* Memory page has hardware error */\n \n+#define ENOTREG\t\t134\t/* Not a regular file */\n+\n #endif\n-- \n2.52.0",
          "reply_to": "",
          "message_date": "2026-01-27"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "The author is addressing a concern about the implementation of O_REGULAR flag support, specifically that it doesn't work as intended in certain cases. They are adding a new test case to cover this scenario and updating the existing code to handle it correctly.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged fix needed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Just a happy path test.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n .../testing/selftests/openat2/openat2_test.c  | 37 ++++++++++++++++++-\n 1 file changed, 36 insertions(+), 1 deletion(-)\n\ndiff --git a/tools/testing/selftests/openat2/openat2_test.c b/tools/testing/selftests/openat2/openat2_test.c\nindex 0e161ef9e9e4..011ebc9af4e5 100644\n--- a/tools/testing/selftests/openat2/openat2_test.c\n+++ b/tools/testing/selftests/openat2/openat2_test.c\n@@ -320,8 +320,42 @@ void test_openat2_flags(void)\n \t}\n }\n \n+#ifndef O_REGULAR\n+#define O_REGULAR 040000000\n+#endif\n+\n+#ifndef ENOTREG\n+#define ENOTREG 134\n+#endif\n+\n+void test_openat2_o_regular_flag(void)\n+{\n+\tif (!openat2_supported) {\n+\t\tksft_test_result_skip(\"Skipping %s as openat2 is not supported\\n\", __func__);\n+\t\treturn;\n+\t}\n+\n+\tstruct open_how how = {\n+\t\t.flags = O_REGULAR | O_RDONLY\n+\t};\n+\n+\tint fd = sys_openat2(AT_FDCWD, \"/dev/null\", &how);\n+\n+\tif (fd == ENOENT) {\n+\t\tksft_test_result_skip(\"Skipping %s as there is no /dev/null\\n\", __func__);\n+\t\treturn;\n+\t}\n+\n+\tif (fd != -ENOTREG) {\n+\t\tksft_test_result_fail(\"openat2 should return ENOTREG\\n\");\n+\t\treturn;\n+\t}\n+\n+\tksft_test_result_pass(\"%s succeeded\\n\", __func__);\n+}\n+\n #define NUM_TESTS (NUM_OPENAT2_STRUCT_VARIATIONS * NUM_OPENAT2_STRUCT_TESTS + \\\n-\t\t   NUM_OPENAT2_FLAG_TESTS)\n+\t\t   NUM_OPENAT2_FLAG_TESTS + 1)\n \n int main(int argc, char **argv)\n {\n@@ -330,6 +364,7 @@ int main(int argc, char **argv)\n \n \ttest_openat2_struct();\n \ttest_openat2_flags();\n+\ttest_openat2_o_regular_flag();\n \n \tif (ksft_get_fail_cnt() + ksft_get_error_cnt() > 0)\n \t\tksft_exit_fail();\n-- \n2.52.0",
          "reply_to": "",
          "message_date": "2026-01-27"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "The author is addressing a concern about the O_REGULAR flag's behavior when combined with other flags like O_CREAT, specifically in arch/sparc/include/uapi/asm/fcntl.h. They are following the convention in include/uapi/asm-generic/fcntl.h and other architecture-specific files by converting hex values to octal, which resolves the issue.",
          "sentiment": "positive",
          "sentiment_signals": [
            "resolved",
            "convention"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Following the convention in include/uapi/asm-generic/fcntl.h and other\narchitecture specific arch/*/include/uapi/asm/fcntl.h files.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n arch/sparc/include/uapi/asm/fcntl.h | 36 ++++++++++++++---------------\n 1 file changed, 18 insertions(+), 18 deletions(-)\n\ndiff --git a/arch/sparc/include/uapi/asm/fcntl.h b/arch/sparc/include/uapi/asm/fcntl.h\nindex a93d18d2c23e..3c16f1a66a6a 100644\n--- a/arch/sparc/include/uapi/asm/fcntl.h\n+++ b/arch/sparc/include/uapi/asm/fcntl.h\n@@ -2,23 +2,23 @@\n #ifndef _SPARC_FCNTL_H\n #define _SPARC_FCNTL_H\n \n-#define O_APPEND\t0x0008\n-#define FASYNC\t\t0x0040\t/* fcntl, for BSD compatibility */\n-#define O_CREAT\t\t0x0200\t/* not fcntl */\n-#define O_TRUNC\t\t0x0400\t/* not fcntl */\n-#define O_EXCL\t\t0x0800\t/* not fcntl */\n-#define O_DSYNC\t\t0x2000\t/* used to be O_SYNC, see below */\n-#define O_NONBLOCK\t0x4000\n+#define O_APPEND\t0000000010\n+#define FASYNC\t\t0000000100\t/* fcntl, for BSD compatibility */\n+#define O_CREAT\t\t0000001000\t/* not fcntl */\n+#define O_TRUNC\t\t0000002000\t/* not fcntl */\n+#define O_EXCL\t\t0000004000\t/* not fcntl */\n+#define O_DSYNC\t\t0000020000\t/* used to be O_SYNC, see below */\n+#define O_NONBLOCK\t0000040000\n #if defined(__sparc__) && defined(__arch64__)\n-#define O_NDELAY\t0x0004\n+#define O_NDELAY\t0000000004\n #else\n-#define O_NDELAY\t(0x0004 | O_NONBLOCK)\n+#define O_NDELAY\t(0000000004 | O_NONBLOCK)\n #endif\n-#define O_NOCTTY\t0x8000\t/* not fcntl */\n-#define O_LARGEFILE\t0x40000\n-#define O_DIRECT        0x100000 /* direct disk access hint */\n-#define O_NOATIME\t0x200000\n-#define O_CLOEXEC\t0x400000\n+#define O_NOCTTY\t0000100000\t/* not fcntl */\n+#define O_LARGEFILE\t0001000000\n+#define O_DIRECT        0004000000 /* direct disk access hint */\n+#define O_NOATIME\t0010000000\n+#define O_CLOEXEC\t0020000000\n /*\n  * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using\n  * the O_SYNC flag.  We continue to use the existing numerical value\n@@ -32,12 +32,12 @@\n  *\n  * Note: __O_SYNC must never be used directly.\n  */\n-#define __O_SYNC\t0x800000\n+#define __O_SYNC\t0040000000\n #define O_SYNC\t\t(__O_SYNC|O_DSYNC)\n \n-#define O_PATH\t\t0x1000000\n-#define __O_TMPFILE\t0x2000000\n-#define O_REGULAR\t0x4000000\n+#define O_PATH\t\t0100000000\n+#define __O_TMPFILE\t0200000000\n+#define O_REGULAR\t0400000000\n \n #define F_GETOWN\t5\t/*  for sockets. */\n #define F_SETOWN\t6\t/*  for sockets. */\n-- \n2.52.0",
          "reply_to": "",
          "message_date": "2026-01-27"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "The author addressed a concern about the O_REGULAR flag's behavior in combination with other flags like O_CREAT, explaining that they followed the convention in include/uapi/asm-generic/fcntl.h and other architecture-specific files by converting the hex values to octal. The author made changes to arch/mips/include/uapi/asm/fcntl.h to match this convention.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Following the convention in include/uapi/asm-generic/fcntl.h and other\narchitecture specific arch/*/include/uapi/asm/fcntl.h files.\n\nSigned-off-by: Dorjoy Chowdhury <dorjoychy111@gmail.com>\n---\n arch/mips/include/uapi/asm/fcntl.h | 22 +++++++++++-----------\n 1 file changed, 11 insertions(+), 11 deletions(-)\n\ndiff --git a/arch/mips/include/uapi/asm/fcntl.h b/arch/mips/include/uapi/asm/fcntl.h\nindex 0369a38e3d4f..6aa3f49df17e 100644\n--- a/arch/mips/include/uapi/asm/fcntl.h\n+++ b/arch/mips/include/uapi/asm/fcntl.h\n@@ -11,15 +11,15 @@\n \n #include <asm/sgidefs.h>\n \n-#define O_APPEND\t0x0008\n-#define O_DSYNC\t\t0x0010\t/* used to be O_SYNC, see below */\n-#define O_NONBLOCK\t0x0080\n-#define O_CREAT\t\t0x0100\t/* not fcntl */\n-#define O_TRUNC\t\t0x0200\t/* not fcntl */\n-#define O_EXCL\t\t0x0400\t/* not fcntl */\n-#define O_NOCTTY\t0x0800\t/* not fcntl */\n-#define FASYNC\t\t0x1000\t/* fcntl, for BSD compatibility */\n-#define O_LARGEFILE\t0x2000\t/* allow large file opens */\n+#define O_APPEND\t0000010\n+#define O_DSYNC\t\t0000020\t/* used to be O_SYNC, see below */\n+#define O_NONBLOCK\t0000200\n+#define O_CREAT\t\t0000400\t/* not fcntl */\n+#define O_TRUNC\t\t0001000\t/* not fcntl */\n+#define O_EXCL\t\t0002000\t/* not fcntl */\n+#define O_NOCTTY\t0004000\t/* not fcntl */\n+#define FASYNC\t\t0010000\t/* fcntl, for BSD compatibility */\n+#define O_LARGEFILE\t0020000\t/* allow large file opens */\n /*\n  * Before Linux 2.6.33 only O_DSYNC semantics were implemented, but using\n  * the O_SYNC flag.  We continue to use the existing numerical value\n@@ -33,9 +33,9 @@\n  *\n  * Note: __O_SYNC must never be used directly.\n  */\n-#define __O_SYNC\t0x4000\n+#define __O_SYNC\t0040000\n #define O_SYNC\t\t(__O_SYNC|O_DSYNC)\n-#define O_DIRECT\t0x8000\t/* direct disk access hint */\n+#define O_DIRECT\t0100000\t/* direct disk access hint */\n \n #define F_GETLK\t\t14\n #define F_SETLK\t\t6\n-- \n2.52.0",
          "reply_to": "",
          "message_date": "2026-01-27"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that the patch lacks handling for ->atomic_open() operations, which most filesystems cannot support properly, and suggested adding patches to return -EINVAL if O_REGULAR is set.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "missing functionality",
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "One thing this patch is missing is handling for ->atomic_open(). I\nimagine most of the filesystems that provide that op can't support\nO_REGULAR properly (maybe cifs can? idk). What you probably want to do\nis add in some patches that make all of the atomic_open operations in\nthe kernel return -EINVAL if O_REGULAR is set.\n\nThen, once the basic support is in, you or someone else can go back and\nimplement support for O_REGULAR where possible.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-01-27"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-01-29": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Christian Brauner",
          "summary": "Reviewer Christian Brauner expressed concerns about adding O_REGULAR flag support outside of openat2(), suggesting it should be prefixed with OPENAT2_ and not made exclusive with O_DIRECTORY, and instead proposed using EFTYPE as the errno code.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "suggested improvements"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Yeah, we shouldn't add support for this outside of openat2(). We also\nshouldn't call this OEXT_* or O2_*. Let's just follow the pattern where\nwe prefix the flag space with the name of the system call\nOPENAT2_REGULAR.\n\nThere's also no real need to make O_DIRECTORY exclusive with\nOPENAT2_REGULAR. Callers could legimitately want to open a directory or\nregular file but not anything else. If someone wants to operate on a\nwhole filesystem tree but only wants to interact with regular files and\ndirectories and ignore devices, sockets, fifos etc it's very handy to\njust be able to set both in flags.\n\nFrankly, this shouldn't be a flag at all but we already have O_DIRECTORY\nin there so no need to move this into a new field.\n\nAdd EFTYPE as the errno code. Some of the bsds including macos already\nhave that.",
          "reply_to": "Dorjoy Chowdhury",
          "message_date": "2026-01-29"
        },
        {
          "author": "Christian Brauner",
          "summary": "Reviewer Christian Brauner noted that the patch's intention to block O_REGULAR for ->atomic_open:: is problematic because it may break filesystems that handle this case correctly, and suggested bypassing ->atomic_open:: for OPENAT2_REGULAR without O_CREAT or implementing a protocol extension.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "concern about potential breakage"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "So I think you're proposing two separate things or there's a typo:\n\n(1) blocking O_DIRECTORY for ->atomic_open::\n(2) blocking O_REGULAR for ->atomic_open::\n\nThe (1) point implies that O_DIRECTORY currently doesn't work correctly\nwith atomic open for all filesystems.\n\nEver since 43b450632676 (\"open: return EINVAL for O_DIRECTORY |\nO_CREAT\") O_DIRECTORY with O_CREAT is blocked. It was accidently allowed\nand completely broken before that.\n\nFor O_DIRECTORY without O_CREAT the kernel will pass that down through\n->atomic_open:: to the filesystem.\n\nThe worry that I see is that a network filesystem via ->atomic_open::\nsomehow already called open on the server side on something that wasn't\na directory. At that point the damage such as side-effects from device\nopening is already done.\n                                    \nBut I suspect that every filesystem implementing ->atomic_open:: just\ndoes finish_no_open() and punts to the VFS for the actual open. And the\nVFS will catch it in do_open() for it actually opens the file. So the\nonly real worry for O_DIRECTORY I see is that there's an fs that handles\nit wrong.\n\nFor (2) it is problematic as there surely are filesystems with\n->atomic_open:: that do handle the ~O_CREAT case and return with\nFMODE_OPENED. So that'll be problematic if the intention is to not\ntrigger an actual open on a non-regular file such as a\ndevice/socket/fifo etc. before the VFS had a chance to validate what's\ngoing on.\n\nSo I'm not excited about having this 70% working and punting on\n->atomic_open:: waiting for someone to fix this. One option would be to\nbypass ->atomic_open:: for OPENAT2_REGULAR without O_CREAT and fallback\nto racy and pricy lookup + open for now. How problematic would that be?\nIf possible I'd prefer this a lot over merging something that works\nhalf-way.\n\nI guess to make that really work you'd need some protocol extension?",
          "reply_to": "Jeff Layton",
          "message_date": "2026-01-29"
        },
        {
          "author": "Jeff Layton",
          "summary": "reviewer noted that sending an immediate close would have unintended consequences",
          "sentiment": "neutral",
          "sentiment_signals": [
            "NEUTRAL",
            "side effects"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Exactly. I guess you could send an immediate close, but that's not\nwithout side effects.",
          "reply_to": "Christian Brauner",
          "message_date": "2026-01-29"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that O_REGULAR flag support may need to be handled differently in various file systems, specifically mentioning NFS and cifs as potential issues.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "potential issues"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "For NFS, I think we're OK. The OPEN call on NFSv4 only works for\nregular files, so it should be able to handle O_REGULAR. We just need\nto rejigger the error handling when it's set (just return an error\ninstead of doing the open of a directory or whatever it is).\n\nThe others (at a quick glance):\n\ncifs: I don't see a way to specify an O_REGULAR equivalent to the\nSMB2_CREATE call and it looks like it can create directories. Maybe\nSteveF (cc'ed) knows if this is possible?\n\nceph: I think CEPH_MDS_OP_OPEN might only work for files, in which case\nO_REGULAR can probably be supported similarly to NFS.\n\nfuse: probably ok? Does finish_no_open() in most cases. May depend on\nthe userland driver though.\n\ngfs2: is ok, it just does finish_no_open() in most cases anyway\n\nvboxsf: does finish_no_open on non-creates, so you could probably just\npunt to that if O_REGULAR is set.\n\nSo, it's probably possible to do this across the board. I'm not sure\nabout cifs though.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Christian Brauner",
          "message_date": "2026-01-29"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton pointed out that SMB2 has an existing flag (FILE_NON_DIRECTORY_FILE) that enforces the same behavior as O_REGULAR, and suggested considering its implications on file types like directories, named pipes, and printer files.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "considering existing SMB2 flag",
            "implications on file types"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "SMB2 does have this flag:\n\nFILE_NON_DIRECTORY_FILE 0x00000040\n\nIf the name of the file being created or opened matches with an\nexisting directory file, the server MUST fail the request with\nSTATUS_FILE_IS_A_DIRECTORY. This flag MUST NOT be used with\nFILE_DIRECTORY_FILE or the server MUST fail the request with\nSTATUS_INVALID_PARAMETER.\n\nSMB2 can also present named pipes and printer files. Not sure if there\nis a way to exclude those with this.",
          "reply_to": "",
          "message_date": "2026-01-29"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that the O_REGULAR flag does not prevent opening directories, and requested a review of the MDS (Memory Description Structure) code to determine if it can be done in a non-racy way.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Actually I'm wrong here. That op can open a directory. We'll need\nsomeone to look at the MDS code and tell us whether this can be done in\na non-racy way.",
          "reply_to": "",
          "message_date": "2026-01-29"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that O_DIRECTORY flag handling is not broken on other file systems, specifically mentioning NFS as an example, and expressed no concerns about the patch",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no specific technical issue raised"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "It looks like NFS at least handles O_DIRECTORY properly. I don't have\nany reason to believe that O_DIRECTORY handling is broken on the\nothers.",
          "reply_to": "Christian Brauner",
          "message_date": "2026-01-29"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author agrees that OPENAT2_REGULAR is a better option than OEXT_*/O2_* options, but asks if it should be defined outside the 32-bit range to avoid conflicts with existing flags and only need to be defined in include/uapi/asm-generic/fcntl.h.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarifying question",
            "request for feedback"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Thanks for the feedback. I agree that OPENAT2_REGULAR is better than\nthe other OEXT_*/O2_* options. Right now in the patch, the O_REGULAR\ntook the next slot in all the fcntl files. Should OPENAT2_REGULAR be a\nbit outside of the 32bits? That way it won't take any of the regular\nO_* bits and we would only need to define it in\ninclude/uapi/asm-generic/fcntl.h file and not need it in\narch/*/fcntl.h files. What do you think?",
          "reply_to": "Christian Brauner",
          "message_date": "2026-01-29"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author acknowledged a need to address Christian Brauner's feedback about the O_REGULAR flag's interaction with other flags like O_CREAT, agreeing to fix this in v4.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a need for revision",
            "agreed to fix"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Great suggestion. Will fixup in v4 submission.\n\nRegards,\nDorjoy",
          "reply_to": "Christian Brauner",
          "message_date": "2026-01-29"
        },
        {
          "author": "Aleksa Sarai",
          "summary": "Reviewer noted that using a bitmask of S_IFMT to reject opening certain file types would be similar in spirit to O_NOFOLLOW, but pointed out that S_IFBLK is a combination of S_IFCHR and S_IFDIR, which complicates the idea.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "NEUTRAL"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "You could even say O_NOFOLLOW is kinda like that too.\n\nIn my other mail I proposed a bitmask of S_IFMT to reject opening (which\nwould let you allow FIFOs and regular files but block devices, etc).\nUnfortunately I forgot that S_IFBLK is S_IFCHR|S_IFDIR. This isn't fatal\nto the idea but it kinda sucks. Grr.",
          "reply_to": "Christian Brauner",
          "message_date": "2026-01-29"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author agrees that introducing a new how->sfmt_allow field with separate bits for file types is a good suggestion, but expresses concern about the complexity of using different bits as an API.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledges feedback",
            "expresses concern"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "It is a good suggestion. I guess we can still introduce a new\nhow->sfmt_allow field and have new bits (instead of keeping in sync\nwith S_IF* ones) that allow types and just start with regular file\nallow bit for now, right? But I guess it would be cumbersome for users\nas an api to use different bits?\n\nRegards,\nDorjoy",
          "reply_to": "Aleksa Sarai",
          "message_date": "2026-01-29"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-19": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author is seeking clarification on which code path the O_REGULAR flag's error handling should occur in, specifically asking if it's inode_operations.atomic_open or file_operations.open.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarifying question"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Thank you for the details. Do you remember which codepath this is? Is\nthis the inode_operations.atomic_open codepath or file_operations.open\ncodepath? I am a bit confused also about where exactly the error\nhandling that needs to be done.",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "The author is clarifying that the atomic_open code paths are being addressed, specifically mentioning finish_no_open in inode_operations.atomic_open.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "question"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "These are all inode_operations.atomic_open code paths, right? Because\nyou mentioned finish_no_open and I see finish_no_open in the\natomic_open code paths as opposed to file_operations.open code paths.\n\nRegards,\nDorjoy",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "The author acknowledges that O_REGULAR needs to be handled as an unknown flag in addition to NFS, and is considering this for future revisions.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledges a fix is needed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Right. And I guess we don't need to worry about O_REGULAR being an\nunknown flag when it gets sent to the server (not only for NFS / but\nothers as well)?",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author acknowledged that O_REGULAR flag handling is needed in additional filesystems and asked if modifying corresponding file_operations.open code paths is also required.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a fix is needed",
            "asked for clarification"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "I can try to look into these and see if I can implement handling for\nO_REGULAR flag for these filesystems in the atomic_open code paths.\nThanks for the details.\n\nWill I need to modify the corresponding file_operations.open code\npaths as well along with atomic_open code paths?\n\nRegards,\nDorjoy",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        },
        {
          "author": "Dorjoy Chowdhury (author)",
          "summary": "Author acknowledged Jeff's feedback and expressed gratitude, indicating no further action is needed.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledgment",
            "gratitude"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Understood. Thanks!\n\nRegards,\nDorjoy",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    }
  }
}