<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: [PATCH v5 29/32] mm: memcontrol: prepare for reparenting non-hierarchical stats</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }
        .reply-to-label {
            font-size: 0.8em;
            color: #999;
            font-style: italic;
            margin-top: 3px;
        }
        .lore-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 0.82em;
            color: #0366d6;
            text-decoration: none;
            font-weight: 500;
            white-space: nowrap;
        }
        .lore-link:hover { text-decoration: underline; color: #0056b3; }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../index.html">&larr; Back to reports</a></div>
    <h1>[PATCH v5 29/32] mm: memcontrol: prepare for reparenting non-hierarchical stats</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/aZ-R87JfacQ2gGq1@linux.dev/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-27">2026-02-27</a> &bull; <a href="#2026-02-26">2026-02-26</a></div>
    <div class="patch-summary-block"><div class="patch-summary-label">Patch summary</div><div class="patch-summary-text">Conversion of objcg to per-memcg per-node type in mm: memcontrol</div></div>
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-26">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-26_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-26">2026-02-26</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Raised a question about whether page/folio/slab points to the same node&#x27;s objcg for a given memcg, but didn&#x27;t express an opinion on the patch itself.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Thu, Feb 26, 2026 at 07:16:50AM -0800, Yosry Ahmed wrote:
&gt; &gt; &gt; Did you measure the impact of making state_local atomic on the flush
&gt; &gt; &gt; path? It&#x27;s a slow path but we&#x27;ve seen pain from it being too slow
&gt; &gt; &gt; before, because it extends the critical section of the rstat flush
&gt; &gt; &gt; lock.
&gt; &gt;
&gt; &gt; Qi, please measure the impact on flushing and if no impact then no need to do
&gt; &gt; anything as I don&#x27;t want anymore churn in this series.
&gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Can we keep this non-atomic and use mod_memcg_lruvec_state() here? It
&gt; &gt; &gt; will update the stat on the local counter and it will be added to
&gt; &gt; &gt; state_local in the flush path when needed. We can even force another
&gt; &gt; &gt; flush in reparent_state_local () after reparenting is completed, if we
&gt; &gt; &gt; want to avoid leaving a potentially large stat update pending, as it
&gt; &gt; &gt; can be missed by mem_cgroup_flush_stats_ratelimited().
&gt; &gt; &gt;
&gt; &gt; &gt; Same for reparent_memcg_state_local(), we can probably use mod_memcg_state()?
&gt; &gt;
&gt; &gt; Yosry, do you mind sending the patch you are thinking about over this series?
&gt; 
&gt; Honestly, I&#x27;d rather squash it into this patch if possible. It avoids
&gt; churn in the history (switch to atomics and back), and is arguably
&gt; simpler than checking for regressions in the flush path.

Yup, let&#x27;s squash it into the original patch. Please add your sign-off tag.

&gt; 
&gt; What I have in mind is the diff below (build tested only). Qi, would
&gt; you be able to test this? It applies directly on this patch in mm-new:

Qi, please squash this diff into the patch and test. You might need to change
the subsequent patches. Once you are done with testing, you can post the diffs
for those in reply to those patches and we will ask Andrew to squash into
orinigal ones.

The diff looks good to me though.
&gt; 
&gt; diff --git a/mm/memcontrol.c b/mm/memcontrol.c
&gt; index d82dbfcc28057..404565e80cbf3 100644
&gt; --- a/mm/memcontrol.c
&gt; +++ b/mm/memcontrol.c
&gt; @@ -234,11 +234,18 @@ static inline void reparent_state_local(struct
&gt; mem_cgroup *memcg, struct mem_cgr
&gt;         if (cgroup_subsys_on_dfl(memory_cgrp_subsys))
&gt;                 return;
&gt; 
&gt; +       /*
&gt; +        * Reparent stats exposed non-hierarchically. Flush @memcg&#x27;s
&gt; stats first to
&gt; +        * read its stats accurately , and conservatively flush @parent&#x27;s stats
&gt; +        * after reparenting to avoid hiding a potentially large stat update
&gt; +        * (e.g. from callers of mem_cgroup_flush_stats_ratelimited()).
&gt; +        */
&gt;         __mem_cgroup_flush_stats(memcg, true);
&gt; 
&gt; -       /* The following counts are all non-hierarchical and need to
&gt; be reparented. */
&gt;         reparent_memcg1_state_local(memcg, parent);
&gt;         reparent_memcg1_lruvec_state_local(memcg, parent);
&gt; +
&gt; +       __mem_cgroup_flush_stats(parent, true);
&gt;  }
&gt;  #else
&gt;  static inline void reparent_state_local(struct mem_cgroup *memcg,
&gt; struct mem_cgroup *parent)
&gt; @@ -442,7 +449,7 @@ struct lruvec_stats {
&gt;         long state[NR_MEMCG_NODE_STAT_ITEMS];
&gt; 
&gt;         /* Non-hierarchical (CPU aggregated) state */
&gt; -       atomic_long_t state_local[NR_MEMCG_NODE_STAT_ITEMS];
&gt; +       long state_local[NR_MEMCG_NODE_STAT_ITEMS];
&gt; 
&gt;         /* Pending child counts during tree propagation */
&gt;         long state_pending[NR_MEMCG_NODE_STAT_ITEMS];
&gt; @@ -485,7 +492,7 @@ unsigned long lruvec_page_state_local(struct lruvec *lruvec,
&gt;                 return 0;
&gt; 
&gt;         pn = container_of(lruvec, struct mem_cgroup_per_node, lruvec);
&gt; -       x = atomic_long_read(&amp;(pn-&gt;lruvec_stats-&gt;state_local[i]));
&gt; +       x = READ_ONCE(pn-&gt;lruvec_stats-&gt;state_local[i]);
&gt;  #ifdef CONFIG_SMP
&gt;         if (x &lt; 0)
&gt;                 x = 0;
&gt; @@ -493,6 +500,10 @@ unsigned long lruvec_page_state_local(struct
&gt; lruvec *lruvec,
&gt;         return x;
&gt;  }
&gt; 
&gt; +static void mod_memcg_lruvec_state(struct lruvec *lruvec,
&gt; +                                  enum node_stat_item idx,
&gt; +                                  int val);
&gt; +
&gt;  #ifdef CONFIG_MEMCG_V1
&gt;  void reparent_memcg_lruvec_state_local(struct mem_cgroup *memcg,
&gt;                                        struct mem_cgroup *parent, int idx)
&gt; @@ -506,12 +517,10 @@ void reparent_memcg_lruvec_state_local(struct
&gt; mem_cgroup *memcg,
&gt;         for_each_node(nid) {
&gt;                 struct lruvec *child_lruvec = mem_cgroup_lruvec(memcg,
&gt; NODE_DATA(nid));
&gt;                 struct lruvec *parent_lruvec =
&gt; mem_cgroup_lruvec(parent, NODE_DATA(nid));
&gt; -               struct mem_cgroup_per_node *parent_pn;
&gt;                 unsigned long value =
&gt; lruvec_page_state_local(child_lruvec, idx);
&gt; 
&gt; -               parent_pn = container_of(parent_lruvec, struct
&gt; mem_cgroup_per_node, lruvec);
&gt; -
&gt; -               atomic_long_add(value,
&gt; &amp;(parent_pn-&gt;lruvec_stats-&gt;state_local[i]));
&gt; +               mod_memcg_lruvec_state(child_lruvec, idx, -value);
&gt; +               mod_memcg_lruvec_state(parent_lruvec, idx, value);
&gt;         }
&gt;  }
&gt;  #endif
&gt; @@ -598,7 +607,7 @@ struct memcg_vmstats {
&gt;         unsigned long           events[NR_MEMCG_EVENTS];
&gt; 
&gt;         /* Non-hierarchical (CPU aggregated) page state &amp; events */
&gt; -       atomic_long_t           state_local[MEMCG_VMSTAT_SIZE];
&gt; +       long                    state_local[MEMCG_VMSTAT_SIZE];
&gt;         unsigned long           events_local[NR_MEMCG_EVENTS];
&gt; 
&gt;         /* Pending child counts during tree propagation */
&gt; @@ -835,7 +844,7 @@ unsigned long memcg_page_state_local(struct
&gt; mem_cgroup *memcg, int idx)
&gt;         if (WARN_ONCE(BAD_STAT_IDX(i), &quot;%s: missing stat item %d\n&quot;,
&gt; __func__, idx))
&gt;                 return 0;
&gt; 
&gt; -       x = atomic_long_read(&amp;(memcg-&gt;vmstats-&gt;state_local[i]));
&gt; +       x = READ_ONCE(memcg-&gt;vmstats-&gt;state_local[i]);
&gt;  #ifdef CONFIG_SMP
&gt;         if (x &lt; 0)
&gt;                 x = 0;
&gt; @@ -852,7 +861,8 @@ void reparent_memcg_state_local(struct mem_cgroup *memcg,
&gt;         if (WARN_ONCE(BAD_STAT_IDX(i), &quot;%s: missing stat item %d\n&quot;,
&gt; __func__, idx))
&gt;                 return;
&gt; 
&gt; -       atomic_long_add(value, &amp;(parent-&gt;vmstats-&gt;state_local[i]));
&gt; +       mod_memcg_state(memcg, idx, -value);
&gt; +       mod_memcg_state(parent, idx, value);
&gt;  }
&gt;  #endif
&gt; 
&gt; @@ -4174,8 +4184,6 @@ struct aggregate_control {
&gt;         long *aggregate;
&gt;         /* pointer to the non-hierarchichal (CPU aggregated) counters */
&gt;         long *local;
&gt; -       /* pointer to the atomic non-hierarchichal (CPU aggregated) counters */
&gt; -       atomic_long_t *alocal;
&gt;         /* pointer to the pending child counters during tree propagation */
&gt;         long *pending;
&gt;         /* pointer to the parent&#x27;s pending counters, could be NULL */
&gt; @@ -4213,12 +4221,8 @@ static void mem_cgroup_stat_aggregate(struct
&gt; aggregate_control *ac)
&gt;                 }
&gt; 
&gt;                 /* Aggregate counts on this level and propagate upwards */
&gt; -               if (delta_cpu) {
&gt; -                       if (ac-&gt;local)
&gt; -                               ac-&gt;local[i] += delta_cpu;
&gt; -                       else if (ac-&gt;alocal)
&gt; -                               atomic_long_add(delta_cpu, &amp;(ac-&gt;alocal[i]));
&gt; -               }
&gt; +               if (delta_cpu)
&gt; +                       ac-&gt;local[i] += delta_cpu;
&gt; 
&gt;                 if (delta) {
&gt;                         ac-&gt;aggregate[i] += delta;
&gt; @@ -4289,8 +4293,7 @@ static void mem_cgroup_css_rstat_flush(struct
&gt; cgroup_subsys_state *css, int cpu)
&gt; 
&gt;         ac = (struct aggregate_control) {
&gt;                 .aggregate = memcg-&gt;vmstats-&gt;state,
&gt; -               .local = NULL,
&gt; -               .alocal = memcg-&gt;vmstats-&gt;state_local,
&gt; +               .local = memcg-&gt;vmstats-&gt;state_local,
&gt;                 .pending = memcg-&gt;vmstats-&gt;state_pending,
&gt;                 .ppending = parent ? parent-&gt;vmstats-&gt;state_pending : NULL,
&gt;                 .cstat = statc-&gt;state,
&gt; @@ -4323,8 +4326,7 @@ static void mem_cgroup_css_rstat_flush(struct
&gt; cgroup_subsys_state *css, int cpu)
&gt; 
&gt;                 ac = (struct aggregate_control) {
&gt;                         .aggregate = lstats-&gt;state,
&gt; -                       .local = NULL,
&gt; -                       .alocal = lstats-&gt;state_local,
&gt; +                       .local = lstats-&gt;state_local,
&gt;                         .pending = lstats-&gt;state_pending,
&gt;                         .ppending = plstats ? plstats-&gt;state_pending : NULL,
&gt;                         .cstat = lstatc-&gt;state,
</pre>
</details>
</div>
<div class="thread-children">
<div class="thread-node depth-1" id="2026-02-27">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Qi Zheng</span>
<a class="date-chip" href="../2026-02-26_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-27">2026-02-27</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Addressed Shakeel&#x27;s concern by stating that maybe not, and suggested changing the comparison to objcg-&gt;memcg equality.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">

On 2/27/26 4:05 AM, Shakeel Butt wrote:
&gt; On Wed, Feb 25, 2026 at 05:44:56PM +0800, Qi Zheng wrote:
&gt;&gt; From: Qi Zheng &lt;zhengqi.arch@bytedance.com&gt;
&gt;&gt;
&gt;&gt; Convert objcg to be per-memcg per-node type, so that when reparent LRU
&gt;&gt; folios later, we can hold the lru lock at the node level, thus avoiding
&gt;&gt; holding too many lru locks at once.
&gt;&gt;
&gt;&gt; Signed-off-by: Qi Zheng &lt;zhengqi.arch@bytedance.com&gt;
&gt;&gt; ---
&gt;&gt; changlog:
&gt;&gt;   - fix a missing root_obj_cgroup conversion and completely delete
&gt;&gt;     root_obj_cgroup.
&gt;&gt;
&gt; 
&gt; After this patch, do we care that page/folio/slab points to the objcg of the
&gt; same node as them for a given memcg?

Maybe not. My only concern is whether the kernel has a way of
determining whether two folios belong to the same memcg by checking if
the objcg pointers are equal. If so, it needs to be changed to check if
objcg-&gt;memcg are equal.

&gt; 


</pre>
</details>
<div class="reply-to-label">&#8627; replying to Shakeel Butt</div>
</div>
</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>