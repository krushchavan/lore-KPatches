<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [LSF/MM/BPF TOPIC] Namespace-aware upcalls from kernel filesystems</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [LSF/MM/BPF TOPIC] Namespace-aware upcalls from kernel filesystems</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/785793ea21fb65c3e721b51f24897b3000e4aec3.camel@kernel.org/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-17">2026-02-17</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-17">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Chuck Lever</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Chuck Lever suggested using existing namespace-aware netlink control interfaces, specifically mentioning their use in kernel TLS handshake and NFSD protocols.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">
On Sat, Feb 14, 2026, at 5:06 AM, Shyam Prasad N wrote:
&gt; Kernel filesystems sometimes need to upcall to userspace to get some
&gt; work done, which cannot be achieved in kernel code (or rather it is
&gt; better to be done in userspace). Some examples are DNS resolutions,
&gt; user authentication, ID mapping etc.
&gt;
&gt; Filesystems like SMB and NFS clients use the kernel keys subsystem for
&gt; some of these, which has an upcall facility that can exec a binary in
&gt; userspace. However, this upcall mechanism is not namespace aware and
&gt; upcalls to the host namespaces (namespaces of the init process).

Hello Shyam, we&#x27;ve been introducing netlink control interfaces, which
are namespace-aware. The kernel TLS handshake mechanism now uses
this approach, as does the new NFSD netlink protocol.


-- 
Chuck Lever


---



On Mon, Feb 16, 2026, at 11:14 PM, Shyam Prasad N wrote:
&gt; On Sat, Feb 14, 2026 at 9:10 PM Chuck Lever &lt;cel@kernel.org&gt; wrote:
&gt;&gt;
&gt;&gt;
&gt;&gt; On Sat, Feb 14, 2026, at 5:06 AM, Shyam Prasad N wrote:
&gt;&gt; &gt; Kernel filesystems sometimes need to upcall to userspace to get some
&gt;&gt; &gt; work done, which cannot be achieved in kernel code (or rather it is
&gt;&gt; &gt; better to be done in userspace). Some examples are DNS resolutions,
&gt;&gt; &gt; user authentication, ID mapping etc.
&gt;&gt; &gt;
&gt;&gt; &gt; Filesystems like SMB and NFS clients use the kernel keys subsystem for
&gt;&gt; &gt; some of these, which has an upcall facility that can exec a binary in
&gt;&gt; &gt; userspace. However, this upcall mechanism is not namespace aware and
&gt;&gt; &gt; upcalls to the host namespaces (namespaces of the init process).
&gt;&gt;
&gt;&gt; Hello Shyam, we&#x27;ve been introducing netlink control interfaces, which
&gt;&gt; are namespace-aware. The kernel TLS handshake mechanism now uses
&gt;&gt; this approach, as does the new NFSD netlink protocol.
&gt;&gt;
&gt;&gt;
&gt;&gt; --
&gt;&gt; Chuck Lever
&gt;
&gt; Hi Chuck,
&gt;
&gt; Interesting. Let me explore this a bit more.
&gt; I&#x27;m assuming that this is the file that I should be looking into:
&gt; fs/nfsd/nfsctl.c

Yes, clustered towards the end of the file. NFSD&#x27;s use of netlink
is as a downcall-style administrative control plane.

net/handshake/netlink.c uses netlink as an upcall for driving
kernel-initiated TLS handshake requests up to a user daemon. This
mechanism has been adopted by NFSD, the NFS client, and the NVMe
over TCP drivers. An in-kernel QUIC implementation is planned and
will also be using this.


&gt; And that there would be a corresponding handler in nfs-utils?

For NFSD, nfs-utils has a new tool called nfsdctl.

The TLS handshake user space components are in ktls-utils. See:
https://github.com/oracle/ktls-utils

-- 
Chuck Lever
</pre>
</details>
<div class="review-comment-signals">Signals: suggested alternative approach, provided examples of existing implementations</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">David Leadbeater</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer David Leadbeater raised concerns about the safety of entering the right namespaces for upcalls from kernel filesystems, citing potential issues with seccomp and other container runtime limits.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Sat, Feb 14, 2026 at 03:36:22PM +0530, Shyam Prasad N wrote:
&gt; I tried to prototype a namespace aware upcall mechanism for kernel keys here:
&gt; https://www.spinics.net/lists/keyrings/msg17581.html
&gt; But it has not been successful so far. I&#x27;m seeking reviews on this
&gt; approach from security point of view.

I have more context from the containers side, but to me this doesn&#x27;t
appear safe. Entering the right namespaces isn&#x27;t enough to safely run
code within a container. The container runtime may have set up seccomp
or other limits which this upcall won&#x27;t respect.

I would like to see a solution to this though, we currently have custom
callback code to make this work. I&#x27;m not familiar enough with the
interfaces but an approach where something registers also seems
desirable because it is able to preserve backwards compatibility, which
changing the namespace the upcall runs in doesn&#x27;t.

David
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, potential security issue</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shyam N (author)</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shyam N asked for more exploration of the issue, specifically looking into a file in fs/nfsd and considering seccomp visibility.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Sat, Feb 14, 2026 at 9:10 PM Chuck Lever &lt;cel@kernel.org&gt; wrote:
&gt;
&gt;
&gt; On Sat, Feb 14, 2026, at 5:06 AM, Shyam Prasad N wrote:
&gt; &gt; Kernel filesystems sometimes need to upcall to userspace to get some
&gt; &gt; work done, which cannot be achieved in kernel code (or rather it is
&gt; &gt; better to be done in userspace). Some examples are DNS resolutions,
&gt; &gt; user authentication, ID mapping etc.
&gt; &gt;
&gt; &gt; Filesystems like SMB and NFS clients use the kernel keys subsystem for
&gt; &gt; some of these, which has an upcall facility that can exec a binary in
&gt; &gt; userspace. However, this upcall mechanism is not namespace aware and
&gt; &gt; upcalls to the host namespaces (namespaces of the init process).
&gt;
&gt; Hello Shyam, we&#x27;ve been introducing netlink control interfaces, which
&gt; are namespace-aware. The kernel TLS handshake mechanism now uses
&gt; this approach, as does the new NFSD netlink protocol.
&gt;
&gt;
&gt; --
&gt; Chuck Lever

Hi Chuck,

Interesting. Let me explore this a bit more.
I&#x27;m assuming that this is the file that I should be looking into:
fs/nfsd/nfsctl.c
And that there would be a corresponding handler in nfs-utils?

-- 
Regards,
Shyam


---

On Mon, Feb 16, 2026 at 6:25 AM David Leadbeater &lt;dgl@dgl.cx&gt; wrote:
&gt;
&gt; On Sat, Feb 14, 2026 at 03:36:22PM +0530, Shyam Prasad N wrote:
&gt; &gt; I tried to prototype a namespace aware upcall mechanism for kernel keys here:
&gt; &gt; https://www.spinics.net/lists/keyrings/msg17581.html
&gt; &gt; But it has not been successful so far. I&#x27;m seeking reviews on this
&gt; &gt; approach from security point of view.
&gt;
&gt; I have more context from the containers side, but to me this doesn&#x27;t
&gt; appear safe. Entering the right namespaces isn&#x27;t enough to safely run
&gt; code within a container. The container runtime may have set up seccomp
&gt; or other limits which this upcall won&#x27;t respect.

Hi David,
Thanks for these comments.
Let me look into seccomp to see if kernel will have any visibility into it.

&gt;
&gt; I would like to see a solution to this though, we currently have custom
&gt; callback code to make this work. I&#x27;m not familiar enough with the
&gt; interfaces but an approach where something registers also seems
&gt; desirable because it is able to preserve backwards compatibility, which
&gt; changing the namespace the upcall runs in doesn&#x27;t.

Ack. Will explore the options and get back to this thread.

&gt;
&gt; David
&gt;


-- 
Regards,
Shyam
</pre>
</details>
<div class="review-comment-signals">Signals: NEEDS_WORK</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Jeff Layton</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer raised concerns about the original approach to namespace-aware upcalls and suggested moving away from usermodehelper as an upcall mechanism, citing a lack of container objects in the Linux kernel.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, 2026-02-17 at 09:21 -0500, Chuck Lever wrote:
&gt; 
&gt; On Mon, Feb 16, 2026, at 11:14 PM, Shyam Prasad N wrote:
&gt; &gt; On Sat, Feb 14, 2026 at 9:10 PM Chuck Lever &lt;cel@kernel.org&gt; wrote:
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; On Sat, Feb 14, 2026, at 5:06 AM, Shyam Prasad N wrote:
&gt; &gt; &gt; &gt; Kernel filesystems sometimes need to upcall to userspace to get some
&gt; &gt; &gt; &gt; work done, which cannot be achieved in kernel code (or rather it is
&gt; &gt; &gt; &gt; better to be done in userspace). Some examples are DNS resolutions,
&gt; &gt; &gt; &gt; user authentication, ID mapping etc.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Filesystems like SMB and NFS clients use the kernel keys subsystem for
&gt; &gt; &gt; &gt; some of these, which has an upcall facility that can exec a binary in
&gt; &gt; &gt; &gt; userspace. However, this upcall mechanism is not namespace aware and
&gt; &gt; &gt; &gt; upcalls to the host namespaces (namespaces of the init process).
&gt; &gt; &gt; 
&gt; &gt; &gt; Hello Shyam, we&#x27;ve been introducing netlink control interfaces, which
&gt; &gt; &gt; are namespace-aware. The kernel TLS handshake mechanism now uses
&gt; &gt; &gt; this approach, as does the new NFSD netlink protocol.
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; --
&gt; &gt; &gt; Chuck Lever
&gt; &gt; 
&gt; &gt; Hi Chuck,
&gt; &gt; 
&gt; &gt; Interesting. Let me explore this a bit more.
&gt; &gt; I&#x27;m assuming that this is the file that I should be looking into:
&gt; &gt; fs/nfsd/nfsctl.c
&gt; 
&gt; Yes, clustered towards the end of the file. NFSD&#x27;s use of netlink
&gt; is as a downcall-style administrative control plane.
&gt; 
&gt; net/handshake/netlink.c uses netlink as an upcall for driving
&gt; kernel-initiated TLS handshake requests up to a user daemon. This
&gt; mechanism has been adopted by NFSD, the NFS client, and the NVMe
&gt; over TCP drivers. An in-kernel QUIC implementation is planned and
&gt; will also be using this.
&gt; 
&gt; 
&gt; &gt; And that there would be a corresponding handler in nfs-utils?
&gt; 
&gt; For NFSD, nfs-utils has a new tool called nfsdctl.
&gt; 
&gt; The TLS handshake user space components are in ktls-utils. See:
&gt; https://github.com/oracle/ktls-utils


I think the consensus at this point is to move away from usermodehelper
as an upcall mechanism. The Linux kernel lacks a container object that
allows you to associate namespaces with one another, so you need an
already-running userspace process to do that association in userland.

netlink upcalls are bound to a network namespace. That works in the
above examples because they are also bound to a network namespace.
netlink upcalls require a running daemon in that namespace, which is
what ties that network namespace to other sorts of namespaces.

So, a related discussion we should have is whether and how we should
deprecate the old usermodehelper upcalls, given that they are
problematic in this way. 
-- 
Jeff Layton &lt;jlayton@kernel.org&gt;

</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, suggested alternative</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>