{
  "thread_id": "aY99MytyXnECJuel@cmpxchg.org",
  "subject": "Re: [PATCH v9] mm/page_alloc: boost watermarks on atomic allocation failure",
  "url": "https://lore.kernel.org/all/aY99MytyXnECJuel@cmpxchg.org/",
  "dates": {
    "2026-02-13": {
      "report_file": "2026-02-13_ollama_llama3.1-8b.html",
      "developer": "Johannes Weiner",
      "reviews": [
        {
          "author": "Vlastimil Babka",
          "summary": "Vlastimil Babka raised concerns about the hardcoded value of 1000 in the patch, suggesting that it makes little sense without the constant being used elsewhere. He also expressed disagreement with the use of mult_frac() for a simple right shift operation.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "disagreement"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On 2/13/26 04:17, Qiliang Yuan wrote:\n> Atomic allocations (GFP_ATOMIC) are prone to failure under heavy memory\n> pressure as they cannot enter direct reclaim. This patch introduces a\n> watermark boost mechanism to mitigate this issue.\n> \n> When a GFP_ATOMIC request enters the slowpath, the preferred zone's\n> watermark_boost is increased under zone->lock protection. This triggers\n> kswapd to proactively reclaim memory, creating a safety buffer for\n> future atomic allocations. A 1-second debounce timer prevents excessive\n> boosts during traffic bursts.\n> \n> This approach reuses existing watermark_boost infrastructure with\n> minimal overhead and proper locking to ensure thread safety.\n> \n> Allocation failure logs:\n> [38535644.718700] node 0: slabs: 1031, objs: 43328, free: 0\n> [38535644.725059] node 1: slabs: 339, objs: 17616, free: 317\n> [38535645.428345] SLUB: Unable to allocate memory on node -1, gfp=0x480020(GFP_ATOMIC)\n> [38535645.436888] cache: skbuff_head_cache, object size: 232, buffer size: 256, default order: 2, min order: 0\n> [38535645.447664] node 0: slabs: 940, objs: 40864, free: 144\n> [38535645.454026] node 1: slabs: 322, objs: 19168, free: 383\n> [38535645.556122] SLUB: Unable to allocate memory on node -1, gfp=0x480020(GFP_ATOMIC)\n> [38535645.564576] cache: skbuff_head_cache, object size: 232, buffer size: 256, default order: 2, min order: 0\n> [38535649.655523] warn_alloc: 59 callbacks suppressed\n> [38535649.655527] swapper/100: page allocation failure: order:0, mode:0x480020(GFP_ATOMIC), nodemask=(null)\n> [38535649.671692] swapper/100 cpuset=/ mems_allowed=0-1\n> \n> Acked-by: Vlastimil Babka <vbabka@suse.cz>\n> Signed-off-by: Qiliang Yuan <realwujing@gmail.com>\n> ---\n> v9:\n> - Use mult_frac() for boost calculation. (SJ)\n> - Add !can_direct_reclaim check. (Vlastimil)\n> - Code cleanup: naming, scope, and line limits. (SJ)\n> - Update tags: Add Vlastimil's Acked-by.\n> \n> v8:\n> - Use spin_lock_irqsave() to prevent inconsistent lock state.\n> \n> v7:\n> - Use local variable for boost_amount.\n> - Add zone->lock protection.\n> - Add lockdep assertion.\n> \n> v6:\n> - Use ATOMIC_BOOST_SCALE_SHIFT define.\n> - Add documentation for 0.1% rationale.\n> \n> v5:\n> - Use native boost_watermark().\n> \n> v4:\n> - Add watermark_scale_boost and gradual decay.\n> \n> v3:\n> - Per-zone debounce timer.\n> \n> v2:\n> - Debounce logic and zone-proportional boosting.\n> \n> v1:\n> - Initial version.\n> ---\n> Link to v8: https://lore.kernel.org/r/20260212-wujing-mm-page_alloc-v8-v8-1-daba38990cd3@gmail.com\n> ---\n>  include/linux/mmzone.h |  1 +\n>  mm/page_alloc.c        | 49 +++++++++++++++++++++++++++++++++++++++++++++++--\n>  2 files changed, 48 insertions(+), 2 deletions(-)\n> \n> diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h\n> index 75ef7c9f9307..8e37e4e6765b 100644\n> --- a/include/linux/mmzone.h\n> +++ b/include/linux/mmzone.h\n> @@ -882,6 +882,7 @@ struct zone {\n>  \t/* zone watermarks, access with *_wmark_pages(zone) macros */\n>  \tunsigned long _watermark[NR_WMARK];\n>  \tunsigned long watermark_boost;\n> +\tunsigned long last_boost_jiffies;\n>  \n>  \tunsigned long nr_reserved_highatomic;\n>  \tunsigned long nr_free_highatomic;\n> diff --git a/mm/page_alloc.c b/mm/page_alloc.c\n> index c380f063e8b7..8af88584a8bd 100644\n> --- a/mm/page_alloc.c\n> +++ b/mm/page_alloc.c\n> @@ -218,6 +218,13 @@ unsigned int pageblock_order __read_mostly;\n>  static void __free_pages_ok(struct page *page, unsigned int order,\n>  \t\t\t    fpi_t fpi_flags);\n>  \n> +/*\n> + * Boost watermarks by ~0.1% of zone size on atomic allocation pressure.\n> + * This provides zone-proportional safety buffers: ~1MB per 1GB of zone size.\n> + * Larger zones under GFP_ATOMIC pressure need proportionally larger reserves.\n> + */\n> +#define ATOMIC_BOOST_FACTOR 1\n\n... so now we #define 1 but it makes little sense without that hardcoded\n1000 below.\n\n> +\n>  /*\n>   * results with 256, 32 in the lowmem_reserve sysctl:\n>   *\t1G machine -> (16M dma, 800M-16M normal, 1G-800M high)\n> @@ -2161,6 +2168,9 @@ bool pageblock_unisolate_and_move_free_pages(struct zone *zone, struct page *pag\n>  static inline bool boost_watermark(struct zone *zone)\n>  {\n>  \tunsigned long max_boost;\n> +\tunsigned long boost_amount;\n> +\n> +\tlockdep_assert_held(&zone->lock);\n>  \n>  \tif (!watermark_boost_factor)\n>  \t\treturn false;\n> @@ -2189,12 +2199,43 @@ static inline bool boost_watermark(struct zone *zone)\n>  \n>  \tmax_boost = max(pageblock_nr_pages, max_boost);\n>  \n> -\tzone->watermark_boost = min(zone->watermark_boost + pageblock_nr_pages,\n> -\t\tmax_boost);\n> +\tboost_amount = max(pageblock_nr_pages,\n> +\t\t\t   mult_frac(zone_managed_pages(zone), ATOMIC_BOOST_FACTOR, 1000));\n\nI don't think mult_frac() was a great suggestion. We're talking about right\nshifting by a constant 10. In the other cases of mult_frac() we use dynamic\nvalues for x and n so it's justified. But this IMHO is unnecessary complication.\n\n> +\tzone->watermark_boost = min(zone->watermark_boost + boost_amount,\n> +\t\t\t\t    max_boost);\n>  \n>  \treturn true;\n>  }\n>  \n> +static void boost_zone_for_atomic(struct alloc_context *ac, gfp_t gfp_mask)\n> +{\n> +\tstruct zoneref *z;\n> +\tstruct zone *zone;\n> +\tunsigned long now = jiffies;\n> +\n> +\tfor_each_zone_zonelist(zone, z, ac->zonelist, ac->highest_zoneidx) {\n> +\t\t/* Rate-limit boosts to once per second per zone */\n> +\t\tif (time_after(now, zone->last_boost_jiffies + HZ)) {\n> +\t\t\tunsigned long flags;\n> +\t\t\tbool should_wake;\n> +\n> +\t\t\tzone->last_boost_jiffies = now;\n> +\n> +\t\t\t/* Modify watermark under lock, wake kswapd outside */\n> +\t\t\tspin_lock_irqsave(&zone->lock, flags);\n> +\t\t\tshould_wake = boost_watermark(zone);\n> +\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n> +\n> +\t\t\tif (should_wake)\n> +\t\t\t\twakeup_kswapd(zone, gfp_mask, 0,\n> +\t\t\t\t\t      ac->highest_zoneidx);\n> +\n> +\t\t\t/* Boost only the preferred zone */\n> +\t\t\tbreak;\n> +\t\t}\n> +\t}\n> +}\n> +\n>  /*\n>   * When we are falling back to another migratetype during allocation, should we\n>   * try to claim an entire block to satisfy further allocations, instead of\n> @@ -4742,6 +4783,10 @@ __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n>  \tif (page)\n>  \t\tgoto got_pg;\n>  \n> +\t/* Boost watermarks for atomic requests entering slowpath */\n> +\tif ((gfp_mask & GFP_ATOMIC) && order == 0 && !can_direct_reclaim)\n> +\t\tboost_zone_for_atomic(ac, gfp_mask);\n> +\n>  \t/*\n>  \t * For costly allocations, try direct compaction first, as it's likely\n>  \t * that we have enough base pages and don't need to reclaim. For non-\n> \n> ---\n> base-commit: b54345928fa1dbde534e32ecaa138678fd5d2135\n> change-id: 20260206-wujing-mm-page_alloc-v8-fb1979bac6fe\n> \n> Best regards,\n\n",
          "reply_to": ""
        },
        {
          "author": "SeongJae Park",
          "summary": "Reviewer SeongJae Park suggested using a consistent denominator for the watermark boost calculation and proposed defining ATOMIC_BOOST_SHIFT as a constant local variable or hard-coding its value to improve readability.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "suggested improvement",
            "personal taste"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Fri, 13 Feb 2026 09:46:14 +0100 Vlastimil Babka <vbabka@suse.cz> wrote:\n\n> On 2/13/26 04:17, Qiliang Yuan wrote:\n> > Atomic allocations (GFP_ATOMIC) are prone to failure under heavy memory\n> > pressure as they cannot enter direct reclaim. This patch introduces a\n> > watermark boost mechanism to mitigate this issue.\n> > \n> > When a GFP_ATOMIC request enters the slowpath, the preferred zone's\n> > watermark_boost is increased under zone->lock protection. This triggers\n> > kswapd to proactively reclaim memory, creating a safety buffer for\n> > future atomic allocations. A 1-second debounce timer prevents excessive\n> > boosts during traffic bursts.\n> > \n> > This approach reuses existing watermark_boost infrastructure with\n> > minimal overhead and proper locking to ensure thread safety.\n[...]\n> > diff --git a/mm/page_alloc.c b/mm/page_alloc.c\n> > index c380f063e8b7..8af88584a8bd 100644\n> > --- a/mm/page_alloc.c\n> > +++ b/mm/page_alloc.c\n> > @@ -218,6 +218,13 @@ unsigned int pageblock_order __read_mostly;\n> >  static void __free_pages_ok(struct page *page, unsigned int order,\n> >  \t\t\t    fpi_t fpi_flags);\n> >  \n> > +/*\n> > + * Boost watermarks by ~0.1% of zone size on atomic allocation pressure.\n> > + * This provides zone-proportional safety buffers: ~1MB per 1GB of zone size.\n> > + * Larger zones under GFP_ATOMIC pressure need proportionally larger reserves.\n> > + */\n> > +#define ATOMIC_BOOST_FACTOR 1\n> \n> ... so now we #define 1 but it makes little sense without that hardcoded\n> 1000 below.\n\nI agree.  I think it could be easier to understand if we use 10000 as the\ndenominator, consistent to other similar ones, like watermark_scale_factor.\nOr, defining as a constant local variable or hard-coded value before its real\nsingle use case might be easier to read, for below-mentioned reason.\n\n> \n> > +\n> >  /*\n> >   * results with 256, 32 in the lowmem_reserve sysctl:\n> >   *\t1G machine -> (16M dma, 800M-16M normal, 1G-800M high)\n> > @@ -2161,6 +2168,9 @@ bool pageblock_unisolate_and_move_free_pages(struct zone *zone, struct page *pag\n> >  static inline bool boost_watermark(struct zone *zone)\n> >  {\n> >  \tunsigned long max_boost;\n> > +\tunsigned long boost_amount;\n> > +\n> > +\tlockdep_assert_held(&zone->lock);\n> >  \n> >  \tif (!watermark_boost_factor)\n> >  \t\treturn false;\n> > @@ -2189,12 +2199,43 @@ static inline bool boost_watermark(struct zone *zone)\n> >  \n> >  \tmax_boost = max(pageblock_nr_pages, max_boost);\n> >  \n> > -\tzone->watermark_boost = min(zone->watermark_boost + pageblock_nr_pages,\n> > -\t\tmax_boost);\n> > +\tboost_amount = max(pageblock_nr_pages,\n> > +\t\t\t   mult_frac(zone_managed_pages(zone), ATOMIC_BOOST_FACTOR, 1000));\n> \n> I don't think mult_frac() was a great suggestion. We're talking about right\n> shifting by a constant 10. In the other cases of mult_frac() we use dynamic\n> values for x and n so it's justified. But this IMHO is unnecessary complication.\n\nThis file uses multi_frac() in two places with hard-coded denominator 10000.\nHence I feel it is more consistent to use mutl_frac() with the same denominator\n(10000) and consistent naming.  In terms of overhead, I think the added\noverhead is negligible, since this is called only once per second.\n\nNo strong opinion but just a trivial and personal taste, though.  Right\nshifting should also be good to me. :)\n\nAnd now I find I was thinking the ATOMIC_BOOST_SHIFT coulb be better to be\nconsistent with other similar code, because it is defined as a macro.  That is,\nI was assuming it would be used in multiple places and therefore better to be\neasily understood by readers.  Now I find it is actually being used only here.\nWhat about defining it as a constant local variable here, or just hard-coding?\n\n\nThanks,\nSJ\n\n[...]\n",
          "reply_to": ""
        },
        {
          "author": "Johannes Weiner",
          "summary": "Johannes Weiner raised concerns about the patch's implementation of watermark boosting for atomic allocation failure. He suggested separating the paths for fragmentation management and atomic boosting, simplifying the mult_frac() calculation, and improving the logic for boosting all eligible zones.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "technical concerns"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Fri, Feb 13, 2026 at 11:17:59AM +0800, Qiliang Yuan wrote:\n> Atomic allocations (GFP_ATOMIC) are prone to failure under heavy memory\n> pressure as they cannot enter direct reclaim. This patch introduces a\n> watermark boost mechanism to mitigate this issue.\n> \n> When a GFP_ATOMIC request enters the slowpath, the preferred zone's\n> watermark_boost is increased under zone->lock protection. This triggers\n> kswapd to proactively reclaim memory, creating a safety buffer for\n> future atomic allocations. A 1-second debounce timer prevents excessive\n> boosts during traffic bursts.\n> \n> This approach reuses existing watermark_boost infrastructure with\n> minimal overhead and proper locking to ensure thread safety.\n> \n> Allocation failure logs:\n> [38535644.718700] node 0: slabs: 1031, objs: 43328, free: 0\n> [38535644.725059] node 1: slabs: 339, objs: 17616, free: 317\n> [38535645.428345] SLUB: Unable to allocate memory on node -1, gfp=0x480020(GFP_ATOMIC)\n> [38535645.436888] cache: skbuff_head_cache, object size: 232, buffer size: 256, default order: 2, min order: 0\n> [38535645.447664] node 0: slabs: 940, objs: 40864, free: 144\n> [38535645.454026] node 1: slabs: 322, objs: 19168, free: 383\n> [38535645.556122] SLUB: Unable to allocate memory on node -1, gfp=0x480020(GFP_ATOMIC)\n> [38535645.564576] cache: skbuff_head_cache, object size: 232, buffer size: 256, default order: 2, min order: 0\n> [38535649.655523] warn_alloc: 59 callbacks suppressed\n> [38535649.655527] swapper/100: page allocation failure: order:0, mode:0x480020(GFP_ATOMIC), nodemask=(null)\n> [38535649.671692] swapper/100 cpuset=/ mems_allowed=0-1\n> \n> Acked-by: Vlastimil Babka <vbabka@suse.cz>\n> Signed-off-by: Qiliang Yuan <realwujing@gmail.com>\n> ---\n> v9:\n> - Use mult_frac() for boost calculation. (SJ)\n> - Add !can_direct_reclaim check. (Vlastimil)\n> - Code cleanup: naming, scope, and line limits. (SJ)\n> - Update tags: Add Vlastimil's Acked-by.\n> \n> v8:\n> - Use spin_lock_irqsave() to prevent inconsistent lock state.\n> \n> v7:\n> - Use local variable for boost_amount.\n> - Add zone->lock protection.\n> - Add lockdep assertion.\n> \n> v6:\n> - Use ATOMIC_BOOST_SCALE_SHIFT define.\n> - Add documentation for 0.1% rationale.\n> \n> v5:\n> - Use native boost_watermark().\n> \n> v4:\n> - Add watermark_scale_boost and gradual decay.\n> \n> v3:\n> - Per-zone debounce timer.\n> \n> v2:\n> - Debounce logic and zone-proportional boosting.\n> \n> v1:\n> - Initial version.\n> ---\n> Link to v8: https://lore.kernel.org/r/20260212-wujing-mm-page_alloc-v8-v8-1-daba38990cd3@gmail.com\n> ---\n>  include/linux/mmzone.h |  1 +\n>  mm/page_alloc.c        | 49 +++++++++++++++++++++++++++++++++++++++++++++++--\n>  2 files changed, 48 insertions(+), 2 deletions(-)\n> \n> diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h\n> index 75ef7c9f9307..8e37e4e6765b 100644\n> --- a/include/linux/mmzone.h\n> +++ b/include/linux/mmzone.h\n> @@ -882,6 +882,7 @@ struct zone {\n>  \t/* zone watermarks, access with *_wmark_pages(zone) macros */\n>  \tunsigned long _watermark[NR_WMARK];\n>  \tunsigned long watermark_boost;\n> +\tunsigned long last_boost_jiffies;\n>  \n>  \tunsigned long nr_reserved_highatomic;\n>  \tunsigned long nr_free_highatomic;\n> diff --git a/mm/page_alloc.c b/mm/page_alloc.c\n> index c380f063e8b7..8af88584a8bd 100644\n> --- a/mm/page_alloc.c\n> +++ b/mm/page_alloc.c\n> @@ -218,6 +218,13 @@ unsigned int pageblock_order __read_mostly;\n>  static void __free_pages_ok(struct page *page, unsigned int order,\n>  \t\t\t    fpi_t fpi_flags);\n>  \n> +/*\n> + * Boost watermarks by ~0.1% of zone size on atomic allocation pressure.\n> + * This provides zone-proportional safety buffers: ~1MB per 1GB of zone size.\n> + * Larger zones under GFP_ATOMIC pressure need proportionally larger reserves.\n> + */\n> +#define ATOMIC_BOOST_FACTOR 1\n> +\n>  /*\n>   * results with 256, 32 in the lowmem_reserve sysctl:\n>   *\t1G machine -> (16M dma, 800M-16M normal, 1G-800M high)\n> @@ -2161,6 +2168,9 @@ bool pageblock_unisolate_and_move_free_pages(struct zone *zone, struct page *pag\n>  static inline bool boost_watermark(struct zone *zone)\n>  {\n>  \tunsigned long max_boost;\n> +\tunsigned long boost_amount;\n> +\n> +\tlockdep_assert_held(&zone->lock);\n>  \n>  \tif (!watermark_boost_factor)\n>  \t\treturn false;\n\nwatermark_boost_factor is for fragmentation management. It's valid to\nhave this set to 0 and still want boosting for atomic.\n\n> @@ -2189,12 +2199,43 @@ static inline bool boost_watermark(struct zone *zone)\n>  \n>  \tmax_boost = max(pageblock_nr_pages, max_boost);\n>  \n> -\tzone->watermark_boost = min(zone->watermark_boost + pageblock_nr_pages,\n> -\t\tmax_boost);\n> +\tboost_amount = max(pageblock_nr_pages,\n> +\t\t\t   mult_frac(zone_managed_pages(zone), ATOMIC_BOOST_FACTOR, 1000));\n> +\tzone->watermark_boost = min(zone->watermark_boost + boost_amount,\n> +\t\t\t\t    max_boost);\n\nLikewise, you don't want to add the atomic boost every time there is a\nfragmentation event. You need to separate these paths.\n\nThe mult_frac() with constants seems a bit funny to me. Just do\nzone_managed_pages(zone) / 1000, drop the define, and move the comment\nand move the comment here.\n\n> +static void boost_zone_for_atomic(struct alloc_context *ac, gfp_t gfp_mask)\n> +{\n> +\tstruct zoneref *z;\n> +\tstruct zone *zone;\n> +\tunsigned long now = jiffies;\n> +\n> +\tfor_each_zone_zonelist(zone, z, ac->zonelist, ac->highest_zoneidx) {\n\nfor_each_zone_zonelist_nodemask() with ac->nodemask?\n\n> +\t\t/* Rate-limit boosts to once per second per zone */\n> +\t\tif (time_after(now, zone->last_boost_jiffies + HZ)) {\n> +\t\t\tunsigned long flags;\n> +\t\t\tbool should_wake;\n> +\n> +\t\t\tzone->last_boost_jiffies = now;\n> +\n> +\t\t\t/* Modify watermark under lock, wake kswapd outside */\n> +\t\t\tspin_lock_irqsave(&zone->lock, flags);\n> +\t\t\tshould_wake = boost_watermark(zone);\n> +\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n> +\n> +\t\t\tif (should_wake)\n> +\t\t\t\twakeup_kswapd(zone, gfp_mask, 0,\n> +\t\t\t\t\t      ac->highest_zoneidx);\n> +\n> +\t\t\t/* Boost only the preferred zone */\n> +\t\t\tbreak;\n> +\t\t}\n> +\t}\n\nThis is a bit strange to me. By the time you boost, all eligible zones\nhave been tried, and ALL their reserves were found to be inadequate\nfor the incoming atomic requests. They all *should* be boosted.\n\nBy doing them one by one, you risk additional failures even though you\nalready KNOW at this point that these other zones are problematic too.\n\nSo IMO, by the time you reach here, they should all be boosted.\n\n> @@ -4742,6 +4783,10 @@ __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n>  \tif (page)\n>  \t\tgoto got_pg;\n>  \n> +\t/* Boost watermarks for atomic requests entering slowpath */\n> +\tif ((gfp_mask & GFP_ATOMIC) && order == 0 && !can_direct_reclaim)\n\nThis is a bit weird. GFP_ATOMIC is a mask, so this check will trigger\non anything that has __GFP_KSWAPD_RECLAIM set (which is most things),\nso in turn you then have to filter out direct reclaim again (which the\nreal GFP_ATOMIC implies).\n\n\tif (gfp_has_flags(gfp_mask, GFP_ATOMIC))\n\n> +\t\tboost_zone_for_atomic(ac, gfp_mask);\n> +\n\n",
          "reply_to": ""
        }
      ],
      "analysis_source": "llm"
    }
  }
}