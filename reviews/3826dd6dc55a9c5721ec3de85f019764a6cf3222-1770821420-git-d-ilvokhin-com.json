{
  "thread_id": "3826dd6dc55a9c5721ec3de85f019764a6cf3222.1770821420.git.d@ilvokhin.com",
  "subject": "[PATCH 1/4] mm: introduce zone lock wrappers",
  "url": "https://lore.kernel.org/all/3826dd6dc55a9c5721ec3de85f019764a6cf3222.1770821420.git.d@ilvokhin.com/",
  "dates": {
    "2026-02-23": {
      "report_file": "2026-02-23.html",
      "developer": "Dmitry Ilvokhin",
      "reviews": [
        {
          "author": "Shakeel Butt",
          "summary": "Any reason you used macros for above two and inlined functions for remaining?",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Wed, Feb 11, 2026 at 03:22:13PM +0000, Dmitry Ilvokhin wrote:\n> Add thin wrappers around zone lock acquire/release operations. This\n> prepares the code for future tracepoint instrumentation without\n> modifying individual call sites.\n> \n> Centralizing zone lock operations behind wrappers allows future\n> instrumentation or debugging hooks to be added without touching\n> all users.\n> \n> No functional change intended. The wrappers are introduced in\n> preparation for subsequent patches and are not yet used.\n> \n> Signed-off-by: Dmitry Ilvokhin <d@ilvokhin.com>\n> ---\n>  MAINTAINERS               |  1 +\n>  include/linux/zone_lock.h | 38 ++++++++++++++++++++++++++++++++++++++\n>  2 files changed, 39 insertions(+)\n>  create mode 100644 include/linux/zone_lock.h\n> \n> diff --git a/MAINTAINERS b/MAINTAINERS\n> index b4088f7290be..680c9ae02d7e 100644\n> --- a/MAINTAINERS\n> +++ b/MAINTAINERS\n> @@ -16498,6 +16498,7 @@ F:\tinclude/linux/pgtable.h\n>  F:\tinclude/linux/ptdump.h\n>  F:\tinclude/linux/vmpressure.h\n>  F:\tinclude/linux/vmstat.h\n> +F:\tinclude/linux/zone_lock.h\n>  F:\tkernel/fork.c\n>  F:\tmm/Kconfig\n>  F:\tmm/debug.c\n> diff --git a/include/linux/zone_lock.h b/include/linux/zone_lock.h\n> new file mode 100644\n> index 000000000000..c531e26280e6\n> --- /dev/null\n> +++ b/include/linux/zone_lock.h\n> @@ -0,0 +1,38 @@\n> +/* SPDX-License-Identifier: GPL-2.0 */\n> +#ifndef _LINUX_ZONE_LOCK_H\n> +#define _LINUX_ZONE_LOCK_H\n> +\n> +#include <linux/mmzone.h>\n> +#include <linux/spinlock.h>\n> +\n> +static inline void zone_lock_init(struct zone *zone)\n> +{\n> +\tspin_lock_init(&zone->lock);\n> +}\n> +\n> +#define zone_lock_irqsave(zone, flags)\t\t\t\t\\\n> +do {\t\t\t\t\t\t\t\t\\\n> +\tspin_lock_irqsave(&(zone)->lock, flags);\t\t\\\n> +} while (0)\n> +\n> +#define zone_trylock_irqsave(zone, flags)\t\t\t\\\n> +({\t\t\t\t\t\t\t\t\\\n> +\tspin_trylock_irqsave(&(zone)->lock, flags);\t\t\\\n> +})\n\nAny reason you used macros for above two and inlined functions for remaining?\n\n> +\n> +static inline void zone_unlock_irqrestore(struct zone *zone, unsigned long flags)\n> +{\n> +\tspin_unlock_irqrestore(&zone->lock, flags);\n> +}\n> +\n> +static inline void zone_lock_irq(struct zone *zone)\n> +{\n> +\tspin_lock_irq(&zone->lock);\n> +}\n> +\n> +static inline void zone_unlock_irq(struct zone *zone)\n> +{\n> +\tspin_unlock_irq(&zone->lock);\n> +}\n> +\n> +#endif /* _LINUX_ZONE_LOCK_H */\n> -- \n> 2.47.3\n> \n",
          "reply_to": "",
          "message_date": "2026-02-23",
          "message_id": ""
        }
      ],
      "analysis_source": "heuristic",
      "patch_summary": "Add thin wrappers around zone lock acquire/release operations. This prepares the code for future tracepoint instrumentation without modifying individual call sites.\n\nCentralizing zone lock operations behind wrappers allows future instrumentation or debugging hooks to be added without touching all users.\n\nNo functional change intended. The wrappers are introduced in preparation for subsequent patches and are not yet used."
    },
    "2026-02-24": {
      "report_file": "2026-02-24.html",
      "developer": "Dmitry Ilvokhin",
      "reviews": [
        {
          "author": "Dmitry Ilvokhin",
          "summary": "No substantive comments or reviews have been made yet, but the patch series appears to be a straightforward addition of tracepoints for zone lock acquire and release operations. The implementation follows a well-established pattern and is likely to be accepted once reviewed.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "WAITING_FOR_REVIEW"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Mon, Feb 23, 2026 at 02:36:01PM -0800, Shakeel Butt wrote:\n> On Wed, Feb 11, 2026 at 03:22:13PM +0000, Dmitry Ilvokhin wrote:\n> > Add thin wrappers around zone lock acquire/release operations. This\n> > prepares the code for future tracepoint instrumentation without\n> > modifying individual call sites.\n> > \n> > Centralizing zone lock operations behind wrappers allows future\n> > instrumentation or debugging hooks to be added without touching\n> > all users.\n> > \n> > No functional change intended. The wrappers are introduced in\n> > preparation for subsequent patches and are not yet used.\n> > \n> > Signed-off-by: Dmitry Ilvokhin <d@ilvokhin.com>\n> > ---\n> >  MAINTAINERS               |  1 +\n> >  include/linux/zone_lock.h | 38 ++++++++++++++++++++++++++++++++++++++\n> >  2 files changed, 39 insertions(+)\n> >  create mode 100644 include/linux/zone_lock.h\n> > \n> > diff --git a/MAINTAINERS b/MAINTAINERS\n> > index b4088f7290be..680c9ae02d7e 100644\n> > --- a/MAINTAINERS\n> > +++ b/MAINTAINERS\n> > @@ -16498,6 +16498,7 @@ F:\tinclude/linux/pgtable.h\n> >  F:\tinclude/linux/ptdump.h\n> >  F:\tinclude/linux/vmpressure.h\n> >  F:\tinclude/linux/vmstat.h\n> > +F:\tinclude/linux/zone_lock.h\n> >  F:\tkernel/fork.c\n> >  F:\tmm/Kconfig\n> >  F:\tmm/debug.c\n> > diff --git a/include/linux/zone_lock.h b/include/linux/zone_lock.h\n> > new file mode 100644\n> > index 000000000000..c531e26280e6\n> > --- /dev/null\n> > +++ b/include/linux/zone_lock.h\n> > @@ -0,0 +1,38 @@\n> > +/* SPDX-License-Identifier: GPL-2.0 */\n> > +#ifndef _LINUX_ZONE_LOCK_H\n> > +#define _LINUX_ZONE_LOCK_H\n> > +\n> > +#include <linux/mmzone.h>\n> > +#include <linux/spinlock.h>\n> > +\n> > +static inline void zone_lock_init(struct zone *zone)\n> > +{\n> > +\tspin_lock_init(&zone->lock);\n> > +}\n> > +\n> > +#define zone_lock_irqsave(zone, flags)\t\t\t\t\\\n> > +do {\t\t\t\t\t\t\t\t\\\n> > +\tspin_lock_irqsave(&(zone)->lock, flags);\t\t\\\n> > +} while (0)\n> > +\n> > +#define zone_trylock_irqsave(zone, flags)\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\\\n> > +\tspin_trylock_irqsave(&(zone)->lock, flags);\t\t\\\n> > +})\n> \n> Any reason you used macros for above two and inlined functions for remaining?\n>\n\nThe reason for using macros in those two cases is that they need to\nmodify the flags variable passed by the caller, just like\nspin_lock_irqsave() and spin_trylock_irqsave() do. I followed the same\nconvention here.\n\nIf we used normal inline functions instead, we would need to pass a\npointer to flags, which would change the call sites and diverge from the\nexisting *_irqsave() locking pattern.\n\nThere is also a difference between zone_lock_irqsave() and\nzone_trylock_irqsave() implementations: the former is implemented as a\ndo { } while (0) macro since it does not return a value, while the\nlatter uses a GCC extension in order to return the trylock result. This\nmatches spin_lock_* convention as well.\n\n> > +\n> > +static inline void zone_unlock_irqrestore(struct zone *zone, unsigned long flags)\n> > +{\n> > +\tspin_unlock_irqrestore(&zone->lock, flags);\n> > +}\n> > +\n> > +static inline void zone_lock_irq(struct zone *zone)\n> > +{\n> > +\tspin_lock_irq(&zone->lock);\n> > +}\n> > +\n> > +static inline void zone_unlock_irq(struct zone *zone)\n> > +{\n> > +\tspin_unlock_irq(&zone->lock);\n> > +}\n> > +\n> > +#endif /* _LINUX_ZONE_LOCK_H */\n> > -- \n> > 2.47.3\n> > \n",
          "reply_to": "",
          "message_date": "2026-02-24",
          "message_id": ""
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "This patch series adds tracepoint instrumentation to zone lock acquire and release operations, allowing for better visibility into the locking behavior of the system. The implementation follows a lightweight pattern where an inline helper checks whether tracing is enabled and calls an out-of-line helper when necessary. When CONFIG_TRACING is disabled, the helpers compile to empty stubs, ensuring the fast path remains unaffected."
    },
    "2026-02-25": {
      "report_file": "2026-02-20.html",
      "developer": "Dmitry Ilvokhin",
      "reviews": [
        {
          "author": "Steven Rostedt",
          "summary": "Have you thought about adding guards as well. It could make the code simpler: (Not tested) #include <linux/cleanup.h> [..] DEFINE_LOCK_GUARD_1(zonelock_irqsave, struct zone *, zone_lock_irqsave(_T->lock, _T->flags), zone_unlock_irqrestore(_T->lock, _T->flags), unsigned long flags) DECLARE_LOCK_GUARD_1_ATTRS(zonelock_irqsave, __acquires(_T), __releases(*(struct zone ***)_T)) #define class_zonelock_irqsave_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(zonelock_irqsave, _T) DEFINE_LOCK_GUARD_1(zonelock_irq, struct zone *, zone_lock_irq(_T->lock), zone_unlock_irq(_T->lock)) DECLARE_LOCK_GUARD_1_ATTRS(zonelock_irq, __acquires(_T), __releases(*(struct zone ***)_T)) #define...",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Wed, 11 Feb 2026 15:22:13 +0000\nDmitry Ilvokhin <d@ilvokhin.com> wrote:\n\n\n> diff --git a/include/linux/zone_lock.h b/include/linux/zone_lock.h\n> new file mode 100644\n> index 000000000000..c531e26280e6\n> --- /dev/null\n> +++ b/include/linux/zone_lock.h\n> @@ -0,0 +1,38 @@\n> +/* SPDX-License-Identifier: GPL-2.0 */\n> +#ifndef _LINUX_ZONE_LOCK_H\n> +#define _LINUX_ZONE_LOCK_H\n> +\n> +#include <linux/mmzone.h>\n> +#include <linux/spinlock.h>\n> +\n> +static inline void zone_lock_init(struct zone *zone)\n> +{\n> +\tspin_lock_init(&zone->lock);\n> +}\n> +\n> +#define zone_lock_irqsave(zone, flags)\t\t\t\t\\\n> +do {\t\t\t\t\t\t\t\t\\\n> +\tspin_lock_irqsave(&(zone)->lock, flags);\t\t\\\n> +} while (0)\n> +\n> +#define zone_trylock_irqsave(zone, flags)\t\t\t\\\n> +({\t\t\t\t\t\t\t\t\\\n> +\tspin_trylock_irqsave(&(zone)->lock, flags);\t\t\\\n> +})\n> +\n> +static inline void zone_unlock_irqrestore(struct zone *zone, unsigned long flags)\n> +{\n> +\tspin_unlock_irqrestore(&zone->lock, flags);\n> +}\n> +\n> +static inline void zone_lock_irq(struct zone *zone)\n> +{\n> +\tspin_lock_irq(&zone->lock);\n> +}\n> +\n> +static inline void zone_unlock_irq(struct zone *zone)\n> +{\n> +\tspin_unlock_irq(&zone->lock);\n> +}\n> +\n> +#endif /* _LINUX_ZONE_LOCK_H */\n\nHave you thought about adding guards as well. It could make the code simpler:\n\n  (Not tested)\n\n#include <linux/cleanup.h>\n[..]\n\nDEFINE_LOCK_GUARD_1(zonelock_irqsave, struct zone *,\n\t\t    zone_lock_irqsave(_T->lock, _T->flags),\n\t\t    zone_unlock_irqrestore(_T->lock, _T->flags),\n\t\t    unsigned long flags)\nDECLARE_LOCK_GUARD_1_ATTRS(zonelock_irqsave, __acquires(_T), __releases(*(struct zone ***)_T))\n#define class_zonelock_irqsave_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(zonelock_irqsave, _T)\n\nDEFINE_LOCK_GUARD_1(zonelock_irq, struct zone *,\n\t\t    zone_lock_irq(_T->lock),\n\t\t    zone_unlock_irq(_T->lock))\nDECLARE_LOCK_GUARD_1_ATTRS(zonelock_irq, __acquires(_T), __releases(*(struct zone ***)_T))\n#define class_zonelock_irq_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(zonelock_irq, _T)\n\nThen you could even remove the \"flags\" variables from the C code, and some goto unlocks.\n\n-- Steve\n\n",
          "reply_to": "",
          "message_date": "2026-02-25",
          "message_id": ""
        }
      ],
      "analysis_source": "heuristic",
      "patch_summary": "Add thin wrappers around zone lock acquire/release operations. This prepares the code for future tracepoint instrumentation without modifying individual call sites.\n\nCentralizing zone lock operations behind wrappers allows future instrumentation or debugging hooks to be added without touching all users.\n\nNo functional change intended. The wrappers are introduced in preparation for subsequent patches and are not yet used."
    },
    "2026-02-20": {
      "report_file": "2026-02-20.html",
      "developer": "Dmitry Ilvokhin",
      "reviews": [],
      "analysis_source": "heuristic",
      "patch_summary": "Add thin wrappers around zone lock acquire/release operations. This prepares the code for future tracepoint instrumentation without modifying individual call sites.\n\nCentralizing zone lock operations behind wrappers allows future instrumentation or debugging hooks to be added without touching all users.\n\nNo functional change intended. The wrappers are introduced in preparation for subsequent patches and are not yet used."
    }
  }
}