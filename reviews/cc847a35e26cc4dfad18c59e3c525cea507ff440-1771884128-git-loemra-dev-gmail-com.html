<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: [PATCH v3 2/3] btrfs: inhibit extent buffer writeback to prevent COW amplification</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }
        .reply-to-label {
            font-size: 0.8em;
            color: #999;
            font-style: italic;
            margin-top: 3px;
        }
        .lore-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 0.82em;
            color: #0366d6;
            text-decoration: none;
            font-weight: 500;
            white-space: nowrap;
        }
        .lore-link:hover { text-decoration: underline; color: #0056b3; }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../index.html">&larr; Back to reports</a></div>
    <h1>[PATCH v3 2/3] btrfs: inhibit extent buffer writeback to prevent COW amplification</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/cc847a35e26cc4dfad18c59e3c525cea507ff440.1771884128.git.loemra.dev@gmail.com/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-26">2026-02-26</a> &bull; <a href="#2026-02-25">2026-02-25</a> &bull; <a href="#2026-02-24">2026-02-24</a></div>
    <div class="patch-summary-block"><div class="patch-summary-label">Patch summary</div><div class="patch-summary-text">This patch addresses a potential issue in the Btrfs file system where COW (Copy On Write) amplification could occur due to incorrect handling of extent buffer writeback. The problem arises when multiple transactions modify the same extent buffer, and one transaction inhibits writeback after COWing the buffer, while another transaction reuses the buffer without re-COWing it. To fix this, the patch modifies the code to inhibit writeback not only when a buffer is COWed but also whenever a handle reuses a COWed buffer without re-COWing it.</div></div>
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-24">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">David Hildenbrand</span>
<a class="date-chip" href="../2026-02-24_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-24">2026-02-24</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The patch looks good, but the author should consider adding a comment to explain why the per-restart-site tracepoint is necessary and how it improves over the existing counter-based approach.</div>
<div class="review-comment-signals">Signals: NEEDS_WORK</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-25">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Sun YangKai</span>
<a class="date-chip" href="../2026-02-25_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-25">2026-02-25</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">I might be missing something here, but I&#x27;m curious whether this atomic counter can ever go above 1. If not, and it&#x27;s strictly binary, perhaps using atomic_set(1/0) instead of atomic_inc/dec would make the intent clearer? Otherwise looks good. Thanks.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">

On 2026/2/25 03:22, Leo Martins wrote:
&gt; Inhibit writeback on COW&#x27;d extent buffers for the lifetime of the
&gt; transaction handle, preventing background writeback from setting
&gt; BTRFS_HEADER_FLAG_WRITTEN and causing unnecessary re-COW.
&gt; 
&gt; COW amplification occurs when background writeback flushes an extent
&gt; buffer that a transaction handle is still actively modifying. When
&gt; lock_extent_buffer_for_io() transitions a buffer from dirty to
&gt; writeback, it sets BTRFS_HEADER_FLAG_WRITTEN, marking the block as
&gt; having been persisted to disk at its current bytenr. Once WRITTEN is
&gt; set, should_cow_block() must either COW the block again or overwrite
&gt; it in place, both of which are unnecessary overhead when the buffer
&gt; is still being modified by the same handle that allocated it. By
&gt; inhibiting background writeback on actively-used buffers, WRITTEN is
&gt; never set while a transaction handle holds a reference to the buffer,
&gt; avoiding this overhead entirely.
&gt; 
&gt; Add an atomic_t writeback_inhibitors counter to struct extent_buffer,
&gt; which fits in an existing 6-byte hole without increasing struct size.
&gt; When a buffer is COW&#x27;d in btrfs_force_cow_block(), call
&gt; btrfs_inhibit_eb_writeback() to store the eb in the transaction
&gt; handle&#x27;s writeback_inhibited_ebs xarray (keyed by eb-&gt;start), take a
&gt; reference, and increment writeback_inhibitors. The function handles
&gt; dedup (same eb inhibited twice by the same handle) and replacement
&gt; (different eb at the same logical address). Allocation failure is
&gt; graceful: the buffer simply falls back to the pre-existing behavior
&gt; where it may be written back and re-COW&#x27;d.
&gt; 
&gt; In lock_extent_buffer_for_io(), when writeback_inhibitors is non-zero
&gt; and the writeback mode is WB_SYNC_NONE, skip the buffer. WB_SYNC_NONE
&gt; is used by the VM flusher threads for background and periodic
&gt; writeback, which are the only paths that cause COW amplification by
&gt; opportunistically writing out dirty extent buffers mid-transaction.
&gt; Skipping these is safe because the buffers remain dirty in the page
&gt; cache and will be written out at transaction commit time.
&gt; 
&gt; WB_SYNC_ALL must always proceed regardless of writeback_inhibitors.
&gt; This is required for correctness in the fsync path: btrfs_sync_log()
&gt; writes log tree blocks via filemap_fdatawrite_range() (WB_SYNC_ALL)
&gt; while the transaction handle that inhibited those same blocks is still
&gt; active. Without the WB_SYNC_ALL bypass, those inhibited log tree
&gt; blocks would be silently skipped, resulting in an incomplete log on
&gt; disk and corruption on replay. btrfs_write_and_wait_transaction()
&gt; also uses WB_SYNC_ALL via filemap_fdatawrite_range(); for that path,
&gt; inhibitors are already cleared beforehand, but the bypass ensures
&gt; correctness regardless.
&gt; 
&gt; Uninhibit in __btrfs_end_transaction() before atomic_dec(num_writers)
&gt; to prevent a race where the committer proceeds while buffers are still
&gt; inhibited. Also uninhibit in btrfs_commit_transaction() before writing
&gt; and in cleanup_transaction() for the error path.
&gt; 
&gt; Signed-off-by: Leo Martins &lt;loemra.dev@gmail.com&gt;
&gt; Reviewed-by: Filipe Manana &lt;fdmanana@suse.com&gt;
&gt; ---
&gt;   fs/btrfs/ctree.c       |  4 +++
&gt;   fs/btrfs/extent_io.c   | 63 +++++++++++++++++++++++++++++++++++++++++-
&gt;   fs/btrfs/extent_io.h   |  6 ++++
&gt;   fs/btrfs/transaction.c | 19 +++++++++++++
&gt;   fs/btrfs/transaction.h |  3 ++
&gt;   5 files changed, 94 insertions(+), 1 deletion(-)
&gt; 
&gt; diff --git a/fs/btrfs/ctree.c b/fs/btrfs/ctree.c
&gt; index 0e02b7b14adc..d4da65bb9096 100644
&gt; --- a/fs/btrfs/ctree.c
&gt; +++ b/fs/btrfs/ctree.c
&gt; @@ -590,6 +590,10 @@ int btrfs_force_cow_block(struct btrfs_trans_handle *trans,
&gt;   		btrfs_tree_unlock(buf);
&gt;   	free_extent_buffer_stale(buf);
&gt;   	btrfs_mark_buffer_dirty(trans, cow);
&gt; +
&gt; +	/* Inhibit writeback on the COW&#x27;d buffer for this transaction handle. */
&gt; +	btrfs_inhibit_eb_writeback(trans, cow);
&gt; +
&gt;   	*cow_ret = cow;
&gt;   	return 0;
&gt;   
&gt; diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
&gt; index ff1fc699a6ca..e04e42a81978 100644
&gt; --- a/fs/btrfs/extent_io.c
&gt; +++ b/fs/btrfs/extent_io.c
&gt; @@ -1940,7 +1940,9 @@ static noinline_for_stack bool lock_extent_buffer_for_io(struct extent_buffer *e
&gt;   	 * of time.
&gt;   	 */
&gt;   	spin_lock(&amp;eb-&gt;refs_lock);
&gt; -	if (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &amp;eb-&gt;bflags)) {
&gt; +	if ((wbc-&gt;sync_mode == WB_SYNC_ALL ||
&gt; +	     atomic_read(&amp;eb-&gt;writeback_inhibitors) == 0) &amp;&amp;
&gt; +	    test_and_clear_bit(EXTENT_BUFFER_DIRTY, &amp;eb-&gt;bflags)) {
&gt;   		XA_STATE(xas, &amp;fs_info-&gt;buffer_tree, eb-&gt;start &gt;&gt; fs_info-&gt;nodesize_bits);
&gt;   		unsigned long flags;
&gt;   
&gt; @@ -2999,6 +3001,64 @@ static inline void btrfs_release_extent_buffer(struct extent_buffer *eb)
&gt;   	kmem_cache_free(extent_buffer_cache, eb);
&gt;   }
&gt;   
&gt; +/*
&gt; + * btrfs_inhibit_eb_writeback - Inhibit writeback on buffer during transaction.
&gt; + * @trans: transaction handle that will own the inhibitor
&gt; + * @eb: extent buffer to inhibit writeback on
&gt; + *
&gt; + * Attempts to track this extent buffer in the transaction&#x27;s inhibited set.
&gt; + * If memory allocation fails, the buffer is simply not tracked. It may
&gt; + * be written back and need re-COW, which is the original behavior.
&gt; + * This is acceptable since inhibiting writeback is an optimization.
&gt; + */
&gt; +void btrfs_inhibit_eb_writeback(struct btrfs_trans_handle *trans,
&gt; +				struct extent_buffer *eb)
&gt; +{
&gt; +	unsigned long index = eb-&gt;start &gt;&gt; trans-&gt;fs_info-&gt;nodesize_bits;
&gt; +	void *old;
&gt; +
&gt; +	/* Check if already inhibited by this handle. */
&gt; +	old = xa_load(&amp;trans-&gt;writeback_inhibited_ebs, index);
&gt; +	if (old == eb)
&gt; +		return;
&gt; +
&gt; +	/* Take reference for the xarray entry. */
&gt; +	refcount_inc(&amp;eb-&gt;refs);
&gt; +
&gt; +	old = xa_store(&amp;trans-&gt;writeback_inhibited_ebs, index, eb, GFP_NOFS);
&gt; +	if (xa_is_err(old)) {
&gt; +		/* Allocation failed, just skip inhibiting this buffer. */
&gt; +		free_extent_buffer(eb);
&gt; +		return;
&gt; +	}
&gt; +
&gt; +	/* Handle replacement of different eb at same index. */
&gt; +	if (old &amp;&amp; old != eb) {
&gt; +		struct extent_buffer *old_eb = old;
&gt; +
&gt; +		atomic_dec(&amp;old_eb-&gt;writeback_inhibitors);
&gt; +		free_extent_buffer(old_eb);
&gt; +	}
&gt; +
&gt; +	atomic_inc(&amp;eb-&gt;writeback_inhibitors);
&gt; +}
&gt; +
&gt; +/*
&gt; + * btrfs_uninhibit_all_eb_writeback - Uninhibit writeback on all buffers.
&gt; + * @trans: transaction handle to clean up
&gt; + */
&gt; +void btrfs_uninhibit_all_eb_writeback(struct btrfs_trans_handle *trans)
&gt; +{
&gt; +	struct extent_buffer *eb;
&gt; +	unsigned long index;
&gt; +
&gt; +	xa_for_each(&amp;trans-&gt;writeback_inhibited_ebs, index, eb) {
&gt; +		atomic_dec(&amp;eb-&gt;writeback_inhibitors);
&gt; +		free_extent_buffer(eb);
&gt; +	}
&gt; +	xa_destroy(&amp;trans-&gt;writeback_inhibited_ebs);
&gt; +}
&gt; +
&gt;   static struct extent_buffer *__alloc_extent_buffer(struct btrfs_fs_info *fs_info,
&gt;   						   u64 start)
&gt;   {
&gt; @@ -3009,6 +3069,7 @@ static struct extent_buffer *__alloc_extent_buffer(struct btrfs_fs_info *fs_info
&gt;   	eb-&gt;len = fs_info-&gt;nodesize;
&gt;   	eb-&gt;fs_info = fs_info;
&gt;   	init_rwsem(&amp;eb-&gt;lock);
&gt; +	atomic_set(&amp;eb-&gt;writeback_inhibitors, 0);
&gt;   
&gt;   	btrfs_leak_debug_add_eb(eb);
&gt;   
&gt; diff --git a/fs/btrfs/extent_io.h b/fs/btrfs/extent_io.h
&gt; index 73571d5d3d5a..fb68fbd4866c 100644
&gt; --- a/fs/btrfs/extent_io.h
&gt; +++ b/fs/btrfs/extent_io.h
&gt; @@ -102,6 +102,8 @@ struct extent_buffer {
&gt;   	/* &gt;= 0 if eb belongs to a log tree, -1 otherwise */
&gt;   	s8 log_index;
&gt;   	u8 folio_shift;
&gt; +	/* Inhibits WB_SYNC_NONE writeback when &gt; 0. */
&gt; +	atomic_t writeback_inhibitors;

I might be missing something here, but I&#x27;m curious whether this atomic 
counter can ever go above 1. If not, and it&#x27;s strictly binary, perhaps 
using atomic_set(1/0) instead of atomic_inc/dec would make the intent 
clearer?

Otherwise looks good. Thanks.

&gt;   	struct rcu_head rcu_head;
&gt;   
&gt;   	struct rw_semaphore lock;
&gt; @@ -381,4 +383,8 @@ void btrfs_extent_buffer_leak_debug_check(struct btrfs_fs_info *fs_info);
&gt;   #define btrfs_extent_buffer_leak_debug_check(fs_info)	do {} while (0)
&gt;   #endif
&gt;   
&gt; +void btrfs_inhibit_eb_writeback(struct btrfs_trans_handle *trans,
&gt; +			       struct extent_buffer *eb);
&gt; +void btrfs_uninhibit_all_eb_writeback(struct btrfs_trans_handle *trans);
&gt; +
&gt;   #endif
&gt; diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c
&gt; index f4cc9e1a1b93..a9a22629b49d 100644
&gt; --- a/fs/btrfs/transaction.c
&gt; +++ b/fs/btrfs/transaction.c
&gt; @@ -15,6 +15,7 @@
&gt;   #include &quot;misc.h&quot;
&gt;   #include &quot;ctree.h&quot;
&gt;   #include &quot;disk-io.h&quot;
&gt; +#include &quot;extent_io.h&quot;
&gt;   #include &quot;transaction.h&quot;
&gt;   #include &quot;locking.h&quot;
&gt;   #include &quot;tree-log.h&quot;
&gt; @@ -688,6 +689,8 @@ start_transaction(struct btrfs_root *root, unsigned int num_items,
&gt;   		goto alloc_fail;
&gt;   	}
&gt;   
&gt; +	xa_init(&amp;h-&gt;writeback_inhibited_ebs);
&gt; +
&gt;   	/*
&gt;   	 * If we are JOIN_NOLOCK we&#x27;re already committing a transaction and
&gt;   	 * waiting on this guy, so we don&#x27;t need to do the sb_start_intwrite
&gt; @@ -1083,6 +1086,13 @@ static int __btrfs_end_transaction(struct btrfs_trans_handle *trans,
&gt;   	if (trans-&gt;type &amp; __TRANS_FREEZABLE)
&gt;   		sb_end_intwrite(info-&gt;sb);
&gt;   
&gt; +	/*
&gt; +	 * Uninhibit extent buffer writeback before decrementing num_writers,
&gt; +	 * since the decrement wakes the committing thread which needs all
&gt; +	 * buffers uninhibited to write them to disk.
&gt; +	 */
&gt; +	btrfs_uninhibit_all_eb_writeback(trans);
&gt; +
&gt;   	WARN_ON(cur_trans != info-&gt;running_transaction);
&gt;   	WARN_ON(atomic_read(&amp;cur_trans-&gt;num_writers) &lt; 1);
&gt;   	atomic_dec(&amp;cur_trans-&gt;num_writers);
&gt; @@ -2110,6 +2120,7 @@ static void cleanup_transaction(struct btrfs_trans_handle *trans, int err)
&gt;   	if (!test_bit(BTRFS_FS_RELOC_RUNNING, &amp;fs_info-&gt;flags))
&gt;   		btrfs_scrub_cancel(fs_info);
&gt;   
&gt; +	btrfs_uninhibit_all_eb_writeback(trans);
&gt;   	kmem_cache_free(btrfs_trans_handle_cachep, trans);
&gt;   }
&gt;   
&gt; @@ -2556,6 +2567,14 @@ int btrfs_commit_transaction(struct btrfs_trans_handle *trans)
&gt;   	    fs_info-&gt;cleaner_kthread)
&gt;   		wake_up_process(fs_info-&gt;cleaner_kthread);
&gt;   
&gt; +	/*
&gt; +	 * Uninhibit writeback on all extent buffers inhibited during this
&gt; +	 * transaction before writing them to disk. Inhibiting prevented
&gt; +	 * writeback while the transaction was building, but now we need
&gt; +	 * them written.
&gt; +	 */
&gt; +	btrfs_uninhibit_all_eb_writeback(trans);
&gt; +
&gt;   	ret = btrfs_write_and_wait_transaction(trans);
&gt;   	if (unlikely(ret)) {
&gt;   		btrfs_err(fs_info, &quot;error while writing out transaction: %d&quot;, ret);
&gt; diff --git a/fs/btrfs/transaction.h b/fs/btrfs/transaction.h
&gt; index 18ef069197e5..7d70fe486758 100644
&gt; --- a/fs/btrfs/transaction.h
&gt; +++ b/fs/btrfs/transaction.h
&gt; @@ -12,6 +12,7 @@
&gt;   #include &lt;linux/time64.h&gt;
&gt;   #include &lt;linux/mutex.h&gt;
&gt;   #include &lt;linux/wait.h&gt;
&gt; +#include &lt;linux/xarray.h&gt;
&gt;   #include &quot;btrfs_inode.h&quot;
&gt;   #include &quot;delayed-ref.h&quot;
&gt;   
&gt; @@ -162,6 +163,8 @@ struct btrfs_trans_handle {
&gt;   	struct btrfs_fs_info *fs_info;
&gt;   	struct list_head new_bgs;
&gt;   	struct btrfs_block_rsv delayed_rsv;
&gt; +	/* Extent buffers with writeback inhibited by this handle. */
&gt; +	struct xarray writeback_inhibited_ebs;
&gt;   };
&gt;   
&gt;   /*

</pre>
</details>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-26">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Sun YangKai</span>
<a class="date-chip" href="../2026-02-26_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-26">2026-02-26</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer noted that the current implementation only inhibits writeback when an extent buffer (eb) is COW&#x27;d, but does not account for cases where a transaction handle reuses a previously COW&#x27;d eb without re-COWing it, potentially leading to COW amplification.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Oh, I&#x27;ve just got the idea. It&#x27;s inhibited per trans handle. Then it 
makes a lot of sense.

There might be some ebs that were inhibited due to tree rebalancing or 
tree walking and are no longer used, but I don&#x27;t think this is a blocker 
for this patch.

Looking forward to your next patch version :)</pre>
</details>
<div class="reply-to-label">&#8627; replying to Leo Martins</div>
<a href="https://lore.kernel.org/r/f5788abc-f4de-4f3a-9ab1-7aaa579c89c9@gmail.com" target="_blank" rel="noopener" class="lore-link">View on lore &#8599;</a>
<div class="review-comment-signals">Signals: potential bug, requested change</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>