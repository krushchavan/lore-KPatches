<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH bpf-next 2/3] mm/memcontrol: Return error when accessing kmem with nokmem</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH bpf-next 2/3] mm/memcontrol: Return error when accessing kmem with nokmem</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/51bbd728-c712-4601-8a4a-7c602c67fe75@gmail.com/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-13">2026-02-13</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-13">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Hui Zhu (author)</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Hui Zhu approved the patch, mentioning that they will fix an issue in a subsequent version.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Hui Zhu &lt;zhuhui@kylinos.cn&gt;

While back-porting &quot;mm: bpf kfuncs to access memcg data&quot;, I
encountered issues with test_cgroup_iter_memcg, specifically
in test_kmem.

The test_cgroup_iter_memcg test would falsely pass when
bpf_mem_cgroup_page_state() failed due to incompatible enum
values across kernel versions. Additionally, test_kmem would
fail on systems with cgroup.memory=nokmem enabled.

This series addresses these issues:
1. Add return value checks for bpf_mem_cgroup_page_state()
2. Return error when accessing kmem with nokmem enabled
3. Skip test_kmem when cgroup.memory=nokmem is set

Hui Zhu (3):
  selftests/bpf: Check bpf_mem_cgroup_page_state return value
  mm/memcontrol: Return error when accessing kmem with nokmem
  selftests/bpf: Skip test_kmem when cgroup.memory=nokmem

 mm/memcontrol.c                               |  3 +-
 .../bpf/prog_tests/cgroup_iter_memcg.c        | 40 +++++++++++++++++++
 2 files changed, 42 insertions(+), 1 deletion(-)

-- 
2.43.0



---

From: Hui Zhu &lt;zhuhui@kylinos.cn&gt;

When running tests on hosts with cgroup.memory=nokmem enabled for
performance reasons, test_kmem always gets a value of 0 for kmem
statistics.

Since BPF programs cannot easily determine whether kmem is enabled,
add a check in memcg_stat_item_valid() to return an error when
attempting to access MEMCG_KMEM statistics while kmem accounting
is disabled via cgroup_memory_nokmem.

This prevents BPF programs from silently receiving zero values and
allows them to properly handle the case where kmem accounting is
unavailable.

Signed-off-by: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
---
 mm/memcontrol.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 129eed3ff5bb..4d8419623d1c 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -667,7 +667,8 @@ unsigned long memcg_page_state(struct mem_cgroup *memcg, int idx)
 
 bool memcg_stat_item_valid(int idx)
 {
-	if ((u32)idx &gt;= MEMCG_NR_STAT)
+	if ((u32)idx &gt;= MEMCG_NR_STAT ||
+	    (cgroup_memory_nokmem &amp;&amp; (u32)idx == MEMCG_KMEM))
 		return false;
 
 	return !BAD_STAT_IDX(memcg_stats_index(idx));
-- 
2.43.0



---

From: Hui Zhu &lt;zhuhui@kylinos.cn&gt;

When cgroup.memory=nokmem is set in kernel command line, kmem
accounting is disabled and the test_kmem subtest will fail.

Add a check to skip this test when the parameter is present.

Signed-off-by: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
---
 .../bpf/prog_tests/cgroup_iter_memcg.c        | 28 +++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
index 13b299512429..203e6b091a21 100644
--- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
+++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
@@ -134,11 +134,39 @@ static void test_shmem(struct bpf_link *link, struct memcg_query *memcg_query)
 	shm_unlink(&quot;/tmp_shmem&quot;);
 }
 
+static bool cmdline_has(const char *arg)
+{
+	char cmdline[4096];
+	int fd;
+	ssize_t len;
+	bool ret = false;
+
+	fd = open(&quot;/proc/cmdline&quot;, O_RDONLY);
+	if (fd &lt; 0)
+		return false;
+
+	len = read(fd, cmdline, sizeof(cmdline) - 1);
+	close(fd);
+	if (len &lt; 0)
+		return false;
+
+	cmdline[len] = &#x27;\0&#x27;;
+	if (strstr(cmdline, arg))
+		ret = true;
+
+	return ret;
+}
+
 #define NR_PIPES 64
 static void test_kmem(struct bpf_link *link, struct memcg_query *memcg_query)
 {
 	int fds[NR_PIPES][2], i;
 
+	if (cmdline_has(&quot;cgroup.memory=nokmem&quot;)) {
+		test__skip();
+		return;
+	}
+
 	/*
 	 * Increase kmem value by creating pipes which will allocate some
 	 * kernel buffers.
-- 
2.43.0



---

2026年2月12日 16:50, bot+bpf-ci@kernel.org mailto:bot+bpf-ci@kernel.org  写到:


&gt; 
&gt; &gt; 
&gt; &gt; diff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; &gt;  --- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; &gt;  +++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; &gt; 
&gt; [ ... ]
&gt; 
&gt; &gt; 
&gt; &gt; @@ -170,6 +180,8 @@ static void test_pgfault(struct bpf_link *link, struct memcg_query *memcg_query)
&gt; &gt;  if (!ASSERT_OK(read_stats(link), &quot;read stats&quot;))
&gt; &gt;  goto cleanup;
&gt; &gt; 
&gt; &gt;  + ASSERT_NEQ(memcg_query-&gt;pgfault, (unsigned long)-1,
&gt; &gt;  + &quot;bpf_mem_cgroup_page_state PGFAULT&quot;);
&gt; &gt; 
&gt;  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
&gt; 
&gt; The assertion message references bpf_mem_cgroup_page_state(), but the BPF
&gt; program actually uses bpf_mem_cgroup_vm_events() to retrieve the pgfault
&gt; value:
&gt; 
&gt; tools/testing/selftests/bpf/progs/cgroup_iter_memcg.c:
&gt;  memcg_query.pgfault = bpf_mem_cgroup_vm_events(memcg, PGFAULT);
&gt; 
&gt; Should the message be &quot;bpf_mem_cgroup_vm_events PGFAULT&quot; instead?

Good catch!  I will fix it in the next version.

Best,
Hui

&gt; 
&gt; ---
&gt; AI reviewed your patch. Please fix the bug or email reply why it&#x27;s not a bug.
&gt; See: https://github.com/kernel-patches/vmtest/blob/master/ci/claude/README.md
&gt; 
&gt; CI run summary: https://github.com/kernel-patches/bpf/actions/runs/21939182103
&gt; 
&gt; AI-authorship-score: low
&gt; AI-authorship-explanation: The commit message uses first-person narrative describing a real back-porting scenario, and the code changes are simple repetitive assertions typical of human-written test improvements.
&gt; issues-found: 1
&gt; issue-severity-score: low
&gt; issue-severity-explanation: Minor documentation issue where an assertion message references the wrong BPF function name; does not affect test correctness or system behavior.
&gt;


---

2026年2月13日 08:14, &quot;JP Kobryn&quot; &lt;inwardvessel@gmail.com mailto:inwardvessel@gmail.com?to=%22JP%20Kobryn%22%20%3Cinwardvessel%40gmail.com%3E &gt; 写到:


&gt; 
&gt; On 2/12/26 12:23 AM, Hui Zhu wrote:
&gt; 
&gt; &gt; 
&gt; &gt; From: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
&gt; &gt;  When back-porting test_progs to different kernel versions, I encountered
&gt; &gt;  an issue where the test_cgroup_iter_memcg test would falsely pass even
&gt; &gt;  when bpf_mem_cgroup_page_state() failed.
&gt; &gt;  The problem occurs when test_progs compiled on one kernel version is
&gt; &gt;  executed on another kernel with different enum values for memory
&gt; &gt;  statistics (e.g., NR_ANON_MAPPED, NR_FILE_PAGES). [...]
&gt; &gt; 
&gt; This patch looks good but I think to fully solve this cross-kernel issue
&gt; we should use co-re in the bpf program. In your second revision, can you
&gt; add an additional patch to make use of bpf_core_enum_value()? This way
&gt; instead of relying on enum values in vmlinux.h at compile-time, we use
&gt; the btf info at load-time instead to get the proper value for the given
&gt; kernel.
&gt;

I post v2 according to your comments.
Thanks for your review.

Best,
Hui

</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged a bug, committed to fixing it</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">bot+bpf-ci</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer pointed out a minor documentation error in the selftests/bpf code, where an assertion message incorrectly referenced bpf_mem_cgroup_page_state() instead of the correct function name bpf_mem_cgroup_vm_events().</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">&gt; diff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; --- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; +++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c

[ ... ]

&gt; @@ -170,6 +180,8 @@ static void test_pgfault(struct bpf_link *link, struct memcg_query *memcg_query)
&gt;  	if (!ASSERT_OK(read_stats(link), &quot;read stats&quot;))
&gt;  		goto cleanup;
&gt;
&gt; +	ASSERT_NEQ(memcg_query-&gt;pgfault, (unsigned long)-1,
&gt; +		  &quot;bpf_mem_cgroup_page_state PGFAULT&quot;);
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^

The assertion message references bpf_mem_cgroup_page_state(), but the BPF
program actually uses bpf_mem_cgroup_vm_events() to retrieve the pgfault
value:

tools/testing/selftests/bpf/progs/cgroup_iter_memcg.c:
    memcg_query.pgfault = bpf_mem_cgroup_vm_events(memcg, PGFAULT);

Should the message be &quot;bpf_mem_cgroup_vm_events PGFAULT&quot; instead?


---
AI reviewed your patch. Please fix the bug or email reply why it&#x27;s not a bug.
See: https://github.com/kernel-patches/vmtest/blob/master/ci/claude/README.md

CI run summary: https://github.com/kernel-patches/bpf/actions/runs/21939182103

AI-authorship-score: low
AI-authorship-explanation: The commit message uses first-person narrative describing a real back-porting scenario, and the code changes are simple repetitive assertions typical of human-written test improvements.
issues-found: 1
issue-severity-score: low
issue-severity-explanation: Minor documentation issue where an assertion message references the wrong BPF function name; does not affect test correctness or system behavior.
</pre>
</details>
<div class="review-comment-signals">Signals: minor documentation issue</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">JP Kobryn</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer JP Kobryn suggested using bpf_core_enum_value() to solve cross-kernel issues in the first patch, but disagreed with returning an error when accessing kmem with nokmem in the second patch, suggesting instead proceeding and confirming a zero value is returned.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 2/12/26 12:23 AM, Hui Zhu wrote:
&gt; From: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
&gt; 
&gt; When back-porting test_progs to different kernel versions, I encountered
&gt; an issue where the test_cgroup_iter_memcg test would falsely pass even
&gt; when bpf_mem_cgroup_page_state() failed.
&gt; 
&gt; The problem occurs when test_progs compiled on one kernel version is
&gt; executed on another kernel with different enum values for memory
&gt; statistics (e.g., NR_ANON_MAPPED, NR_FILE_PAGES). [...]

This patch looks good but I think to fully solve this cross-kernel issue
we should use co-re in the bpf program. In your second revision, can you
add an additional patch to make use of bpf_core_enum_value()? This way
instead of relying on enum values in vmlinux.h at compile-time, we use
the btf info at load-time instead to get the proper value for the given
kernel.


---

On 2/12/26 12:23 AM, Hui Zhu wrote:
&gt; From: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
&gt; 
&gt; When running tests on hosts with cgroup.memory=nokmem enabled for
&gt; performance reasons, test_kmem always gets a value of 0 for kmem
&gt; statistics.
&gt; 
&gt; Since BPF programs cannot easily determine whether kmem is enabled,
&gt; add a check in memcg_stat_item_valid() to return an error when
&gt; attempting to access MEMCG_KMEM statistics while kmem accounting
&gt; is disabled via cgroup_memory_nokmem.
&gt; 
&gt; This prevents BPF programs from silently receiving zero values and
&gt; allows them to properly handle the case where kmem accounting is
&gt; unavailable.
&gt; 
&gt; Signed-off-by: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
&gt; ---
&gt;   mm/memcontrol.c | 3 ++-
&gt;   1 file changed, 2 insertions(+), 1 deletion(-)
&gt; 
&gt; diff --git a/mm/memcontrol.c b/mm/memcontrol.c
&gt; index 129eed3ff5bb..4d8419623d1c 100644
&gt; --- a/mm/memcontrol.c
&gt; +++ b/mm/memcontrol.c
&gt; @@ -667,7 +667,8 @@ unsigned long memcg_page_state(struct mem_cgroup *memcg, int idx)
&gt;   
&gt;   bool memcg_stat_item_valid(int idx)
&gt;   {
&gt; -	if ((u32)idx &gt;= MEMCG_NR_STAT)
&gt; +	if ((u32)idx &gt;= MEMCG_NR_STAT ||
&gt; +	    (cgroup_memory_nokmem &amp;&amp; (u32)idx == MEMCG_KMEM))
&gt;   		return false;

It&#x27;s still a valid stat though, right? When it&#x27;s disabled the value will
just remain zero. I don&#x27;t think this is necessary.


---

On 2/12/26 12:23 AM, Hui Zhu wrote:
&gt; From: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
&gt; 
&gt; When cgroup.memory=nokmem is set in kernel command line, kmem
&gt; accounting is disabled and the test_kmem subtest will fail.
&gt; 
&gt; Add a check to skip this test when the parameter is present.
&gt; 
&gt; Signed-off-by: Hui Zhu &lt;zhuhui@kylinos.cn&gt;
&gt; ---
&gt;   .../bpf/prog_tests/cgroup_iter_memcg.c        | 28 +++++++++++++++++++
&gt;   1 file changed, 28 insertions(+)
&gt; 
&gt; diff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; index 13b299512429..203e6b091a21 100644
&gt; --- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; +++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c
&gt; @@ -134,11 +134,39 @@ static void test_shmem(struct bpf_link *link, struct memcg_query *memcg_query)
&gt;   	shm_unlink(&quot;/tmp_shmem&quot;);
&gt;   }
&gt;   
&gt; +static bool cmdline_has(const char *arg)
&gt; +{
&gt; +	char cmdline[4096];
&gt; +	int fd;
&gt; +	ssize_t len;
&gt; +	bool ret = false;
&gt; +
&gt; +	fd = open(&quot;/proc/cmdline&quot;, O_RDONLY);
&gt; +	if (fd &lt; 0)
&gt; +		return false;
&gt; +
&gt; +	len = read(fd, cmdline, sizeof(cmdline) - 1);
&gt; +	close(fd);
&gt; +	if (len &lt; 0)
&gt; +		return false;
&gt; +
&gt; +	cmdline[len] = &#x27;\0&#x27;;
&gt; +	if (strstr(cmdline, arg))
&gt; +		ret = true;
&gt; +
&gt; +	return ret;
&gt; +}
&gt; +
&gt;   #define NR_PIPES 64
&gt;   static void test_kmem(struct bpf_link *link, struct memcg_query *memcg_query)
&gt;   {
&gt;   	int fds[NR_PIPES][2], i;
&gt;   
&gt; +	if (cmdline_has(&quot;cgroup.memory=nokmem&quot;)) {
&gt; +		test__skip();
&gt; +		return;
&gt; +	}

Instead of just skipping what if we proceed and then confirm we get a
zero value after the allocations?
</pre>
</details>
<div class="review-comment-signals">Signals: cross-kernel issue, disagreement on patch</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>