{
  "thread_id": "20260221043013.1420169-1-gourry@gourry.net",
  "subject": "[PATCH 1/2] cxl/region: fix region leak when attach_target fails in cxl_add_to_region",
  "url": "https://lore.kernel.org/all/20260221043013.1420169-1-gourry@gourry.net/",
  "dates": {
    "2026-02-20": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Gregory Price",
      "reviews": [
        {
          "author": "Gregory Price (author)",
          "summary": "Author addressed a concern about device_attach() being called on auto-discovered regions when a custom attach callback is present. They explained that this can lead to dax memory being left online due to dax_kmem refusing to offline during its remove path. The author agreed to skip device_attach() in such cases, with the custom attach callback responsible for setting up the region afterwards.",
          "sentiment": "needs_work",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "When a CXL memdev has a custom attach callback, cxl_add_to_region()\nshould not call device_attach() on the auto-discovered region.\n\nThe default device_attach() binds the dax driver, which may online\nmemory via dax_kmem.  The custom attach callback then has to tear down\nthe dax stack to convert the region to sysram, but dax_kmem refuses to\noffline memory during its remove path, leaving regions stuck online.\n\nSkip device_attach() when cxlmd->attach is set.  The attach callback\nis responsible for setting up the region after auto-discovery completes\n(e.g. adding it as sysram directly).\n\nSigned-off-by: Gregory Price <gourry@gourry.net>\n---\n drivers/cxl/core/region.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\ndiff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c\nindex 276046d49f88..e5edeabd9262 100644\n--- a/drivers/cxl/core/region.c\n+++ b/drivers/cxl/core/region.c\n@@ -3971,6 +3971,12 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)\n \t}\n \n \tif (attach) {\n+\t\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n+\n+\t\t/* Skip device_attach if memdev has is own attach callback */\n+\t\tif (cxlmd->attach)\n+\t\t\treturn 0;\n+\n \t\t/*\n \t\t * If device_attach() fails the range may still be active via\n \t\t * the platform-firmware memory map, otherwise the driver for\n-- \n2.47.3",
          "reply_to": "",
          "message_date": "2026-02-20",
          "message_id": ""
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "This patch fixes a region leak in the CXL driver when attaching a target fails. When `attach_target` returns an error, the auto-discovered region remains registered and consumes HPA resources without ever reaching a committed state. The patch tracks whether the region was created by checking the return value of `cxl_add_to_region`, and if it was not created successfully, it calls `drop_region` to unregister the region and release the HPA resource. This prevents subsequent region creation attempts from failing due to reserved HPA ranges."
    },
    "2026-02-21": {
      "report_file": "2026-02-21_ollama_llama3.1-8b.html",
      "developer": "Gregory Price",
      "reviews": [
        {
          "author": "Gregory Price (author)",
          "summary": "BAH - disregard this patch, it uses drop_region which is introduced by Alejandro here: https://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:\n> cxl_add_to_region() ignores the return value of attach_target().  When\n> attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),\n> the auto-discovered region remains registered with its HPA resource\n> consumed but never reaches COMMIT state.  Subsequent region creation\n> attempts fail with -ENOSPC because the HPA range is already reserved.\n> \n> Track whether this call to cxl_add_to_region() created the region, and\n> call drop_region() on attach_target() failure to unregister it and\n> release the HPA resource.  Pre-existing regions are left alone since\n> other endpoints may already be attached.\n> \n> Signed-off-by: Gregory Price <gourry@gourry.net>\n\nBAH - disregard this patch, it uses drop_region which is introduced by\nAlejandro here:\n\nhttps://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/\n\n",
          "reply_to": "",
          "message_date": "2026-02-21",
          "message_id": ""
        }
      ],
      "analysis_source": "heuristic",
      "patch_summary": "cxl_add_to_region() ignores the return value of attach_target().  When attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO), the auto-discovered region remains registered with its HPA resource consumed but never reaches COMMIT state.  Subsequent region creation attempts fail with -ENOSPC because the HPA range is already reserved.\n\nTrack whether this call to cxl_add_to_region() created the region, and call drop_region() on attach_target() failure to unregister it and release the HPA resource.  Pre-existing regions are left alone since other endpoints may already be attached."
    },
    "2026-02-23": {
      "report_file": "2026-02-23.html",
      "developer": "Gregory Price",
      "reviews": [
        {
          "author": "Alison Schofield",
          "summary": "I see you dropping this, perhaps just for the moment, because the drop_region() you wanted to use is not available yet. This looks a lot like https://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/ cxl/region: Unregister auto-created region when assembly fails When auto-created region assembly fails the region remains registered but disabled. The region continues to reserve its memory resource, preventing DAX from registering the memory. Unregister the region on assembly failure to release the resource. And the review comments on that one, or at least on that thread in general, was to leave all the broken things in place. I didn't agree with that, and hope to see this version move ahead when you have the drop_region you need.",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:\n> cxl_add_to_region() ignores the return value of attach_target().  When\n> attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),\n> the auto-discovered region remains registered with its HPA resource\n> consumed but never reaches COMMIT state.  Subsequent region creation\n> attempts fail with -ENOSPC because the HPA range is already reserved.\n> \n> Track whether this call to cxl_add_to_region() created the region, and\n> call drop_region() on attach_target() failure to unregister it and\n> release the HPA resource.  Pre-existing regions are left alone since\n> other endpoints may already be attached.\n\nI see you dropping this, perhaps just for the moment, because\nthe drop_region() you wanted to use is not available yet.\n\nThis looks a lot like \n\thttps://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/\n\tcxl/region: Unregister auto-created region when assembly fails\n\tWhen auto-created region assembly fails the region remains registered\n\tbut disabled. The region continues to reserve its memory resource,\n\tpreventing DAX from registering the memory.\n\tUnregister the region on assembly failure to release the resource.\n\nAnd the review comments on that one, or at least on that thread in\ngeneral, was to leave all the broken things in place.\nI didn't agree with that, and hope to see this version move ahead\nwhen you have the drop_region you need.\n\n-- Alison\n\n\n\n\n\n\n> \n> Signed-off-by: Gregory Price <gourry@gourry.net>\n> ---\n>  drivers/cxl/core/region.c | 15 ++++++++++++---\n>  1 file changed, 12 insertions(+), 3 deletions(-)\n> \n> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c\n> index 385be9cb44cd..276046d49f88 100644\n> --- a/drivers/cxl/core/region.c\n> +++ b/drivers/cxl/core/region.c\n> @@ -3923,6 +3923,7 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)\n>  \tstruct cxl_region_context ctx;\n>  \tstruct cxl_region_params *p;\n>  \tbool attach = false;\n> +\tbool newly_created = false;\n>  \tint rc;\n>  \n>  \tctx = (struct cxl_region_context) {\n> @@ -3946,15 +3947,23 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)\n>  \tmutex_lock(&cxlrd->range_lock);\n>  \tstruct cxl_region *cxlr __free(put_cxl_region) =\n>  \t\tcxl_find_region_by_range(cxlrd, &ctx.hpa_range);\n> -\tif (!cxlr)\n> +\tif (!cxlr) {\n>  \t\tcxlr = construct_region(cxlrd, &ctx);\n> +\t\tnewly_created = !IS_ERR(cxlr);\n> +\t}\n>  \tmutex_unlock(&cxlrd->range_lock);\n>  \n>  \trc = PTR_ERR_OR_ZERO(cxlr);\n>  \tif (rc)\n>  \t\treturn rc;\n>  \n> -\tattach_target(cxlr, cxled, -1, TASK_UNINTERRUPTIBLE);\n> +\trc = attach_target(cxlr, cxled, -1, TASK_UNINTERRUPTIBLE);\n> +\tif (rc) {\n> +\t\t/* If endpoint was just created, tear it down to release HPA */\n> +\t\tif (newly_created)\n> +\t\t\tdrop_region(cxlrd, cxlr);\n> +\t\treturn rc;\n> +\t}\n>  \n>  \tscoped_guard(rwsem_read, &cxl_rwsem.region) {\n>  \t\tp = &cxlr->params;\n> @@ -3972,7 +3981,7 @@ int cxl_add_to_region(struct cxl_endpoint_decoder *cxled)\n>  \t\t\t\tp->res);\n>  \t}\n>  \n> -\treturn rc;\n> +\treturn 0;\n>  }\n>  EXPORT_SYMBOL_NS_GPL(cxl_add_to_region, \"CXL\");\n>  \n> -- \n> 2.47.3\n> \n",
          "reply_to": "",
          "message_date": "2026-02-23",
          "message_id": ""
        },
        {
          "author": "Gregory Price (author)",
          "summary": "Yeah it's not a particularly useful cleanup in the current infrastructure because nothing actually uses this pattern (yet). The important note here is the difference between auto-regions and manually created regions.  For auto-regions, you might have another endpoint show up looking for the partially created region - and then just go off and create it anyway because it thinks it was first. But in my driver, i'm explicitly converting these auto-regions into other things, and if that fails it causes *all other* region creation to fail - even if it wasn't actually dependent on that original region. This is only an issue if you have two devices unbind/bind cycling at the same time - i.e. echo 0000:d0:00.00 > cxl_pci/unbind echo 0000:e0:00.00 > cxl_pci/unbind echo 0000:d0:00.",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Mon, Feb 23, 2026 at 11:48:42AM -0800, Alison Schofield wrote:\n> On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:\n> > cxl_add_to_region() ignores the return value of attach_target().  When\n> > attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),\n> > the auto-discovered region remains registered with its HPA resource\n> > consumed but never reaches COMMIT state.  Subsequent region creation\n> > attempts fail with -ENOSPC because the HPA range is already reserved.\n> > \n> > Track whether this call to cxl_add_to_region() created the region, and\n> > call drop_region() on attach_target() failure to unregister it and\n> > release the HPA resource.  Pre-existing regions are left alone since\n> > other endpoints may already be attached.\n> \n> I see you dropping this, perhaps just for the moment, because\n> the drop_region() you wanted to use is not available yet.\n> \n\nYeah it's not a particularly useful cleanup in the current\ninfrastructure because nothing actually uses this pattern (yet).\n\n> This looks a lot like \n> \thttps://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/\n> \tcxl/region: Unregister auto-created region when assembly fails\n> \tWhen auto-created region assembly fails the region remains registered\n> \tbut disabled. The region continues to reserve its memory resource,\n> \tpreventing DAX from registering the memory.\n> \tUnregister the region on assembly failure to release the resource.\n> \n> And the review comments on that one, or at least on that thread in\n> general, was to leave all the broken things in place.\n> I didn't agree with that, and hope to see this version move ahead\n> when you have the drop_region you need.\n> \n> \n\nThe important note here is the difference between auto-regions and\nmanually created regions.  For auto-regions, you might have another\nendpoint show up looking for the partially created region - and then\njust go off and create it anyway because it thinks it was first.\n\nBut in my driver, i'm explicitly converting these auto-regions into\nother things, and if that fails it causes *all other* region creation to\nfail - even if it wasn't actually dependent on that original region.\n\nThis is only an issue if you have two devices unbind/bind cycling at\nthe same time - i.e.\n\n   echo 0000:d0:00.00 > cxl_pci/unbind\n   echo 0000:e0:00.00 > cxl_pci/unbind\n   echo 0000:d0:00.00 > mydriver/bind\n   echo 0000:e0:00.00 > mydriver/bind\n\nIf the platform has pre-programmed and locked the decoders, and one of\nthe two devices fails to probe and leaves a hanging partially\ncreated region, the other device will fail too.\n\nIt's a pretty narrow failure scenario.\n\n~Gregory\n",
          "reply_to": "",
          "message_date": "2026-02-23",
          "message_id": ""
        },
        {
          "author": "Alison Schofield",
          "summary": "That's by design, and that'll eventually fail too. But - is see how your case is different. Thanks for the explanation.",
          "sentiment": "neutral",
          "sentiment_signals": [],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Mon, Feb 23, 2026 at 03:15:16PM -0500, Gregory Price wrote:\n> On Mon, Feb 23, 2026 at 11:48:42AM -0800, Alison Schofield wrote:\n> > On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:\n> > > cxl_add_to_region() ignores the return value of attach_target().  When\n> > > attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),\n> > > the auto-discovered region remains registered with its HPA resource\n> > > consumed but never reaches COMMIT state.  Subsequent region creation\n> > > attempts fail with -ENOSPC because the HPA range is already reserved.\n> > > \n> > > Track whether this call to cxl_add_to_region() created the region, and\n> > > call drop_region() on attach_target() failure to unregister it and\n> > > release the HPA resource.  Pre-existing regions are left alone since\n> > > other endpoints may already be attached.\n> > \n> > I see you dropping this, perhaps just for the moment, because\n> > the drop_region() you wanted to use is not available yet.\n> > \n> \n> Yeah it's not a particularly useful cleanup in the current\n> infrastructure because nothing actually uses this pattern (yet).\n> \n> > This looks a lot like \n> > \thttps://lore.kernel.org/linux-cxl/2a613604c0cdda6d9f838ae9b47ea6d936c5e4ce.1769746294.git.alison.schofield@intel.com/\n> > \tcxl/region: Unregister auto-created region when assembly fails\n> > \tWhen auto-created region assembly fails the region remains registered\n> > \tbut disabled. The region continues to reserve its memory resource,\n> > \tpreventing DAX from registering the memory.\n> > \tUnregister the region on assembly failure to release the resource.\n> > \n> > And the review comments on that one, or at least on that thread in\n> > general, was to leave all the broken things in place.\n> > I didn't agree with that, and hope to see this version move ahead\n> > when you have the drop_region you need.\n> > \n> > \n> \n> The important note here is the difference between auto-regions and\n> manually created regions.  For auto-regions, you might have another\n> endpoint show up looking for the partially created region - and then\n> just go off and create it anyway because it thinks it was first.\n\nThat's by design, and that'll eventually fail too.\n\nBut - is see how your case is different. Thanks for the explanation.\n\n> \n> But in my driver, i'm explicitly converting these auto-regions into\n> other things, and if that fails it causes *all other* region creation to\n> fail - even if it wasn't actually dependent on that original region.\n> \n> This is only an issue if you have two devices unbind/bind cycling at\n> the same time - i.e.\n> \n>    echo 0000:d0:00.00 > cxl_pci/unbind\n>    echo 0000:e0:00.00 > cxl_pci/unbind\n>    echo 0000:d0:00.00 > mydriver/bind\n>    echo 0000:e0:00.00 > mydriver/bind\n> \n> If the platform has pre-programmed and locked the decoders, and one of\n> the two devices fails to probe and leaves a hanging partially\n> created region, the other device will fail too.\n> \n> It's a pretty narrow failure scenario.\n> \n> ~Gregory\n> \n",
          "reply_to": "",
          "message_date": "2026-02-23",
          "message_id": ""
        }
      ],
      "analysis_source": "heuristic",
      "patch_summary": "cxl_add_to_region() ignores the return value of attach_target().  When attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO), the auto-discovered region remains registered with its HPA resource consumed but never reaches COMMIT state.  Subsequent region creation attempts fail with -ENOSPC because the HPA range is already reserved.\n\nTrack whether this call to cxl_add_to_region() created the region, and call drop_region() on attach_target() failure to unregister it and release the HPA resource.  Pre-existing regions are left alone since other endpoints may already be attached."
    },
    "2026-02-24": {
      "report_file": "2026-02-24.html",
      "developer": "Gregory Price",
      "reviews": [
        {
          "author": "Alejandro Palau",
          "summary": "Feel free to add it to this series. I have started to send individual series as you know but the part changing the region creation will require more work than the already sent. About this fix, it looks good to me, although I have to admit I'm a bit lost after following the discussion Allison points to. If we want to keep the state of failure for forensics, not sure if the debugging/tracing or default error info in this case will be enough. In any case:",
          "sentiment": "positive",
          "sentiment_signals": [
            "LGTM"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "heuristic",
          "raw_body": "\nOn 2/21/26 05:17, Gregory Price wrote:\n> On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:\n>> cxl_add_to_region() ignores the return value of attach_target().  When\n>> attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),\n>> the auto-discovered region remains registered with its HPA resource\n>> consumed but never reaches COMMIT state.  Subsequent region creation\n>> attempts fail with -ENOSPC because the HPA range is already reserved.\n>>\n>> Track whether this call to cxl_add_to_region() created the region, and\n>> call drop_region() on attach_target() failure to unregister it and\n>> release the HPA resource.  Pre-existing regions are left alone since\n>> other endpoints may already be attached.\n>>\n>> Signed-off-by: Gregory Price <gourry@gourry.net>\n> BAH - disregard this patch, it uses drop_region which is introduced by\n> Alejandro here:\n>\n> https://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/\n>\nFeel free to add it to this series. I have started to send individual \nseries as you know but the part changing the region creation will \nrequire more work than the already sent.\n\nAbout this fix, it looks good to me, although I have to admit I'm a bit \nlost after following the discussion Allison points to. If we want to \nkeep the state of failure for forensics, not sure if the \ndebugging/tracing or default error info in this case will be enough.\n\nIn any case:\n\nReviewed-by: Alejandro Lucero <alucerop@amd.com>\n\n",
          "reply_to": "",
          "message_date": "2026-02-24",
          "message_id": ""
        },
        {
          "author": "Gregory Price (author)",
          "summary": "Yeah i don't quite follow the want to keep the objects around, it seems to cause more issues than it solves - but then i also don't think this is going to be a particularly common problem",
          "sentiment": "positive",
          "sentiment_signals": [
            "LGTM"
          ],
          "has_inline_review": true,
          "tags_given": [],
          "analysis_source": "heuristic",
          "raw_body": "On Tue, Feb 24, 2026 at 04:15:33PM +0000, Alejandro Lucero Palau wrote:\n> \n> On 2/21/26 05:17, Gregory Price wrote:\n> > On Fri, Feb 20, 2026 at 11:30:12PM -0500, Gregory Price wrote:\n> > > cxl_add_to_region() ignores the return value of attach_target().  When\n> > > attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO),\n> > > the auto-discovered region remains registered with its HPA resource\n> > > consumed but never reaches COMMIT state.  Subsequent region creation\n> > > attempts fail with -ENOSPC because the HPA range is already reserved.\n> > > \n> > > Track whether this call to cxl_add_to_region() created the region, and\n> > > call drop_region() on attach_target() failure to unregister it and\n> > > release the HPA resource.  Pre-existing regions are left alone since\n> > > other endpoints may already be attached.\n> > > \n> > > Signed-off-by: Gregory Price <gourry@gourry.net>\n> > BAH - disregard this patch, it uses drop_region which is introduced by\n> > Alejandro here:\n> > \n> > https://lore.kernel.org/linux-cxl/20260201155438.2664640-20-alejandro.lucero-palau@amd.com/\n> > \n> Feel free to add it to this series. I have started to send individual series\n> as you know but the part changing the region creation will require more work\n> than the already sent.\n> \n> About this fix, it looks good to me, although I have to admit I'm a bit lost\n> after following the discussion Allison points to. If we want to keep the\n> state of failure for forensics, not sure if the debugging/tracing or default\n> error info in this case will be enough.\n> \n> In any case:\n> \n> Reviewed-by: Alejandro Lucero <alucerop@amd.com>\n> \n\nYeah i don't quite follow the want to keep the objects around, it seems\nto cause more issues than it solves - but then i also don't think this\nis going to be a particularly common problem\n\n~Gregory\n\n",
          "reply_to": "",
          "message_date": "2026-02-24",
          "message_id": ""
        }
      ],
      "analysis_source": "heuristic",
      "patch_summary": "cxl_add_to_region() ignores the return value of attach_target().  When attach_target() fails (e.g. cxl_port_setup_targets() returns -ENXIO), the auto-discovered region remains registered with its HPA resource consumed but never reaches COMMIT state.  Subsequent region creation attempts fail with -ENOSPC because the HPA range is already reserved.\n\nTrack whether this call to cxl_add_to_region() created the region, and call drop_region() on attach_target() failure to unregister it and release the HPA resource.  Pre-existing regions are left alone since other endpoints may already be attached."
    }
  }
}