<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH v7 2/3] mm: vmscan: add cgroup IDs to vmscan tracepoints</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }
        .reply-to-label {
            font-size: 0.8em;
            color: #999;
            font-style: italic;
            margin-top: 3px;
        }
        .lore-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 0.82em;
            color: #0366d6;
            text-decoration: none;
            font-weight: 500;
            white-space: nowrap;
        }
        .lore-link:hover { text-decoration: underline; color: #0056b3; }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../index.html">&larr; Back to reports</a></div>
    <h1>Re: [PATCH v7 2/3] mm: vmscan: add cgroup IDs to vmscan tracepoints</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/aZyrkRDJpHh8ZnCW@linux.dev/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-24">2026-02-24</a> &bull; <a href="#2026-02-23">2026-02-23</a> &bull; <a href="#2026-02-16">2026-02-16</a> &bull; <a href="#2026-02-13">2026-02-13</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-13">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about passing memcg pointers as arguments in tracepoints instead of using memcg_id, explaining that this change was made to update Steven&#x27;s patch and improve the code.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v6:
- Updated Steven&#x27;s patch with sign-off
- Passed memcg pointers as arguments in tracepoints instead of memcg_id

Link to v5:
https://lore.kernel.org/linux-trace-kernel/20260122182510.2126-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 104 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 48 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
<div class="thread-children">
<div class="thread-node depth-1" id="2026-02-16">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Usama Arif</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-16">2026-02-16</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer questioned the removal of __entry-&gt;shrink in this patch, wondering if it was an intentional change, and implied that its presence is still necessary for some functionality.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">__entry-&gt;shrink is removed here, but still printed below. Was this an intended
change of this commit?</pre>
</details>
<div class="reply-to-label">&#8627; replying to Thomas Ballasi</div>
<div class="review-comment-signals">Signals: unclear intention, potential bug</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-16">2026-02-16</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the patch does not handle the case where a cgroup is being moved to another parent, and suggested adding a check for this scenario

reviewer made a lighthearted comment about the patch author typing tracepoint names manually, rather than copying them from another file</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 16 Feb 2026 08:13:21 -0800
Usama Arif &lt;usama.arif@linux.dev&gt; wrote:

---

Yeah. That&#x27;s when you should have done &quot;cut-and-paste&quot; but instead just
typed it in by memory :-p

-- Steve</pre>
</details>
<div class="reply-to-label">&#8627; replying to Usama Arif</div>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Reviewed-by</div>
<div class="reply-to-label">&#8627; replying to Thomas Ballasi</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Acked-by</div>
<div class="reply-to-label">&#8627; replying to Thomas Ballasi</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shakeel Butt questioned the necessity of an __event_in_irq() check in this patch, pointing out that memory reclaim only occurs in process context and therefore such a check is not required.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Where is this in_task() check happening? Also this patch is changing
tracepoints for memory reclaim which never happens in any context other than
process context, so we don&#x27;t need __event_in_irq() checks for these tracepoints.</pre>
</details>
<div class="reply-to-label">&#8627; replying to Thomas Ballasi</div>
<div class="review-comment-signals">Signals: requested change, technical clarification</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-02-24">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Masami (Google)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-24">2026-02-24</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer noted that the patch does not handle the case where a cgroup is being destroyed, and requested that the patch be updated to handle this scenario

Reviewer Masami suggested using the existing common_pid field in the tracepoint format to store the current process ID, instead of duplicating it.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Hi,

On Mon, 23 Feb 2026 09:15:44 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

All entries saves current-&gt;pid in common_pid field. Can you use
this common field?

# cat events/vmscan/mm_vmscan_reclaim_pages/format 
name: mm_vmscan_reclaim_pages
ID: 590
format:
	field:unsigned short common_type;	offset:0;	size:2;	signed:0;
	field:unsigned char common_flags;	offset:2;	size:1;	signed:0;
	field:unsigned char common_preempt_count;	offset:3;	size:1;	signed:0;
	field:int common_pid;	offset:4;	size:4;	signed:1;    ## &lt;------------here

	field:int nid;	offset:8;	size:4;	signed:1;
	field:unsigned long nr_scanned;	offset:16;	size:8;	signed:0;
	field:unsigned long nr_reclaimed;	offset:24;	size:8;	signed:0;
	field:unsigned long nr_dirty;	offset:32;	size:8;	signed:0;
	field:unsigned long nr_writeback;	offset:40;	size:8;	signed:0;
	field:unsigned long nr_congested;	offset:48;	size:8;	signed:0;
	field:unsigned long nr_immediate;	offset:56;	size:8;	signed:0;
	field:unsigned int nr_activate0;	offset:64;	size:4;	signed:0;
	field:unsigned int nr_activate1;	offset:68;	size:4;	signed:0;
	field:unsigned long nr_ref_keep;	offset:72;	size:8;	signed:0;
	field:unsigned long nr_unmap_fail;	offset:80;	size:8;	signed:0;

Thank you,

-- 
Masami Hiramatsu (Google) &lt;mhiramat@kernel.org&gt;</pre>
</details>
<div class="reply-to-label">&#8627; replying to Thomas Ballasi</div>
<div class="review-comment-signals">Signals: missing edge case, requested change</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about tracepoint flags being stored in the event structure itself, instead of using helper macros that can access the flags portion of the event header. The author agreed to use these helper macros and added them to the patch.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __entry_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: agreed, added</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the default value of the memory cgroup ID (memcg_id) in vmscan tracepoints, explaining that it is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..1212f6a7c223e 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ddf784f996a59 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   shrinkctl-&gt;memcg);
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 shrinkctl-&gt;memcg);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 614ccf39fe3fa..9d512fb354fcd 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6603,11 +6603,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6636,8 +6636,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      memcg);
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6648,7 +6649,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, memcg);
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6684,13 +6685,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, memcg);
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, memcg);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7642,7 +7643,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that the PID field uses in_task() to safely access current-&gt;pid when in process context and sets it to -1 as a sentinel value otherwise.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 35 +++++++++++++++++++++++++----------
 1 file changed, 25 insertions(+), 10 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 1212f6a7c223e..a68b712ef757a 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-23">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author acknowledged a concern about the __entry_in_irq() macro and confirmed that it was renamed to __event_in_irq() in v6, which addressed the issue.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v6:
- Edited __entry_in_irq() to __event_in_irq() in corresponding commit
  message
- Restore an entry that was removed inadvertently

Link to v6:
https://lore.kernel.org/linux-trace-kernel/20260213181537.54350-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 103 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 47 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged, confirmed</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about tracepoint flags and how they are stored in the event header, specifically that some events want to expose if triggered in interrupt or softirq context. The author agrees that instead of recording this information directly in the event structure, helper macros should be used to access the flags portion of the event header. A fix is planned for v2.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged a need for restructuring, agreed to restructure in v2</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the default value of the memory cgroup ID (memcg_id) in tracepoints, explaining that it is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..1212f6a7c223e 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ddf784f996a59 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   shrinkctl-&gt;memcg);
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 shrinkctl-&gt;memcg);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 614ccf39fe3fa..9d512fb354fcd 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6603,11 +6603,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6636,8 +6636,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      memcg);
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6648,7 +6649,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, memcg);
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6684,13 +6685,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, memcg);
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, memcg);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7642,7 +7643,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that they use in_task() to safely access current-&gt;pid when in process context and set it to -1 as a sentinel value otherwise.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 34 +++++++++++++++++++++++++---------
 1 file changed, 25 insertions(+), 9 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 1212f6a7c223e..15b31281f0955 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,6 +278,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
@@ -277,18 +290,21 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>