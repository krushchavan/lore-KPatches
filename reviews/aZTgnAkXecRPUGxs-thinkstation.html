<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH] mm: Add AnonZero accounting for zero-filled anonymous pages</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH] mm: Add AnonZero accounting for zero-filled anonymous pages</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/aZTgnAkXecRPUGxs@thinkstation/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-17">2026-02-17</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-17">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Kiryl Shutsemau</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Kiryl Shutsemau expressed concerns that the patch will slow down /proc/pid/smaps reads and proposed a more scalable solution using a syscall to return memory stats in binary form.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; have been allocated and mapped to userspace but zero-filled.
&gt; 
&gt; This feature is mainly used to debug large folio mechanism, which
&gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; waste from unaccessed pages.
&gt; 
&gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.

I expect it to slowdown /proc/pid/smaps read substantially. I don&#x27;t
think this line in smaps worth it.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov


---

On Mon, Feb 16, 2026 at 12:45:13PM +0100, David Hildenbrand (Arm) wrote:
&gt; On 2/16/26 12:34, Kiryl Shutsemau wrote:
&gt; &gt; On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; &gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt; &gt; &gt; 
&gt; &gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; &gt; waste from unaccessed pages.
&gt; &gt; &gt; 
&gt; &gt; &gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; &gt; 
&gt; &gt; I expect it to slowdown /proc/pid/smaps read substantially. I don&#x27;t
&gt; &gt; think this line in smaps worth it.
&gt; &gt; 
&gt; 
&gt; That&#x27;s why it&#x27;s enabled through a command line parameter.

One users want the stat and all users on the machine pay the price?
That&#x27;s a poor trade off.

In general, smaps scales poorly. It collects a lot of stats and most of
them are ignored by user. We need something like statx(2) where user can
declare what he is interested in, so kernel won&#x27;t waste cycles.

Kernel cmdline parameter is the wrong place to declare what stats you
want to see.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov


---

On Mon, Feb 16, 2026 at 11:59:50PM +0800, Wenchao Hao wrote:
&gt; On Mon, Feb 16, 2026 at 7:58\u202fPM Kiryl Shutsemau &lt;kirill@shutemov.name&gt; wrote:
&gt; &gt;
&gt; &gt; On Mon, Feb 16, 2026 at 12:45:13PM +0100, David Hildenbrand (Arm) wrote:
&gt; &gt; &gt; On 2/16/26 12:34, Kiryl Shutsemau wrote:
&gt; &gt; &gt; &gt; On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; &gt; &gt; &gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; &gt; &gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; &gt; &gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; &gt; &gt; &gt; waste from unaccessed pages.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; I expect it to slowdown /proc/pid/smaps read substantially. I don&#x27;t
&gt; &gt; &gt; &gt; think this line in smaps worth it.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; That&#x27;s why it&#x27;s enabled through a command line parameter.
&gt; &gt;
&gt; &gt; One users want the stat and all users on the machine pay the price?
&gt; &gt; That&#x27;s a poor trade off.
&gt; &gt;
&gt; &gt; In general, smaps scales poorly. It collects a lot of stats and most of
&gt; &gt; them are ignored by user. We need something like statx(2) where user can
&gt; &gt; declare what he is interested in, so kernel won&#x27;t waste cycles.
&gt; &gt;
&gt; 
&gt; I initially considered two approaches:
&gt; 
&gt; First, exposing the needed information via smaps. This does incur some
&gt; performance cost but is the simplest to implement. The new feature can be
&gt; dynamically toggled via a command-line parameter. When disabled, the
&gt; overhead is negligible\u2014only a minor if check, which is insignificant compared
&gt; to the full smaps cost.
&gt; 
&gt; Second, adding a new system call or extending madvise with a new command
&gt; like MADV_GET_ZEROANON. Userspace tools can then use it to measure
&gt; memory waste from zero-filled anonymous huge pages.
&gt; 
&gt; This is slightly more complex but minimizes system impact: environments that
&gt; don\u2019t care about zero-filled anonymous pages pay zero overhead when the
&gt; command is not used.
&gt; 
&gt; The exact implementation approach can be discussed after we confirm whether
&gt; the upstream kernel needs this debugging feature.

What I would like to see in the kernel is a syscall that return the
memory stats in binary form. Something like

size_t memstat(int pidfd, struct memstat memstatbuf[], size_t n,
		unsigned long flags, unsigned long start, unsigned long end);

The syscall will fill up to n memstatbufs, one per-VMA. What exactly
filled there defined by flags. The return value is how many memstatbuf
is populated. The caller can call it multiple times to walk address
space it is interested in.

We also can have a flag that mirrors smaps_rollup behaviour and collect
all the data into a single memstatbuf.

Internally, the kernel can use the infrastructure built for this syscall
to provide /proc/&lt;PID&gt;/{maps,smaps,smaps_rollup}. This way we will not
duplicate the code.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov


---

On Mon, Feb 16, 2026 at 05:01:51PM +0000, Matthew Wilcox wrote:
&gt; On Mon, Feb 16, 2026 at 04:54:05PM +0000, Kiryl Shutsemau wrote:
&gt; &gt; What I would like to see in the kernel is a syscall that return the
&gt; &gt; memory stats in binary form. Something like
&gt; &gt; 
&gt; &gt; size_t memstat(int pidfd, struct memstat memstatbuf[], size_t n,
&gt; &gt; 		unsigned long flags, unsigned long start, unsigned long end);
&gt; &gt; 
&gt; &gt; The syscall will fill up to n memstatbufs, one per-VMA. What exactly
&gt; &gt; filled there defined by flags. The return value is how many memstatbuf
&gt; &gt; is populated. The caller can call it multiple times to walk address
&gt; &gt; space it is interested in.
&gt; &gt; 
&gt; &gt; We also can have a flag that mirrors smaps_rollup behaviour and collect
&gt; &gt; all the data into a single memstatbuf.
&gt; 
&gt; But is that what we want?  Let&#x27;s say a process allocates a 2MB THP, uses
&gt; 12kB of it and then forks.  A lot.  Now all children that haven&#x27;t called
&gt; exec() see the wasted 2036kB.  Would we rather have something that scans
&gt; (say) the LRU list looking for zero memory?

Are describing THP shrinker? :)

I don&#x27;t particular care about original poster use-case. I want to see
more scalable way to access memory statistic information in general.
smaps is slow, because it collects information user doesn&#x27;t care about.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov
</pre>
</details>
<div class="review-comment-signals">Signals: performance concern, scalability issue</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">David (Arm)</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer David (Arm) raised concerns about the patch&#x27;s design and functionality, questioning its usefulness beyond debugging and suggesting alternative approaches such as providing a system call for filtering specific stats or using a file-based solution.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 2/16/26 12:34, Kiryl Shutsemau wrote:
&gt; On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt;&gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt;&gt; have been allocated and mapped to userspace but zero-filled.
&gt;&gt;
&gt;&gt; This feature is mainly used to debug large folio mechanism, which
&gt;&gt; pre-allocates and map more pages than actually needed, leading to memory
&gt;&gt; waste from unaccessed pages.
&gt;&gt;
&gt;&gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; 
&gt; I expect it to slowdown /proc/pid/smaps read substantially. I don&#x27;t
&gt; think this line in smaps worth it.
&gt; 

That&#x27;s why it&#x27;s enabled through a command line parameter.

-- 
Cheers,

David


---

On 2/14/26 09:45, Wenchao Hao wrote:
&gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; have been allocated and mapped to userspace but zero-filled.

&quot;count_zero_page&quot; is rather sub-optimal parameter name. &quot;anonzero_in_smaps&quot; or sth like that?

Still wondering if there could be a better way to enable this dynamically.

In particular, not using a core parameter.

If you use a module parameter, you can just set on the cmdline

	proc.anonzero_in_smaps=1

And dynamically set/observe it in

	/sys/module/proc/parameters/anonzero_in_smaps


diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index d7d52e259055..0301b9cd28f8 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -34,6 +34,10 @@
  
  #define SEQ_PUT_DEC(str, val) \
                 seq_put_decimal_ull_width(m, str, (val) &lt;&lt; (PAGE_SHIFT-10), 8)
+
+static bool anonzero_in_smaps;
+module_param(anonzero_in_smaps, bool, 0644);
+
  void task_mem(struct seq_file *m, struct mm_struct *mm)
  {
         unsigned long text, lib, swap, anon, file, shmem;


&gt; 
&gt; This feature is mainly used to debug large folio mechanism, which
&gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; waste from unaccessed pages.
&gt; 
&gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; 
&gt; Link: https://lore.kernel.org/linux-mm/20260210043456.2137482-1-haowenchao22@gmail.com/
&gt; Signed-off-by: Wenchao Hao &lt;haowenchao22@gmail.com&gt;
&gt; ---
&gt;   Documentation/filesystems/proc.rst |  5 +++++
&gt;   fs/proc/task_mmu.c                 | 10 ++++++++++
&gt;   2 files changed, 15 insertions(+)
&gt; 
&gt; diff --git a/Documentation/filesystems/proc.rst b/Documentation/filesystems/proc.rst
&gt; index b0c0d1b45b99..573c8b015e39 100644
&gt; --- a/Documentation/filesystems/proc.rst
&gt; +++ b/Documentation/filesystems/proc.rst
&gt; @@ -545,6 +545,11 @@ replaced by copy-on-write) part of the underlying shmem object out on swap.
&gt;   does not take into account swapped out page of underlying shmem objects.
&gt;   &quot;Locked&quot; indicates whether the mapping is locked in memory or not.
&gt;   
&gt; +&quot;AnonZero&quot; shows the size of anonymous pages that have never been accessed
&gt; +after mapping, and it can reflect the memory waste caused by huge pages.

That&#x27;s not correct. They could be read/written, but with zeroes.

&gt; +Implemented by scanning the size of zero-filled pages of the VMA. It
&gt; +is default disabled, and enabled via cmdline param &quot;count_zero_page=true&quot;.

Probably best to keep it simpler:

&quot;AnonZero&quot; shows the size of anonymous pages that contain zeroes. Zero-filled
pages can indicate memory waste caused by memory-overallocation with (m)THPs.
Availability is controlled through XYZ.

-- 
Cheers,

David


---

On 2/16/26 12:58, Kiryl Shutsemau wrote:
&gt; On Mon, Feb 16, 2026 at 12:45:13PM +0100, David Hildenbrand (Arm) wrote:
&gt;&gt; On 2/16/26 12:34, Kiryl Shutsemau wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; I expect it to slowdown /proc/pid/smaps read substantially. I don&#x27;t
&gt;&gt;&gt; think this line in smaps worth it.
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; That&#x27;s why it&#x27;s enabled through a command line parameter.
&gt; 
&gt; One users want the stat and all users on the machine pay the price?
&gt; That&#x27;s a poor trade off.
&gt; 

It&#x27;s a debug mechanism as stated in the patch description.

Similar to CONFIG_DEBUG_VM slowing your machine down.

&gt; In general, smaps scales poorly. It collects a lot of stats and most of
&gt; them are ignored by user. We need something like statx(2) where user can
&gt; declare what he is interested in, so kernel won&#x27;t waste cycles.
&gt; 
&gt; Kernel cmdline parameter is the wrong place to declare what stats you
&gt; want to see.

If you have a good idea, please shoot. I proposed using module parameter 
that
can get toggled more easily by the admin that debugs something.

It&#x27;s a good question of someone would want to use this mechanism not 
just for debugging. Then, indeed, a more selective (per-process) toggle 
could be warranted. But likely the scanning would in any case be too 
expensive for any non-debug case.

So let&#x27;s not over-engineer a debug mechanism if this is intended to stay 
a debug mechanism.

-- 
Cheers,

David


---

On 2/16/26 16:10, Wenchao Hao wrote:
&gt; On Mon, Feb 16, 2026 at 8:15\u202fPM David Hildenbrand (Arm)
&gt; &lt;david@kernel.org&gt; wrote:
&gt;&gt;
&gt;&gt; On 2/14/26 09:45, Wenchao Hao wrote:
&gt;&gt;&gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt;&gt;&gt; have been allocated and mapped to userspace but zero-filled.
&gt;&gt;
&gt;&gt; &quot;count_zero_page&quot; is rather sub-optimal parameter name. &quot;anonzero_in_smaps&quot; or sth like that?
&gt;&gt;
&gt; Your naming suggestion is indeed better than mine. If this patch is still needed
&gt; for further development, I will modify it according to your advice.
&gt; 
&gt;&gt; Still wondering if there could be a better way to enable this dynamically.
&gt;&gt;
&gt;&gt; In particular, not using a core parameter.
&gt;&gt;
&gt;&gt; If you use a module parameter, you can just set on the cmdline
&gt;&gt;
&gt;&gt;          proc.anonzero_in_smaps=1
&gt;&gt;
&gt;&gt; And dynamically set/observe it in
&gt;&gt;
&gt;&gt;          /sys/module/proc/parameters/anonzero_in_smaps
&gt;&gt;
&gt; Regarding the use of module parameters versus core_param, I think
&gt; either approach is ok.
&gt; Currently, the core_param I&#x27;m using also supports two modification methods:
&gt; 
&gt; 1. Command line parameter: count_zero_page=Y
&gt; 2. After system boot, view or modify it via
&gt; /sys/module/kernel/parameters/count_zero_page
&gt; 
&gt; It is true that this modification would be more appropriately placed
&gt; in the proc module,
&gt; which aligns with your earlier suggestion.
&gt; 
&gt; If there is a possibility of further iteration on this change, I will
&gt; move it to the proc module instead
&gt; of using a core_param
&gt; 
&gt;&gt;&gt;
&gt;&gt;&gt; This feature is mainly used to debug large folio mechanism, which
&gt;&gt;&gt; pre-allocates and map more pages than actually needed, leading to memory
&gt;&gt;&gt; waste from unaccessed pages.
&gt;&gt;&gt;
&gt;&gt;&gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt;&gt;&gt;
&gt;&gt;&gt; Link: https://lore.kernel.org/linux-mm/20260210043456.2137482-1-haowenchao22@gmail.com/
&gt;&gt;&gt; Signed-off-by: Wenchao Hao &lt;haowenchao22@gmail.com&gt;
&gt;&gt;&gt; ---
&gt;&gt;&gt;    Documentation/filesystems/proc.rst |  5 +++++
&gt;&gt;&gt;    fs/proc/task_mmu.c                 | 10 ++++++++++
&gt;&gt;&gt;    2 files changed, 15 insertions(+)
&gt;&gt;&gt;
&gt;&gt;&gt; diff --git a/Documentation/filesystems/proc.rst b/Documentation/filesystems/proc.rst
&gt;&gt;&gt; index b0c0d1b45b99..573c8b015e39 100644
&gt;&gt;&gt; --- a/Documentation/filesystems/proc.rst
&gt;&gt;&gt; +++ b/Documentation/filesystems/proc.rst
&gt;&gt;&gt; @@ -545,6 +545,11 @@ replaced by copy-on-write) part of the underlying shmem object out on swap.
&gt;&gt;&gt;    does not take into account swapped out page of underlying shmem objects.
&gt;&gt;&gt;    &quot;Locked&quot; indicates whether the mapping is locked in memory or not.
&gt;&gt;&gt;
&gt;&gt;&gt; +&quot;AnonZero&quot; shows the size of anonymous pages that have never been accessed
&gt;&gt;&gt; +after mapping, and it can reflect the memory waste caused by huge pages.
&gt;&gt;
&gt;&gt; That&#x27;s not correct. They could be read/written, but with zeroes.
&gt;&gt;
&gt;&gt;&gt; +Implemented by scanning the size of zero-filled pages of the VMA. It
&gt;&gt;&gt; +is default disabled, and enabled via cmdline param &quot;count_zero_page=true&quot;.
&gt;&gt;
&gt;&gt; Probably best to keep it simpler:
&gt;&gt;
&gt;&gt; &quot;AnonZero&quot; shows the size of anonymous pages that contain zeroes. Zero-filled
&gt;&gt; pages can indicate memory waste caused by memory-overallocation with (m)THPs.
&gt;&gt; Availability is controlled through XYZ.
&gt;&gt;
&gt; As with your earlier suggestion, if this change is to be iterated on
&gt; further, I will update it according
&gt; to your suggestion.

Let&#x27;s wait first for other opinions. Willy doesn&#x27;t seem to like it if 
there is no use case besides for limited experiments where you could 
just use the OOT patch, possibly.

-- 
Cheers,

David


---

On 2/16/26 17:42, Michal Hocko wrote:
&gt; On Mon 16-02-26 23:59:50, Wenchao Hao wrote:
&gt;&gt; On Mon, Feb 16, 2026 at 7:58\u202fPM Kiryl Shutsemau &lt;kirill@shutemov.name&gt; wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; One users want the stat and all users on the machine pay the price?
&gt;&gt;&gt; That&#x27;s a poor trade off.
&gt;&gt;&gt;
&gt;&gt;&gt; In general, smaps scales poorly. It collects a lot of stats and most of
&gt;&gt;&gt; them are ignored by user. We need something like statx(2) where user can
&gt;&gt;&gt; declare what he is interested in, so kernel won&#x27;t waste cycles.
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; I initially considered two approaches:
&gt;&gt;
&gt;&gt; First, exposing the needed information via smaps. This does incur some
&gt;&gt; performance cost but is the simplest to implement. The new feature can be
&gt;&gt; dynamically toggled via a command-line parameter. When disabled, the
&gt;&gt; overhead is negligible\u2014only a minor if check, which is insignificant compared
&gt;&gt; to the full smaps cost.
&gt; 
&gt; You are comparing content of all anon pages, aren&#x27;t you? Depending on
&gt; the content this can add a lot of overhead.
&gt; 
&gt;&gt; Second, adding a new system call or extending madvise with a new command
&gt;&gt; like MADV_GET_ZEROANON. Userspace tools can then use it to measure
&gt;&gt; memory waste from zero-filled anonymous huge pages.
&gt; 
&gt; MADV_GET_ZEROPAGE would make more sense to me. But a more fundamental
&gt; question is whether this metric is really what you want long term.
&gt; Kernel can do all sorts of optimizations behind userspace back - e.g.
&gt; map shared zero page - so just learning that a process has a lot of
&gt; pages filled up with zeroes doesn&#x27;t tell you all that much. Or does it?

If a sysadmin wants to see where THP hurt (zero-filled pages), surely 
MADV_GET_ZEROPAGE is the wrong (ugly) interface.

All we want are per-process stats. What am I missing?


KSM could deduplicate them, the deferred shrinker could remove them. 
Unless both mechanisms are not desired or are ineffective for another 
reason (e.g., page pinning).

-- 
Cheers,

David


---

On 2/16/26 18:01, Matthew Wilcox wrote:
&gt; On Mon, Feb 16, 2026 at 04:54:05PM +0000, Kiryl Shutsemau wrote:
&gt;&gt; What I would like to see in the kernel is a syscall that return the
&gt;&gt; memory stats in binary form. Something like
&gt;&gt;
&gt;&gt; size_t memstat(int pidfd, struct memstat memstatbuf[], size_t n,
&gt;&gt; 		unsigned long flags, unsigned long start, unsigned long end);
&gt;&gt;
&gt;&gt; The syscall will fill up to n memstatbufs, one per-VMA. What exactly
&gt;&gt; filled there defined by flags. The return value is how many memstatbuf
&gt;&gt; is populated. The caller can call it multiple times to walk address
&gt;&gt; space it is interested in.
&gt;&gt;
&gt;&gt; We also can have a flag that mirrors smaps_rollup behaviour and collect
&gt;&gt; all the data into a single memstatbuf.
&gt; 
&gt; But is that what we want?  Let&#x27;s say a process allocates a 2MB THP, uses
&gt; 12kB of it and then forks.
That&#x27;s just like all of these entries (Rss, Anonymous, KSM) except the 
Pss ones behave.

-- 
Cheers,

David


---

On 2/16/26 18:10, Michal Hocko wrote:
&gt; On Mon 16-02-26 17:56:12, David Hildenbrand wrote:
&gt;&gt; On 2/16/26 17:42, Michal Hocko wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; You are comparing content of all anon pages, aren&#x27;t you? Depending on
&gt;&gt;&gt; the content this can add a lot of overhead.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; MADV_GET_ZEROPAGE would make more sense to me. But a more fundamental
&gt;&gt;&gt; question is whether this metric is really what you want long term.
&gt;&gt;&gt; Kernel can do all sorts of optimizations behind userspace back - e.g.
&gt;&gt;&gt; map shared zero page - so just learning that a process has a lot of
&gt;&gt;&gt; pages filled up with zeroes doesn&#x27;t tell you all that much. Or does it?
&gt;&gt;
&gt;&gt; If a sysadmin wants to see where THP hurt (zero-filled pages), surely
&gt;&gt; MADV_GET_ZEROPAGE is the wrong (ugly) interface.
&gt; 
&gt; The question is whether sysadmin should really ask questions like that.
&gt; Without a deeper understanding of the workload the answer could be
&gt; misleading at best, no matter what interface is available.

Given the requests for per-process control of THPs I assume some 
sysadmins (at hyperscalers :) ) really care about the relevant processes 
and even the relevant memory areas (e.g., jmalloc area).

&gt; 
&gt; If you know and understand the workload you already know that THP is not
&gt; a good fit and you do not need to ask about that. If you want to
&gt; understand whether your particular workload has a big internal
&gt; fragmentation due to THPs then MADV_GET_ZEROPAGE sounds like a
&gt; reasonable fit to me.

You could also just scan the pages yourself for 0-content, or what&#x27;s the 
benefit of letting the kernel do that?

&gt; 
&gt;  From a sysadmin POV you care about the overall memory consuption, right?

I&#x27;m not so sure about that.

-- 
Cheers,

David


---

On 2/17/26 16:22, Wenchao Hao wrote:
&gt; On Sat, Feb 14, 2026 at 4:45\u202fPM Wenchao Hao &lt;haowenchao22@gmail.com&gt; wrote:
&gt;&gt;
&gt;&gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt;&gt; have been allocated and mapped to userspace but zero-filled.
&gt;&gt;
&gt;&gt; This feature is mainly used to debug large folio mechanism, which
&gt;&gt; pre-allocates and map more pages than actually needed, leading to memory
&gt;&gt; waste from unaccessed pages.
&gt;&gt;
&gt;&gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt;&gt;
&gt;&gt; Link: https://lore.kernel.org/linux-mm/20260210043456.2137482-1-haowenchao22@gmail.com/
&gt; 
&gt; Sorry for the late reply. We are now on Chinese New Year holiday, so...
&gt; 
&gt; The original goal of this patch is to measure memory waste from anonymous
&gt; THPs - pages pre-allocated on fault but never accessed.
&gt; 
&gt; On memory-sensitive devices like mobile phones, this helps us make better
&gt; decisions about when and how to enable THP. I think this is useful for
&gt; guiding THP policies, even as a debugging feature.
&gt; 
&gt; Let me summarize the discussion so far:
&gt; - Matthew Wilcox questioned the value and raised concerns fork but haven&#x27;t
&gt;    exec path
&gt; - Michal Hocko criticized the inefficiency of scanning zero-filled pages.
&gt; - Kiryl Shutsemau prefers a system-call-based interface.
&gt; - David Hildenbrand acknowledged the value and suggested implementation
&gt;    improvements.
&gt; Please correct me if I missed or misrepresented anything.
&gt; 
&gt; I suggest we first agree whether this functionality is useful for upstream,
&gt; before discussing implementation details.
&gt; 
&gt; Reasons why this should go upstream from me:
&gt; 
&gt; - Anonymous THP can introduce real memory waste, but we currently have no
&gt;    good way to measure it.
&gt; - With accurate metrics, we can make better THP policy: disable for
&gt;    low-utilization cases, or early-unmap to relieve memory pressure and so
&gt;    on. This is especially valuable for mobile/embedded devices.
&gt; 
&gt; Possible implementations:
&gt; 
&gt; 1. A new smaps counter (default-off) to count zero-filled pages.
&gt; 2. A new madvise command like MADV_GET_ZEROPAGE
&gt; 3. A dedicated system call

I understand Kiyls point about smaps providing too much information 
users might not be interested in already. So sorting that out might 
provide a real benefit to other users that are only interested in 
specific stats (e.g., Rss).

Providing a system call where one can specify/filter in theory sounds 
like a good idea. A syscall implies that one has to write a tool to 
obtain these metrics.

The nice thing about smaps/smaps_rollup is that it can be easily 
consumed on any system while debugging.

I wonder if there could be a way to achieve something similar with a 
file. Likely not, but maybe someone reading along can surprise me :)

Otherwise we&#x27;d have to go with a tool.

-- 
Cheers,

David
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, alternative approaches</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Matthew Wilcox</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="badge" style="color:#721c24;background:#f8d7da">Contentious</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Matthew Wilcox expressed strong disagreement and skepticism about the patch&#x27;s usefulness, questioning its purpose and suggesting alternative approaches to tracking memory waste.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; have been allocated and mapped to userspace but zero-filled.
&gt; 
&gt; This feature is mainly used to debug large folio mechanism, which
&gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; waste from unaccessed pages.

Why are you trying to get this upstream when you admitted in an earlier
email this is just for your internal use?

Why do you think that &quot;unaccessed pages&quot; are the only, or even the
largest source of extra memory consumption?  The vast majority of files
are never mmaped.

This just seems like a giant waste of time.


---

On Mon, Feb 16, 2026 at 04:54:05PM +0000, Kiryl Shutsemau wrote:
&gt; What I would like to see in the kernel is a syscall that return the
&gt; memory stats in binary form. Something like
&gt; 
&gt; size_t memstat(int pidfd, struct memstat memstatbuf[], size_t n,
&gt; 		unsigned long flags, unsigned long start, unsigned long end);
&gt; 
&gt; The syscall will fill up to n memstatbufs, one per-VMA. What exactly
&gt; filled there defined by flags. The return value is how many memstatbuf
&gt; is populated. The caller can call it multiple times to walk address
&gt; space it is interested in.
&gt; 
&gt; We also can have a flag that mirrors smaps_rollup behaviour and collect
&gt; all the data into a single memstatbuf.

But is that what we want?  Let&#x27;s say a process allocates a 2MB THP, uses
12kB of it and then forks.  A lot.  Now all children that haven&#x27;t called
exec() see the wasted 2036kB.  Would we rather have something that scans
(say) the LRU list looking for zero memory?


---

On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; +		if (count_zero_page &amp;&amp; pages_identical(page, ZERO_PAGE(0)))

Pretty sure you want memchr_inv() here?
</pre>
</details>
<div class="review-comment-signals">Signals: strong disagreement, skeptical</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Wenchao Hao (author)</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Wenchao Hao, discussed the usefulness of the patch for measuring memory waste from anonymous THPs and proposed three possible implementations: a new smaps counter, a new madvise command, or a dedicated system call.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, Feb 16, 2026 at 8:15 PM David Hildenbrand (Arm)
&lt;david@kernel.org&gt; wrote:
&gt;
&gt; On 2/14/26 09:45, Wenchao Hao wrote:
&gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt;
&gt; &quot;count_zero_page&quot; is rather sub-optimal parameter name. &quot;anonzero_in_smaps&quot; or sth like that?
&gt;
Your naming suggestion is indeed better than mine. If this patch is still needed
for further development, I will modify it according to your advice.

&gt; Still wondering if there could be a better way to enable this dynamically.
&gt;
&gt; In particular, not using a core parameter.
&gt;
&gt; If you use a module parameter, you can just set on the cmdline
&gt;
&gt;         proc.anonzero_in_smaps=1
&gt;
&gt; And dynamically set/observe it in
&gt;
&gt;         /sys/module/proc/parameters/anonzero_in_smaps
&gt;
Regarding the use of module parameters versus core_param, I think
either approach is ok.
Currently, the core_param I&#x27;m using also supports two modification methods:

1. Command line parameter: count_zero_page=Y
2. After system boot, view or modify it via
/sys/module/kernel/parameters/count_zero_page

It is true that this modification would be more appropriately placed
in the proc module,
which aligns with your earlier suggestion.

If there is a possibility of further iteration on this change, I will
move it to the proc module instead
of using a core_param

&gt; &gt;
&gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; waste from unaccessed pages.
&gt; &gt;
&gt; &gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; &gt;
&gt; &gt; Link: https://lore.kernel.org/linux-mm/20260210043456.2137482-1-haowenchao22@gmail.com/
&gt; &gt; Signed-off-by: Wenchao Hao &lt;haowenchao22@gmail.com&gt;
&gt; &gt; ---
&gt; &gt;   Documentation/filesystems/proc.rst |  5 +++++
&gt; &gt;   fs/proc/task_mmu.c                 | 10 ++++++++++
&gt; &gt;   2 files changed, 15 insertions(+)
&gt; &gt;
&gt; &gt; diff --git a/Documentation/filesystems/proc.rst b/Documentation/filesystems/proc.rst
&gt; &gt; index b0c0d1b45b99..573c8b015e39 100644
&gt; &gt; --- a/Documentation/filesystems/proc.rst
&gt; &gt; +++ b/Documentation/filesystems/proc.rst
&gt; &gt; @@ -545,6 +545,11 @@ replaced by copy-on-write) part of the underlying shmem object out on swap.
&gt; &gt;   does not take into account swapped out page of underlying shmem objects.
&gt; &gt;   &quot;Locked&quot; indicates whether the mapping is locked in memory or not.
&gt; &gt;
&gt; &gt; +&quot;AnonZero&quot; shows the size of anonymous pages that have never been accessed
&gt; &gt; +after mapping, and it can reflect the memory waste caused by huge pages.
&gt;
&gt; That&#x27;s not correct. They could be read/written, but with zeroes.
&gt;
&gt; &gt; +Implemented by scanning the size of zero-filled pages of the VMA. It
&gt; &gt; +is default disabled, and enabled via cmdline param &quot;count_zero_page=true&quot;.
&gt;
&gt; Probably best to keep it simpler:
&gt;
&gt; &quot;AnonZero&quot; shows the size of anonymous pages that contain zeroes. Zero-filled
&gt; pages can indicate memory waste caused by memory-overallocation with (m)THPs.
&gt; Availability is controlled through XYZ.
&gt;
As with your earlier suggestion, if this change is to be iterated on
further, I will update it according
to your suggestion.

Thanks.

&gt; --
&gt; Cheers,
&gt;
&gt; David


---

On Mon, Feb 16, 2026 at 10:23 PM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt;
&gt; On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt; &gt;
&gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; waste from unaccessed pages.
&gt;
&gt; Why are you trying to get this upstream when you admitted in an earlier
&gt; email this is just for your internal use?
&gt;

I see this as a debugging feature, not limited to internal use only.

Our real goal is to gain more precise visibility into how system memory is used.
A basic requirement is to measure the memory overhead caused by anonymous
hugepages that have been pre-allocated but never accessed.
With this information, we can implement various policies:
 - Allocate only 4K pages for applications that suffer severe memory waste from
   anonymous hugepages.
- Evaluate per-process hugepage waste during low system load and proactively
   split hugepages accordingly.

So I believe this debugging feature still provides value when merged upstream.
Currently, there is no effective way to account for memory waste from
pre-allocated
but unused anonymous hugepages, and this feature fills that gap. Or do you have
any suggestions about how to get this info?

&gt; Why do you think that &quot;unaccessed pages&quot; are the only, or even the
&gt; largest source of extra memory consumption?  The vast majority of files
&gt; are never mmaped.
&gt;

In my view, memory waste from anonymous hugepages is less acceptable than that
from file pages.

Although file pages may also be unmapped, a cache hit can still reduce
I/O overhead.
By contrast, pre-allocated anonymous hugepages that are never accessed represent
pure waste.

Furthermore, the total number of unmapped file pages can already be
estimated from
/proc/meminfo, so we can already apply policies to control file page waste.

&gt;From my research, many memory-sensitive environments already apply
special policies
for file pages—for example, the RFC patch from vivo that manages
readahead file pages
separately:
https://lore.kernel.org/linux-mm/20250916072226.220426-1-liulei.rjpt@vivo.com/

But file page waste is not the main point I want to focus on here.

Thanks.


---

On Mon, Feb 16, 2026 at 7:58 PM Kiryl Shutsemau &lt;kirill@shutemov.name&gt; wrote:
&gt;
&gt; On Mon, Feb 16, 2026 at 12:45:13PM +0100, David Hildenbrand (Arm) wrote:
&gt; &gt; On 2/16/26 12:34, Kiryl Shutsemau wrote:
&gt; &gt; &gt; On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; &gt; &gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; &gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; &gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; &gt; &gt; waste from unaccessed pages.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; &gt; &gt;
&gt; &gt; &gt; I expect it to slowdown /proc/pid/smaps read substantially. I don&#x27;t
&gt; &gt; &gt; think this line in smaps worth it.
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; That&#x27;s why it&#x27;s enabled through a command line parameter.
&gt;
&gt; One users want the stat and all users on the machine pay the price?
&gt; That&#x27;s a poor trade off.
&gt;
&gt; In general, smaps scales poorly. It collects a lot of stats and most of
&gt; them are ignored by user. We need something like statx(2) where user can
&gt; declare what he is interested in, so kernel won&#x27;t waste cycles.
&gt;

I initially considered two approaches:

First, exposing the needed information via smaps. This does incur some
performance cost but is the simplest to implement. The new feature can be
dynamically toggled via a command-line parameter. When disabled, the
overhead is negligible—only a minor if check, which is insignificant compared
to the full smaps cost.

Second, adding a new system call or extending madvise with a new command
like MADV_GET_ZEROANON. Userspace tools can then use it to measure
memory waste from zero-filled anonymous huge pages.

This is slightly more complex but minimizes system impact: environments that
don’t care about zero-filled anonymous pages pay zero overhead when the
command is not used.

The exact implementation approach can be discussed after we confirm whether
the upstream kernel needs this debugging feature.

Thanks.

&gt; Kernel cmdline parameter is the wrong place to declare what stats you
&gt; want to see.
&gt;
&gt; --
&gt;   Kiryl Shutsemau / Kirill A. Shutemov


---

On Sat, Feb 14, 2026 at 4:45 PM Wenchao Hao &lt;haowenchao22@gmail.com&gt; wrote:
&gt;
&gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; have been allocated and mapped to userspace but zero-filled.
&gt;
&gt; This feature is mainly used to debug large folio mechanism, which
&gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; waste from unaccessed pages.
&gt;
&gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt;
&gt; Link: https://lore.kernel.org/linux-mm/20260210043456.2137482-1-haowenchao22@gmail.com/

Sorry for the late reply. We are now on Chinese New Year holiday, so...

The original goal of this patch is to measure memory waste from anonymous
THPs - pages pre-allocated on fault but never accessed.

On memory-sensitive devices like mobile phones, this helps us make better
decisions about when and how to enable THP. I think this is useful for
guiding THP policies, even as a debugging feature.

Let me summarize the discussion so far:
- Matthew Wilcox questioned the value and raised concerns fork but haven&#x27;t
  exec path
- Michal Hocko criticized the inefficiency of scanning zero-filled pages.
- Kiryl Shutsemau prefers a system-call-based interface.
- David Hildenbrand acknowledged the value and suggested implementation
  improvements.
Please correct me if I missed or misrepresented anything.

I suggest we first agree whether this functionality is useful for upstream,
before discussing implementation details.

Reasons why this should go upstream from me:

- Anonymous THP can introduce real memory waste, but we currently have no
  good way to measure it.
- With accurate metrics, we can make better THP policy: disable for
  low-utilization cases, or early-unmap to relieve memory pressure and so
  on. This is especially valuable for mobile/embedded devices.

Possible implementations:

1. A new smaps counter (default-off) to count zero-filled pages.
2. A new madvise command like MADV_GET_ZEROPAGE
3. A dedicated system call

I welcome feedback on whether this is useful, and any better approaches.

Thank you.
</pre>
</details>
<div class="review-comment-signals">Signals: NEEDS_WORK, POSITIVE</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Michal Hocko</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Michal Hocko raised concerns about the overhead of tracking zero-filled anonymous pages and suggested alternative approaches such as using MADV_GET_ZEROPAGE or a high-level compression interface.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon 16-02-26 23:59:50, Wenchao Hao wrote:
&gt; On Mon, Feb 16, 2026 at 7:58\u202fPM Kiryl Shutsemau &lt;kirill@shutemov.name&gt; wrote:
&gt; &gt;
&gt; &gt; On Mon, Feb 16, 2026 at 12:45:13PM +0100, David Hildenbrand (Arm) wrote:
&gt; &gt; &gt; On 2/16/26 12:34, Kiryl Shutsemau wrote:
&gt; &gt; &gt; &gt; On Sat, Feb 14, 2026 at 04:45:14PM +0800, Wenchao Hao wrote:
&gt; &gt; &gt; &gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; &gt; &gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; &gt; &gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; &gt; &gt; &gt; waste from unaccessed pages.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; I expect it to slowdown /proc/pid/smaps read substantially. I don&#x27;t
&gt; &gt; &gt; &gt; think this line in smaps worth it.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; That&#x27;s why it&#x27;s enabled through a command line parameter.
&gt; &gt;
&gt; &gt; One users want the stat and all users on the machine pay the price?
&gt; &gt; That&#x27;s a poor trade off.
&gt; &gt;
&gt; &gt; In general, smaps scales poorly. It collects a lot of stats and most of
&gt; &gt; them are ignored by user. We need something like statx(2) where user can
&gt; &gt; declare what he is interested in, so kernel won&#x27;t waste cycles.
&gt; &gt;
&gt; 
&gt; I initially considered two approaches:
&gt; 
&gt; First, exposing the needed information via smaps. This does incur some
&gt; performance cost but is the simplest to implement. The new feature can be
&gt; dynamically toggled via a command-line parameter. When disabled, the
&gt; overhead is negligible\u2014only a minor if check, which is insignificant compared
&gt; to the full smaps cost.

You are comparing content of all anon pages, aren&#x27;t you? Depending on
the content this can add a lot of overhead.

&gt; Second, adding a new system call or extending madvise with a new command
&gt; like MADV_GET_ZEROANON. Userspace tools can then use it to measure
&gt; memory waste from zero-filled anonymous huge pages.

MADV_GET_ZEROPAGE would make more sense to me. But a more fundamental
question is whether this metric is really what you want long term.
Kernel can do all sorts of optimizations behind userspace back - e.g.
map shared zero page - so just learning that a process has a lot of
pages filled up with zeroes doesn&#x27;t tell you all that much. Or does it?

Also think about what do you do with those numbers. Any action performed
later is inherently racy. Aren&#x27;t you really looking for something like
MADV_COMPACT or maybe even MADV_COMPRESS?
-- 
Michal Hocko
SUSE Labs


---

On Mon 16-02-26 17:56:12, David Hildenbrand wrote:
&gt; On 2/16/26 17:42, Michal Hocko wrote:
&gt; &gt; On Mon 16-02-26 23:59:50, Wenchao Hao wrote:
&gt; &gt; &gt; On Mon, Feb 16, 2026 at 7:58\u202fPM Kiryl Shutsemau &lt;kirill@shutemov.name&gt; wrote:
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; One users want the stat and all users on the machine pay the price?
&gt; &gt; &gt; &gt; That&#x27;s a poor trade off.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; In general, smaps scales poorly. It collects a lot of stats and most of
&gt; &gt; &gt; &gt; them are ignored by user. We need something like statx(2) where user can
&gt; &gt; &gt; &gt; declare what he is interested in, so kernel won&#x27;t waste cycles.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; I initially considered two approaches:
&gt; &gt; &gt; 
&gt; &gt; &gt; First, exposing the needed information via smaps. This does incur some
&gt; &gt; &gt; performance cost but is the simplest to implement. The new feature can be
&gt; &gt; &gt; dynamically toggled via a command-line parameter. When disabled, the
&gt; &gt; &gt; overhead is negligible\u2014only a minor if check, which is insignificant compared
&gt; &gt; &gt; to the full smaps cost.
&gt; &gt; 
&gt; &gt; You are comparing content of all anon pages, aren&#x27;t you? Depending on
&gt; &gt; the content this can add a lot of overhead.
&gt; &gt; 
&gt; &gt; &gt; Second, adding a new system call or extending madvise with a new command
&gt; &gt; &gt; like MADV_GET_ZEROANON. Userspace tools can then use it to measure
&gt; &gt; &gt; memory waste from zero-filled anonymous huge pages.
&gt; &gt; 
&gt; &gt; MADV_GET_ZEROPAGE would make more sense to me. But a more fundamental
&gt; &gt; question is whether this metric is really what you want long term.
&gt; &gt; Kernel can do all sorts of optimizations behind userspace back - e.g.
&gt; &gt; map shared zero page - so just learning that a process has a lot of
&gt; &gt; pages filled up with zeroes doesn&#x27;t tell you all that much. Or does it?
&gt; 
&gt; If a sysadmin wants to see where THP hurt (zero-filled pages), surely
&gt; MADV_GET_ZEROPAGE is the wrong (ugly) interface.

The question is whether sysadmin should really ask questions like that.
Without a deeper understanding of the workload the answer could be
misleading at best, no matter what interface is available.

If you know and understand the workload you already know that THP is not
a good fit and you do not need to ask about that. If you want to
understand whether your particular workload has a big internal
fragmentation due to THPs then MADV_GET_ZEROPAGE sounds like a
reasonable fit to me.

&gt;From a sysadmin POV you care about the overall memory consuption, right?
And for that I believe you need some sort of high level compression or
similar interface.

-- 
Michal Hocko
SUSE Labs


---

On Tue 17-02-26 23:22:20, Wenchao Hao wrote:
&gt; On Sat, Feb 14, 2026 at 4:45\u202fPM Wenchao Hao &lt;haowenchao22@gmail.com&gt; wrote:
&gt; &gt;
&gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt; &gt;
&gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; waste from unaccessed pages.
&gt; &gt;
&gt; &gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; &gt;
&gt; &gt; Link: https://lore.kernel.org/linux-mm/20260210043456.2137482-1-haowenchao22@gmail.com/
&gt; 
&gt; Sorry for the late reply. We are now on Chinese New Year holiday, so...
&gt; 
&gt; The original goal of this patch is to measure memory waste from anonymous
&gt; THPs - pages pre-allocated on fault but never accessed.

I believe you wanted to say &quot;but never modified&quot;. Unless you map THP
through ptes you have simply do not have that information. Reading
zeroes might be just what your workload needs (e.g. large sparce data
structures).

&gt; On memory-sensitive devices like mobile phones, this helps us make better
&gt; decisions about when and how to enable THP. I think this is useful for
&gt; guiding THP policies, even as a debugging feature.
&gt; 
&gt; Let me summarize the discussion so far:
&gt; - Matthew Wilcox questioned the value and raised concerns fork but haven&#x27;t
&gt;   exec path
&gt; - Michal Hocko criticized the inefficiency of scanning zero-filled pages.

Let me clarify. I am not objecting the inefficiency. _If_ you need to
recognize zero content then there are no ways around. I have merely
mentioned that the overhead is not negligible for /proc/&lt;pid&gt;/smaps as
you suggested.

&gt; - Kiryl Shutsemau prefers a system-call-based interface.
&gt; - David Hildenbrand acknowledged the value and suggested implementation
&gt;   improvements.
&gt; Please correct me if I missed or misrepresented anything.
&gt; 
&gt; I suggest we first agree whether this functionality is useful for upstream,
&gt; before discussing implementation details.

Completely agreed!

&gt; Reasons why this should go upstream from me:
&gt; 
&gt; - Anonymous THP can introduce real memory waste, but we currently have no
&gt;   good way to measure it.
&gt; - With accurate metrics, we can make better THP policy: disable for
&gt;   low-utilization cases, or early-unmap to relieve memory pressure and so
&gt;   on. This is especially valuable for mobile/embedded devices.

While I agree with your first point I am not so sure about the second.
You can easily run the same workload with and without THP enabled and
compare the rss to learn about a typical internal fragmentation (there
are several layers of precision you can influence - only for process,
madvise...). This is a very crude estimate but it gives you some
picture. Is it convenient. Not at all but likely sufficient if you are
debugging a reproducible workload. 

So I would start by explaining why this crude approach is not really
feasible. You are talking about early-unmap. How exactly do you envision
this to be done? I mean finding zero pages is one thing but how do you
make any educated guess that that particular sparsely used page needs to
be broken down and partially unmapped. What kind of interface do you
want to use for that? MADV_FREE for all zero subranges?
-- 
Michal Hocko
SUSE Labs

</pre>
</details>
<div class="review-comment-signals">Signals: overhead, alternative approaches</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Kiryl Shutsemau</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer suggested that the patch could be improved by providing a tool for users to easily access and analyze the AnonZero data, possibly by integrating it into util-linux.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, Feb 17, 2026 at 09:29:02PM +0100, David Hildenbrand (Arm) wrote:
&gt; On 2/17/26 16:22, Wenchao Hao wrote:
&gt; &gt; On Sat, Feb 14, 2026 at 4:45\u202fPM Wenchao Hao &lt;haowenchao22@gmail.com&gt; wrote:
&gt; &gt; &gt; 
&gt; &gt; &gt; Add kernel command line option &quot;count_zero_page&quot; to track anonymous pages
&gt; &gt; &gt; have been allocated and mapped to userspace but zero-filled.
&gt; &gt; &gt; 
&gt; &gt; &gt; This feature is mainly used to debug large folio mechanism, which
&gt; &gt; &gt; pre-allocates and map more pages than actually needed, leading to memory
&gt; &gt; &gt; waste from unaccessed pages.
&gt; &gt; &gt; 
&gt; &gt; &gt; Export the result in /proc/pid/smaps as &quot;AnonZero&quot; field.
&gt; &gt; &gt; 
&gt; &gt; &gt; Link: https://lore.kernel.org/linux-mm/20260210043456.2137482-1-haowenchao22@gmail.com/
&gt; &gt; 
&gt; &gt; Sorry for the late reply. We are now on Chinese New Year holiday, so...
&gt; &gt; 
&gt; &gt; The original goal of this patch is to measure memory waste from anonymous
&gt; &gt; THPs - pages pre-allocated on fault but never accessed.
&gt; &gt; 
&gt; &gt; On memory-sensitive devices like mobile phones, this helps us make better
&gt; &gt; decisions about when and how to enable THP. I think this is useful for
&gt; &gt; guiding THP policies, even as a debugging feature.
&gt; &gt; 
&gt; &gt; Let me summarize the discussion so far:
&gt; &gt; - Matthew Wilcox questioned the value and raised concerns fork but haven&#x27;t
&gt; &gt;    exec path
&gt; &gt; - Michal Hocko criticized the inefficiency of scanning zero-filled pages.
&gt; &gt; - Kiryl Shutsemau prefers a system-call-based interface.
&gt; &gt; - David Hildenbrand acknowledged the value and suggested implementation
&gt; &gt;    improvements.
&gt; &gt; Please correct me if I missed or misrepresented anything.
&gt; &gt; 
&gt; &gt; I suggest we first agree whether this functionality is useful for upstream,
&gt; &gt; before discussing implementation details.
&gt; &gt; 
&gt; &gt; Reasons why this should go upstream from me:
&gt; &gt; 
&gt; &gt; - Anonymous THP can introduce real memory waste, but we currently have no
&gt; &gt;    good way to measure it.
&gt; &gt; - With accurate metrics, we can make better THP policy: disable for
&gt; &gt;    low-utilization cases, or early-unmap to relieve memory pressure and so
&gt; &gt;    on. This is especially valuable for mobile/embedded devices.
&gt; &gt; 
&gt; &gt; Possible implementations:
&gt; &gt; 
&gt; &gt; 1. A new smaps counter (default-off) to count zero-filled pages.
&gt; &gt; 2. A new madvise command like MADV_GET_ZEROPAGE
&gt; &gt; 3. A dedicated system call
&gt; 
&gt; I understand Kiyls point about smaps providing too much information users
&gt; might not be interested in already. So sorting that out might provide a real
&gt; benefit to other users that are only interested in specific stats (e.g.,
&gt; Rss).

You can also limit the range of virtual address space you want to look
at.

&gt; Providing a system call where one can specify/filter in theory sounds like a
&gt; good idea. A syscall implies that one has to write a tool to obtain these
&gt; metrics.
&gt; 
&gt; The nice thing about smaps/smaps_rollup is that it can be easily consumed on
&gt; any system while debugging.
&gt; 
&gt; I wonder if there could be a way to achieve something similar with a file.
&gt; Likely not, but maybe someone reading along can surprise me :)

I guess you can open a file write to it what you want to get and then
read. It is awkward from shell to keep file descriptor around, but doable.

&gt; Otherwise we&#x27;d have to go with a tool.

A tool might be more ergonomic.

To minimize friction, it would be nice to put the tool into util-linux
(or whatever trendy Rust-rewrite called), so it would find its way to
every machine. Eventually.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>