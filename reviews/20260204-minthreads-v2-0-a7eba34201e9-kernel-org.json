{
  "thread_id": "20260204-minthreads-v2-0-a7eba34201e9@kernel.org",
  "subject": "[PATCH nfs-utils v2 0/4] nfsdctl: properly handle older kernels that don't support min-threads",
  "url": "https://lore.kernel.org/all/20260204-minthreads-v2-0-a7eba34201e9@kernel.org/",
  "dates": {
    "2026-02-18": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Jeff Layton (author)",
          "summary": "The reviewer approved the patch series but requested a change to unconditionally compile in min-threads support, which was previously dependent on system headers.",
          "sentiment": "positive",
          "sentiment_signals": [
            "NEEDS_WORK"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I originally had this depend on the system header, but if we maintain\nour copy of nfsd_netlink.h in tree, then we can unconditionally compile\nin support for the MIN_THREADS option.\n\nSigned-off-by: Jeff Layton <jlayton@kernel.org>\n---\n configure.ac                 |  6 ++----\n utils/nfsdctl/nfsd_netlink.h |  2 ++\n utils/nfsdctl/nfsdctl.c      | 16 +---------------\n 3 files changed, 5 insertions(+), 19 deletions(-)\n\ndiff --git a/configure.ac b/configure.ac\nindex 5cc1e9186542c975abf200edbef30bc8f6ecb8ee..a65c7837b8cb72eaa2f3dbb89069599c074be4ec 100644\n--- a/configure.ac\n+++ b/configure.ac\n@@ -262,12 +262,10 @@ AC_ARG_ENABLE(nfsdctl,\n \t\tPKG_CHECK_MODULES(LIBNLGENL3, libnl-genl-3.0 >= 3.1)\n \t\tPKG_CHECK_MODULES(LIBREADLINE, readline)\n \t\tAC_CHECK_HEADERS(linux/nfsd_netlink.h)\n-\t\tAC_CHECK_DECLS([NFSD_A_SERVER_MIN_THREADS], , ,\n-\t\t\t       [#include <linux/nfsd_netlink.h>])\n \n-\t\t# ensure we have the pool-mode commands\n+\t\t# ensure we have the MIN_THREADS attribute\n \t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <linux/nfsd_netlink.h>]],\n-\t\t\t\t                   [[int foo = NFSD_CMD_POOL_MODE_GET;]])],\n+\t\t\t\t                   [[int foo = NFSD_A_SERVER_MIN_THREADS;]])],\n \t\t\t\t   [AC_DEFINE([USE_SYSTEM_NFSD_NETLINK_H], 1,\n \t\t\t\t\t      [\"Use system's linux/nfsd_netlink.h\"])])\n \t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <linux/lockd_netlink.h>]],\ndiff --git a/utils/nfsdctl/nfsd_netlink.h b/utils/nfsdctl/nfsd_netlink.h\nindex 887cbd12b695f2398c96976ba2d70e68ee0d93c0..e9efbc9e63d83ed25fcd790b7a877c0023638f15 100644\n--- a/utils/nfsdctl/nfsd_netlink.h\n+++ b/utils/nfsdctl/nfsd_netlink.h\n@@ -2,6 +2,7 @@\n /* Do not edit directly, auto-generated from: */\n /*\tDocumentation/netlink/specs/nfsd.yaml */\n /* YNL-GEN uapi header */\n+/* To regenerate run: tools/net/ynl/ynl-regen.sh */\n \n #ifndef _UAPI_LINUX_NFSD_NETLINK_H\n #define _UAPI_LINUX_NFSD_NETLINK_H\n@@ -34,6 +35,7 @@ enum {\n \tNFSD_A_SERVER_GRACETIME,\n \tNFSD_A_SERVER_LEASETIME,\n \tNFSD_A_SERVER_SCOPE,\n+\tNFSD_A_SERVER_MIN_THREADS,\n \n \t__NFSD_A_SERVER_MAX,\n \tNFSD_A_SERVER_MAX = (__NFSD_A_SERVER_MAX - 1)\ndiff --git a/utils/nfsdctl/nfsdctl.c b/utils/nfsdctl/nfsdctl.c\nindex c906a2c8ba6d357e182d341a30610e367e74c093..6b3c98009488d1687e7e751eaed6c4f1d9613d39 100644\n--- a/utils/nfsdctl/nfsdctl.c\n+++ b/utils/nfsdctl/nfsdctl.c\n@@ -324,11 +324,9 @@ static void parse_threads_get(struct genlmsghdr *gnlh)\n \t\tcase NFSD_A_SERVER_THREADS:\n \t\t\tpool_threads[i++] = nla_get_u32(attr);\n \t\t\tbreak;\n-#if HAVE_DECL_NFSD_A_SERVER_MIN_THREADS\n \t\tcase NFSD_A_SERVER_MIN_THREADS:\n \t\t\tprintf(\"min-threads: %u\\n\", nla_get_u32(attr));\n \t\t\tbreak;\n-#endif\n \t\tdefault:\n \t\t\tbreak;\n \t\t}\n@@ -546,10 +544,8 @@ static int threads_doit(struct nl_sock *sock, int cmd, int grace, int lease,\n \t\t\tnla_put_u32(msg, NFSD_A_SERVER_LEASETIME, lease);\n \t\tif (scope)\n \t\t\tnla_put_string(msg, NFSD_A_SERVER_SCOPE, scope);\n-#if HAVE_DECL_NFSD_A_SERVER_MIN_THREADS\n \t\tif (minthreads >= 0)\n \t\t\tnla_put_u32(msg, NFSD_A_SERVER_MIN_THREADS, minthreads);\n-#endif\n \t\tfor (i = 0; i < pool_count; ++i)\n \t\t\tnla_put_u32(msg, NFSD_A_SERVER_THREADS, pool_threads[i]);\n \t}\n@@ -591,24 +587,16 @@ out:\n static void threads_usage(void)\n {\n \tprintf(\"Usage: %s threads { --min-threads=X } [ pool0_count ] [ pool1_count ] ...\\n\", taskname);\n-#if HAVE_DECL_NFSD_A_SERVER_MIN_THREADS\n \tprintf(\"    --min-threads= set the minimum thread count per pool to value\\n\");\n-#endif\n \tprintf(\"    pool0_count: thread count for pool0, etc...\\n\");\n \tprintf(\"Omit any arguments to show current thread counts.\\n\");\n }\n \n-#if HAVE_DECL_NFSD_A_SERVER_MIN_THREADS\n static const struct option threads_options[] = {\n \t{ \"help\", no_argument, NULL, 'h' },\n \t{ \"min-threads\", required_argument, NULL, 'm' },\n \t{ },\n };\n-#define THREADS_OPTSTRING \"hm:\"\n-#else\n-#define threads_options help_only_options\n-#define THREADS_OPTSTRING \"h\"\n-#endif\n \n static int threads_func(struct nl_sock *sock, int argc, char **argv)\n {\n@@ -618,12 +606,11 @@ static int threads_func(struct nl_sock *sock, int argc, char **argv)\n \tint opt, pools = 0;\n \n \toptind = 1;\n-\twhile ((opt = getopt_long(argc, argv, THREADS_OPTSTRING, threads_options, NULL)) != -1) {\n+\twhile ((opt = getopt_long(argc, argv, \"hm:\", threads_options, NULL)) != -1) {\n \t\tswitch (opt) {\n \t\tcase 'h':\n \t\t\tthreads_usage();\n \t\t\treturn 0;\n-#if HAVE_DECL_NFSD_A_SERVER_MIN_THREADS\n \t\tcase 'm':\n \t\t\terrno = 0;\n \t\t\tminthreads = strtoul(optarg, NULL, 0);\n@@ -632,7 +619,6 @@ static int threads_func(struct nl_sock *sock, int argc, char **argv)\n \t\t\t\treturn 1;\n \t\t\t}\n \t\t\tbreak;\n-#endif\n \t\t}\n \t}\n \n\n-- \n2.52.0\n\n\n\n---\n\nThe current code resolves the string name to an id for every netlink\ncall. Just resolve the family names once and keep them.\n\nSigned-off-by: Jeff Layton <jlayton@kernel.org>\n---\n utils/nfsdctl/nfsdctl.c | 83 ++++++++++++++++++++++++++++++++++++++-----------\n 1 file changed, 64 insertions(+), 19 deletions(-)\n\ndiff --git a/utils/nfsdctl/nfsdctl.c b/utils/nfsdctl/nfsdctl.c\nindex 6b3c98009488d1687e7e751eaed6c4f1d9613d39..86a4a944d4e131f1114ca358d81779de0a034872 100644\n--- a/utils/nfsdctl/nfsdctl.c\n+++ b/utils/nfsdctl/nfsdctl.c\n@@ -46,9 +46,11 @@\n #include \"conffile.h\"\n #include \"xlog.h\"\n \n-/* compile note:\n- * gcc -I/usr/include/libnl3/ -o <prog-name> <prog-name>.c -lnl-3 -lnl-genl-3\n- */\n+/* The index of the \"lockd\" netlink family */\n+static int lockd_nl_family;\n+\n+/* The index of the \"nfsd\" netlink family */\n+static int nfsd_nl_family;\n \n struct nfs_version {\n \tuint8_t\tmajor;\n@@ -433,24 +435,18 @@ static struct nl_sock *netlink_sock_alloc(void)\n \treturn sock;\n }\n \n-static struct nl_msg *netlink_msg_alloc(struct nl_sock *sock, const char *family)\n+static struct nl_msg *netlink_msg_alloc(struct nl_sock *sock, int family)\n {\n \tstruct nl_msg *msg;\n \tint id;\n \n-\tid = genl_ctrl_resolve(sock, family);\n-\tif (id < 0) {\n-\t\txlog(L_ERROR, \"failed to resolve %s generic netlink family\", family);\n-\t\treturn NULL;\n-\t}\n-\n \tmsg = nlmsg_alloc();\n \tif (!msg) {\n \t\txlog(L_ERROR, \"failed to allocate netlink message\");\n \t\treturn NULL;\n \t}\n \n-\tif (!genlmsg_put(msg, 0, 0, id, 0, 0, 0, 0)) {\n+\tif (!genlmsg_put(msg, 0, 0, family, 0, 0, 0, 0)) {\n \t\txlog(L_ERROR, \"failed to add generic netlink headers to netlink message\");\n \t\tnlmsg_free(msg);\n \t\treturn NULL;\n@@ -459,6 +455,31 @@ static struct nl_msg *netlink_msg_alloc(struct nl_sock *sock, const char *family\n \treturn msg;\n }\n \n+static int resolve_family(struct nl_sock *sock, const char *name)\n+{\n+\tint family = genl_ctrl_resolve(sock, name);\n+\n+\tif (family < 0) {\n+\t\txlog(L_ERROR, \"failed to resolve %s generic netlink family: %d\", name, family);\n+\t\tfamily = 0;\n+\t}\n+\treturn family;\n+}\n+\n+static int lockd_nl_family_setup(struct nl_sock *sock)\n+{\n+\tif (!lockd_nl_family)\n+\t\tlockd_nl_family = resolve_family(sock, LOCKD_FAMILY_NAME);\n+\treturn lockd_nl_family;\n+}\n+\n+static int nfsd_nl_family_setup(struct nl_sock *sock)\n+{\n+\tif (!nfsd_nl_family)\n+\t\tnfsd_nl_family = resolve_family(sock, NFSD_FAMILY_NAME);\n+\treturn nfsd_nl_family;\n+}\n+\n static void status_usage(void)\n {\n \tprintf(\"Usage: %s status\\n\", taskname);\n@@ -482,7 +503,10 @@ static int status_func(struct nl_sock *sock, int argc, char ** argv)\n \t\t}\n \t}\n \n-\tmsg = netlink_msg_alloc(sock, NFSD_FAMILY_NAME);\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, nfsd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n@@ -530,7 +554,10 @@ static int threads_doit(struct nl_sock *sock, int cmd, int grace, int lease,\n \tstruct nl_cb *cb;\n \tint ret;\n \n-\tmsg = netlink_msg_alloc(sock, NFSD_FAMILY_NAME);\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, nfsd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n@@ -660,7 +687,10 @@ static int fetch_nfsd_versions(struct nl_sock *sock)\n \tstruct nl_cb *cb;\n \tint ret;\n \n-\tmsg = netlink_msg_alloc(sock, NFSD_FAMILY_NAME);\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, nfsd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n@@ -725,7 +755,10 @@ static int set_nfsd_versions(struct nl_sock *sock)\n \tstruct nl_cb *cb;\n \tint i, ret;\n \n-\tmsg = netlink_msg_alloc(sock, NFSD_FAMILY_NAME);\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, nfsd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n@@ -906,7 +939,10 @@ static int fetch_current_listeners(struct nl_sock *sock)\n \tstruct nl_cb *cb;\n \tint ret;\n \n-\tmsg = netlink_msg_alloc(sock, NFSD_FAMILY_NAME);\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, nfsd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n@@ -1151,7 +1187,10 @@ static int set_listeners(struct nl_sock *sock)\n \tstruct nl_cb *cb;\n \tint i, ret;\n \n-\tmsg = netlink_msg_alloc(sock, NFSD_FAMILY_NAME);\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, nfsd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n@@ -1272,7 +1311,10 @@ static int pool_mode_doit(struct nl_sock *sock, int cmd, const char *pool_mode)\n \tstruct nl_cb *cb;\n \tint ret;\n \n-\tmsg = netlink_msg_alloc(sock, NFSD_FAMILY_NAME);\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, nfsd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n@@ -1365,7 +1407,10 @@ static int lockd_config_doit(struct nl_sock *sock, int cmd, int grace, int tcppo\n \t\t\treturn 0;\n \t}\n \n-\tmsg = netlink_msg_alloc(sock, LOCKD_FAMILY_NAME);\n+\tif (!lockd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, lockd_nl_family);\n \tif (!msg)\n \t\treturn 1;\n \n\n-- \n2.52.0\n\n\n\n---\n\nBen reported a problem when using new nfs-utils with an old kernel that\ndoesn't support the min-threads setting. While netlink is an extensible\nformat, genetlink (which we are using) will reject unknown attributes by\ndefault with -EINVAL.\n\nWe could fix this in the kernel by having it ignore unknown attributes,\nbut there is no way to fix old kernels and silently ignoring it is less\nthan ideal. By handling this in userland, we can properly error out when\nthe kernel doesn't support this attribute.\n\nWhen starting, have nfsdctl query the kernel for the \"policy\" of the\nthreads operation, and determine the highest attribute index it\nsupports.  For the \"threads\" command, have it fail if the --min-threads\noption is passed and the kernel doesn't support it. For \"autostart\", log\na warning and ignore the setting.\n\nFixes: 00e2e62b8998 (\"nfsdctl: add support for min-threads parameter\")\nReported-by: Ben Coddington <bcodding@hammerspace.com>\nSigned-off-by: Jeff Layton <jlayton@kernel.org>\n---\n utils/nfsdctl/nfsdctl.c | 95 ++++++++++++++++++++++++++++++++++++++++++++++++-\n 1 file changed, 94 insertions(+), 1 deletion(-)\n\ndiff --git a/utils/nfsdctl/nfsdctl.c b/utils/nfsdctl/nfsdctl.c\nindex 86a4a944d4e131f1114ca358d81779de0a034872..4a3744a1c22e6beac7c039bded05fc087a121200 100644\n--- a/utils/nfsdctl/nfsdctl.c\n+++ b/utils/nfsdctl/nfsdctl.c\n@@ -52,6 +52,9 @@ static int lockd_nl_family;\n /* The index of the \"nfsd\" netlink family */\n static int nfsd_nl_family;\n \n+/* The highest attribute index supported by NFSD_CMD_THREADS_SET on this kernel */\n+int nfsd_threads_max_nlattr;\n+\n struct nfs_version {\n \tuint8_t\tmajor;\n \tuint8_t\tminor;\n@@ -480,6 +483,83 @@ static int nfsd_nl_family_setup(struct nl_sock *sock)\n \treturn nfsd_nl_family;\n }\n \n+static int getpolicy_handler(struct nl_msg *msg, void *arg)\n+{\n+\tstruct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));\n+\tstruct nlattr *attr;\n+\tint rem;\n+\n+\tnla_for_each_attr(attr, genlmsg_attrdata(gnlh, 0), genlmsg_attrlen(gnlh, 0), rem) {\n+\t\tstruct nlattr *a, *b;\n+\t\tint i, j, index;\n+\n+\t\tif (nla_type(attr) == CTRL_ATTR_POLICY) {\n+\t\t\tnla_for_each_nested(a, attr, i) {\n+\t\t\t\tnla_for_each_nested(b, a, j) {\n+\t\t\t\t\tint idx = nla_type(b);\n+\n+\t\t\t\t\tif (nfsd_threads_max_nlattr < idx)\n+\t\t\t\t\t\tnfsd_threads_max_nlattr = idx;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn NL_SKIP;\n+}\n+\n+static int query_nfsd_nl_policy(struct nl_sock *sock)\n+{\n+\tstruct genlmsghdr *ghdr;\n+\tstruct nlmsghdr *nlh;\n+\tstruct nl_msg *msg;\n+\tstruct nl_cb *cb;\n+\tint opt, ret, id;\n+\n+\tif (!nfsd_nl_family_setup(sock))\n+\t\treturn 1;\n+\n+\tmsg = netlink_msg_alloc(sock, GENL_ID_CTRL);\n+\tif (!msg)\n+\t\treturn 1;\n+\n+\tnlh = nlmsg_hdr(msg);\n+\tnlh->nlmsg_flags |= NLM_F_DUMP;\n+\tghdr = nlmsg_data(nlh);\n+\tghdr->cmd = CTRL_CMD_GETPOLICY;\n+\n+\tcb = nl_cb_alloc(NL_CB_CUSTOM);\n+\tif (!cb) {\n+\t\txlog(L_ERROR, \"failed to allocate netlink callbacks\");\n+\t\tret = 1;\n+\t\tgoto out;\n+\t}\n+\n+\tnla_put_u16(msg, CTRL_ATTR_FAMILY_ID, nfsd_nl_family);\n+\tnla_put_u32(msg, CTRL_ATTR_OP, NFSD_CMD_THREADS_SET);\n+\n+\tret = nl_send_auto(sock, msg);\n+\tif (ret < 0)\n+\t\tgoto out_cb;\n+\n+\tret = 1;\n+\tnl_cb_err(cb, NL_CB_CUSTOM, error_handler, &ret);\n+\tnl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &ret);\n+\tnl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &ret);\n+\tnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, getpolicy_handler, NULL);\n+\n+\twhile (ret > 0)\n+\t\tnl_recvmsgs(sock, cb);\n+\tif (ret < 0) {\n+\t\txlog(L_ERROR, \"Error: %s\", strerror(-ret));\n+\t\tret = 1;\n+\t}\n+out_cb:\n+\tnl_cb_put(cb);\n+out:\n+\tnlmsg_free(msg);\n+\treturn ret;\n+}\n+\n static void status_usage(void)\n {\n \tprintf(\"Usage: %s status\\n\", taskname);\n@@ -639,6 +719,11 @@ static int threads_func(struct nl_sock *sock, int argc, char **argv)\n \t\t\tthreads_usage();\n \t\t\treturn 0;\n \t\tcase 'm':\n+\t\t\tif (nfsd_threads_max_nlattr < NFSD_A_SERVER_MIN_THREADS) {\n+\t\t\t\txlog(L_ERROR, \"This kernel does not support dynamic threading.\");\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\n \t\t\terrno = 0;\n \t\t\tminthreads = strtoul(optarg, NULL, 0);\n \t\t\tif (minthreads == ULONG_MAX && errno != 0) {\n@@ -1743,7 +1828,12 @@ static int autostart_func(struct nl_sock *sock, int argc, char ** argv)\n \n \tlease = conf_get_num(\"nfsd\", \"lease-time\", 0);\n \tscope = conf_get_str(\"nfsd\", \"scope\");\n-\tminthreads = conf_get_num(\"nfsd\", \"min-threads\", 0);\n+\tminthreads = conf_get_num(\"nfsd\", \"min-threads\", -1);\n+\n+\tif (minthreads >= 0 && nfsd_threads_max_nlattr < NFSD_A_SERVER_MIN_THREADS) {\n+\t\txlog(L_WARNING, \"This kernel does not support dynamic threading. min-threads setting ignored.\");\n+\t\tminthreads = -1;\n+\t}\n \n \tret = threads_doit(sock, NFSD_CMD_THREADS_SET, grace, lease, pools,\n \t\t\t   threads, scope, minthreads);\n@@ -1936,6 +2026,9 @@ int main(int argc, char **argv)\n \t\treturn 1;\n \t}\n \n+\tif (query_nfsd_nl_policy(sock))\n+\t\treturn 1;\n+\n \tif (optind > argc) {\n \t\tusage();\n \t\treturn 1;\n\n-- \n2.52.0\n\n\n\n---\n\nSigned-off-by: Jeff Layton <jlayton@kernel.org>\n---\n utils/nfsdctl/nfsdctl.c | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\ndiff --git a/utils/nfsdctl/nfsdctl.c b/utils/nfsdctl/nfsdctl.c\nindex 4a3744a1c22e6beac7c039bded05fc087a121200..2b01f705874a4a3cad04042f6dfad22a66a7536f 100644\n--- a/utils/nfsdctl/nfsdctl.c\n+++ b/utils/nfsdctl/nfsdctl.c\n@@ -1514,14 +1514,14 @@ static int lockd_config_doit(struct nl_sock *sock, int cmd, int grace, int tcppo\n \n \tcb = nl_cb_alloc(NL_CB_CUSTOM);\n \tif (!cb) {\n-\t\txlog(L_ERROR, \"failed to allocate netlink callbacks\\n\");\n+\t\txlog(L_ERROR, \"failed to allocate netlink callbacks\");\n \t\tret = 1;\n \t\tgoto out;\n \t}\n \n \tret = nl_send_auto(sock, msg);\n \tif (ret < 0) {\n-\t\txlog(L_ERROR, \"send failed (%d)!\\n\", ret);\n+\t\txlog(L_ERROR, \"send failed (%d)!\", ret);\n \t\tgoto out_cb;\n \t}\n \n@@ -1534,7 +1534,7 @@ static int lockd_config_doit(struct nl_sock *sock, int cmd, int grace, int tcppo\n \twhile (ret > 0)\n \t\tnl_recvmsgs(sock, cb);\n \tif (ret < 0) {\n-\t\txlog(L_ERROR, \"Error: %s\\n\", strerror(-ret));\n+\t\txlog(L_ERROR, \"Error: %s\", strerror(-ret));\n \t\tret = 1;\n \t}\n out_cb:\n@@ -1554,7 +1554,7 @@ static int get_service(const char *svc)\n \n \tret = getaddrinfo(NULL, svc, &hints, &res);\n \tif (ret) {\n-\t\txlog(L_ERROR, \"getaddrinfo of \\\"%s\\\" failed: %s\\n\",\n+\t\txlog(L_ERROR, \"getaddrinfo of \\\"%s\\\" failed: %s\",\n \t\t\tsvc, gai_strerror(ret));\n \t\treturn -1;\n \t}\n@@ -1575,7 +1575,7 @@ static int get_service(const char *svc)\n \t\t}\n \t\tbreak;\n \tdefault:\n-\t\txlog(L_ERROR, \"Bad address family: %d\\n\", res->ai_family);\n+\t\txlog(L_ERROR, \"Bad address family: %d\", res->ai_family);\n \t\tport = -1;\n \t}\n \tfreeaddrinfo(res);\n\n-- \n2.52.0\n\n\n\n---\n\nOn Wed, 2026-02-04 at 11:48 -0500, Jeff Layton wrote:\n> Ben reported a problem with using new userland with old kernel. If he\n> tried to send down a setting that the kernel doesn't support, it returns\n> -EINVAL to the call.\n> \n> This patch series adds a mechanism for nfsdctl to tell what attributes\n> are supported by the \"threads\" command. If can then use that to\n> determine whether to pass down the min-threads attribute or report an\n> error or warning.\n> \n> This also removes the dependency on the UAPI headers by properly\n> maintaining the private nfsd_netlink.h file.\n> \n> Signed-off-by: Jeff Layton <jlayton@kernel.org>\n> ---\n> Changes in v2:\n> - Add patch to unconditionally compile in min-threads support\n> - Make getpolicy_handler() return NL_SKIP\n> - Link to v1: https://lore.kernel.org/r/20260204-minthreads-v1-0-9f348608f884@kernel.org\n> \n> ---\n> Jeff Layton (4):\n>       nfsdctl: unconditionally enable support for min-threads\n>       nfsdctl: only resolve netlink family names once\n>       nfsdctl: query netlink policy before sending the minthreads attribute to kernel\n>       nfsdctl: remove unneeded newlines from xlog() format strings\n> \n>  configure.ac                 |   6 +-\n>  utils/nfsdctl/nfsd_netlink.h |   2 +\n>  utils/nfsdctl/nfsdctl.c      | 204 ++++++++++++++++++++++++++++++++++---------\n>  3 files changed, 168 insertions(+), 44 deletions(-)\n> ---\n> base-commit: 8f54511aefe1455161a6c4406ed8c770139f61e3\n> change-id: 20260203-minthreads-402ce87096e0\n> \n> Best regards,\n\nSteve, ping? Can we get this merged?\n\nThanks,\n-- \nJeff Layton <jlayton@kernel.org>\n",
          "reply_to": ""
        },
        {
          "author": "Steve Dickson",
          "summary": "Steve Dickson requested changes to handle older kernels that don't support min-threads, but his message was a response to Jeff Layton's ping and didn't contain any technical concerns.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no specific technical concerns raised"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "\n\nOn 2/18/26 9:19 AM, Jeff Layton wrote:\n> On Wed, 2026-02-04 at 11:48 -0500, Jeff Layton wrote:\n>> Ben reported a problem with using new userland with old kernel. If he\n>> tried to send down a setting that the kernel doesn't support, it returns\n>> -EINVAL to the call.\n>>\n>> This patch series adds a mechanism for nfsdctl to tell what attributes\n>> are supported by the \"threads\" command. If can then use that to\n>> determine whether to pass down the min-threads attribute or report an\n>> error or warning.\n>>\n>> This also removes the dependency on the UAPI headers by properly\n>> maintaining the private nfsd_netlink.h file.\n>>\n>> Signed-off-by: Jeff Layton <jlayton@kernel.org>\n>> ---\n>> Changes in v2:\n>> - Add patch to unconditionally compile in min-threads support\n>> - Make getpolicy_handler() return NL_SKIP\n>> - Link to v1: https://lore.kernel.org/r/20260204-minthreads-v1-0-9f348608f884@kernel.org\n>>\n>> ---\n>> Jeff Layton (4):\n>>        nfsdctl: unconditionally enable support for min-threads\n>>        nfsdctl: only resolve netlink family names once\n>>        nfsdctl: query netlink policy before sending the minthreads attribute to kernel\n>>        nfsdctl: remove unneeded newlines from xlog() format strings\n>>\n>>   configure.ac                 |   6 +-\n>>   utils/nfsdctl/nfsd_netlink.h |   2 +\n>>   utils/nfsdctl/nfsdctl.c      | 204 ++++++++++++++++++++++++++++++++++---------\n>>   3 files changed, 168 insertions(+), 44 deletions(-)\n>> ---\n>> base-commit: 8f54511aefe1455161a6c4406ed8c770139f61e3\n>> change-id: 20260203-minthreads-402ce87096e0\n>>\n>> Best regards,\n> \n> Steve, ping? Can we get this merged?\nI'm on it... thanks for the ping!\n\nsteved.\n> \n> Thanks,\n\n",
          "reply_to": ""
        },
        {
          "author": "Benjamin Coddington",
          "summary": "The reviewer approved the patch and provided Reviewed-by and Tested-by tags.",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by",
            "Tested-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On 4 Feb 2026, at 11:48, Jeff Layton wrote:\n\n> Ben reported a problem with using new userland with old kernel. If he\n> tried to send down a setting that the kernel doesn't support, it returns\n> -EINVAL to the call.\n>\n> This patch series adds a mechanism for nfsdctl to tell what attributes\n> are supported by the \"threads\" command. If can then use that to\n> determine whether to pass down the min-threads attribute or report an\n> error or warning.\n>\n> This also removes the dependency on the UAPI headers by properly\n> maintaining the private nfsd_netlink.h file.\n>\n> Signed-off-by: Jeff Layton <jlayton@kernel.org>\n\n\nI mean to send R-b and T-b on these - because yes, both were done!\n\nReviewed-by: Benjamin Coddington <bcodding@hammerspace.com>\nTested-by: Benjamin Coddington <bcodding@hammerspace.com>\n\nBen\n\n",
          "reply_to": ""
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "This patch series updates the nfsdctl tool to properly handle older Linux kernels that do not support the min-threads attribute. It adds a mechanism for nfsdctl to determine which attributes are supported by the kernel and only passes down supported settings, preventing errors when using new userland with old kernel. The patches also remove dependencies on UAPI headers and maintain a private header file."
    }
  }
}