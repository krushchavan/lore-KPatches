<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH v8 09/17] btrfs: redirect I/O for remapped block groups</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH v8 09/17] btrfs: redirect I/O for remapped block groups</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/8369b0f4-f7b7-40ad-8a72-4d7fafd88a84@harmstone.com/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-18">2026-02-18</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-18">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Mark Harmstone (author)</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Mark Harmstone pointed out a mistake in the code where a return value was leaked due to copying from another section of code.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Add an incompat flag for the new remap-tree feature, and the constants
and definitions needed to support it.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/accessors.h            |  4 ++++
 fs/btrfs/locking.c              |  1 +
 fs/btrfs/sysfs.c                |  2 ++
 fs/btrfs/tree-checker.c         |  6 ++----
 fs/btrfs/tree-checker.h         |  5 +++++
 fs/btrfs/volumes.c              |  1 +
 include/uapi/linux/btrfs.h      |  1 +
 include/uapi/linux/btrfs_tree.h | 17 +++++++++++++++++
 8 files changed, 33 insertions(+), 4 deletions(-)

diff --git a/fs/btrfs/accessors.h b/fs/btrfs/accessors.h
index 78721412951c..09cdd6bfddf5 100644
--- a/fs/btrfs/accessors.h
+++ b/fs/btrfs/accessors.h
@@ -1010,6 +1010,10 @@ BTRFS_SETGET_STACK_FUNCS(stack_verity_descriptor_encryption,
 BTRFS_SETGET_STACK_FUNCS(stack_verity_descriptor_size,
 			 struct btrfs_verity_descriptor_item, size, 64);
 
+BTRFS_SETGET_FUNCS(remap_address, struct btrfs_remap_item, address, 64);
+BTRFS_SETGET_STACK_FUNCS(stack_remap_address, struct btrfs_remap_item,
+			 address, 64);
+
 /* Cast into the data area of the leaf. */
 #define btrfs_item_ptr(leaf, slot, type)				\
 	((type *)(btrfs_item_nr_offset(leaf, 0) + btrfs_item_offset(leaf, slot)))
diff --git a/fs/btrfs/locking.c b/fs/btrfs/locking.c
index 0035851d72b0..e3df5ca0b552 100644
--- a/fs/btrfs/locking.c
+++ b/fs/btrfs/locking.c
@@ -73,6 +73,7 @@ static struct btrfs_lockdep_keyset {
 	{ .id = BTRFS_FREE_SPACE_TREE_OBJECTID,	DEFINE_NAME(&quot;free-space&quot;) },
 	{ .id = BTRFS_BLOCK_GROUP_TREE_OBJECTID, DEFINE_NAME(&quot;block-group&quot;) },
 	{ .id = BTRFS_RAID_STRIPE_TREE_OBJECTID, DEFINE_NAME(&quot;raid-stripe&quot;) },
+	{ .id = BTRFS_REMAP_TREE_OBJECTID,      DEFINE_NAME(&quot;remap&quot;) },
 	{ .id = 0,				DEFINE_NAME(&quot;tree&quot;)	},
 };
 
diff --git a/fs/btrfs/sysfs.c b/fs/btrfs/sysfs.c
index f0974f4c0ae4..0e2ed8072443 100644
--- a/fs/btrfs/sysfs.c
+++ b/fs/btrfs/sysfs.c
@@ -291,6 +291,7 @@ BTRFS_FEAT_ATTR_COMPAT_RO(free_space_tree, FREE_SPACE_TREE);
 BTRFS_FEAT_ATTR_COMPAT_RO(block_group_tree, BLOCK_GROUP_TREE);
 BTRFS_FEAT_ATTR_INCOMPAT(raid1c34, RAID1C34);
 BTRFS_FEAT_ATTR_INCOMPAT(simple_quota, SIMPLE_QUOTA);
+BTRFS_FEAT_ATTR_INCOMPAT(remap_tree, REMAP_TREE);
 #ifdef CONFIG_BLK_DEV_ZONED
 BTRFS_FEAT_ATTR_INCOMPAT(zoned, ZONED);
 #endif
@@ -331,6 +332,7 @@ static struct attribute *btrfs_supported_feature_attrs[] = {
 #ifdef CONFIG_BTRFS_EXPERIMENTAL
 	BTRFS_FEAT_ATTR_PTR(extent_tree_v2),
 	BTRFS_FEAT_ATTR_PTR(raid_stripe_tree),
+	BTRFS_FEAT_ATTR_PTR(remap_tree),
 #endif
 #ifdef CONFIG_FS_VERITY
 	BTRFS_FEAT_ATTR_PTR(verity),
diff --git a/fs/btrfs/tree-checker.c b/fs/btrfs/tree-checker.c
index c21c21adf61e..aedc208a95b8 100644
--- a/fs/btrfs/tree-checker.c
+++ b/fs/btrfs/tree-checker.c
@@ -913,12 +913,10 @@ int btrfs_check_chunk_valid(const struct btrfs_fs_info *fs_info,
 			  length, btrfs_stripe_nr_to_offset(U32_MAX));
 		return -EUCLEAN;
 	}
-	if (unlikely(type &amp; ~(BTRFS_BLOCK_GROUP_TYPE_MASK |
-			      BTRFS_BLOCK_GROUP_PROFILE_MASK))) {
+	if (unlikely(type &amp; ~BTRFS_BLOCK_GROUP_VALID)) {
 		chunk_err(fs_info, leaf, chunk, logical,
 			  &quot;unrecognized chunk type: 0x%llx&quot;,
-			  ~(BTRFS_BLOCK_GROUP_TYPE_MASK |
-			    BTRFS_BLOCK_GROUP_PROFILE_MASK) &amp; type);
+			  type &amp; ~BTRFS_BLOCK_GROUP_VALID);
 		return -EUCLEAN;
 	}
 
diff --git a/fs/btrfs/tree-checker.h b/fs/btrfs/tree-checker.h
index eb201f4ec3c7..833e2fd989eb 100644
--- a/fs/btrfs/tree-checker.h
+++ b/fs/btrfs/tree-checker.h
@@ -57,6 +57,11 @@ enum btrfs_tree_block_status {
 	BTRFS_TREE_BLOCK_WRITTEN_NOT_SET,
 };
 
+
+#define BTRFS_BLOCK_GROUP_VALID	(BTRFS_BLOCK_GROUP_TYPE_MASK | \
+				 BTRFS_BLOCK_GROUP_PROFILE_MASK | \
+				 BTRFS_BLOCK_GROUP_REMAPPED)
+
 /*
  * Exported simply for btrfs-progs which wants to have the
  * btrfs_tree_block_status return codes.
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index ce0535c0264d..1134474926ff 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -231,6 +231,7 @@ void btrfs_describe_block_groups(u64 bg_flags, char *buf, u32 size_buf)
 	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_DATA, &quot;data&quot;);
 	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_SYSTEM, &quot;system&quot;);
 	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_METADATA, &quot;metadata&quot;);
+	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_REMAPPED, &quot;remapped&quot;);
 
 	DESCRIBE_FLAG(BTRFS_AVAIL_ALLOC_BIT_SINGLE, &quot;single&quot;);
 	for (i = 0; i &lt; BTRFS_NR_RAID_TYPES; i++)
diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index e8fd92789423..9165154a274d 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -336,6 +336,7 @@ struct btrfs_ioctl_fs_info_args {
 #define BTRFS_FEATURE_INCOMPAT_EXTENT_TREE_V2	(1ULL &lt;&lt; 13)
 #define BTRFS_FEATURE_INCOMPAT_RAID_STRIPE_TREE	(1ULL &lt;&lt; 14)
 #define BTRFS_FEATURE_INCOMPAT_SIMPLE_QUOTA	(1ULL &lt;&lt; 16)
+#define BTRFS_FEATURE_INCOMPAT_REMAP_TREE	(1ULL &lt;&lt; 17)
 
 struct btrfs_ioctl_feature_flags {
 	__u64 compat_flags;
diff --git a/include/uapi/linux/btrfs_tree.h b/include/uapi/linux/btrfs_tree.h
index fc29d273845d..f011d34cb699 100644
--- a/include/uapi/linux/btrfs_tree.h
+++ b/include/uapi/linux/btrfs_tree.h
@@ -76,6 +76,9 @@
 /* Tracks RAID stripes in block groups. */
 #define BTRFS_RAID_STRIPE_TREE_OBJECTID 12ULL
 
+/* Holds details of remapped addresses after relocation. */
+#define BTRFS_REMAP_TREE_OBJECTID 13ULL
+
 /* device stats in the device tree */
 #define BTRFS_DEV_STATS_OBJECTID 0ULL
 
@@ -282,6 +285,10 @@
 
 #define BTRFS_RAID_STRIPE_KEY	230
 
+#define BTRFS_IDENTITY_REMAP_KEY 	234
+#define BTRFS_REMAP_KEY		 	235
+#define BTRFS_REMAP_BACKREF_KEY	 	236
+
 /*
  * Records the overall state of the qgroups.
  * There&#x27;s only one instance of this key present,
@@ -1161,6 +1168,7 @@ struct btrfs_dev_replace_item {
 #define BTRFS_BLOCK_GROUP_RAID6         (1ULL &lt;&lt; 8)
 #define BTRFS_BLOCK_GROUP_RAID1C3       (1ULL &lt;&lt; 9)
 #define BTRFS_BLOCK_GROUP_RAID1C4       (1ULL &lt;&lt; 10)
+#define BTRFS_BLOCK_GROUP_REMAPPED      (1ULL &lt;&lt; 11)
 #define BTRFS_BLOCK_GROUP_RESERVED	(BTRFS_AVAIL_ALLOC_BIT_SINGLE | \
 					 BTRFS_SPACE_INFO_GLOBAL_RSV)
 
@@ -1323,4 +1331,13 @@ struct btrfs_verity_descriptor_item {
 	__u8 encryption;
 } __attribute__ ((__packed__));
 
+/*
+ * For a range identified by a BTRFS_REMAP_KEY item in the remap tree, gives
+ * the address that the start of the range will get remapped to.  This
+ * structure is also shared by BTRFS_REMAP_BACKREF_KEY.
+ */
+struct btrfs_remap_item {
+	__le64 address;
+} __attribute__ ((__packed__));
+
 #endif /* _BTRFS_CTREE_H_ */
-- 
2.51.2



---

Add a new METADATA_REMAP chunk type, which is a metadata chunk that holds the
remap tree.

This is needed for bootstrapping purposes: the remap tree can&#x27;t itself
be remapped, and must be relocated the existing way, by COWing every
leaf. The remap tree can&#x27;t go in the SYSTEM chunk as space there is
limited, because a copy of the chunk item gets placed in the superblock.

The changes in fs/btrfs/volumes.h are because we&#x27;re adding a new block
group type bit after the profile bits, and so can no longer rely on the
const_ilog2 trick.

The sizing to 32MB per chunk, matching the SYSTEM chunk, is an estimate
here, we can adjust it later if it proves to be too big or too small.
This works out to be ~500,000 remap items, which for a 4KB block size
covers ~2GB of remapped data in the worst case and ~500TB in the best case.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/block-rsv.c            |  9 +++++++++
 fs/btrfs/block-rsv.h            |  1 +
 fs/btrfs/disk-io.c              |  1 +
 fs/btrfs/fs.h                   |  2 ++
 fs/btrfs/space-info.c           | 13 ++++++++++++-
 fs/btrfs/sysfs.c                |  2 ++
 fs/btrfs/tree-checker.c         | 13 +++++++++++--
 fs/btrfs/volumes.c              |  3 +++
 fs/btrfs/volumes.h              | 10 +++++++++-
 include/uapi/linux/btrfs_tree.h |  4 +++-
 10 files changed, 53 insertions(+), 5 deletions(-)

diff --git a/fs/btrfs/block-rsv.c b/fs/btrfs/block-rsv.c
index 96cf7a162987..2781abf18f26 100644
--- a/fs/btrfs/block-rsv.c
+++ b/fs/btrfs/block-rsv.c
@@ -419,6 +419,9 @@ void btrfs_init_root_block_rsv(struct btrfs_root *root)
 	case BTRFS_TREE_LOG_OBJECTID:
 		root-&gt;block_rsv = &amp;fs_info-&gt;treelog_rsv;
 		break;
+	case BTRFS_REMAP_TREE_OBJECTID:
+		root-&gt;block_rsv = &amp;fs_info-&gt;remap_block_rsv;
+		break;
 	default:
 		root-&gt;block_rsv = NULL;
 		break;
@@ -432,6 +435,10 @@ void btrfs_init_global_block_rsv(struct btrfs_fs_info *fs_info)
 	space_info = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);
 	fs_info-&gt;chunk_block_rsv.space_info = space_info;
 
+	space_info = btrfs_find_space_info(fs_info,
+					   BTRFS_BLOCK_GROUP_METADATA_REMAP);
+	fs_info-&gt;remap_block_rsv.space_info = space_info;
+
 	space_info = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_METADATA);
 	fs_info-&gt;global_block_rsv.space_info = space_info;
 	fs_info-&gt;trans_block_rsv.space_info = space_info;
@@ -458,6 +465,8 @@ void btrfs_release_global_block_rsv(struct btrfs_fs_info *fs_info)
 	WARN_ON(fs_info-&gt;trans_block_rsv.reserved &gt; 0);
 	WARN_ON(fs_info-&gt;chunk_block_rsv.size &gt; 0);
 	WARN_ON(fs_info-&gt;chunk_block_rsv.reserved &gt; 0);
+	WARN_ON(fs_info-&gt;remap_block_rsv.size &gt; 0);
+	WARN_ON(fs_info-&gt;remap_block_rsv.reserved &gt; 0);
 	WARN_ON(fs_info-&gt;delayed_block_rsv.size &gt; 0);
 	WARN_ON(fs_info-&gt;delayed_block_rsv.reserved &gt; 0);
 	WARN_ON(fs_info-&gt;delayed_refs_rsv.reserved &gt; 0);
diff --git a/fs/btrfs/block-rsv.h b/fs/btrfs/block-rsv.h
index 79ae9d05cd91..8359fb96bc3c 100644
--- a/fs/btrfs/block-rsv.h
+++ b/fs/btrfs/block-rsv.h
@@ -22,6 +22,7 @@ enum btrfs_rsv_type {
 	BTRFS_BLOCK_RSV_DELALLOC,
 	BTRFS_BLOCK_RSV_TRANS,
 	BTRFS_BLOCK_RSV_CHUNK,
+	BTRFS_BLOCK_RSV_REMAP,
 	BTRFS_BLOCK_RSV_DELOPS,
 	BTRFS_BLOCK_RSV_DELREFS,
 	BTRFS_BLOCK_RSV_TREELOG,
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index cecb81d0f9e0..cbfb7127b528 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -2773,6 +2773,7 @@ void btrfs_init_fs_info(struct btrfs_fs_info *fs_info)
 			     BTRFS_BLOCK_RSV_GLOBAL);
 	btrfs_init_block_rsv(&amp;fs_info-&gt;trans_block_rsv, BTRFS_BLOCK_RSV_TRANS);
 	btrfs_init_block_rsv(&amp;fs_info-&gt;chunk_block_rsv, BTRFS_BLOCK_RSV_CHUNK);
+	btrfs_init_block_rsv(&amp;fs_info-&gt;remap_block_rsv, BTRFS_BLOCK_RSV_REMAP);
 	btrfs_init_block_rsv(&amp;fs_info-&gt;treelog_rsv, BTRFS_BLOCK_RSV_TREELOG);
 	btrfs_init_block_rsv(&amp;fs_info-&gt;empty_block_rsv, BTRFS_BLOCK_RSV_EMPTY);
 	btrfs_init_block_rsv(&amp;fs_info-&gt;delayed_block_rsv,
diff --git a/fs/btrfs/fs.h b/fs/btrfs/fs.h
index 0dc851b9c51b..46c4f1dcec47 100644
--- a/fs/btrfs/fs.h
+++ b/fs/btrfs/fs.h
@@ -501,6 +501,8 @@ struct btrfs_fs_info {
 	struct btrfs_block_rsv trans_block_rsv;
 	/* Block reservation for chunk tree */
 	struct btrfs_block_rsv chunk_block_rsv;
+	/* Block reservation for remap tree. */
+	struct btrfs_block_rsv remap_block_rsv;
 	/* Block reservation for delayed operations */
 	struct btrfs_block_rsv delayed_block_rsv;
 	/* Block reservation for delayed refs */
diff --git a/fs/btrfs/space-info.c b/fs/btrfs/space-info.c
index 7b7b7255f7d8..badebe6e0b34 100644
--- a/fs/btrfs/space-info.c
+++ b/fs/btrfs/space-info.c
@@ -215,7 +215,7 @@ static u64 calc_chunk_size(const struct btrfs_fs_info *fs_info, u64 flags)
 
 	if (flags &amp; BTRFS_BLOCK_GROUP_DATA)
 		return BTRFS_MAX_DATA_CHUNK_SIZE;
-	else if (flags &amp; BTRFS_BLOCK_GROUP_SYSTEM)
+	else if (flags &amp; (BTRFS_BLOCK_GROUP_SYSTEM | BTRFS_BLOCK_GROUP_METADATA_REMAP))
 		return SZ_32M;
 
 	/* Handle BTRFS_BLOCK_GROUP_METADATA */
@@ -344,6 +344,8 @@ int btrfs_init_space_info(struct btrfs_fs_info *fs_info)
 	if (mixed) {
 		flags = BTRFS_BLOCK_GROUP_METADATA | BTRFS_BLOCK_GROUP_DATA;
 		ret = create_space_info(fs_info, flags);
+		if (ret)
+			goto out;
 	} else {
 		flags = BTRFS_BLOCK_GROUP_METADATA;
 		ret = create_space_info(fs_info, flags);
@@ -352,7 +354,15 @@ int btrfs_init_space_info(struct btrfs_fs_info *fs_info)
 
 		flags = BTRFS_BLOCK_GROUP_DATA;
 		ret = create_space_info(fs_info, flags);
+		if (ret)
+			goto out;
+	}
+
+	if (features &amp; BTRFS_FEATURE_INCOMPAT_REMAP_TREE) {
+		flags = BTRFS_BLOCK_GROUP_METADATA_REMAP;
+		ret = create_space_info(fs_info, flags);
 	}
+
 out:
 	return ret;
 }
@@ -607,6 +617,7 @@ static void dump_global_block_rsv(struct btrfs_fs_info *fs_info)
 	DUMP_BLOCK_RSV(fs_info, global_block_rsv);
 	DUMP_BLOCK_RSV(fs_info, trans_block_rsv);
 	DUMP_BLOCK_RSV(fs_info, chunk_block_rsv);
+	DUMP_BLOCK_RSV(fs_info, remap_block_rsv);
 	DUMP_BLOCK_RSV(fs_info, delayed_block_rsv);
 	DUMP_BLOCK_RSV(fs_info, delayed_refs_rsv);
 }
diff --git a/fs/btrfs/sysfs.c b/fs/btrfs/sysfs.c
index 0e2ed8072443..0213a3c44628 100644
--- a/fs/btrfs/sysfs.c
+++ b/fs/btrfs/sysfs.c
@@ -1972,6 +1972,8 @@ static const char *alloc_name(struct btrfs_space_info *space_info)
 	case BTRFS_BLOCK_GROUP_SYSTEM:
 		ASSERT(space_info-&gt;subgroup_id == BTRFS_SUB_GROUP_PRIMARY);
 		return &quot;system&quot;;
+	case BTRFS_BLOCK_GROUP_METADATA_REMAP:
+		return &quot;metadata-remap&quot;;
 	default:
 		WARN_ON(1);
 		return &quot;invalid-combination&quot;;
diff --git a/fs/btrfs/tree-checker.c b/fs/btrfs/tree-checker.c
index aedc208a95b8..a6c158cd8fcd 100644
--- a/fs/btrfs/tree-checker.c
+++ b/fs/btrfs/tree-checker.c
@@ -748,17 +748,26 @@ static int check_block_group_item(struct extent_buffer *leaf,
 		return -EUCLEAN;
 	}
 
+	if (unlikely(flags &amp; BTRFS_BLOCK_GROUP_METADATA_REMAP &amp;&amp;
+		     !btrfs_fs_incompat(fs_info, REMAP_TREE))) {
+		block_group_err(leaf, slot,
+&quot;invalid flags, have 0x%llx (METADATA_REMAP flag set) but no remap-tree incompat flag&quot;,
+				flags);
+		return -EUCLEAN;
+	}
+
 	type = flags &amp; BTRFS_BLOCK_GROUP_TYPE_MASK;
 	if (unlikely(type != BTRFS_BLOCK_GROUP_DATA &amp;&amp;
 		     type != BTRFS_BLOCK_GROUP_METADATA &amp;&amp;
 		     type != BTRFS_BLOCK_GROUP_SYSTEM &amp;&amp;
+		     type != BTRFS_BLOCK_GROUP_METADATA_REMAP &amp;&amp;
 		     type != (BTRFS_BLOCK_GROUP_METADATA |
 			      BTRFS_BLOCK_GROUP_DATA))) {
 		block_group_err(leaf, slot,
-&quot;invalid type, have 0x%llx (%lu bits set) expect either 0x%llx, 0x%llx, 0x%llx or 0x%llx&quot;,
+&quot;invalid type, have 0x%llx (%lu bits set) expect either 0x%llx, 0x%llx, 0x%llx, 0x%llx or 0x%llx&quot;,
 			type, hweight64(type),
 			BTRFS_BLOCK_GROUP_DATA, BTRFS_BLOCK_GROUP_METADATA,
-			BTRFS_BLOCK_GROUP_SYSTEM,
+			BTRFS_BLOCK_GROUP_SYSTEM, BTRFS_BLOCK_GROUP_METADATA_REMAP,
 			BTRFS_BLOCK_GROUP_METADATA | BTRFS_BLOCK_GROUP_DATA);
 		return -EUCLEAN;
 	}
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 1134474926ff..07d42ba38d7d 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -231,6 +231,9 @@ void btrfs_describe_block_groups(u64 bg_flags, char *buf, u32 size_buf)
 	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_DATA, &quot;data&quot;);
 	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_SYSTEM, &quot;system&quot;);
 	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_METADATA, &quot;metadata&quot;);
+	/* Block groups containing the remap tree. */
+	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_METADATA_REMAP, &quot;metadata-remap&quot;);
+	/* Block group that has been remapped. */
 	DESCRIBE_FLAG(BTRFS_BLOCK_GROUP_REMAPPED, &quot;remapped&quot;);
 
 	DESCRIBE_FLAG(BTRFS_AVAIL_ALLOC_BIT_SINGLE, &quot;single&quot;);
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 34b854c1a303..4117fabb248b 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -58,7 +58,6 @@ static_assert(ilog2(BTRFS_STRIPE_LEN) == BTRFS_STRIPE_LEN_SHIFT);
  */
 static_assert(const_ffs(BTRFS_BLOCK_GROUP_RAID0) &lt;
 	      const_ffs(BTRFS_BLOCK_GROUP_PROFILE_MASK &amp; ~BTRFS_BLOCK_GROUP_RAID0));
-static_assert(ilog2(BTRFS_BLOCK_GROUP_RAID0) &gt; ilog2(BTRFS_BLOCK_GROUP_TYPE_MASK));
 
 /* ilog2() can handle both constants and variables */
 #define BTRFS_BG_FLAG_TO_INDEX(profile)					\
@@ -80,6 +79,15 @@ enum btrfs_raid_types {
 	BTRFS_NR_RAID_TYPES
 };
 
+static_assert(BTRFS_RAID_RAID0 == 1);
+static_assert(BTRFS_RAID_RAID1 == 2);
+static_assert(BTRFS_RAID_DUP == 3);
+static_assert(BTRFS_RAID_RAID10 == 4);
+static_assert(BTRFS_RAID_RAID5 == 5);
+static_assert(BTRFS_RAID_RAID6 == 6);
+static_assert(BTRFS_RAID_RAID1C3 == 7);
+static_assert(BTRFS_RAID_RAID1C4 == 8);
+
 /*
  * Use sequence counter to get consistent device stat data on
  * 32-bit processors.
diff --git a/include/uapi/linux/btrfs_tree.h b/include/uapi/linux/btrfs_tree.h
index f011d34cb699..76578426671c 100644
--- a/include/uapi/linux/btrfs_tree.h
+++ b/include/uapi/linux/btrfs_tree.h
@@ -1169,12 +1169,14 @@ struct btrfs_dev_replace_item {
 #define BTRFS_BLOCK_GROUP_RAID1C3       (1ULL &lt;&lt; 9)
 #define BTRFS_BLOCK_GROUP_RAID1C4       (1ULL &lt;&lt; 10)
 #define BTRFS_BLOCK_GROUP_REMAPPED      (1ULL &lt;&lt; 11)
+#define BTRFS_BLOCK_GROUP_METADATA_REMAP (1ULL &lt;&lt; 12)
 #define BTRFS_BLOCK_GROUP_RESERVED	(BTRFS_AVAIL_ALLOC_BIT_SINGLE | \
 					 BTRFS_SPACE_INFO_GLOBAL_RSV)
 
 #define BTRFS_BLOCK_GROUP_TYPE_MASK	(BTRFS_BLOCK_GROUP_DATA |    \
 					 BTRFS_BLOCK_GROUP_SYSTEM |  \
-					 BTRFS_BLOCK_GROUP_METADATA)
+					 BTRFS_BLOCK_GROUP_METADATA | \
+					 BTRFS_BLOCK_GROUP_METADATA_REMAP)
 
 #define BTRFS_BLOCK_GROUP_PROFILE_MASK	(BTRFS_BLOCK_GROUP_RAID0 |   \
 					 BTRFS_BLOCK_GROUP_RAID1 |   \
-- 
2.51.2



---

This is version 8 of the patch series for the new logical remapping tree
feature - see the previous cover letters for more information including
the rationale:

* RFC: https://lore.kernel.org/all/20250515163641.3449017-1-maharmstone@fb.com/
* Version 1: https://lore.kernel.org/all/20250605162345.2561026-1-maharmstone@fb.com/
* Version 2: https://lore.kernel.org/all/20250813143509.31073-1-mark@harmstone.com/
* Version 3: https://lore.kernel.org/all/20251009112814.13942-1-mark@harmstone.com/
* Version 4: https://lore.kernel.org/all/20251024181227.32228-1-mark@harmstone.com/
* Version 5: https://lore.kernel.org/all/20251110171511.20900-1-mark@harmstone.com/
* Version 6: https://lore.kernel.org/all/20251114184745.9304-1-mark@harmstone.com/
* Version 7: https://lore.kernel.org/all/20251124185335.16556-1-mark@harmstone.com/

Changes since version 7:
* renamed struct btrfs_remap to struct btrfs_remap_item
* renamed BTRFS_BLOCK_GROUP_FLAGS_REMAP to BTRFS_BLOCK_GROUP_FLAGS_METADATA_REMAP
* added unlikelies
* renamed new commit_* fields in struct btrfs_block_group to last_*, and added
  new patch renaming existing commit_used to last_used to match
* merged do_copy() into copy_remapped_data()
* initialized on-stack struct btrfs_remap_items
* fixed comments
* added other minor changes as suggested by David Sterba

Mark Harmstone (17):
  btrfs: add definitions and constants for remap-tree
  btrfs: add METADATA_REMAP chunk type
  btrfs: allow remapped chunks to have zero stripes
  btrfs: remove remapped block groups from the free-space tree
  btrfs: don&#x27;t add metadata items for the remap tree to the extent tree
  btrfs: rename struct btrfs_block_group field commit_used to last_used
  btrfs: add extended version of struct block_group_item
  btrfs: allow mounting filesystems with remap-tree incompat flag
  btrfs: redirect I/O for remapped block groups
  btrfs: handle deletions from remapped block group
  btrfs: handle setting up relocation of block group with remap-tree
  btrfs: move existing remaps before relocating block group
  btrfs: replace identity remaps with actual remaps when doing
    relocations
  btrfs: add do_remap param to btrfs_discard_extent()
  btrfs: allow balancing remap tree
  btrfs: handle discarding fully-remapped block groups
  btrfs: populate fully_remapped_bgs_list on mount

 fs/btrfs/Kconfig                |    2 +
 fs/btrfs/accessors.h            |   30 +
 fs/btrfs/bio.c                  |    3 +-
 fs/btrfs/bio.h                  |    3 +
 fs/btrfs/block-group.c          |  323 ++++--
 fs/btrfs/block-group.h          |   29 +-
 fs/btrfs/block-rsv.c            |    9 +
 fs/btrfs/block-rsv.h            |    1 +
 fs/btrfs/discard.c              |   57 +-
 fs/btrfs/disk-io.c              |  130 ++-
 fs/btrfs/extent-tree.c          |  151 ++-
 fs/btrfs/extent-tree.h          |    4 +-
 fs/btrfs/free-space-cache.c     |   59 +-
 fs/btrfs/free-space-cache.h     |    1 +
 fs/btrfs/free-space-tree.c      |    4 +-
 fs/btrfs/free-space-tree.h      |    5 +-
 fs/btrfs/fs.h                   |   10 +-
 fs/btrfs/inode.c                |    2 +-
 fs/btrfs/locking.c              |    1 +
 fs/btrfs/relocation.c           | 1885 +++++++++++++++++++++++++++++--
 fs/btrfs/relocation.h           |   18 +
 fs/btrfs/space-info.c           |   22 +-
 fs/btrfs/sysfs.c                |    4 +
 fs/btrfs/transaction.c          |    7 +
 fs/btrfs/tree-checker.c         |   94 +-
 fs/btrfs/tree-checker.h         |    5 +
 fs/btrfs/volumes.c              |  355 +++++-
 fs/btrfs/volumes.h              |   18 +-
 include/uapi/linux/btrfs.h      |    1 +
 include/uapi/linux/btrfs_tree.h |   34 +-
 30 files changed, 2991 insertions(+), 276 deletions(-)

-- 
2.51.2



---

When a chunk has been fully remapped, we are going to set its
num_stripes to 0, as it will no longer represent a physical location on
disk.

Change tree-checker to allow for this, and fix read_one_chunk() to avoid
a divide by zero.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/tree-checker.c | 65 ++++++++++++++++++++++++++++-------------
 fs/btrfs/volumes.c      |  7 ++++-
 2 files changed, 51 insertions(+), 21 deletions(-)

diff --git a/fs/btrfs/tree-checker.c b/fs/btrfs/tree-checker.c
index a6c158cd8fcd..4e390d6517a3 100644
--- a/fs/btrfs/tree-checker.c
+++ b/fs/btrfs/tree-checker.c
@@ -816,6 +816,41 @@ static void chunk_err(const struct btrfs_fs_info *fs_info,
 	va_end(args);
 }
 
+static bool valid_stripe_count(u64 profile, u16 num_stripes,
+			       u16 sub_stripes)
+{
+	switch (profile) {
+	case BTRFS_BLOCK_GROUP_RAID0:
+		return true;
+	case BTRFS_BLOCK_GROUP_RAID10:
+		return sub_stripes ==
+			btrfs_raid_array[BTRFS_RAID_RAID10].sub_stripes;
+	case BTRFS_BLOCK_GROUP_RAID1:
+		return num_stripes ==
+			btrfs_raid_array[BTRFS_RAID_RAID1].devs_min;
+	case BTRFS_BLOCK_GROUP_RAID1C3:
+		return num_stripes ==
+			btrfs_raid_array[BTRFS_RAID_RAID1C3].devs_min;
+	case BTRFS_BLOCK_GROUP_RAID1C4:
+		return num_stripes ==
+			btrfs_raid_array[BTRFS_RAID_RAID1C4].devs_min;
+	case BTRFS_BLOCK_GROUP_RAID5:
+		return num_stripes &gt;=
+			btrfs_raid_array[BTRFS_RAID_RAID5].devs_min;
+	case BTRFS_BLOCK_GROUP_RAID6:
+		return num_stripes &gt;=
+			btrfs_raid_array[BTRFS_RAID_RAID6].devs_min;
+	case BTRFS_BLOCK_GROUP_DUP:
+		return num_stripes ==
+			btrfs_raid_array[BTRFS_RAID_DUP].dev_stripes;
+	case 0: /* SINGLE */
+		return num_stripes ==
+			btrfs_raid_array[BTRFS_RAID_SINGLE].dev_stripes;
+	default:
+		BUG();
+	}
+}
+
 /*
  * The common chunk check which could also work on super block sys chunk array.
  *
@@ -839,6 +874,7 @@ int btrfs_check_chunk_valid(const struct btrfs_fs_info *fs_info,
 	u64 features;
 	u32 chunk_sector_size;
 	bool mixed = false;
+	bool remapped;
 	int raid_index;
 	int nparity;
 	int ncopies;
@@ -862,12 +898,14 @@ int btrfs_check_chunk_valid(const struct btrfs_fs_info *fs_info,
 	ncopies = btrfs_raid_array[raid_index].ncopies;
 	nparity = btrfs_raid_array[raid_index].nparity;
 
-	if (unlikely(!num_stripes)) {
+	remapped = type &amp; BTRFS_BLOCK_GROUP_REMAPPED;
+
+	if (unlikely(!remapped &amp;&amp; !num_stripes)) {
 		chunk_err(fs_info, leaf, chunk, logical,
 			  &quot;invalid chunk num_stripes, have %u&quot;, num_stripes);
 		return -EUCLEAN;
 	}
-	if (unlikely(num_stripes &lt; ncopies)) {
+	if (unlikely(num_stripes != 0 &amp;&amp; num_stripes &lt; ncopies)) {
 		chunk_err(fs_info, leaf, chunk, logical,
 			  &quot;invalid chunk num_stripes &lt; ncopies, have %u &lt; %d&quot;,
 			  num_stripes, ncopies);
@@ -965,22 +1003,9 @@ int btrfs_check_chunk_valid(const struct btrfs_fs_info *fs_info,
 		}
 	}
 
-	if (unlikely((type &amp; BTRFS_BLOCK_GROUP_RAID10 &amp;&amp;
-		      sub_stripes != btrfs_raid_array[BTRFS_RAID_RAID10].sub_stripes) ||
-		     (type &amp; BTRFS_BLOCK_GROUP_RAID1 &amp;&amp;
-		      num_stripes != btrfs_raid_array[BTRFS_RAID_RAID1].devs_min) ||
-		     (type &amp; BTRFS_BLOCK_GROUP_RAID1C3 &amp;&amp;
-		      num_stripes != btrfs_raid_array[BTRFS_RAID_RAID1C3].devs_min) ||
-		     (type &amp; BTRFS_BLOCK_GROUP_RAID1C4 &amp;&amp;
-		      num_stripes != btrfs_raid_array[BTRFS_RAID_RAID1C4].devs_min) ||
-		     (type &amp; BTRFS_BLOCK_GROUP_RAID5 &amp;&amp;
-		      num_stripes &lt; btrfs_raid_array[BTRFS_RAID_RAID5].devs_min) ||
-		     (type &amp; BTRFS_BLOCK_GROUP_RAID6 &amp;&amp;
-		      num_stripes &lt; btrfs_raid_array[BTRFS_RAID_RAID6].devs_min) ||
-		     (type &amp; BTRFS_BLOCK_GROUP_DUP &amp;&amp;
-		      num_stripes != btrfs_raid_array[BTRFS_RAID_DUP].dev_stripes) ||
-		     ((type &amp; BTRFS_BLOCK_GROUP_PROFILE_MASK) == 0 &amp;&amp;
-		      num_stripes != btrfs_raid_array[BTRFS_RAID_SINGLE].dev_stripes))) {
+	if (!remapped &amp;&amp;
+	    !valid_stripe_count(type &amp; BTRFS_BLOCK_GROUP_PROFILE_MASK,
+				num_stripes, sub_stripes)) {
 		chunk_err(fs_info, leaf, chunk, logical,
 			&quot;invalid num_stripes:sub_stripes %u:%u for profile %llu&quot;,
 			num_stripes, sub_stripes,
@@ -1004,11 +1029,11 @@ static int check_leaf_chunk_item(struct extent_buffer *leaf,
 	struct btrfs_fs_info *fs_info = leaf-&gt;fs_info;
 	int num_stripes;
 
-	if (unlikely(btrfs_item_size(leaf, slot) &lt; sizeof(struct btrfs_chunk))) {
+	if (unlikely(btrfs_item_size(leaf, slot) &lt; offsetof(struct btrfs_chunk, stripe))) {
 		chunk_err(fs_info, leaf, chunk, key-&gt;offset,
 			&quot;invalid chunk item size: have %u expect [%zu, %u)&quot;,
 			btrfs_item_size(leaf, slot),
-			sizeof(struct btrfs_chunk),
+			offsetof(struct btrfs_chunk, stripe),
 			BTRFS_LEAF_DATA_SIZE(fs_info));
 		return -EUCLEAN;
 	}
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 07d42ba38d7d..070efac46a81 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -7045,7 +7045,12 @@ static int read_one_chunk(struct btrfs_key *key, struct extent_buffer *leaf,
 	 */
 	map-&gt;sub_stripes = btrfs_raid_array[index].sub_stripes;
 	map-&gt;verified_stripes = 0;
-	map-&gt;stripe_size = btrfs_calc_stripe_length(map);
+
+	if (num_stripes &gt; 0)
+		map-&gt;stripe_size = btrfs_calc_stripe_length(map);
+	else
+		map-&gt;stripe_size = 0;
+
 	for (i = 0; i &lt; num_stripes; i++) {
 		map-&gt;stripes[i].physical =
 			btrfs_stripe_offset_nr(leaf, chunk, i);
-- 
2.51.2



---

Add a struct btrfs_block_group_item_v2, which is used in the block group
tree if the remap-tree incompat flag is set.

This adds two new fields to the block group item: `remap_bytes` and
`identity_remap_count`.

`remap_bytes` records the amount of data that&#x27;s physically within this
block group, but nominally in another, remapped block group. This is
necessary because this data will need to be moved first if this block
group is itself relocated. If `remap_bytes` &gt; 0, this is an indicator to
the relocation thread that it will need to search the remap-tree for
backrefs. A block group must also have `remap_bytes` == 0 before it can
be dropped.

`identity_remap_count` records how many identity remap items are located
in the remap tree for this block group. When relocation is begun for
this block group, this is set to the number of holes in the free-space
tree for this range. As identity remaps are converted into actual remaps
by the relocation process, this number is decreased. Once it reaches 0,
either because of relocation or because extents have been deleted, the
block group has been fully remapped and its chunk&#x27;s device extents are
removed.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/accessors.h            |  20 +++++++
 fs/btrfs/block-group.c          | 100 ++++++++++++++++++++++++--------
 fs/btrfs/block-group.h          |  14 ++++-
 fs/btrfs/discard.c              |   2 +-
 fs/btrfs/tree-checker.c         |  10 +++-
 include/uapi/linux/btrfs_tree.h |   8 +++
 6 files changed, 126 insertions(+), 28 deletions(-)

diff --git a/fs/btrfs/accessors.h b/fs/btrfs/accessors.h
index 09cdd6bfddf5..9797f9e8d4e5 100644
--- a/fs/btrfs/accessors.h
+++ b/fs/btrfs/accessors.h
@@ -240,6 +240,26 @@ BTRFS_SETGET_FUNCS(block_group_flags, struct btrfs_block_group_item, flags, 64);
 BTRFS_SETGET_STACK_FUNCS(stack_block_group_flags,
 			struct btrfs_block_group_item, flags, 64);
 
+/* struct btrfs_block_group_item_v2 */
+BTRFS_SETGET_STACK_FUNCS(stack_block_group_v2_used, struct btrfs_block_group_item_v2,
+			 used, 64);
+BTRFS_SETGET_FUNCS(block_group_v2_used, struct btrfs_block_group_item_v2, used, 64);
+BTRFS_SETGET_STACK_FUNCS(stack_block_group_v2_chunk_objectid,
+			 struct btrfs_block_group_item_v2, chunk_objectid, 64);
+BTRFS_SETGET_FUNCS(block_group_v2_chunk_objectid,
+		   struct btrfs_block_group_item_v2, chunk_objectid, 64);
+BTRFS_SETGET_STACK_FUNCS(stack_block_group_v2_flags,
+			 struct btrfs_block_group_item_v2, flags, 64);
+BTRFS_SETGET_FUNCS(block_group_v2_flags, struct btrfs_block_group_item_v2, flags, 64);
+BTRFS_SETGET_STACK_FUNCS(stack_block_group_v2_remap_bytes,
+			 struct btrfs_block_group_item_v2, remap_bytes, 64);
+BTRFS_SETGET_FUNCS(block_group_v2_remap_bytes, struct btrfs_block_group_item_v2,
+		   remap_bytes, 64);
+BTRFS_SETGET_STACK_FUNCS(stack_block_group_v2_identity_remap_count,
+			 struct btrfs_block_group_item_v2, identity_remap_count, 32);
+BTRFS_SETGET_FUNCS(block_group_v2_identity_remap_count, struct btrfs_block_group_item_v2,
+		   identity_remap_count, 32);
+
 /* struct btrfs_free_space_info */
 BTRFS_SETGET_FUNCS(free_space_extent_count, struct btrfs_free_space_info,
 		   extent_count, 32);
diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.c
index 822c5306a7a4..4962d17a175e 100644
--- a/fs/btrfs/block-group.c
+++ b/fs/btrfs/block-group.c
@@ -2372,7 +2372,7 @@ static int check_chunk_block_group_mappings(struct btrfs_fs_info *fs_info)
 }
 
 static int read_one_block_group(struct btrfs_fs_info *info,
-				struct btrfs_block_group_item *bgi,
+				struct btrfs_block_group_item_v2 *bgi,
 				const struct btrfs_key *key,
 				int need_clear)
 {
@@ -2387,11 +2387,16 @@ static int read_one_block_group(struct btrfs_fs_info *info,
 		return -ENOMEM;
 
 	cache-&gt;length = key-&gt;offset;
-	cache-&gt;used = btrfs_stack_block_group_used(bgi);
+	cache-&gt;used = btrfs_stack_block_group_v2_used(bgi);
 	cache-&gt;last_used = cache-&gt;used;
-	cache-&gt;flags = btrfs_stack_block_group_flags(bgi);
-	cache-&gt;global_root_id = btrfs_stack_block_group_chunk_objectid(bgi);
+	cache-&gt;flags = btrfs_stack_block_group_v2_flags(bgi);
+	cache-&gt;global_root_id = btrfs_stack_block_group_v2_chunk_objectid(bgi);
 	cache-&gt;space_info = btrfs_find_space_info(info, cache-&gt;flags);
+	cache-&gt;remap_bytes = btrfs_stack_block_group_v2_remap_bytes(bgi);
+	cache-&gt;last_remap_bytes = cache-&gt;remap_bytes;
+	cache-&gt;identity_remap_count =
+		btrfs_stack_block_group_v2_identity_remap_count(bgi);
+	cache-&gt;last_identity_remap_count = cache-&gt;identity_remap_count;
 
 	btrfs_set_free_space_tree_thresholds(cache);
 
@@ -2456,7 +2461,7 @@ static int read_one_block_group(struct btrfs_fs_info *info,
 	} else if (cache-&gt;length == cache-&gt;used) {
 		cache-&gt;cached = BTRFS_CACHE_FINISHED;
 		btrfs_free_excluded_extents(cache);
-	} else if (cache-&gt;used == 0) {
+	} else if (cache-&gt;used == 0 &amp;&amp; cache-&gt;remap_bytes == 0) {
 		cache-&gt;cached = BTRFS_CACHE_FINISHED;
 		ret = btrfs_add_new_free_space(cache, cache-&gt;start,
 					       cache-&gt;start + cache-&gt;length, NULL);
@@ -2476,7 +2481,7 @@ static int read_one_block_group(struct btrfs_fs_info *info,
 
 	set_avail_alloc_bits(info, cache-&gt;flags);
 	if (btrfs_chunk_writeable(info, cache-&gt;start)) {
-		if (cache-&gt;used == 0) {
+		if (cache-&gt;used == 0 &amp;&amp; cache-&gt;remap_bytes == 0) {
 			ASSERT(list_empty(&amp;cache-&gt;bg_list));
 			if (btrfs_test_opt(info, DISCARD_ASYNC))
 				btrfs_discard_queue_work(&amp;info-&gt;discard_ctl, cache);
@@ -2580,9 +2585,10 @@ int btrfs_read_block_groups(struct btrfs_fs_info *info)
 		need_clear = 1;
 
 	while (1) {
-		struct btrfs_block_group_item bgi;
+		struct btrfs_block_group_item_v2 bgi;
 		struct extent_buffer *leaf;
 		int slot;
+		size_t size;
 
 		ret = find_first_block_group(info, path, &amp;key);
 		if (ret &gt; 0)
@@ -2593,8 +2599,16 @@ int btrfs_read_block_groups(struct btrfs_fs_info *info)
 		leaf = path-&gt;nodes[0];
 		slot = path-&gt;slots[0];
 
+		if (btrfs_fs_incompat(info, REMAP_TREE)) {
+			size = sizeof(struct btrfs_block_group_item_v2);
+		} else {
+			size = sizeof(struct btrfs_block_group_item);
+			btrfs_set_stack_block_group_v2_remap_bytes(&amp;bgi, 0);
+			btrfs_set_stack_block_group_v2_identity_remap_count(&amp;bgi, 0);
+		}
+
 		read_extent_buffer(leaf, &amp;bgi, btrfs_item_ptr_offset(leaf, slot),
-				   sizeof(bgi));
+				   size);
 
 		btrfs_item_key_to_cpu(leaf, &amp;key, slot);
 		btrfs_release_path(path);
@@ -2664,25 +2678,38 @@ static int insert_block_group_item(struct btrfs_trans_handle *trans,
 				   struct btrfs_block_group *block_group)
 {
 	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
-	struct btrfs_block_group_item bgi;
+	struct btrfs_block_group_item_v2 bgi;
 	struct btrfs_root *root = btrfs_block_group_root(fs_info);
 	struct btrfs_key key;
 	u64 old_last_used;
+	size_t size;
 	int ret;
 
 	spin_lock(&amp;block_group-&gt;lock);
-	btrfs_set_stack_block_group_used(&amp;bgi, block_group-&gt;used);
-	btrfs_set_stack_block_group_chunk_objectid(&amp;bgi,
-						   block_group-&gt;global_root_id);
-	btrfs_set_stack_block_group_flags(&amp;bgi, block_group-&gt;flags);
+	btrfs_set_stack_block_group_v2_used(&amp;bgi, block_group-&gt;used);
+	btrfs_set_stack_block_group_v2_chunk_objectid(&amp;bgi,
+						      block_group-&gt;global_root_id);
+	btrfs_set_stack_block_group_v2_flags(&amp;bgi, block_group-&gt;flags);
+	btrfs_set_stack_block_group_v2_remap_bytes(&amp;bgi,
+						   block_group-&gt;remap_bytes);
+	btrfs_set_stack_block_group_v2_identity_remap_count(&amp;bgi,
+					block_group-&gt;identity_remap_count);
 	old_last_used = block_group-&gt;last_used;
 	block_group-&gt;last_used = block_group-&gt;used;
+	block_group-&gt;last_remap_bytes = block_group-&gt;remap_bytes;
+	block_group-&gt;last_identity_remap_count =
+		block_group-&gt;identity_remap_count;
 	key.objectid = block_group-&gt;start;
 	key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;
 	key.offset = block_group-&gt;length;
 	spin_unlock(&amp;block_group-&gt;lock);
 
-	ret = btrfs_insert_item(trans, root, &amp;key, &amp;bgi, sizeof(bgi));
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE))
+		size = sizeof(struct btrfs_block_group_item_v2);
+	else
+		size = sizeof(struct btrfs_block_group_item);
+
+	ret = btrfs_insert_item(trans, root, &amp;key, &amp;bgi, size);
 	if (ret &lt; 0) {
 		spin_lock(&amp;block_group-&gt;lock);
 		block_group-&gt;last_used = old_last_used;
@@ -3137,10 +3164,12 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 	struct btrfs_root *root = btrfs_block_group_root(fs_info);
 	unsigned long bi;
 	struct extent_buffer *leaf;
-	struct btrfs_block_group_item bgi;
+	struct btrfs_block_group_item_v2 bgi;
 	struct btrfs_key key;
-	u64 old_last_used;
-	u64 used;
+	u64 old_last_used, old_last_remap_bytes;
+	u32 old_last_identity_remap_count;
+	u64 used, remap_bytes;
+	u32 identity_remap_count;
 
 	/*
 	 * Block group items update can be triggered out of commit transaction
@@ -3150,13 +3179,21 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 	 */
 	spin_lock(&amp;cache-&gt;lock);
 	old_last_used = cache-&gt;last_used;
+	old_last_remap_bytes = cache-&gt;last_remap_bytes;
+	old_last_identity_remap_count = cache-&gt;last_identity_remap_count;
 	used = cache-&gt;used;
-	/* No change in used bytes, can safely skip it. */
-	if (cache-&gt;last_used == used) {
+	remap_bytes = cache-&gt;remap_bytes;
+	identity_remap_count = cache-&gt;identity_remap_count;
+	/* No change in values, can safely skip it. */
+	if (cache-&gt;last_used == used &amp;&amp;
+	    cache-&gt;last_remap_bytes == remap_bytes &amp;&amp;
+	    cache-&gt;last_identity_remap_count == identity_remap_count) {
 		spin_unlock(&amp;cache-&gt;lock);
 		return 0;
 	}
 	cache-&gt;last_used = used;
+	cache-&gt;last_remap_bytes = remap_bytes;
+	cache-&gt;last_identity_remap_count = identity_remap_count;
 	spin_unlock(&amp;cache-&gt;lock);
 
 	key.objectid = cache-&gt;start;
@@ -3172,11 +3209,23 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 
 	leaf = path-&gt;nodes[0];
 	bi = btrfs_item_ptr_offset(leaf, path-&gt;slots[0]);
-	btrfs_set_stack_block_group_used(&amp;bgi, used);
-	btrfs_set_stack_block_group_chunk_objectid(&amp;bgi,
-						   cache-&gt;global_root_id);
-	btrfs_set_stack_block_group_flags(&amp;bgi, cache-&gt;flags);
-	write_extent_buffer(leaf, &amp;bgi, bi, sizeof(bgi));
+	btrfs_set_stack_block_group_v2_used(&amp;bgi, used);
+	btrfs_set_stack_block_group_v2_chunk_objectid(&amp;bgi,
+						      cache-&gt;global_root_id);
+	btrfs_set_stack_block_group_v2_flags(&amp;bgi, cache-&gt;flags);
+
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE)) {
+		btrfs_set_stack_block_group_v2_remap_bytes(&amp;bgi,
+							   cache-&gt;remap_bytes);
+		btrfs_set_stack_block_group_v2_identity_remap_count(&amp;bgi,
+						cache-&gt;identity_remap_count);
+		write_extent_buffer(leaf, &amp;bgi, bi,
+				    sizeof(struct btrfs_block_group_item_v2));
+	} else {
+		write_extent_buffer(leaf, &amp;bgi, bi,
+				    sizeof(struct btrfs_block_group_item));
+	}
+
 fail:
 	btrfs_release_path(path);
 	/*
@@ -3191,6 +3240,9 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 	if (ret &lt; 0 &amp;&amp; ret != -ENOENT) {
 		spin_lock(&amp;cache-&gt;lock);
 		cache-&gt;last_used = old_last_used;
+		cache-&gt;last_remap_bytes = old_last_remap_bytes;
+		cache-&gt;last_identity_remap_count =
+			old_last_identity_remap_count;
 		spin_unlock(&amp;cache-&gt;lock);
 	}
 	return ret;
diff --git a/fs/btrfs/block-group.h b/fs/btrfs/block-group.h
index 01401e9959c1..4cee3448ded3 100644
--- a/fs/btrfs/block-group.h
+++ b/fs/btrfs/block-group.h
@@ -129,6 +129,8 @@ struct btrfs_block_group {
 	u64 flags;
 	u64 cache_generation;
 	u64 global_root_id;
+	u64 remap_bytes;
+	u32 identity_remap_count;
 
 	/*
 	 * The last committed used bytes of this block group, if the above @used
@@ -136,6 +138,15 @@ struct btrfs_block_group {
 	 * group item of this block group.
 	 */
 	u64 last_used;
+	/*
+	 * The last committed remap_bytes value of this block group.
+	 */
+	u64 last_remap_bytes;
+	/*
+	 * The last commited identity_remap_count value of this block group.
+	 */
+	u32 last_identity_remap_count;
+
 	/*
 	 * If the free space extent count exceeds this number, convert the block
 	 * group to bitmaps.
@@ -282,7 +293,8 @@ static inline bool btrfs_is_block_group_used(const struct btrfs_block_group *bg)
 {
 	lockdep_assert_held(&amp;bg-&gt;lock);
 
-	return (bg-&gt;used &gt; 0 || bg-&gt;reserved &gt; 0 || bg-&gt;pinned &gt; 0);
+	return (bg-&gt;used &gt; 0 || bg-&gt;reserved &gt; 0 || bg-&gt;pinned &gt; 0 ||
+		bg-&gt;remap_bytes &gt; 0);
 }
 
 static inline bool btrfs_is_block_group_data_only(const struct btrfs_block_group *block_group)
diff --git a/fs/btrfs/discard.c b/fs/btrfs/discard.c
index 89fe85778115..ee5f5b2788e1 100644
--- a/fs/btrfs/discard.c
+++ b/fs/btrfs/discard.c
@@ -373,7 +373,7 @@ void btrfs_discard_queue_work(struct btrfs_discard_ctl *discard_ctl,
 	if (!block_group || !btrfs_test_opt(block_group-&gt;fs_info, DISCARD_ASYNC))
 		return;
 
-	if (block_group-&gt;used == 0)
+	if (block_group-&gt;used == 0 &amp;&amp; block_group-&gt;remap_bytes == 0)
 		add_to_discard_unused_list(discard_ctl, block_group);
 	else
 		add_to_discard_list(discard_ctl, block_group);
diff --git a/fs/btrfs/tree-checker.c b/fs/btrfs/tree-checker.c
index 4e390d6517a3..d524fd4c3898 100644
--- a/fs/btrfs/tree-checker.c
+++ b/fs/btrfs/tree-checker.c
@@ -688,6 +688,7 @@ static int check_block_group_item(struct extent_buffer *leaf,
 	u64 chunk_objectid;
 	u64 flags;
 	u64 type;
+	size_t exp_size;
 
 	/*
 	 * Here we don&#x27;t really care about alignment since extent allocator can
@@ -699,10 +700,15 @@ static int check_block_group_item(struct extent_buffer *leaf,
 		return -EUCLEAN;
 	}
 
-	if (unlikely(item_size != sizeof(bgi))) {
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE))
+		exp_size = sizeof(struct btrfs_block_group_item_v2);
+	else
+		exp_size = sizeof(struct btrfs_block_group_item);
+
+	if (unlikely(item_size != exp_size)) {
 		block_group_err(leaf, slot,
 			&quot;invalid item size, have %u expect %zu&quot;,
-				item_size, sizeof(bgi));
+				item_size, exp_size);
 		return -EUCLEAN;
 	}
 
diff --git a/include/uapi/linux/btrfs_tree.h b/include/uapi/linux/btrfs_tree.h
index 76578426671c..86820a9644e8 100644
--- a/include/uapi/linux/btrfs_tree.h
+++ b/include/uapi/linux/btrfs_tree.h
@@ -1229,6 +1229,14 @@ struct btrfs_block_group_item {
 	__le64 flags;
 } __attribute__ ((__packed__));
 
+struct btrfs_block_group_item_v2 {
+	__le64 used;
+	__le64 chunk_objectid;
+	__le64 flags;
+	__le64 remap_bytes;
+	__le32 identity_remap_count;
+} __attribute__ ((__packed__));
+
 struct btrfs_free_space_info {
 	__le32 extent_count;
 	__le32 flags;
-- 
2.51.2



---

Change btrfs_map_block() so that if the block group has the REMAPPED
flag set, we call btrfs_translate_remap() to obtain a new address.

btrfs_translate_remap() searches the remap tree for a range
corresponding to the logical address passed to btrfs_map_block(). If it
is within an identity remap, this part of the block group hasn&#x27;t yet
been relocated, and so we use the existing address.

If it is within an actual remap, we subtract the start of the remap
range and add the address of its destination, contained in the item&#x27;s
payload.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/relocation.c | 54 +++++++++++++++++++++++++++++++++++++++++++
 fs/btrfs/relocation.h |  2 ++
 fs/btrfs/volumes.c    | 19 +++++++++++++++
 3 files changed, 75 insertions(+)

diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 310b7d817a27..525f45c668f6 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -3859,6 +3859,60 @@ static const char *stage_to_string(enum reloc_stage stage)
 	return &quot;unknown&quot;;
 }
 
+int btrfs_translate_remap(struct btrfs_fs_info *fs_info, u64 *logical,
+			  u64 *length)
+{
+	int ret;
+	struct btrfs_key key, found_key;
+	struct extent_buffer *leaf;
+	struct btrfs_remap_item *remap;
+	BTRFS_PATH_AUTO_FREE(path);
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+
+	key.objectid = *logical;
+	key.type = (u8)-1;
+	key.offset = (u64)-1;
+
+	ret = btrfs_search_slot(NULL, fs_info-&gt;remap_root, &amp;key, path,
+				0, 0);
+	if (ret &lt; 0)
+		return ret;
+
+	leaf = path-&gt;nodes[0];
+
+	if (path-&gt;slots[0] == 0)
+		return -ENOENT;
+
+	path-&gt;slots[0]--;
+
+	btrfs_item_key_to_cpu(leaf, &amp;found_key, path-&gt;slots[0]);
+
+	if (found_key.type != BTRFS_REMAP_KEY &amp;&amp;
+	    found_key.type != BTRFS_IDENTITY_REMAP_KEY) {
+		return -ENOENT;
+	}
+
+	if (found_key.objectid &gt; *logical ||
+	    found_key.objectid + found_key.offset &lt;= *logical) {
+		return -ENOENT;
+	}
+
+	if (*logical + *length &gt; found_key.objectid + found_key.offset)
+		*length = found_key.objectid + found_key.offset - *logical;
+
+	if (found_key.type == BTRFS_IDENTITY_REMAP_KEY)
+		return 0;
+
+	remap = btrfs_item_ptr(leaf, path-&gt;slots[0], struct btrfs_remap_item);
+
+	*logical += btrfs_remap_address(leaf, remap) - found_key.objectid;
+
+	return 0;
+}
+
 /*
  * function to relocate all extents in a block group.
  */
diff --git a/fs/btrfs/relocation.h b/fs/btrfs/relocation.h
index 5c36b3f84b57..b2ba83966650 100644
--- a/fs/btrfs/relocation.h
+++ b/fs/btrfs/relocation.h
@@ -31,5 +31,7 @@ int btrfs_should_cancel_balance(const struct btrfs_fs_info *fs_info);
 struct btrfs_root *find_reloc_root(struct btrfs_fs_info *fs_info, u64 bytenr);
 bool btrfs_should_ignore_reloc_root(const struct btrfs_root *root);
 u64 btrfs_get_reloc_bg_bytenr(const struct btrfs_fs_info *fs_info);
+int btrfs_translate_remap(struct btrfs_fs_info *fs_info, u64 *logical,
+			  u64 *length);
 
 #endif
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index d6060e0e2144..557ce56df800 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -6584,6 +6584,25 @@ int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 	if (IS_ERR(map))
 		return PTR_ERR(map);
 
+	if (map-&gt;type &amp; BTRFS_BLOCK_GROUP_REMAPPED) {
+		u64 new_logical = logical;
+
+		ret = btrfs_translate_remap(fs_info, &amp;new_logical, length);
+		if (ret)
+			return ret;
+
+		if (new_logical != logical) {
+			btrfs_free_chunk_map(map);
+
+			map = btrfs_get_chunk_map(fs_info, new_logical,
+						  *length);
+			if (IS_ERR(map))
+				return PTR_ERR(map);
+
+			logical = new_logical;
+		}
+	}
+
 	num_copies = btrfs_chunk_map_num_copies(map);
 	if (io_geom.mirror_num &gt; num_copies)
 		return -EINVAL;
-- 
2.51.2



---

If we encounter a filesystem with the remap-tree incompat flag set,
valdiate its compatibility with the other flags, and load the remap tree
using the values that have been added to the superblock.

The remap-tree feature depends on the free space tere, but no-holes and
block-group-tree have been made dependencies to reduce the testing
matrix. Similarly I&#x27;m not aware of any reason why mixed-bg and zoned would be
incompatible with remap-tree, but this is blocked for the time being
until it can be fully tested.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/Kconfig                |   2 +
 fs/btrfs/accessors.h            |   6 ++
 fs/btrfs/disk-io.c              | 111 ++++++++++++++++++++++++++++----
 fs/btrfs/extent-tree.c          |   2 +
 fs/btrfs/fs.h                   |   4 +-
 fs/btrfs/transaction.c          |   7 ++
 include/uapi/linux/btrfs_tree.h |   5 +-
 7 files changed, 122 insertions(+), 15 deletions(-)

diff --git a/fs/btrfs/Kconfig b/fs/btrfs/Kconfig
index bf7feff2fe44..ee2fdcb49719 100644
--- a/fs/btrfs/Kconfig
+++ b/fs/btrfs/Kconfig
@@ -115,4 +115,6 @@ config BTRFS_EXPERIMENTAL
 
 	  - large folio support
 
+	  - remap-tree - logical address remapping tree
+
 	  If unsure, say N.
diff --git a/fs/btrfs/accessors.h b/fs/btrfs/accessors.h
index 9797f9e8d4e5..8938357fcb40 100644
--- a/fs/btrfs/accessors.h
+++ b/fs/btrfs/accessors.h
@@ -883,6 +883,12 @@ BTRFS_SETGET_STACK_FUNCS(super_uuid_tree_generation, struct btrfs_super_block,
 			 uuid_tree_generation, 64);
 BTRFS_SETGET_STACK_FUNCS(super_nr_global_roots, struct btrfs_super_block,
 			 nr_global_roots, 64);
+BTRFS_SETGET_STACK_FUNCS(super_remap_root, struct btrfs_super_block,
+			 remap_root, 64);
+BTRFS_SETGET_STACK_FUNCS(super_remap_root_generation, struct btrfs_super_block,
+			 remap_root_generation, 64);
+BTRFS_SETGET_STACK_FUNCS(super_remap_root_level, struct btrfs_super_block,
+			 remap_root_level, 8);
 
 /* struct btrfs_file_extent_item */
 BTRFS_SETGET_STACK_FUNCS(stack_file_extent_type, struct btrfs_file_extent_item,
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index c36367f9017f..b03654ee91f5 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -1158,6 +1158,8 @@ static struct btrfs_root *btrfs_get_global_root(struct btrfs_fs_info *fs_info,
 		return btrfs_grab_root(btrfs_global_root(fs_info, &amp;key));
 	case BTRFS_RAID_STRIPE_TREE_OBJECTID:
 		return btrfs_grab_root(fs_info-&gt;stripe_root);
+	case BTRFS_REMAP_TREE_OBJECTID:
+		return btrfs_grab_root(fs_info-&gt;remap_root);
 	default:
 		return NULL;
 	}
@@ -1248,6 +1250,7 @@ void btrfs_free_fs_info(struct btrfs_fs_info *fs_info)
 	btrfs_put_root(fs_info-&gt;data_reloc_root);
 	btrfs_put_root(fs_info-&gt;block_group_root);
 	btrfs_put_root(fs_info-&gt;stripe_root);
+	btrfs_put_root(fs_info-&gt;remap_root);
 	btrfs_check_leaked_roots(fs_info);
 	btrfs_extent_buffer_leak_debug_check(fs_info);
 	kfree(fs_info-&gt;super_copy);
@@ -1800,6 +1803,7 @@ static void free_root_pointers(struct btrfs_fs_info *info, bool free_chunk_root)
 	free_root_extent_buffers(info-&gt;data_reloc_root);
 	free_root_extent_buffers(info-&gt;block_group_root);
 	free_root_extent_buffers(info-&gt;stripe_root);
+	free_root_extent_buffers(info-&gt;remap_root);
 	if (free_chunk_root)
 		free_root_extent_buffers(info-&gt;chunk_root);
 }
@@ -2213,21 +2217,49 @@ static int btrfs_read_roots(struct btrfs_fs_info *fs_info)
 	if (ret)
 		goto out;
 
-	/*
-	 * This tree can share blocks with some other fs tree during relocation
-	 * and we need a proper setup by btrfs_get_fs_root
-	 */
-	root = btrfs_get_fs_root(tree_root-&gt;fs_info,
-				 BTRFS_DATA_RELOC_TREE_OBJECTID, true);
-	if (IS_ERR(root)) {
-		if (!btrfs_test_opt(fs_info, IGNOREBADROOTS)) {
-			location.objectid = BTRFS_DATA_RELOC_TREE_OBJECTID;
-			ret = PTR_ERR(root);
-			goto out;
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE)) {
+		/*
+		 * The remap_root has already been loaded in
+		 * load_important_roots().
+		 */
+		root = fs_info-&gt;remap_root;
+
+		set_bit(BTRFS_ROOT_TRACK_DIRTY, &amp;root-&gt;state);
+
+		root-&gt;root_key.objectid = BTRFS_REMAP_TREE_OBJECTID;
+		root-&gt;root_key.type = BTRFS_ROOT_ITEM_KEY;
+		root-&gt;root_key.offset = 0;
+
+		/* Check that data reloc tree doesn&#x27;t also exist. */
+		location.objectid = BTRFS_DATA_RELOC_TREE_OBJECTID;
+		root = btrfs_read_tree_root(fs_info-&gt;tree_root, &amp;location);
+		if (!IS_ERR(root)) {
+			btrfs_err(fs_info,
+			   &quot;data reloc tree exists when remap-tree enabled&quot;);
+			btrfs_put_root(root);
+			return -EIO;
+		} else if (PTR_ERR(root) != -ENOENT) {
+			btrfs_warn(fs_info,
+			   &quot;error %ld when checking for data reloc tree&quot;,
+				   PTR_ERR(root));
 		}
 	} else {
-		set_bit(BTRFS_ROOT_TRACK_DIRTY, &amp;root-&gt;state);
-		fs_info-&gt;data_reloc_root = root;
+		/*
+		 * This tree can share blocks with some other fs tree during
+		 * relocation and we need a proper setup by btrfs_get_fs_root().
+		 */
+		root = btrfs_get_fs_root(tree_root-&gt;fs_info,
+					 BTRFS_DATA_RELOC_TREE_OBJECTID, true);
+		if (IS_ERR(root)) {
+			if (!btrfs_test_opt(fs_info, IGNOREBADROOTS)) {
+				location.objectid = BTRFS_DATA_RELOC_TREE_OBJECTID;
+				ret = PTR_ERR(root);
+				goto out;
+			}
+		} else {
+			set_bit(BTRFS_ROOT_TRACK_DIRTY, &amp;root-&gt;state);
+			fs_info-&gt;data_reloc_root = root;
+		}
 	}
 
 	location.objectid = BTRFS_QUOTA_TREE_OBJECTID;
@@ -2467,6 +2499,36 @@ int btrfs_validate_super(const struct btrfs_fs_info *fs_info,
 		ret = -EINVAL;
 	}
 
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE)) {
+		/*
+		 * Reduce test matrix for remap tree by requiring block-group-tree
+		 * and no-holes. Free-space-tree is a hard requirement.
+		 */
+		if (!btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE_VALID) ||
+		    !btrfs_fs_incompat(fs_info, NO_HOLES) ||
+		    !btrfs_fs_compat_ro(fs_info, BLOCK_GROUP_TREE)) {
+			btrfs_err(fs_info,
+&quot;remap-tree feature requires free-space-tree, no-holes, and block-group-tree&quot;);
+			ret = -EINVAL;
+		}
+
+		if (btrfs_fs_incompat(fs_info, MIXED_GROUPS)) {
+			btrfs_err(fs_info, &quot;remap-tree not supported with mixed-bg&quot;);
+			ret = -EINVAL;
+		}
+
+		if (btrfs_fs_incompat(fs_info, ZONED)) {
+			btrfs_err(fs_info, &quot;remap-tree not supported with zoned devices&quot;);
+			ret = -EINVAL;
+		}
+
+		if (sectorsize &gt; PAGE_SIZE) {
+			btrfs_err(fs_info,
+				  &quot;remap-tree not supported when block size &gt; page size&quot;);
+			ret = -EINVAL;
+		}
+	}
+
 	/*
 	 * Hint to catch really bogus numbers, bitflips or so, more exact checks are
 	 * done later
@@ -2625,6 +2687,18 @@ static int load_important_roots(struct btrfs_fs_info *fs_info)
 		btrfs_warn(fs_info, &quot;couldn&#x27;t read tree root&quot;);
 		return ret;
 	}
+
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE)) {
+		bytenr = btrfs_super_remap_root(sb);
+		gen = btrfs_super_remap_root_generation(sb);
+		level = btrfs_super_remap_root_level(sb);
+		ret = load_super_root(fs_info-&gt;remap_root, bytenr, gen, level);
+		if (ret) {
+			btrfs_warn(fs_info, &quot;couldn&#x27;t read remap root&quot;);
+			return ret;
+		}
+	}
+
 	return 0;
 }
 
@@ -3245,6 +3319,7 @@ int __cold open_ctree(struct super_block *sb, struct btrfs_fs_devices *fs_device
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_root *tree_root;
 	struct btrfs_root *chunk_root;
+	struct btrfs_root *remap_root;
 	int ret;
 	int level;
 
@@ -3375,6 +3450,16 @@ int __cold open_ctree(struct super_block *sb, struct btrfs_fs_devices *fs_device
 	if (ret &lt; 0)
 		goto fail_alloc;
 
+	if (btrfs_super_incompat_flags(disk_super) &amp; BTRFS_FEATURE_INCOMPAT_REMAP_TREE) {
+		remap_root = btrfs_alloc_root(fs_info, BTRFS_REMAP_TREE_OBJECTID,
+					      GFP_KERNEL);
+		fs_info-&gt;remap_root = remap_root;
+		if (!remap_root) {
+			ret = -ENOMEM;
+			goto fail_alloc;
+		}
+	}
+
 	/*
 	 * At this point our mount options are validated, if we set -&gt;max_inline
 	 * to something non-standard make sure we truncate it to sectorsize.
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 43473a6d91d7..3868a295be62 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -2589,6 +2589,8 @@ static u64 get_alloc_profile_by_root(struct btrfs_root *root, int data)
 		flags = BTRFS_BLOCK_GROUP_DATA;
 	else if (root == fs_info-&gt;chunk_root)
 		flags = BTRFS_BLOCK_GROUP_SYSTEM;
+	else if (root == fs_info-&gt;remap_root)
+		flags = BTRFS_BLOCK_GROUP_METADATA_REMAP;
 	else
 		flags = BTRFS_BLOCK_GROUP_METADATA;
 
diff --git a/fs/btrfs/fs.h b/fs/btrfs/fs.h
index 46c4f1dcec47..af11f2ce310a 100644
--- a/fs/btrfs/fs.h
+++ b/fs/btrfs/fs.h
@@ -307,7 +307,8 @@ enum {
 #define BTRFS_FEATURE_INCOMPAT_SUPP		\
 	(BTRFS_FEATURE_INCOMPAT_SUPP_STABLE |	\
 	 BTRFS_FEATURE_INCOMPAT_RAID_STRIPE_TREE | \
-	 BTRFS_FEATURE_INCOMPAT_EXTENT_TREE_V2)
+	 BTRFS_FEATURE_INCOMPAT_EXTENT_TREE_V2 | \
+	 BTRFS_FEATURE_INCOMPAT_REMAP_TREE)
 
 #else
 
@@ -467,6 +468,7 @@ struct btrfs_fs_info {
 	struct btrfs_root *data_reloc_root;
 	struct btrfs_root *block_group_root;
 	struct btrfs_root *stripe_root;
+	struct btrfs_root *remap_root;
 
 	/* The log root tree is a directory of all the other log roots */
 	struct btrfs_root *log_root_tree;
diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c
index e2f993b1783f..f4cc9e1a1b93 100644
--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@ -1967,6 +1967,13 @@ static void update_super_roots(struct btrfs_fs_info *fs_info)
 		super-&gt;cache_generation = 0;
 	if (test_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &amp;fs_info-&gt;flags))
 		super-&gt;uuid_tree_generation = root_item-&gt;generation;
+
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE)) {
+		root_item = &amp;fs_info-&gt;remap_root-&gt;root_item;
+		super-&gt;remap_root = root_item-&gt;bytenr;
+		super-&gt;remap_root_generation = root_item-&gt;generation;
+		super-&gt;remap_root_level = root_item-&gt;level;
+	}
 }
 
 int btrfs_transaction_blocked(struct btrfs_fs_info *info)
diff --git a/include/uapi/linux/btrfs_tree.h b/include/uapi/linux/btrfs_tree.h
index 86820a9644e8..f7843e6bb978 100644
--- a/include/uapi/linux/btrfs_tree.h
+++ b/include/uapi/linux/btrfs_tree.h
@@ -721,9 +721,12 @@ struct btrfs_super_block {
 	__u8 metadata_uuid[BTRFS_FSID_SIZE];
 
 	__u64 nr_global_roots;
+	__le64 remap_root;
+	__le64 remap_root_generation;
+	__u8 remap_root_level;
 
 	/* Future expansion */
-	__le64 reserved[27];
+	__u8 reserved[199];
 	__u8 sys_chunk_array[BTRFS_SYSTEM_CHUNK_ARRAY_SIZE];
 	struct btrfs_root_backup super_roots[BTRFS_NUM_BACKUP_ROOTS];
 
-- 
2.51.2



---

Rename the field commit_used in struct btrfs_block_group to last_used,
for clarity and consistency with the similar fields we&#x27;re about to add.
It&#x27;s not obvious that commit_flags means &quot;flags as of the last commit&quot;
rather than &quot;flags related to a commit&quot;.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
---
 fs/btrfs/block-group.c | 24 ++++++++++++------------
 fs/btrfs/block-group.h |  4 ++--
 2 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.c
index 39e2db630bce..822c5306a7a4 100644
--- a/fs/btrfs/block-group.c
+++ b/fs/btrfs/block-group.c
@@ -2388,7 +2388,7 @@ static int read_one_block_group(struct btrfs_fs_info *info,
 
 	cache-&gt;length = key-&gt;offset;
 	cache-&gt;used = btrfs_stack_block_group_used(bgi);
-	cache-&gt;commit_used = cache-&gt;used;
+	cache-&gt;last_used = cache-&gt;used;
 	cache-&gt;flags = btrfs_stack_block_group_flags(bgi);
 	cache-&gt;global_root_id = btrfs_stack_block_group_chunk_objectid(bgi);
 	cache-&gt;space_info = btrfs_find_space_info(info, cache-&gt;flags);
@@ -2667,7 +2667,7 @@ static int insert_block_group_item(struct btrfs_trans_handle *trans,
 	struct btrfs_block_group_item bgi;
 	struct btrfs_root *root = btrfs_block_group_root(fs_info);
 	struct btrfs_key key;
-	u64 old_commit_used;
+	u64 old_last_used;
 	int ret;
 
 	spin_lock(&amp;block_group-&gt;lock);
@@ -2675,8 +2675,8 @@ static int insert_block_group_item(struct btrfs_trans_handle *trans,
 	btrfs_set_stack_block_group_chunk_objectid(&amp;bgi,
 						   block_group-&gt;global_root_id);
 	btrfs_set_stack_block_group_flags(&amp;bgi, block_group-&gt;flags);
-	old_commit_used = block_group-&gt;commit_used;
-	block_group-&gt;commit_used = block_group-&gt;used;
+	old_last_used = block_group-&gt;last_used;
+	block_group-&gt;last_used = block_group-&gt;used;
 	key.objectid = block_group-&gt;start;
 	key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;
 	key.offset = block_group-&gt;length;
@@ -2685,7 +2685,7 @@ static int insert_block_group_item(struct btrfs_trans_handle *trans,
 	ret = btrfs_insert_item(trans, root, &amp;key, &amp;bgi, sizeof(bgi));
 	if (ret &lt; 0) {
 		spin_lock(&amp;block_group-&gt;lock);
-		block_group-&gt;commit_used = old_commit_used;
+		block_group-&gt;last_used = old_last_used;
 		spin_unlock(&amp;block_group-&gt;lock);
 	}
 
@@ -3139,7 +3139,7 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 	struct extent_buffer *leaf;
 	struct btrfs_block_group_item bgi;
 	struct btrfs_key key;
-	u64 old_commit_used;
+	u64 old_last_used;
 	u64 used;
 
 	/*
@@ -3149,14 +3149,14 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 	 * may be changed.
 	 */
 	spin_lock(&amp;cache-&gt;lock);
-	old_commit_used = cache-&gt;commit_used;
+	old_last_used = cache-&gt;last_used;
 	used = cache-&gt;used;
 	/* No change in used bytes, can safely skip it. */
-	if (cache-&gt;commit_used == used) {
+	if (cache-&gt;last_used == used) {
 		spin_unlock(&amp;cache-&gt;lock);
 		return 0;
 	}
-	cache-&gt;commit_used = used;
+	cache-&gt;last_used = used;
 	spin_unlock(&amp;cache-&gt;lock);
 
 	key.objectid = cache-&gt;start;
@@ -3180,17 +3180,17 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 fail:
 	btrfs_release_path(path);
 	/*
-	 * We didn&#x27;t update the block group item, need to revert commit_used
+	 * We didn&#x27;t update the block group item, need to revert last_used
 	 * unless the block group item didn&#x27;t exist yet - this is to prevent a
 	 * race with a concurrent insertion of the block group item, with
 	 * insert_block_group_item(), that happened just after we attempted to
-	 * update. In that case we would reset commit_used to 0 just after the
+	 * update. In that case we would reset last_used to 0 just after the
 	 * insertion set it to a value greater than 0 - if the block group later
 	 * becomes with 0 used bytes, we would incorrectly skip its update.
 	 */
 	if (ret &lt; 0 &amp;&amp; ret != -ENOENT) {
 		spin_lock(&amp;cache-&gt;lock);
-		cache-&gt;commit_used = old_commit_used;
+		cache-&gt;last_used = old_last_used;
 		spin_unlock(&amp;cache-&gt;lock);
 	}
 	return ret;
diff --git a/fs/btrfs/block-group.h b/fs/btrfs/block-group.h
index 5f933455118c..01401e9959c1 100644
--- a/fs/btrfs/block-group.h
+++ b/fs/btrfs/block-group.h
@@ -132,10 +132,10 @@ struct btrfs_block_group {
 
 	/*
 	 * The last committed used bytes of this block group, if the above @used
-	 * is still the same as @commit_used, we don&#x27;t need to update block
+	 * is still the same as @last_used, we don&#x27;t need to update block
 	 * group item of this block group.
 	 */
-	u64 commit_used;
+	u64 last_used;
 	/*
 	 * If the free space extent count exceeds this number, convert the block
 	 * group to bitmaps.
-- 
2.51.2



---

btrfs_discard_extent() can be called either when an extent is removed
or from walking the free-space tree. With a remapped block group these
two things are no longer equivalent: the extent&#x27;s addresses are
remapped, while the free-space tree exclusively uses underlying
addresses.

Add a do_remap parameter to btrfs_discard_extent() and
btrfs_map_discard(), saying whether or not the address needs to be run
through the remap tree first.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/extent-tree.c      | 11 +++++++----
 fs/btrfs/extent-tree.h      |  2 +-
 fs/btrfs/free-space-cache.c |  2 +-
 fs/btrfs/inode.c            |  2 +-
 fs/btrfs/volumes.c          | 23 +++++++++++++++++++++--
 fs/btrfs/volumes.h          |  2 +-
 6 files changed, 32 insertions(+), 10 deletions(-)

diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 70020ba8ef92..9d68f3fa4fa9 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -1381,7 +1381,7 @@ static int do_discard_extent(struct btrfs_discard_stripe *stripe, u64 *bytes)
 }
 
 int btrfs_discard_extent(struct btrfs_fs_info *fs_info, u64 bytenr,
-			 u64 num_bytes, u64 *actual_bytes)
+			 u64 num_bytes, u64 *actual_bytes, bool do_remap)
 {
 	int ret = 0;
 	u64 discarded_bytes = 0;
@@ -1399,7 +1399,8 @@ int btrfs_discard_extent(struct btrfs_fs_info *fs_info, u64 bytenr,
 		int i;
 
 		num_bytes = end - cur;
-		stripes = btrfs_map_discard(fs_info, cur, &amp;num_bytes, &amp;num_stripes);
+		stripes = btrfs_map_discard(fs_info, cur, &amp;num_bytes,
+					    &amp;num_stripes, do_remap);
 		if (IS_ERR(stripes)) {
 			ret = PTR_ERR(stripes);
 			if (ret == -EOPNOTSUPP)
@@ -2932,7 +2933,8 @@ int btrfs_finish_extent_commit(struct btrfs_trans_handle *trans)
 
 		if (btrfs_test_opt(fs_info, DISCARD_SYNC))
 			ret = btrfs_discard_extent(fs_info, start,
-						   end + 1 - start, NULL);
+						   end + 1 - start, NULL,
+						   true);
 
 		next_state = btrfs_next_extent_state(unpin, cached_state);
 		btrfs_clear_extent_dirty(unpin, start, end, &amp;cached_state);
@@ -2990,7 +2992,8 @@ int btrfs_finish_extent_commit(struct btrfs_trans_handle *trans)
 		ret = -EROFS;
 		if (!TRANS_ABORTED(trans))
 			ret = btrfs_discard_extent(fs_info, block_group-&gt;start,
-						   block_group-&gt;length, NULL);
+						   block_group-&gt;length, NULL,
+						   true);
 
 		/*
 		 * Not strictly necessary to lock, as the block_group should be
diff --git a/fs/btrfs/extent-tree.h b/fs/btrfs/extent-tree.h
index d7b6aeb63656..ff330d4896d6 100644
--- a/fs/btrfs/extent-tree.h
+++ b/fs/btrfs/extent-tree.h
@@ -161,7 +161,7 @@ int btrfs_drop_subtree(struct btrfs_trans_handle *trans,
 			struct extent_buffer *parent);
 void btrfs_error_unpin_extent_range(struct btrfs_fs_info *fs_info, u64 start, u64 end);
 int btrfs_discard_extent(struct btrfs_fs_info *fs_info, u64 bytenr,
-			 u64 num_bytes, u64 *actual_bytes);
+			 u64 num_bytes, u64 *actual_bytes, bool do_remap);
 int btrfs_trim_fs(struct btrfs_fs_info *fs_info, struct fstrim_range *range);
 void btrfs_handle_fully_remapped_bgs(struct btrfs_fs_info *fs_info);
 int btrfs_complete_bg_remapping(struct btrfs_block_group *bg);
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index 8d4db3d57cf7..17e79ee3e021 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -3677,7 +3677,7 @@ static int do_trimming(struct btrfs_block_group *block_group,
 	}
 	spin_unlock(&amp;space_info-&gt;lock);
 
-	ret = btrfs_discard_extent(fs_info, start, bytes, &amp;trimmed);
+	ret = btrfs_discard_extent(fs_info, start, bytes, &amp;trimmed, false);
 	if (!ret) {
 		*total_trimmed += trimmed;
 		trim_state = BTRFS_TRIM_STATE_TRIMMED;
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 247b373bf5cf..3915e08d252c 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -3370,7 +3370,7 @@ int btrfs_finish_one_ordered(struct btrfs_ordered_extent *ordered_extent)
 				btrfs_discard_extent(fs_info,
 						ordered_extent-&gt;disk_bytenr,
 						ordered_extent-&gt;disk_num_bytes,
-						NULL);
+						NULL, true);
 			btrfs_free_reserved_extent(fs_info,
 					ordered_extent-&gt;disk_bytenr,
 					ordered_extent-&gt;disk_num_bytes, true);
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index caffee6527b2..b0aef4d489e7 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -3425,7 +3425,7 @@ static int btrfs_relocate_chunk_finish(struct btrfs_fs_info *fs_info,
 	 */
 	if (btrfs_is_zoned(fs_info)) {
 		ret = btrfs_discard_extent(fs_info, bg-&gt;start, length,
-					   NULL);
+					   NULL, true);
 		if (ret)
 			btrfs_info(fs_info,
 				   &quot;failed to reset zone %llu after relocation&quot;,
@@ -6111,7 +6111,7 @@ void btrfs_put_bioc(struct btrfs_io_context *bioc)
  */
 struct btrfs_discard_stripe *btrfs_map_discard(struct btrfs_fs_info *fs_info,
 					       u64 logical, u64 *length_ret,
-					       u32 *num_stripes)
+					       u32 *num_stripes, bool do_remap)
 {
 	struct btrfs_chunk_map *map;
 	struct btrfs_discard_stripe *stripes;
@@ -6135,6 +6135,25 @@ struct btrfs_discard_stripe *btrfs_map_discard(struct btrfs_fs_info *fs_info,
 	if (IS_ERR(map))
 		return ERR_CAST(map);
 
+	if (do_remap &amp;&amp; map-&gt;type &amp; BTRFS_BLOCK_GROUP_REMAPPED) {
+		u64 new_logical = logical;
+
+		ret = btrfs_translate_remap(fs_info, &amp;new_logical, &amp;length);
+		if (ret)
+			goto out_free_map;
+
+		if (new_logical != logical) {
+			btrfs_free_chunk_map(map);
+
+			map = btrfs_get_chunk_map(fs_info, new_logical,
+						  length);
+			if (IS_ERR(map))
+				return ERR_CAST(map);
+
+			logical = new_logical;
+		}
+	}
+
 	/* we don&#x27;t discard raid56 yet */
 	if (map-&gt;type &amp; BTRFS_BLOCK_GROUP_RAID56_MASK) {
 		ret = -EOPNOTSUPP;
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index ccf0a459180d..505a50689fb0 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -732,7 +732,7 @@ int btrfs_map_repair_block(struct btrfs_fs_info *fs_info,
 			   u32 length, int mirror_num);
 struct btrfs_discard_stripe *btrfs_map_discard(struct btrfs_fs_info *fs_info,
 					       u64 logical, u64 *length_ret,
-					       u32 *num_stripes);
+					       u32 *num_stripes, bool do_remap);
 int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 struct btrfs_block_group *btrfs_create_chunk(struct btrfs_trans_handle *trans,
-- 
2.51.2



---

Add a function do_remap_tree_reloc(), which does the actual work of
doing a relocation using the remap tree.

In a loop we call do_remap_reloc_trans(), which searches for the first
identity remap for the block group. We call btrfs_reserve_extent() to
find space elsewhere for it, and read the data into memory and write it
to the new location. We then carve out the identity remap and replace it
with an actual remap, which points to the new location in which to look.

Once the last identity remap has been removed we call
last_identity_remap_gone(), which, as with deletions, removes the
chunk&#x27;s stripes and device extents.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/relocation.c | 337 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 337 insertions(+)

diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 82f0e15f0f84..20cf0f7fd401 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -4633,6 +4633,61 @@ static int create_remap_tree_entries(struct btrfs_trans_handle *trans,
 	return ret;
 }
 
+static int find_next_identity_remap(struct btrfs_trans_handle *trans,
+				    struct btrfs_path *path, u64 bg_end,
+				    u64 last_start, u64 *start,
+				    u64 *length)
+{
+	int ret;
+	struct btrfs_key key, found_key;
+	struct btrfs_root *remap_root = trans-&gt;fs_info-&gt;remap_root;
+	struct extent_buffer *leaf;
+
+	key.objectid = last_start;
+	key.type = BTRFS_IDENTITY_REMAP_KEY;
+	key.offset = 0;
+
+	ret = btrfs_search_slot(trans, remap_root, &amp;key, path, 0, 0);
+	if (ret &lt; 0)
+		goto out;
+
+	leaf = path-&gt;nodes[0];
+	while (true) {
+		if (path-&gt;slots[0] &gt;= btrfs_header_nritems(leaf)) {
+			ret = btrfs_next_leaf(remap_root, path);
+
+			if (ret != 0) {
+				if (ret == 1)
+					ret = -ENOENT;
+				goto out;
+			}
+
+			leaf = path-&gt;nodes[0];
+		}
+
+		btrfs_item_key_to_cpu(leaf, &amp;found_key, path-&gt;slots[0]);
+
+		if (found_key.objectid &gt;= bg_end) {
+			ret = -ENOENT;
+			goto out;
+		}
+
+		if (found_key.type == BTRFS_IDENTITY_REMAP_KEY) {
+			*start = found_key.objectid;
+			*length = found_key.offset;
+			ret = 0;
+			goto out;
+		}
+
+		path-&gt;slots[0]++;
+	}
+
+out:
+	btrfs_release_path(path);
+
+	return ret;
+}
+
 static int remove_chunk_stripes(struct btrfs_trans_handle *trans,
 				struct btrfs_chunk_map *chunk_map,
 				struct btrfs_path *path)
@@ -4779,6 +4834,96 @@ static void adjust_identity_remap_count(struct btrfs_trans_handle *trans,
 		btrfs_mark_bg_fully_remapped(bg, trans);
 }
 
+static int add_remap_entry(struct btrfs_trans_handle *trans,
+			   struct btrfs_path *path,
+			   struct btrfs_block_group *src_bg, u64 old_addr,
+			   u64 new_addr, u64 length)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_key key, new_key;
+	int ret;
+	int identity_count_delta = 0;
+
+	key.objectid = old_addr;
+	key.type = (u8)-1;
+	key.offset = (u64)-1;
+
+	ret = btrfs_search_slot(trans, fs_info-&gt;remap_root, &amp;key, path, -1, 1);
+	if (ret &lt; 0)
+		goto end;
+
+	if (path-&gt;slots[0] == 0) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	path-&gt;slots[0]--;
+
+	btrfs_item_key_to_cpu(path-&gt;nodes[0], &amp;key, path-&gt;slots[0]);
+
+	if (key.type != BTRFS_IDENTITY_REMAP_KEY ||
+	    key.objectid &gt; old_addr ||
+	    key.objectid + key.offset &lt;= old_addr) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	/* Shorten or delete identity mapping entry. */
+
+	if (key.objectid == old_addr) {
+		ret = btrfs_del_item(trans, fs_info-&gt;remap_root, path);
+		if (ret)
+			goto end;
+
+		identity_count_delta--;
+	} else {
+		new_key.objectid = key.objectid;
+		new_key.type = BTRFS_IDENTITY_REMAP_KEY;
+		new_key.offset = old_addr - key.objectid;
+
+		btrfs_set_item_key_safe(trans, path, &amp;new_key);
+	}
+
+	btrfs_release_path(path);
+
+	/* Create new remap entry. */
+
+	ret = add_remap_item(trans, path, new_addr, length, old_addr);
+	if (ret)
+		goto end;
+
+	/* Add entry for remainder of identity mapping, if necessary. */
+
+	if (key.objectid + key.offset != old_addr + length) {
+		new_key.objectid = old_addr + length;
+		new_key.type = BTRFS_IDENTITY_REMAP_KEY;
+		new_key.offset = key.objectid + key.offset - old_addr - length;
+
+		ret = btrfs_insert_empty_item(trans, fs_info-&gt;remap_root,
+					      path, &amp;new_key, 0);
+		if (ret)
+			goto end;
+
+		btrfs_release_path(path);
+
+		identity_count_delta++;
+	}
+
+	/* Add backref. */
+
+	ret = add_remap_backref_item(trans, path, new_addr, length, old_addr);
+	if (ret)
+		goto end;
+
+	if (identity_count_delta != 0)
+		adjust_identity_remap_count(trans, src_bg, identity_count_delta);
+
+end:
+	btrfs_release_path(path);
+
+	return ret;
+}
+
 static int mark_chunk_remapped(struct btrfs_trans_handle *trans,
 			       struct btrfs_path *path, uint64_t start)
 {
@@ -4828,6 +4973,190 @@ static int mark_chunk_remapped(struct btrfs_trans_handle *trans,
 	return ret;
 }
 
+static int do_remap_reloc_trans(struct btrfs_fs_info *fs_info,
+				struct btrfs_block_group *src_bg,
+				struct btrfs_path *path, u64 *last_start)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *extent_root;
+	struct btrfs_key ins;
+	struct btrfs_block_group *dest_bg = NULL;
+	u64 start, remap_length, length, new_addr, min_size;
+	int ret;
+	bool no_more = false;
+	bool is_data = src_bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_DATA;
+	bool made_reservation = false, bg_needs_free_space;
+	struct btrfs_space_info *sinfo = src_bg-&gt;space_info;
+
+	extent_root = btrfs_extent_root(fs_info, src_bg-&gt;start);
+
+	trans = btrfs_start_transaction(extent_root, 0);
+	if (IS_ERR(trans))
+		return PTR_ERR(trans);
+
+	mutex_lock(&amp;fs_info-&gt;remap_mutex);
+
+	ret = find_next_identity_remap(trans, path, src_bg-&gt;start + src_bg-&gt;length,
+				       *last_start, &amp;start, &amp;remap_length);
+	if (ret == -ENOENT) {
+		no_more = true;
+		goto next;
+	} else if (ret) {
+		mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+		btrfs_end_transaction(trans);
+		return ret;
+	}
+
+	/* Try to reserve enough space for block. */
+
+	spin_lock(&amp;sinfo-&gt;lock);
+	btrfs_space_info_update_bytes_may_use(sinfo, remap_length);
+	spin_unlock(&amp;sinfo-&gt;lock);
+
+	if (is_data)
+		min_size = fs_info-&gt;sectorsize;
+	else
+		min_size = fs_info-&gt;nodesize;
+
+	/*
+	 * We&#x27;re using btrfs_reserve_extent() to allocate a contiguous
+	 * logical address range, but this will become a remap item rather than
+	 * an extent in the extent tree.
+	 *
+	 * Short allocations are fine: it means that we chop off the beginning
+	 * of the identity remap that we&#x27;re processing, and will tackle the
+	 * rest of it the next time round.
+	 */
+	ret = btrfs_reserve_extent(fs_info-&gt;fs_root, remap_length,
+				   remap_length, min_size,
+				   0, 0, &amp;ins, is_data, false);
+	if (ret) {
+		spin_lock(&amp;sinfo-&gt;lock);
+		btrfs_space_info_update_bytes_may_use(sinfo, -remap_length);
+		spin_unlock(&amp;sinfo-&gt;lock);
+
+		mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+		btrfs_end_transaction(trans);
+		return ret;
+	}
+
+	made_reservation = true;
+
+	new_addr = ins.objectid;
+	length = ins.offset;
+
+	if (!is_data &amp;&amp; !IS_ALIGNED(length, fs_info-&gt;nodesize)) {
+		u64 new_length = ALIGN_DOWN(length, fs_info-&gt;nodesize);
+
+		btrfs_free_reserved_extent(fs_info, new_addr + new_length,
+					   length - new_length, 0);
+
+		length = new_length;
+	}
+
+	dest_bg = btrfs_lookup_block_group(fs_info, new_addr);
+
+	mutex_lock(&amp;dest_bg-&gt;free_space_lock);
+	bg_needs_free_space = test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE,
+				       &amp;dest_bg-&gt;runtime_flags);
+	mutex_unlock(&amp;dest_bg-&gt;free_space_lock);
+
+	if (bg_needs_free_space) {
+		ret = btrfs_add_block_group_free_space(trans, dest_bg);
+		if (ret)
+			goto fail;
+	}
+
+	ret = copy_remapped_data(fs_info, start, new_addr, length);
+	if (ret)
+		goto fail;
+
+	ret = btrfs_remove_from_free_space_tree(trans, new_addr, length);
+	if (ret)
+		goto fail;
+
+	ret = add_remap_entry(trans, path, src_bg, start, new_addr, length);
+	if (ret) {
+		btrfs_add_to_free_space_tree(trans, new_addr, length);
+		goto fail;
+	}
+
+	adjust_block_group_remap_bytes(trans, dest_bg, length);
+	btrfs_free_reserved_bytes(dest_bg, length, 0);
+
+	spin_lock(&amp;sinfo-&gt;lock);
+	sinfo-&gt;bytes_readonly += length;
+	spin_unlock(&amp;sinfo-&gt;lock);
+
+next:
+	if (dest_bg)
+		btrfs_put_block_group(dest_bg);
+
+	if (made_reservation)
+		btrfs_dec_block_group_reservations(fs_info, new_addr);
+
+	mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+
+	if (src_bg-&gt;identity_remap_count == 0) {
+		bool mark_fully_remapped = false;
+
+		spin_lock(&amp;src_bg-&gt;lock);
+
+		if (!test_bit(BLOCK_GROUP_FLAG_FULLY_REMAPPED, &amp;src_bg-&gt;runtime_flags)) {
+			mark_fully_remapped = true;
+			set_bit(BLOCK_GROUP_FLAG_FULLY_REMAPPED,
+				&amp;src_bg-&gt;runtime_flags);
+		}
+
+		spin_unlock(&amp;src_bg-&gt;lock);
+
+		if (mark_fully_remapped)
+			btrfs_mark_bg_fully_remapped(src_bg, trans);
+	}
+
+	ret = btrfs_end_transaction(trans);
+	if (ret)
+		return ret;
+
+	if (no_more)
+		return 1;
+
+	*last_start = start;
+
+	return 0;
+
+fail:
+	if (dest_bg)
+		btrfs_put_block_group(dest_bg);
+
+	btrfs_free_reserved_extent(fs_info, new_addr, length, 0);
+
+	mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+	btrfs_end_transaction(trans);
+
+	return ret;
+}
+
+static int do_remap_reloc(struct btrfs_fs_info *fs_info,
+			  struct btrfs_path *path, struct btrfs_block_group *bg)
+{
+	u64 last_start;
+	int ret;
+
+	last_start = bg-&gt;start;
+
+	while (true) {
+		ret = do_remap_reloc_trans(fs_info, bg, path, &amp;last_start);
+		if (ret) {
+			if (ret == 1)
+				ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
 int btrfs_translate_remap(struct btrfs_fs_info *fs_info, u64 *logical,
 			  u64 *length)
 {
@@ -5121,6 +5450,14 @@ int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start,
 		}
 
 		ret = start_block_group_remapping(fs_info, path, bg);
+		if (ret)
+			goto out;
+
+		ret = do_remap_reloc(fs_info, path, rc-&gt;block_group);
+		if (ret)
+			goto out;
+
+		btrfs_delete_unused_bgs(fs_info);
 	} else {
 		ret = do_nonremap_reloc(fs_info, verbose, rc);
 	}
-- 
2.51.2



---

There is the following potential problem with the remap tree and delayed refs:

* Remapped extent freed in a delayed ref, which removes an entry from the
  remap tree
* Remap tree now small enough to fit in a single leaf
* Corruption as we now have a level-0 block with a level-1 metadata item
  in the extent tree

One solution to this would be to rework the remap tree code so that it operates
via delayed refs. But as we&#x27;re hoping to remove cow-only metadata items in the
future anyway, change things so that the remap tree doesn&#x27;t have any entries in
the extent tree. This also has the benefit of reducing write amplification.

We also make it so that the clear_cache mount option is a no-op, as with the
extent tree v2, as the free-space tree can no longer be recreated from the
extent tree.

Finally disable relocating the remap tree itself, which is added back in
a later patch. As it is we would get corruption as the traditional
relocation method walks the extent tree, and we&#x27;re removing its metadata
items.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/disk-io.c     |  3 +++
 fs/btrfs/extent-tree.c | 31 ++++++++++++++++++++++++++++++-
 fs/btrfs/volumes.c     |  3 +++
 3 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index cbfb7127b528..c36367f9017f 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -3007,6 +3007,9 @@ int btrfs_start_pre_rw_mount(struct btrfs_fs_info *fs_info)
 		if (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2))
 			btrfs_warn(fs_info,
 				   &quot;&#x27;clear_cache&#x27; option is ignored with extent tree v2&quot;);
+		else if (btrfs_fs_incompat(fs_info, REMAP_TREE))
+			btrfs_warn(fs_info,
+				   &quot;&#x27;clear_cache&#x27; option is ignored with remap tree&quot;);
 		else
 			rebuild_free_space_tree = true;
 	} else if (btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE) &amp;&amp;
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 1dcd69fe97ed..43473a6d91d7 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -1553,6 +1553,28 @@ static void free_head_ref_squota_rsv(struct btrfs_fs_info *fs_info,
 				  BTRFS_QGROUP_RSV_DATA);
 }
 
+static int drop_remap_tree_ref(struct btrfs_trans_handle *trans,
+			       const struct btrfs_delayed_ref_node *node)
+{
+	u64 bytenr = node-&gt;bytenr;
+	u64 num_bytes = node-&gt;num_bytes;
+	int ret;
+
+	ret = btrfs_add_to_free_space_tree(trans, bytenr, num_bytes);
+	if (unlikely(ret)) {
+		btrfs_abort_transaction(trans, ret);
+		return ret;
+	}
+
+	ret = btrfs_update_block_group(trans, bytenr, num_bytes, false);
+	if (unlikely(ret)) {
+		btrfs_abort_transaction(trans, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
 static int run_delayed_data_ref(struct btrfs_trans_handle *trans,
 				struct btrfs_delayed_ref_head *href,
 				const struct btrfs_delayed_ref_node *node,
@@ -1747,7 +1769,10 @@ static int run_delayed_tree_ref(struct btrfs_trans_handle *trans,
 	} else if (node-&gt;action == BTRFS_ADD_DELAYED_REF) {
 		ret = __btrfs_inc_extent_ref(trans, node, extent_op);
 	} else if (node-&gt;action == BTRFS_DROP_DELAYED_REF) {
-		ret = __btrfs_free_extent(trans, href, node, extent_op);
+		if (node-&gt;ref_root == BTRFS_REMAP_TREE_OBJECTID)
+			ret = drop_remap_tree_ref(trans, node);
+		else
+			ret = __btrfs_free_extent(trans, href, node, extent_op);
 	} else {
 		BUG();
 	}
@@ -4886,6 +4911,9 @@ static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,
 	int level = btrfs_delayed_ref_owner(node);
 	bool skinny_metadata = btrfs_fs_incompat(fs_info, SKINNY_METADATA);
 
+	if (unlikely(node-&gt;ref_root == BTRFS_REMAP_TREE_OBJECTID))
+		goto skip;
+
 	extent_key.objectid = node-&gt;bytenr;
 	if (skinny_metadata) {
 		/* The owner of a tree block is the level. */
@@ -4938,6 +4966,7 @@ static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,
 
 	btrfs_free_path(path);
 
+skip:
 	return alloc_reserved_extent(trans, node-&gt;bytenr, fs_info-&gt;nodesize);
 }
 
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 070efac46a81..d6060e0e2144 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -3970,6 +3970,9 @@ static bool should_balance_chunk(struct extent_buffer *leaf, struct btrfs_chunk
 	struct btrfs_balance_args *bargs = NULL;
 	u64 chunk_type = btrfs_chunk_type(leaf, chunk);
 
+	if (chunk_type &amp; BTRFS_BLOCK_GROUP_METADATA_REMAP)
+		return false;
+
 	/* type filter */
 	if (!((chunk_type &amp; BTRFS_BLOCK_GROUP_TYPE_MASK) &amp;
 	      (bctl-&gt;flags &amp; BTRFS_BALANCE_TYPE_MASK))) {
-- 
2.51.2



---

Handle the case where we free an extent from a block group that has the
REMAPPED flag set. Because the remap tree is orthogonal to the extent
tree, for data this may be within any number of identity remaps or
actual remaps. If we&#x27;re freeing a metadata node, this will be wholly
inside one or the other.

btrfs_remove_extent_from_remap_tree() searches the remap tree for the
remaps that cover the range in question, then calls
remove_range_from_remap_tree() for each one, to punch a hole in the
remap and adjust the free-space tree.

For an identity remap, remove_range_from_remap_tree() will adjust the
block group&#x27;s `identity_remap_count` if this changes. If it reaches
zero we mark the block group as fully remapped.

For an identity remap, remove_range_from_remap_tree() will adjust the
block group&#x27;s `identity_remap_count` if this changes. If it reaches
zero we mark the block group as fully remapped.

Fully remapped block groups have their chunk stripes removed and their
device extents freed, which makes the disk space available again to the
chunk allocator. This happens asynchronously: in the cleaner thread for
sync discard and nodiscard, and (in a later patch) in the discard worker
for async discard.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/block-group.c |  98 ++++++---
 fs/btrfs/block-group.h |   4 +
 fs/btrfs/disk-io.c     |   6 +
 fs/btrfs/extent-tree.c |  98 ++++++++-
 fs/btrfs/extent-tree.h |   2 +
 fs/btrfs/fs.h          |   4 +-
 fs/btrfs/relocation.c  | 453 +++++++++++++++++++++++++++++++++++++++++
 fs/btrfs/relocation.h  |   5 +
 fs/btrfs/volumes.c     |  57 ++++--
 fs/btrfs/volumes.h     |   6 +
 10 files changed, 678 insertions(+), 55 deletions(-)

diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.c
index 4962d17a175e..0143b0290a72 100644
--- a/fs/btrfs/block-group.c
+++ b/fs/btrfs/block-group.c
@@ -1067,6 +1067,29 @@ static int remove_block_group_item(struct btrfs_trans_handle *trans,
 	return btrfs_del_item(trans, root, path);
 }
 
+void btrfs_remove_bg_from_sinfo(struct btrfs_block_group *bg)
+{
+	int factor = btrfs_bg_type_to_factor(bg-&gt;flags);
+
+	spin_lock(&amp;bg-&gt;space_info-&gt;lock);
+
+	if (btrfs_test_opt(bg-&gt;fs_info, ENOSPC_DEBUG)) {
+		WARN_ON(bg-&gt;space_info-&gt;total_bytes &lt; bg-&gt;length);
+		WARN_ON(bg-&gt;space_info-&gt;bytes_readonly
+			&lt; bg-&gt;length - bg-&gt;zone_unusable);
+		WARN_ON(bg-&gt;space_info-&gt;bytes_zone_unusable
+			&lt; bg-&gt;zone_unusable);
+		WARN_ON(bg-&gt;space_info-&gt;disk_total &lt; bg-&gt;length * factor);
+	}
+	bg-&gt;space_info-&gt;total_bytes -= bg-&gt;length;
+	bg-&gt;space_info-&gt;bytes_readonly -= (bg-&gt;length - bg-&gt;zone_unusable);
+	btrfs_space_info_update_bytes_zone_unusable(bg-&gt;space_info,
+						    -bg-&gt;zone_unusable);
+	bg-&gt;space_info-&gt;disk_total -= bg-&gt;length * factor;
+
+	spin_unlock(&amp;bg-&gt;space_info-&gt;lock);
+}
+
 int btrfs_remove_block_group(struct btrfs_trans_handle *trans,
 			     struct btrfs_chunk_map *map)
 {
@@ -1078,7 +1101,6 @@ int btrfs_remove_block_group(struct btrfs_trans_handle *trans,
 	struct kobject *kobj = NULL;
 	int ret;
 	int index;
-	int factor;
 	struct btrfs_caching_control *caching_ctl = NULL;
 	bool remove_map;
 	bool remove_rsv = false;
@@ -1087,7 +1109,7 @@ int btrfs_remove_block_group(struct btrfs_trans_handle *trans,
 	if (!block_group)
 		return -ENOENT;
 
-	BUG_ON(!block_group-&gt;ro);
+	BUG_ON(!block_group-&gt;ro &amp;&amp; !(block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED));
 
 	trace_btrfs_remove_block_group(block_group);
 	/*
@@ -1099,7 +1121,6 @@ int btrfs_remove_block_group(struct btrfs_trans_handle *trans,
 				  block_group-&gt;length);
 
 	index = btrfs_bg_flags_to_raid_index(block_group-&gt;flags);
-	factor = btrfs_bg_type_to_factor(block_group-&gt;flags);
 
 	/* make sure this block group isn&#x27;t part of an allocation cluster */
 	cluster = &amp;fs_info-&gt;data_alloc_cluster;
@@ -1223,26 +1244,11 @@ int btrfs_remove_block_group(struct btrfs_trans_handle *trans,
 
 	spin_lock(&amp;block_group-&gt;space_info-&gt;lock);
 	list_del_init(&amp;block_group-&gt;ro_list);
-
-	if (btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {
-		WARN_ON(block_group-&gt;space_info-&gt;total_bytes
-			&lt; block_group-&gt;length);
-		WARN_ON(block_group-&gt;space_info-&gt;bytes_readonly
-			&lt; block_group-&gt;length - block_group-&gt;zone_unusable);
-		WARN_ON(block_group-&gt;space_info-&gt;bytes_zone_unusable
-			&lt; block_group-&gt;zone_unusable);
-		WARN_ON(block_group-&gt;space_info-&gt;disk_total
-			&lt; block_group-&gt;length * factor);
-	}
-	block_group-&gt;space_info-&gt;total_bytes -= block_group-&gt;length;
-	block_group-&gt;space_info-&gt;bytes_readonly -=
-		(block_group-&gt;length - block_group-&gt;zone_unusable);
-	btrfs_space_info_update_bytes_zone_unusable(block_group-&gt;space_info,
-						    -block_group-&gt;zone_unusable);
-	block_group-&gt;space_info-&gt;disk_total -= block_group-&gt;length * factor;
-
 	spin_unlock(&amp;block_group-&gt;space_info-&gt;lock);
 
+	if (!(block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED))
+		btrfs_remove_bg_from_sinfo(block_group);
+
 	/*
 	 * Remove the free space for the block group from the free space tree
 	 * and the block group&#x27;s item from the extent tree before marking the
@@ -1576,8 +1582,10 @@ void btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info)
 
 		spin_lock(&amp;space_info-&gt;lock);
 		spin_lock(&amp;block_group-&gt;lock);
-		if (btrfs_is_block_group_used(block_group) || block_group-&gt;ro ||
-		    list_is_singular(&amp;block_group-&gt;list)) {
+		if (btrfs_is_block_group_used(block_group) ||
+		    (block_group-&gt;ro &amp;&amp; !(block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED)) ||
+		    list_is_singular(&amp;block_group-&gt;list) ||
+		    test_bit(BLOCK_GROUP_FLAG_FULLY_REMAPPED, &amp;block_group-&gt;runtime_flags)) {
 			/*
 			 * We want to bail if we made new allocations or have
 			 * outstanding allocations in this block group.  We do
@@ -1618,9 +1626,10 @@ void btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info)
 		 * needing to allocate extents from the block group.
 		 */
 		used = btrfs_space_info_used(space_info, true);
-		if ((space_info-&gt;total_bytes - block_group-&gt;length &lt; used &amp;&amp;
-		     block_group-&gt;zone_unusable &lt; block_group-&gt;length) ||
-		    has_unwritten_metadata(block_group)) {
+		if (((space_info-&gt;total_bytes - block_group-&gt;length &lt; used &amp;&amp;
+		      block_group-&gt;zone_unusable &lt; block_group-&gt;length) ||
+		     has_unwritten_metadata(block_group)) &amp;&amp;
+		    !(block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED)) {
 			/*
 			 * Add a reference for the list, compensate for the ref
 			 * drop under the &quot;next&quot; label for the
@@ -1785,6 +1794,12 @@ void btrfs_mark_bg_unused(struct btrfs_block_group *bg)
 		btrfs_get_block_group(bg);
 		trace_btrfs_add_unused_block_group(bg);
 		list_add_tail(&amp;bg-&gt;bg_list, &amp;fs_info-&gt;unused_bgs);
+	} else if (bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED &amp;&amp;
+		   bg-&gt;identity_remap_count == 0) {
+		/*
+		 * Leave fully remapped block groups on the
+		 * fully_remapped_bgs list.
+		 */
 	} else if (!test_bit(BLOCK_GROUP_FLAG_NEW, &amp;bg-&gt;runtime_flags)) {
 		/* Pull out the block group from the reclaim_bgs list. */
 		trace_btrfs_add_unused_block_group(bg);
@@ -4594,6 +4609,14 @@ int btrfs_free_block_groups(struct btrfs_fs_info *info)
 		list_del_init(&amp;block_group-&gt;bg_list);
 		btrfs_put_block_group(block_group);
 	}
+
+	while (!list_empty(&amp;info-&gt;fully_remapped_bgs)) {
+		block_group = list_first_entry(&amp;info-&gt;fully_remapped_bgs,
+					       struct btrfs_block_group,
+					       bg_list);
+		list_del_init(&amp;block_group-&gt;bg_list);
+		btrfs_put_block_group(block_group);
+	}
 	spin_unlock(&amp;info-&gt;unused_bgs_lock);
 
 	spin_lock(&amp;info-&gt;zone_active_bgs_lock);
@@ -4781,3 +4804,26 @@ bool btrfs_block_group_should_use_size_class(const struct btrfs_block_group *bg)
 		return false;
 	return true;
 }
+
+void btrfs_mark_bg_fully_remapped(struct btrfs_block_group *bg,
+				  struct btrfs_trans_handle *trans)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+
+	spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
+
+	/*
+	 * The block group might already be on the unused_bgs list, remove it
+	 * if it is. It&#x27;ll get readded after the async discard worker finishes,
+	 * or in btrfs_handle_fully_remapped_bgs() if we&#x27;re not using async
+	 * discard.
+	 */
+	if (!list_empty(&amp;bg-&gt;bg_list))
+		list_del(&amp;bg-&gt;bg_list);
+	else
+		btrfs_get_block_group(bg);
+
+	list_add_tail(&amp;bg-&gt;bg_list, &amp;fs_info-&gt;fully_remapped_bgs);
+
+	spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+}
diff --git a/fs/btrfs/block-group.h b/fs/btrfs/block-group.h
index 4cee3448ded3..436d51a707a9 100644
--- a/fs/btrfs/block-group.h
+++ b/fs/btrfs/block-group.h
@@ -92,6 +92,7 @@ enum btrfs_block_group_flags {
 	 * transaction.
 	 */
 	BLOCK_GROUP_FLAG_NEW,
+	BLOCK_GROUP_FLAG_FULLY_REMAPPED,
 };
 
 enum btrfs_caching_type {
@@ -336,6 +337,7 @@ int btrfs_add_new_free_space(struct btrfs_block_group *block_group,
 struct btrfs_trans_handle *btrfs_start_trans_remove_block_group(
 				struct btrfs_fs_info *fs_info,
 				const u64 chunk_offset);
+void btrfs_remove_bg_from_sinfo(struct btrfs_block_group *bg);
 int btrfs_remove_block_group(struct btrfs_trans_handle *trans,
 			     struct btrfs_chunk_map *map);
 void btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info);
@@ -407,5 +409,7 @@ int btrfs_use_block_group_size_class(struct btrfs_block_group *bg,
 				     enum btrfs_block_group_size_class size_class,
 				     bool force_wrong_size_class);
 bool btrfs_block_group_should_use_size_class(const struct btrfs_block_group *bg);
+void btrfs_mark_bg_fully_remapped(struct btrfs_block_group *bg,
+				  struct btrfs_trans_handle *trans);
 
 #endif /* BTRFS_BLOCK_GROUP_H */
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index b03654ee91f5..ba500e3bf0d8 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -1495,6 +1495,10 @@ static int cleaner_kthread(void *arg)
 		 */
 		btrfs_run_defrag_inodes(fs_info);
 
+		if (btrfs_fs_incompat(fs_info, REMAP_TREE) &amp;&amp;
+		    !btrfs_test_opt(fs_info, DISCARD_ASYNC))
+			btrfs_handle_fully_remapped_bgs(fs_info);
+
 		/*
 		 * Acquires fs_info-&gt;reclaim_bgs_lock to avoid racing
 		 * with relocation (btrfs_relocate_chunk) and relocation
@@ -2835,6 +2839,7 @@ void btrfs_init_fs_info(struct btrfs_fs_info *fs_info)
 	INIT_LIST_HEAD(&amp;fs_info-&gt;tree_mod_seq_list);
 	INIT_LIST_HEAD(&amp;fs_info-&gt;unused_bgs);
 	INIT_LIST_HEAD(&amp;fs_info-&gt;reclaim_bgs);
+	INIT_LIST_HEAD(&amp;fs_info-&gt;fully_remapped_bgs);
 	INIT_LIST_HEAD(&amp;fs_info-&gt;zone_active_bgs);
 #ifdef CONFIG_BTRFS_DEBUG
 	INIT_LIST_HEAD(&amp;fs_info-&gt;allocated_roots);
@@ -2890,6 +2895,7 @@ void btrfs_init_fs_info(struct btrfs_fs_info *fs_info)
 	mutex_init(&amp;fs_info-&gt;chunk_mutex);
 	mutex_init(&amp;fs_info-&gt;transaction_kthread_mutex);
 	mutex_init(&amp;fs_info-&gt;cleaner_mutex);
+	mutex_init(&amp;fs_info-&gt;remap_mutex);
 	mutex_init(&amp;fs_info-&gt;ro_block_group_mutex);
 	init_rwsem(&amp;fs_info-&gt;commit_root_sem);
 	init_rwsem(&amp;fs_info-&gt;cleanup_work_sem);
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 3868a295be62..fef85ade017c 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -41,6 +41,7 @@
 #include &quot;tree-checker.h&quot;
 #include &quot;raid-stripe-tree.h&quot;
 #include &quot;delayed-inode.h&quot;
+#include &quot;relocation.h&quot;
 
 #undef SCRAMBLE_DELAYED_REFS
 
@@ -2844,6 +2845,73 @@ static int unpin_extent_range(struct btrfs_fs_info *fs_info,
 	return 0;
 }
 
+/*
+ * Complete the remapping of a block group by removing its chunk stripes and
+ * device extents, and adding it to the unused list if there&#x27;s no longer any
+ * extents nominally within it.
+ */
+int btrfs_complete_bg_remapping(struct btrfs_block_group *bg)
+{
+	struct btrfs_fs_info *fs_info = bg-&gt;fs_info;
+	struct btrfs_chunk_map *map;
+	int ret;
+
+	map = btrfs_get_chunk_map(fs_info, bg-&gt;start, 1);
+	if (IS_ERR(map))
+		return PTR_ERR(map);
+
+	ret = btrfs_last_identity_remap_gone(map, bg);
+	if (ret) {
+		btrfs_free_chunk_map(map);
+		return ret;
+	}
+
+	/*
+	 * Set num_stripes to 0, so that btrfs_remove_dev_extents()
+	 * won&#x27;t run a second time.
+	 */
+	map-&gt;num_stripes = 0;
+
+	btrfs_free_chunk_map(map);
+
+	if (bg-&gt;used == 0) {
+		spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
+		if (!list_empty(&amp;bg-&gt;bg_list)) {
+			list_del_init(&amp;bg-&gt;bg_list);
+			btrfs_put_block_group(bg);
+		}
+		spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+
+		btrfs_mark_bg_unused(bg);
+	}
+
+	return 0;
+}
+
+void btrfs_handle_fully_remapped_bgs(struct btrfs_fs_info *fs_info)
+{
+	struct btrfs_block_group *bg;
+	int ret;
+
+	spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
+	while (!list_empty(&amp;fs_info-&gt;fully_remapped_bgs)) {
+		bg = list_first_entry(&amp;fs_info-&gt;fully_remapped_bgs,
+				      struct btrfs_block_group, bg_list);
+		list_del_init(&amp;bg-&gt;bg_list);
+		spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+
+		ret = btrfs_complete_bg_remapping(bg);
+		if (ret) {
+			btrfs_put_block_group(bg);
+			return;
+		}
+
+		btrfs_put_block_group(bg);
+		spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
+	}
+	spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+}
+
 int btrfs_finish_extent_commit(struct btrfs_trans_handle *trans)
 {
 	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
@@ -2996,11 +3064,23 @@ u64 btrfs_get_extent_owner_root(struct btrfs_fs_info *fs_info,
 }
 
 static int do_free_extent_accounting(struct btrfs_trans_handle *trans,
-				     u64 bytenr, struct btrfs_squota_delta *delta)
+				     u64 bytenr, struct btrfs_squota_delta *delta,
+				     struct btrfs_path *path)
 {
 	int ret;
+	bool remapped = false;
 	u64 num_bytes = delta-&gt;num_bytes;
 
+	/* Returns 1 on success and 0 on no-op. */
+	ret = btrfs_remove_extent_from_remap_tree(trans, path, bytenr,
+						  num_bytes);
+	if (unlikely(ret &lt; 0)) {
+		btrfs_abort_transaction(trans, ret);
+		return ret;
+	} else if (ret == 1) {
+		remapped = true;
+	}
+
 	if (delta-&gt;is_data) {
 		struct btrfs_root *csum_root;
 
@@ -3024,10 +3104,16 @@ static int do_free_extent_accounting(struct btrfs_trans_handle *trans,
 		return ret;
 	}
 
-	ret = btrfs_add_to_free_space_tree(trans, bytenr, num_bytes);
-	if (unlikely(ret)) {
-		btrfs_abort_transaction(trans, ret);
-		return ret;
+	/*
+	 * If remapped, FST has already been taken care of in
+	 * remove_range_from_remap_tree().
+	 */
+	if (!remapped) {
+		ret = btrfs_add_to_free_space_tree(trans, bytenr, num_bytes);
+		if (unlikely(ret)) {
+			btrfs_abort_transaction(trans, ret);
+			return ret;
+		}
 	}
 
 	ret = btrfs_update_block_group(trans, bytenr, num_bytes, false);
@@ -3386,7 +3472,7 @@ static int __btrfs_free_extent(struct btrfs_trans_handle *trans,
 		}
 		btrfs_release_path(path);
 
-		ret = do_free_extent_accounting(trans, bytenr, &amp;delta);
+		ret = do_free_extent_accounting(trans, bytenr, &amp;delta, path);
 	}
 	btrfs_release_path(path);
 
diff --git a/fs/btrfs/extent-tree.h b/fs/btrfs/extent-tree.h
index 71bb8109c969..d7b6aeb63656 100644
--- a/fs/btrfs/extent-tree.h
+++ b/fs/btrfs/extent-tree.h
@@ -163,5 +163,7 @@ void btrfs_error_unpin_extent_range(struct btrfs_fs_info *fs_info, u64 start, u6
 int btrfs_discard_extent(struct btrfs_fs_info *fs_info, u64 bytenr,
 			 u64 num_bytes, u64 *actual_bytes);
 int btrfs_trim_fs(struct btrfs_fs_info *fs_info, struct fstrim_range *range);
+void btrfs_handle_fully_remapped_bgs(struct btrfs_fs_info *fs_info);
+int btrfs_complete_bg_remapping(struct btrfs_block_group *bg);
 
 #endif
diff --git a/fs/btrfs/fs.h b/fs/btrfs/fs.h
index af11f2ce310a..b59bda3f8e62 100644
--- a/fs/btrfs/fs.h
+++ b/fs/btrfs/fs.h
@@ -579,6 +579,7 @@ struct btrfs_fs_info {
 	struct mutex transaction_kthread_mutex;
 	struct mutex cleaner_mutex;
 	struct mutex chunk_mutex;
+	struct mutex remap_mutex;
 
 	/*
 	 * This is taken to make sure we don&#x27;t set block groups ro after the
@@ -832,10 +833,11 @@ struct btrfs_fs_info {
 	struct list_head reclaim_bgs;
 	int bg_reclaim_threshold;
 
-	/* Protects the lists unused_bgs and reclaim_bgs. */
+	/* Protects the lists unused_bgs, reclaim_bgs, and fully_remapped_bgs. */
 	spinlock_t unused_bgs_lock;
 	/* Protected by unused_bgs_lock. */
 	struct list_head unused_bgs;
+	struct list_head fully_remapped_bgs;
 	struct mutex unused_bg_unpin_mutex;
 	/* Protect block groups that are going to be deleted */
 	struct mutex reclaim_bgs_lock;
diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 525f45c668f6..e47234d5a156 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -37,6 +37,7 @@
 #include &quot;super.h&quot;
 #include &quot;tree-checker.h&quot;
 #include &quot;raid-stripe-tree.h&quot;
+#include &quot;free-space-tree.h&quot;
 
 /*
  * Relocation overview
@@ -3859,6 +3860,184 @@ static const char *stage_to_string(enum reloc_stage stage)
 	return &quot;unknown&quot;;
 }
 
+static void adjust_block_group_remap_bytes(struct btrfs_trans_handle *trans,
+					   struct btrfs_block_group *bg,
+					   s64 diff)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	bool bg_already_dirty = true, mark_unused = false;
+
+	spin_lock(&amp;bg-&gt;lock);
+
+	bg-&gt;remap_bytes += diff;
+
+	if (bg-&gt;used == 0 &amp;&amp; bg-&gt;remap_bytes == 0)
+		mark_unused = true;
+
+	spin_unlock(&amp;bg-&gt;lock);
+
+	if (mark_unused)
+		btrfs_mark_bg_unused(bg);
+
+	spin_lock(&amp;trans-&gt;transaction-&gt;dirty_bgs_lock);
+	if (list_empty(&amp;bg-&gt;dirty_list)) {
+		list_add_tail(&amp;bg-&gt;dirty_list, &amp;trans-&gt;transaction-&gt;dirty_bgs);
+		bg_already_dirty = false;
+		btrfs_get_block_group(bg);
+	}
+	spin_unlock(&amp;trans-&gt;transaction-&gt;dirty_bgs_lock);
+
+	/* Modified block groups are accounted for in the delayed_refs_rsv. */
+	if (!bg_already_dirty)
+		btrfs_inc_delayed_refs_rsv_bg_updates(fs_info);
+}
+
+static int remove_chunk_stripes(struct btrfs_trans_handle *trans,
+				struct btrfs_chunk_map *chunk_map,
+				struct btrfs_path *path)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_key key;
+	struct extent_buffer *leaf;
+	struct btrfs_chunk *chunk;
+	int ret;
+
+	key.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;
+	key.type = BTRFS_CHUNK_ITEM_KEY;
+	key.offset = chunk_map-&gt;start;
+
+	btrfs_reserve_chunk_metadata(trans, false);
+
+	ret = btrfs_search_slot(trans, fs_info-&gt;chunk_root, &amp;key, path,
+				0, 1);
+	if (ret) {
+		if (ret == 1) {
+			btrfs_release_path(path);
+			ret = -ENOENT;
+		}
+		btrfs_trans_release_chunk_metadata(trans);
+		return ret;
+	}
+
+	leaf = path-&gt;nodes[0];
+
+	chunk = btrfs_item_ptr(leaf, path-&gt;slots[0], struct btrfs_chunk);
+	btrfs_set_chunk_num_stripes(leaf, chunk, 0);
+	btrfs_set_chunk_sub_stripes(leaf, chunk, 0);
+
+	btrfs_truncate_item(trans, path, offsetof(struct btrfs_chunk, stripe),
+			    1);
+
+	btrfs_mark_buffer_dirty(trans, leaf);
+
+	btrfs_release_path(path);
+	btrfs_trans_release_chunk_metadata(trans);
+
+	return 0;
+}
+
+int btrfs_last_identity_remap_gone(struct btrfs_chunk_map *chunk_map,
+				   struct btrfs_block_group *bg)
+{
+	struct btrfs_fs_info *fs_info = bg-&gt;fs_info;
+	struct btrfs_trans_handle *trans;
+	int ret;
+	unsigned int num_items;
+	BTRFS_PATH_AUTO_FREE(path);
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+
+	/*
+	 * One item for each entry we&#x27;re removing in the dev extents tree, and
+	 * another for each device. DUP chunks are all on one device,
+	 * everything else has one device per stripe.
+	 */
+	if (bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_DUP)
+		num_items = chunk_map-&gt;num_stripes + 1;
+	else
+		num_items = 2 * chunk_map-&gt;num_stripes;
+
+	trans = btrfs_start_transaction_fallback_global_rsv(fs_info-&gt;tree_root,
+							    num_items);
+	if (IS_ERR(trans))
+		return PTR_ERR(trans);
+
+	ret = btrfs_remove_dev_extents(trans, chunk_map);
+	if (unlikely(ret)) {
+		btrfs_abort_transaction(trans, ret);
+		return ret;
+	}
+
+	mutex_lock(&amp;trans-&gt;fs_info-&gt;chunk_mutex);
+
+	for (unsigned int i = 0; i &lt; chunk_map-&gt;num_stripes; i++) {
+		ret = btrfs_update_device(trans, chunk_map-&gt;stripes[i].dev);
+		if (unlikely(ret)) {
+			mutex_unlock(&amp;trans-&gt;fs_info-&gt;chunk_mutex);
+			btrfs_abort_transaction(trans, ret);
+			return ret;
+		}
+	}
+
+	mutex_unlock(&amp;trans-&gt;fs_info-&gt;chunk_mutex);
+
+	write_lock(&amp;trans-&gt;fs_info-&gt;mapping_tree_lock);
+	btrfs_chunk_map_device_clear_bits(chunk_map, CHUNK_ALLOCATED);
+	write_unlock(&amp;trans-&gt;fs_info-&gt;mapping_tree_lock);
+
+	btrfs_remove_bg_from_sinfo(bg);
+
+	ret = remove_chunk_stripes(trans, chunk_map, path);
+	if (unlikely(ret)) {
+		btrfs_abort_transaction(trans, ret);
+		return ret;
+	}
+
+	ret = btrfs_commit_transaction(trans);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void adjust_identity_remap_count(struct btrfs_trans_handle *trans,
+				        struct btrfs_block_group *bg, int delta)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	bool bg_already_dirty = true, mark_fully_remapped = false;
+
+	WARN_ON(delta &lt; 0 &amp;&amp; -delta &gt; bg-&gt;identity_remap_count);
+
+	spin_lock(&amp;bg-&gt;lock);
+
+	bg-&gt;identity_remap_count += delta;
+
+	if (bg-&gt;identity_remap_count == 0 &amp;&amp;
+	    !test_bit(BLOCK_GROUP_FLAG_FULLY_REMAPPED, &amp;bg-&gt;runtime_flags)) {
+		set_bit(BLOCK_GROUP_FLAG_FULLY_REMAPPED, &amp;bg-&gt;runtime_flags);
+		mark_fully_remapped = true;
+	}
+
+	spin_unlock(&amp;bg-&gt;lock);
+
+	spin_lock(&amp;trans-&gt;transaction-&gt;dirty_bgs_lock);
+	if (list_empty(&amp;bg-&gt;dirty_list)) {
+		list_add_tail(&amp;bg-&gt;dirty_list, &amp;trans-&gt;transaction-&gt;dirty_bgs);
+		bg_already_dirty = false;
+		btrfs_get_block_group(bg);
+	}
+	spin_unlock(&amp;trans-&gt;transaction-&gt;dirty_bgs_lock);
+
+	/* Modified block groups are accounted for in the delayed_refs_rsv. */
+	if (!bg_already_dirty)
+		btrfs_inc_delayed_refs_rsv_bg_updates(fs_info);
+
+	if (mark_fully_remapped)
+		btrfs_mark_bg_fully_remapped(bg, trans);
+}
+
 int btrfs_translate_remap(struct btrfs_fs_info *fs_info, u64 *logical,
 			  u64 *length)
 {
@@ -4467,3 +4646,277 @@ u64 btrfs_get_reloc_bg_bytenr(const struct btrfs_fs_info *fs_info)
 		logical = fs_info-&gt;reloc_ctl-&gt;block_group-&gt;start;
 	return logical;
 }
+
+static int insert_remap_item(struct btrfs_trans_handle *trans,
+			     struct btrfs_path *path, u64 old_addr, u64 length,
+			     u64 new_addr)
+{
+	int ret;
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_key key;
+	struct btrfs_remap_item remap = { 0 };
+
+	if (old_addr == new_addr) {
+		/* Add new identity remap item. */
+
+		key.objectid = old_addr;
+		key.type = BTRFS_IDENTITY_REMAP_KEY;
+		key.offset = length;
+
+		ret = btrfs_insert_empty_item(trans, fs_info-&gt;remap_root,
+					      path, &amp;key, 0);
+		if (ret)
+			return ret;
+	} else {
+		/* Add new remap item. */
+
+		key.objectid = old_addr;
+		key.type = BTRFS_REMAP_KEY;
+		key.offset = length;
+
+		ret = btrfs_insert_empty_item(trans, fs_info-&gt;remap_root,
+					      path, &amp;key,
+					      sizeof(struct btrfs_remap_item));
+		if (ret)
+			return ret;
+
+		btrfs_set_stack_remap_address(&amp;remap, new_addr);
+
+		write_extent_buffer(path-&gt;nodes[0], &amp;remap,
+			btrfs_item_ptr_offset(path-&gt;nodes[0], path-&gt;slots[0]),
+			sizeof(struct btrfs_remap_item));
+
+		btrfs_release_path(path);
+
+		/* Add new backref item. */
+
+		key.objectid = new_addr;
+		key.type = BTRFS_REMAP_BACKREF_KEY;
+		key.offset = length;
+
+		ret = btrfs_insert_empty_item(trans, fs_info-&gt;remap_root,
+					      path, &amp;key,
+					      sizeof(struct btrfs_remap_item));
+		if (ret)
+			return ret;
+
+		btrfs_set_stack_remap_address(&amp;remap, old_addr);
+
+		write_extent_buffer(path-&gt;nodes[0], &amp;remap,
+			btrfs_item_ptr_offset(path-&gt;nodes[0], path-&gt;slots[0]),
+			sizeof(struct btrfs_remap_item));
+	}
+
+	btrfs_release_path(path);
+
+	return 0;
+}
+
+/*
+ * Punch a hole in the remap item or identity remap item pointed to by path,
+ * for the range [hole_start, hole_start + hole_length).
+ */
+static int remove_range_from_remap_tree(struct btrfs_trans_handle *trans,
+					struct btrfs_path *path,
+					struct btrfs_block_group *bg,
+					u64 hole_start, u64 hole_length)
+{
+	int ret;
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct extent_buffer *leaf = path-&gt;nodes[0];
+	struct btrfs_key key;
+	u64 hole_end, new_addr, remap_start, remap_length, remap_end;
+	u64 overlap_length;
+	bool is_identity_remap;
+	int identity_count_delta = 0;
+
+	hole_end = hole_start + hole_length;
+
+	btrfs_item_key_to_cpu(leaf, &amp;key, path-&gt;slots[0]);
+
+	is_identity_remap = key.type == BTRFS_IDENTITY_REMAP_KEY;
+
+	remap_start = key.objectid;
+	remap_length = key.offset;
+
+	remap_end = remap_start + remap_length;
+
+	if (is_identity_remap) {
+		new_addr = remap_start;
+	} else {
+		struct btrfs_remap_item *remap_ptr;
+
+		remap_ptr = btrfs_item_ptr(leaf, path-&gt;slots[0],
+					   struct btrfs_remap_item);
+		new_addr = btrfs_remap_address(leaf, remap_ptr);
+	}
+
+	/* Delete old item. */
+
+	ret = btrfs_del_item(trans, fs_info-&gt;remap_root, path);
+
+	btrfs_release_path(path);
+
+	if (ret)
+		return ret;
+
+	if (is_identity_remap) {
+		identity_count_delta = -1;
+	} else {
+		/* Remove backref. */
+
+		key.objectid = new_addr;
+		key.type = BTRFS_REMAP_BACKREF_KEY;
+		key.offset = remap_length;
+
+		ret = btrfs_search_slot(trans, fs_info-&gt;remap_root,
+					&amp;key, path, -1, 1);
+		if (ret) {
+			if (ret == 1) {
+				btrfs_release_path(path);
+				ret = -ENOENT;
+			}
+			return ret;
+		}
+
+		ret = btrfs_del_item(trans, fs_info-&gt;remap_root, path);
+
+		btrfs_release_path(path);
+
+		if (ret)
+			return ret;
+	}
+
+	/* If hole_start &gt; remap_start, re-add the start of the remap item. */
+	if (hole_start &gt; remap_start) {
+		ret = insert_remap_item(trans, path, remap_start,
+					hole_start - remap_start, new_addr);
+		if (ret)
+			return ret;
+
+		if (is_identity_remap)
+			identity_count_delta++;
+	}
+
+	/* If hole_end &lt; remap_end, re-add the end of the remap item. */
+	if (hole_end &lt; remap_end) {
+		ret = insert_remap_item(trans, path, hole_end,
+				remap_end - hole_end,
+				hole_end - remap_start + new_addr);
+		if (ret)
+			return ret;
+
+		if (is_identity_remap)
+			identity_count_delta++;
+	}
+
+	if (identity_count_delta != 0)
+		adjust_identity_remap_count(trans, bg, identity_count_delta);
+
+	overlap_length = min_t(u64, hole_end, remap_end) -
+			 max_t(u64, hole_start, remap_start);
+
+	if (!is_identity_remap) {
+		struct btrfs_block_group *dest_bg;
+
+		dest_bg = btrfs_lookup_block_group(fs_info, new_addr);
+
+		adjust_block_group_remap_bytes(trans, dest_bg, -overlap_length);
+
+		btrfs_put_block_group(dest_bg);
+
+		ret = btrfs_add_to_free_space_tree(trans,
+					     hole_start - remap_start + new_addr,
+					     overlap_length);
+		if (ret)
+			return ret;
+	}
+
+	ret = overlap_length;
+
+	return ret;
+}
+
+/*
+ * Returns 1 if remove_range_from_remap_tree() has been called successfully,
+ * 0 if block group wasn&#x27;t remapped, and a negative number on error.
+ */
+int btrfs_remove_extent_from_remap_tree(struct btrfs_trans_handle *trans,
+					struct btrfs_path *path,
+					u64 bytenr, u64 num_bytes)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_key key, found_key;
+	struct extent_buffer *leaf;
+	struct btrfs_block_group *bg;
+	int ret, length;
+
+	if (!(btrfs_super_incompat_flags(fs_info-&gt;super_copy) &amp;
+	      BTRFS_FEATURE_INCOMPAT_REMAP_TREE))
+		return 0;
+
+	bg = btrfs_lookup_block_group(fs_info, bytenr);
+	if (!bg)
+		return 0;
+
+	mutex_lock(&amp;fs_info-&gt;remap_mutex);
+
+	if (!(bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED)) {
+		mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+		btrfs_put_block_group(bg);
+		return 0;
+	}
+
+	do {
+		key.objectid = bytenr;
+		key.type = (u8)-1;
+		key.offset = (u64)-1;
+
+		ret = btrfs_search_slot(trans, fs_info-&gt;remap_root, &amp;key, path,
+					-1, 1);
+		if (ret &lt; 0)
+			goto end;
+
+		leaf = path-&gt;nodes[0];
+
+		if (path-&gt;slots[0] == 0) {
+			ret = -ENOENT;
+			goto end;
+		}
+
+		path-&gt;slots[0]--;
+
+		btrfs_item_key_to_cpu(leaf, &amp;found_key, path-&gt;slots[0]);
+
+		if (found_key.type != BTRFS_IDENTITY_REMAP_KEY &amp;&amp;
+		    found_key.type != BTRFS_REMAP_KEY) {
+			ret = -ENOENT;
+			goto end;
+		}
+
+		if (bytenr &lt; found_key.objectid ||
+		    bytenr &gt;= found_key.objectid + found_key.offset) {
+			ret = -ENOENT;
+			goto end;
+		}
+
+		length = remove_range_from_remap_tree(trans, path, bg, bytenr,
+						      num_bytes);
+		if (length &lt; 0) {
+			ret = length;
+			goto end;
+		}
+
+		bytenr += length;
+		num_bytes -= length;
+	} while (num_bytes &gt; 0);
+
+	ret = 1;
+
+end:
+	mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+
+	btrfs_put_block_group(bg);
+	btrfs_release_path(path);
+	return ret;
+}
diff --git a/fs/btrfs/relocation.h b/fs/btrfs/relocation.h
index b2ba83966650..0f4874f815db 100644
--- a/fs/btrfs/relocation.h
+++ b/fs/btrfs/relocation.h
@@ -33,5 +33,10 @@ bool btrfs_should_ignore_reloc_root(const struct btrfs_root *root);
 u64 btrfs_get_reloc_bg_bytenr(const struct btrfs_fs_info *fs_info);
 int btrfs_translate_remap(struct btrfs_fs_info *fs_info, u64 *logical,
 			  u64 *length);
+int btrfs_remove_extent_from_remap_tree(struct btrfs_trans_handle *trans,
+					struct btrfs_path *path,
+					u64 bytenr, u64 num_bytes);
+int btrfs_last_identity_remap_gone(struct btrfs_chunk_map *chunk_map,
+				   struct btrfs_block_group *bg);
 
 #endif
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 557ce56df800..46c5acc96725 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -2923,8 +2923,8 @@ int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *device_path
 	return ret;
 }
 
-static noinline int btrfs_update_device(struct btrfs_trans_handle *trans,
-					struct btrfs_device *device)
+int btrfs_update_device(struct btrfs_trans_handle *trans,
+			struct btrfs_device *device)
 {
 	int ret;
 	BTRFS_PATH_AUTO_FREE(path);
@@ -3222,25 +3222,13 @@ static int remove_chunk_item(struct btrfs_trans_handle *trans,
 	return btrfs_free_chunk(trans, chunk_offset);
 }
 
-int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset)
+int btrfs_remove_dev_extents(struct btrfs_trans_handle *trans,
+			     struct btrfs_chunk_map *map)
 {
 	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
-	struct btrfs_chunk_map *map;
+	struct btrfs_fs_devices *fs_devices = fs_info-&gt;fs_devices;
 	u64 dev_extent_len = 0;
 	int i, ret = 0;
-	struct btrfs_fs_devices *fs_devices = fs_info-&gt;fs_devices;
-
-	map = btrfs_get_chunk_map(fs_info, chunk_offset, 1);
-	if (IS_ERR(map)) {
-		/*
-		 * This is a logic error, but we don&#x27;t want to just rely on the
-		 * user having built with ASSERT enabled, so if ASSERT doesn&#x27;t
-		 * do anything we still error out.
-		 */
-		DEBUG_WARN(&quot;errr %ld reading chunk map at offset %llu&quot;,
-			   PTR_ERR(map), chunk_offset);
-		return PTR_ERR(map);
-	}
 
 	/*
 	 * First delete the device extent items from the devices btree.
@@ -3261,7 +3249,7 @@ int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset)
 		if (unlikely(ret)) {
 			mutex_unlock(&amp;fs_devices-&gt;device_list_mutex);
 			btrfs_abort_transaction(trans, ret);
-			goto out;
+			return ret;
 		}
 
 		if (device-&gt;bytes_used &gt; 0) {
@@ -3281,6 +3269,31 @@ int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset)
 	}
 	mutex_unlock(&amp;fs_devices-&gt;device_list_mutex);
 
+	return 0;
+}
+
+int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_chunk_map *map;
+	int ret;
+
+	map = btrfs_get_chunk_map(fs_info, chunk_offset, 1);
+	if (IS_ERR(map)) {
+		/*
+		 * This is a logic error, but we don&#x27;t want to just rely on the
+		 * user having built with ASSERT enabled, so if ASSERT doesn&#x27;t
+		 * do anything we still error out.
+		 */
+		DEBUG_WARN(&quot;errr %ld reading chunk map at offset %llu&quot;,
+			   PTR_ERR(map), chunk_offset);
+		return PTR_ERR(map);
+	}
+
+	ret = btrfs_remove_dev_extents(trans, map);
+	if (ret)
+		goto out;
+
 	/*
 	 * We acquire fs_info-&gt;chunk_mutex for 2 reasons:
 	 *
@@ -5417,7 +5430,7 @@ static void chunk_map_device_set_bits(struct btrfs_chunk_map *map, unsigned int
 	}
 }
 
-static void chunk_map_device_clear_bits(struct btrfs_chunk_map *map, unsigned int bits)
+void btrfs_chunk_map_device_clear_bits(struct btrfs_chunk_map *map, unsigned int bits)
 {
 	for (int i = 0; i &lt; map-&gt;num_stripes; i++) {
 		struct btrfs_io_stripe *stripe = &amp;map-&gt;stripes[i];
@@ -5434,7 +5447,7 @@ void btrfs_remove_chunk_map(struct btrfs_fs_info *fs_info, struct btrfs_chunk_ma
 	write_lock(&amp;fs_info-&gt;mapping_tree_lock);
 	rb_erase_cached(&amp;map-&gt;rb_node, &amp;fs_info-&gt;mapping_tree);
 	RB_CLEAR_NODE(&amp;map-&gt;rb_node);
-	chunk_map_device_clear_bits(map, CHUNK_ALLOCATED);
+	btrfs_chunk_map_device_clear_bits(map, CHUNK_ALLOCATED);
 	write_unlock(&amp;fs_info-&gt;mapping_tree_lock);
 
 	/* Once for the tree reference. */
@@ -5470,7 +5483,7 @@ int btrfs_add_chunk_map(struct btrfs_fs_info *fs_info, struct btrfs_chunk_map *m
 		return -EEXIST;
 	}
 	chunk_map_device_set_bits(map, CHUNK_ALLOCATED);
-	chunk_map_device_clear_bits(map, CHUNK_TRIMMED);
+	btrfs_chunk_map_device_clear_bits(map, CHUNK_TRIMMED);
 	write_unlock(&amp;fs_info-&gt;mapping_tree_lock);
 
 	return 0;
@@ -5826,7 +5839,7 @@ void btrfs_mapping_tree_free(struct btrfs_fs_info *fs_info)
 		map = rb_entry(node, struct btrfs_chunk_map, rb_node);
 		rb_erase_cached(&amp;map-&gt;rb_node, &amp;fs_info-&gt;mapping_tree);
 		RB_CLEAR_NODE(&amp;map-&gt;rb_node);
-		chunk_map_device_clear_bits(map, CHUNK_ALLOCATED);
+		btrfs_chunk_map_device_clear_bits(map, CHUNK_ALLOCATED);
 		/* Once for the tree ref. */
 		btrfs_free_chunk_map(map);
 		cond_resched_rwlock_write(&amp;fs_info-&gt;mapping_tree_lock);
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 4117fabb248b..ccf0a459180d 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -794,6 +794,8 @@ u64 btrfs_calc_stripe_length(const struct btrfs_chunk_map *map);
 int btrfs_nr_parity_stripes(u64 type);
 int btrfs_chunk_alloc_add_chunk_item(struct btrfs_trans_handle *trans,
 				     struct btrfs_block_group *bg);
+int btrfs_remove_dev_extents(struct btrfs_trans_handle *trans,
+			     struct btrfs_chunk_map *map);
 int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset);
 
 #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
@@ -905,6 +907,10 @@ bool btrfs_repair_one_zone(struct btrfs_fs_info *fs_info, u64 logical);
 
 bool btrfs_pinned_by_swapfile(struct btrfs_fs_info *fs_info, void *ptr);
 const u8 *btrfs_sb_fsid_ptr(const struct btrfs_super_block *sb);
+int btrfs_update_device(struct btrfs_trans_handle *trans,
+			struct btrfs_device *device);
+void btrfs_chunk_map_device_clear_bits(struct btrfs_chunk_map *map,
+				       unsigned int bits);
 
 #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
 struct btrfs_io_context *alloc_btrfs_io_context(struct btrfs_fs_info *fs_info,
-- 
2.51.2



---

If when relocating a block group we find that `remap_bytes` &gt; 0 in its
block group item, that means that it has been the destination block
group for another that has been remapped.

We need to seach the remap tree for any remap backrefs within this
range, and move the data to a third block group. This is because
otherwise btrfs_translate_remap() could end up following an unbounded
chain of remaps, which would only get worse over time.

We only relocate one block group at a time, so `remap_bytes` will only
ever go down while we are doing this. Once we&#x27;re finished we set the
REMAPPED flag on the block group, which will permanently prevent any
other data from being moved to within it.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/bio.c         |   3 +-
 fs/btrfs/bio.h         |   3 +
 fs/btrfs/extent-tree.c |   6 +-
 fs/btrfs/relocation.c  | 481 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 490 insertions(+), 3 deletions(-)

diff --git a/fs/btrfs/bio.c b/fs/btrfs/bio.c
index a12446aa0fbf..1be042c0d521 100644
--- a/fs/btrfs/bio.c
+++ b/fs/btrfs/bio.c
@@ -826,7 +826,8 @@ static bool btrfs_submit_chunk(struct btrfs_bio *bbio, int mirror_num)
 		 */
 		if (!(inode-&gt;flags &amp; BTRFS_INODE_NODATASUM) &amp;&amp;
 		    !test_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &amp;fs_info-&gt;fs_state) &amp;&amp;
-		    !btrfs_is_data_reloc_root(inode-&gt;root)) {
+		    !btrfs_is_data_reloc_root(inode-&gt;root) &amp;&amp;
+		    !bbio-&gt;is_remap) {
 			if (should_async_write(bbio) &amp;&amp;
 			    btrfs_wq_submit_bio(bbio, bioc, &amp;smap, mirror_num))
 				goto done;
diff --git a/fs/btrfs/bio.h b/fs/btrfs/bio.h
index 157cdfa2f78a..303ed6c7103d 100644
--- a/fs/btrfs/bio.h
+++ b/fs/btrfs/bio.h
@@ -90,6 +90,9 @@ struct btrfs_bio {
 	 */
 	bool is_scrub:1;
 
+	/* Whether the bio is coming from copy_remapped_data_io(). */
+	bool is_remap:1;
+
 	/* Whether the csum generation for data write is async. */
 	bool async_csum:1;
 
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index fef85ade017c..70020ba8ef92 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -4557,7 +4557,8 @@ static noinline int find_free_extent(struct btrfs_root *root,
 		    block_group-&gt;cached != BTRFS_CACHE_NO) {
 			down_read(&amp;space_info-&gt;groups_sem);
 			if (list_empty(&amp;block_group-&gt;list) ||
-			    block_group-&gt;ro) {
+			    block_group-&gt;ro ||
+			    block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED) {
 				/*
 				 * someone is removing this block group,
 				 * we can&#x27;t jump into the have_block_group
@@ -4591,7 +4592,8 @@ static noinline int find_free_extent(struct btrfs_root *root,
 
 		ffe_ctl-&gt;hinted = false;
 		/* If the block group is read-only, we can skip it entirely. */
-		if (unlikely(block_group-&gt;ro)) {
+		if (unlikely(block_group-&gt;ro ||
+			     block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED)) {
 			if (ffe_ctl-&gt;for_treelog)
 				btrfs_clear_treelog_bg(block_group);
 			if (ffe_ctl-&gt;for_data_reloc)
diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 143eede52be0..82f0e15f0f84 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -3976,6 +3976,481 @@ static void adjust_block_group_remap_bytes(struct btrfs_trans_handle *trans,
 		btrfs_inc_delayed_refs_rsv_bg_updates(fs_info);
 }
 
+/* Private structure for I/O from copy_remapped_data().  */
+struct reloc_io_private {
+	struct completion done;
+	refcount_t pending_refs;
+	blk_status_t status;
+};
+
+static void reloc_endio(struct btrfs_bio *bbio)
+{
+	struct reloc_io_private *priv = bbio-&gt;private;
+
+	if (bbio-&gt;bio.bi_status)
+		WRITE_ONCE(priv-&gt;status, bbio-&gt;bio.bi_status);
+
+	if (refcount_dec_and_test(&amp;priv-&gt;pending_refs))
+		complete(&amp;priv-&gt;done);
+
+	bio_put(&amp;bbio-&gt;bio);
+}
+
+static int copy_remapped_data_io(struct btrfs_fs_info *fs_info,
+				 struct reloc_io_private *priv,
+				 struct page **pages, u64 addr, u64 length,
+				 blk_opf_t op)
+{
+	struct btrfs_bio *bbio;
+	unsigned int i = 0;
+
+	init_completion(&amp;priv-&gt;done);
+	refcount_set(&amp;priv-&gt;pending_refs, 1);
+	priv-&gt;status = 0;
+
+	bbio = btrfs_bio_alloc(BIO_MAX_VECS, op, BTRFS_I(fs_info-&gt;btree_inode),
+			       addr, reloc_endio, priv);
+	bbio-&gt;bio.bi_iter.bi_sector = addr &gt;&gt; SECTOR_SHIFT;
+	bbio-&gt;is_remap = true;
+
+	do {
+		size_t bytes = min_t(u64, length, PAGE_SIZE);
+
+		if (bio_add_page(&amp;bbio-&gt;bio, pages[i], bytes, 0) &lt; bytes) {
+			refcount_inc(&amp;priv-&gt;pending_refs);
+			btrfs_submit_bbio(bbio, 0);
+
+			bbio = btrfs_bio_alloc(BIO_MAX_VECS, op,
+					       BTRFS_I(fs_info-&gt;btree_inode),
+					       addr, reloc_endio, priv);
+			bbio-&gt;bio.bi_iter.bi_sector = addr &gt;&gt; SECTOR_SHIFT;
+			bbio-&gt;is_remap = true;
+			continue;
+		}
+
+		i++;
+		addr += bytes;
+		length -= bytes;
+	} while (length);
+
+	refcount_inc(&amp;priv-&gt;pending_refs);
+	btrfs_submit_bbio(bbio, 0);
+
+	if (!refcount_dec_and_test(&amp;priv-&gt;pending_refs))
+		wait_for_completion_io(&amp;priv-&gt;done);
+
+	return blk_status_to_errno(READ_ONCE(priv-&gt;status));
+}
+
+static int copy_remapped_data(struct btrfs_fs_info *fs_info, u64 old_addr,
+			      u64 new_addr, u64 length)
+{
+	int ret;
+	u64 copy_len = min_t(u64, length, SZ_1M);
+	struct page **pages;
+	struct reloc_io_private priv;
+	unsigned int nr_pages = DIV_ROUND_UP(length, PAGE_SIZE);
+
+	pages = kcalloc(nr_pages, sizeof(struct page *), GFP_NOFS);
+	if (!pages)
+		return -ENOMEM;
+
+	ret = btrfs_alloc_page_array(nr_pages, pages, 0);
+	if (ret) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	/* Copy 1MB at a time, to avoid using too much memory. */
+
+	do {
+		u64 to_copy = min_t(u64, length, copy_len);
+
+		/* Limit to one bio. */
+		to_copy = min_t(u64, to_copy, BIO_MAX_VECS &lt;&lt; PAGE_SHIFT);
+
+		ret = copy_remapped_data_io(fs_info, &amp;priv, pages, old_addr,
+					    to_copy, REQ_OP_READ);
+		if (ret)
+			goto end;
+
+		ret = copy_remapped_data_io(fs_info, &amp;priv, pages, new_addr,
+					    to_copy, REQ_OP_WRITE);
+		if (ret)
+			goto end;
+
+		if (to_copy == length)
+			break;
+
+		old_addr += to_copy;
+		new_addr += to_copy;
+		length -= to_copy;
+	} while (true);
+
+	ret = 0;
+end:
+	for (unsigned int i = 0; i &lt; nr_pages; i++) {
+		if (pages[i])
+			__free_page(pages[i]);
+	}
+	kfree(pages);
+
+	return ret;
+}
+
+static int add_remap_item(struct btrfs_trans_handle *trans,
+			  struct btrfs_path *path, u64 new_addr, u64 length,
+			  u64 old_addr)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_remap_item remap = { 0 };
+	struct btrfs_key key;
+	struct extent_buffer *leaf;
+	int ret;
+
+	key.objectid = old_addr;
+	key.type = BTRFS_REMAP_KEY;
+	key.offset = length;
+
+	ret = btrfs_insert_empty_item(trans, fs_info-&gt;remap_root, path,
+				      &amp;key, sizeof(struct btrfs_remap_item));
+	if (ret)
+		return ret;
+
+	leaf = path-&gt;nodes[0];
+
+	btrfs_set_stack_remap_address(&amp;remap, new_addr);
+
+	write_extent_buffer(leaf, &amp;remap,
+			    btrfs_item_ptr_offset(leaf, path-&gt;slots[0]),
+			    sizeof(struct btrfs_remap_item));
+
+	btrfs_release_path(path);
+
+	return 0;
+}
+
+static int add_remap_backref_item(struct btrfs_trans_handle *trans,
+				  struct btrfs_path *path, u64 new_addr,
+				  u64 length, u64 old_addr)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_remap_item remap = { 0 };
+	struct btrfs_key key;
+	struct extent_buffer *leaf;
+	int ret;
+
+	key.objectid = new_addr;
+	key.type = BTRFS_REMAP_BACKREF_KEY;
+	key.offset = length;
+
+	ret = btrfs_insert_empty_item(trans, fs_info-&gt;remap_root,
+				      path, &amp;key,
+				      sizeof(struct btrfs_remap_item));
+	if (ret)
+		return ret;
+
+	leaf = path-&gt;nodes[0];
+
+	btrfs_set_stack_remap_address(&amp;remap, old_addr);
+
+	write_extent_buffer(leaf, &amp;remap,
+			    btrfs_item_ptr_offset(leaf, path-&gt;slots[0]),
+			    sizeof(struct btrfs_remap_item));
+
+	btrfs_release_path(path);
+
+	return 0;
+}
+
+static int move_existing_remap(struct btrfs_fs_info *fs_info,
+			       struct btrfs_path *path,
+			       struct btrfs_block_group *bg, u64 new_addr,
+			       u64 length, u64 old_addr)
+{
+	struct btrfs_trans_handle *trans;
+	struct extent_buffer *leaf;
+	struct btrfs_remap_item *remap_ptr;
+	struct btrfs_remap_item remap = { 0 };
+	struct btrfs_key key, ins;
+	u64 dest_addr, dest_length, min_size;
+	struct btrfs_block_group *dest_bg;
+	int ret;
+	const bool is_data = bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_DATA;
+	struct btrfs_space_info *sinfo = bg-&gt;space_info;
+	bool mutex_taken = false, bg_needs_free_space;
+
+	spin_lock(&amp;sinfo-&gt;lock);
+	btrfs_space_info_update_bytes_may_use(sinfo, length);
+	spin_unlock(&amp;sinfo-&gt;lock);
+
+	if (is_data)
+		min_size = fs_info-&gt;sectorsize;
+	else
+		min_size = fs_info-&gt;nodesize;
+
+	ret = btrfs_reserve_extent(fs_info-&gt;fs_root, length, length, min_size,
+				   0, 0, &amp;ins, is_data, false);
+	if (unlikely(ret)) {
+		spin_lock(&amp;sinfo-&gt;lock);
+		btrfs_space_info_update_bytes_may_use(sinfo, -length);
+		spin_unlock(&amp;sinfo-&gt;lock);
+		return ret;
+	}
+
+	dest_addr = ins.objectid;
+	dest_length = ins.offset;
+
+	if (!is_data &amp;&amp; !IS_ALIGNED(dest_length, fs_info-&gt;nodesize)) {
+		u64 new_length = ALIGN_DOWN(dest_length, fs_info-&gt;nodesize);
+
+		btrfs_free_reserved_extent(fs_info, dest_addr + new_length,
+					   dest_length - new_length, 0);
+
+		dest_length = new_length;
+	}
+
+	trans = btrfs_join_transaction(fs_info-&gt;remap_root);
+	if (IS_ERR(trans)) {
+		ret = PTR_ERR(trans);
+		trans = NULL;
+		goto end;
+	}
+
+	mutex_lock(&amp;fs_info-&gt;remap_mutex);
+	mutex_taken = true;
+
+	/* Find old remap entry. */
+
+	key.objectid = old_addr;
+	key.type = BTRFS_REMAP_KEY;
+	key.offset = length;
+
+	ret = btrfs_search_slot(trans, fs_info-&gt;remap_root, &amp;key,
+				path, 0, 1);
+	if (ret == 1) {
+		/*
+		 * Not a problem if the remap entry wasn&#x27;t found: that means
+		 * that another transaction has deallocated the data.
+		 * move_existing_remaps() loops until the BG contains no
+		 * remaps, so we can just return 0 in this case.
+		 */
+		btrfs_release_path(path);
+		ret = 0;
+		goto end;
+	} else if (unlikely(ret)) {
+		goto end;
+	}
+
+	ret = copy_remapped_data(fs_info, new_addr, dest_addr, dest_length);
+	if (unlikely(ret))
+		goto end;
+
+	/* Change data of old remap entry. */
+
+	leaf = path-&gt;nodes[0];
+
+	remap_ptr = btrfs_item_ptr(leaf, path-&gt;slots[0],
+				   struct btrfs_remap_item);
+	btrfs_set_remap_address(leaf, remap_ptr, dest_addr);
+
+	btrfs_mark_buffer_dirty(trans, leaf);
+
+	if (dest_length != length) {
+		key.offset = dest_length;
+		btrfs_set_item_key_safe(trans, path, &amp;key);
+	}
+
+	btrfs_release_path(path);
+
+	if (dest_length != length) {
+		/* Add remap item for remainder. */
+
+		ret = add_remap_item(trans, path, new_addr + dest_length,
+				     length - dest_length,
+				     old_addr + dest_length);
+		if (unlikely(ret))
+			goto end;
+	}
+
+	/* Change or remove old backref. */
+
+	key.objectid = new_addr;
+	key.type = BTRFS_REMAP_BACKREF_KEY;
+	key.offset = length;
+
+	ret = btrfs_search_slot(trans, fs_info-&gt;remap_root, &amp;key,
+				path, -1, 1);
+	if (unlikely(ret)) {
+		if (ret == 1) {
+			btrfs_release_path(path);
+			ret = -ENOENT;
+		}
+		goto end;
+	}
+
+	leaf = path-&gt;nodes[0];
+
+	if (dest_length == length) {
+		ret = btrfs_del_item(trans, fs_info-&gt;remap_root, path);
+		if (unlikely(ret)) {
+			btrfs_release_path(path);
+			goto end;
+		}
+	} else {
+		key.objectid += dest_length;
+		key.offset -= dest_length;
+		btrfs_set_item_key_safe(trans, path, &amp;key);
+
+		btrfs_set_stack_remap_address(&amp;remap, old_addr + dest_length);
+
+		write_extent_buffer(leaf, &amp;remap,
+				    btrfs_item_ptr_offset(leaf, path-&gt;slots[0]),
+				    sizeof(struct btrfs_remap_item));
+	}
+
+	btrfs_release_path(path);
+
+	/* Add new backref. */
+
+	ret = add_remap_backref_item(trans, path, dest_addr, dest_length,
+				     old_addr);
+	if (unlikely(ret))
+		goto end;
+
+	adjust_block_group_remap_bytes(trans, bg, -dest_length);
+
+	ret = btrfs_add_to_free_space_tree(trans, new_addr, dest_length);
+	if (unlikely(ret))
+		goto end;
+
+	dest_bg = btrfs_lookup_block_group(fs_info, dest_addr);
+
+	adjust_block_group_remap_bytes(trans, dest_bg, dest_length);
+
+	mutex_lock(&amp;dest_bg-&gt;free_space_lock);
+	bg_needs_free_space = test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE,
+				       &amp;dest_bg-&gt;runtime_flags);
+	mutex_unlock(&amp;dest_bg-&gt;free_space_lock);
+	btrfs_put_block_group(dest_bg);
+
+	if (bg_needs_free_space) {
+		ret = btrfs_add_block_group_free_space(trans, dest_bg);
+		if (unlikely(ret))
+			goto end;
+	}
+
+	ret = btrfs_remove_from_free_space_tree(trans, dest_addr, dest_length);
+	if (unlikely(ret)) {
+		btrfs_remove_from_free_space_tree(trans, new_addr,
+						  dest_length);
+		goto end;
+	}
+
+	ret = 0;
+
+end:
+	if (mutex_taken)
+		mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+
+	btrfs_dec_block_group_reservations(fs_info, dest_addr);
+
+	if (unlikely(ret)) {
+		btrfs_free_reserved_extent(fs_info, dest_addr, dest_length, 0);
+
+		if (trans) {
+			btrfs_abort_transaction(trans, ret);
+			btrfs_end_transaction(trans);
+		}
+	} else {
+		dest_bg = btrfs_lookup_block_group(fs_info, dest_addr);
+		btrfs_free_reserved_bytes(dest_bg, dest_length, 0);
+		btrfs_put_block_group(dest_bg);
+
+		ret = btrfs_commit_transaction(trans);
+	}
+
+	return ret;
+}
+
+static int move_existing_remaps(struct btrfs_fs_info *fs_info,
+				struct btrfs_block_group *bg,
+				struct btrfs_path *path)
+{
+	int ret;
+	struct btrfs_key key;
+	struct extent_buffer *leaf;
+	struct btrfs_remap_item *remap;
+	u64 old_addr;
+
+	/* Look for backrefs in remap tree. */
+
+	while (bg-&gt;remap_bytes &gt; 0) {
+		key.objectid = bg-&gt;start;
+		key.type = BTRFS_REMAP_BACKREF_KEY;
+		key.offset = 0;
+
+		ret = btrfs_search_slot(NULL, fs_info-&gt;remap_root, &amp;key, path,
+					0, 0);
+		if (ret &lt; 0)
+			return ret;
+
+		leaf = path-&gt;nodes[0];
+
+		if (path-&gt;slots[0] &gt;= btrfs_header_nritems(leaf)) {
+			ret = btrfs_next_leaf(fs_info-&gt;remap_root, path);
+			if (ret &lt; 0) {
+				btrfs_release_path(path);
+				return ret;
+			}
+
+			if (ret) {
+				btrfs_release_path(path);
+				break;
+			}
+
+			leaf = path-&gt;nodes[0];
+		}
+
+		btrfs_item_key_to_cpu(leaf, &amp;key, path-&gt;slots[0]);
+
+		if (key.type != BTRFS_REMAP_BACKREF_KEY) {
+			path-&gt;slots[0]++;
+
+			if (path-&gt;slots[0] &gt;= btrfs_header_nritems(leaf)) {
+				ret = btrfs_next_leaf(fs_info-&gt;remap_root, path);
+				if (ret &lt; 0) {
+					btrfs_release_path(path);
+					return ret;
+				}
+
+				if (ret) {
+					btrfs_release_path(path);
+					break;
+				}
+
+				leaf = path-&gt;nodes[0];
+			}
+		}
+
+		remap = btrfs_item_ptr(leaf, path-&gt;slots[0],
+				       struct btrfs_remap_item);
+
+		old_addr = btrfs_remap_address(leaf, remap);
+
+		btrfs_release_path(path);
+
+		ret = move_existing_remap(fs_info, path, bg, key.objectid,
+					  key.offset, old_addr);
+		if (ret)
+			return ret;
+	}
+
+	ASSERT(bg-&gt;remap_bytes == 0);
+
+	return 0;
+}
+
 static int create_remap_tree_entries(struct btrfs_trans_handle *trans,
 				     struct btrfs_path *path,
 				     struct btrfs_block_group *bg)
@@ -4639,6 +5114,12 @@ int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start,
 	WARN_ON(ret &amp;&amp; ret != -EAGAIN);
 
 	if (should_relocate_using_remap_tree(bg)) {
+		if (bg-&gt;remap_bytes != 0) {
+			ret = move_existing_remaps(fs_info, bg, path);
+			if (ret)
+				goto out;
+		}
+
 		ret = start_block_group_remapping(fs_info, path, bg);
 	} else {
 		ret = do_nonremap_reloc(fs_info, verbose, rc);
-- 
2.51.2



---

Handle the preliminary work for relocating a block group in a filesystem
with the remap-tree flag set.

If the block group is SYSTEM btrfs_relocate_block_group() proceeds as it
does already, as bootstrapping issues mean that these block groups have
to be processed the existing way. Similarly with METADATA_REMAP blocks, which
are dealt with in a later patch.

Otherwise we walk the free-space tree for the block group in question,
recording any holes. These get converted into identity remaps and placed
in the remap tree, and the block group&#x27;s REMAPPED flag is set. From now
on no new allocations are possible within this block group, and any I/O
to it will be funnelled through btrfs_translate_remap(). We store the
number of identity remaps in `identity_remap_count`, so that we know
when we&#x27;ve removed the last one and the block group is fully remapped.

The change in btrfs_read_roots() is because data relocations no longer
rely on the data reloc tree as a hidden subvolume in which to do
snapshots.

(Thanks to Sun YangKai for his suggestions.)

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/block-group.c     |   6 +-
 fs/btrfs/block-group.h     |   4 +
 fs/btrfs/free-space-tree.c |   4 +-
 fs/btrfs/free-space-tree.h |   5 +-
 fs/btrfs/relocation.c      | 516 +++++++++++++++++++++++++++++++++----
 fs/btrfs/relocation.h      |  11 +
 fs/btrfs/space-info.c      |   9 +-
 fs/btrfs/volumes.c         |  89 ++++---
 8 files changed, 551 insertions(+), 93 deletions(-)

diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.c
index 0143b0290a72..2b3fd80a690f 100644
--- a/fs/btrfs/block-group.c
+++ b/fs/btrfs/block-group.c
@@ -2405,6 +2405,7 @@ static int read_one_block_group(struct btrfs_fs_info *info,
 	cache-&gt;used = btrfs_stack_block_group_v2_used(bgi);
 	cache-&gt;last_used = cache-&gt;used;
 	cache-&gt;flags = btrfs_stack_block_group_v2_flags(bgi);
+	cache-&gt;last_flags = cache-&gt;flags;
 	cache-&gt;global_root_id = btrfs_stack_block_group_v2_chunk_objectid(bgi);
 	cache-&gt;space_info = btrfs_find_space_info(info, cache-&gt;flags);
 	cache-&gt;remap_bytes = btrfs_stack_block_group_v2_remap_bytes(bgi);
@@ -2714,6 +2715,7 @@ static int insert_block_group_item(struct btrfs_trans_handle *trans,
 	block_group-&gt;last_remap_bytes = block_group-&gt;remap_bytes;
 	block_group-&gt;last_identity_remap_count =
 		block_group-&gt;identity_remap_count;
+	block_group-&gt;last_flags = block_group-&gt;flags;
 	key.objectid = block_group-&gt;start;
 	key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;
 	key.offset = block_group-&gt;length;
@@ -3202,13 +3204,15 @@ static int update_block_group_item(struct btrfs_trans_handle *trans,
 	/* No change in values, can safely skip it. */
 	if (cache-&gt;last_used == used &amp;&amp;
 	    cache-&gt;last_remap_bytes == remap_bytes &amp;&amp;
-	    cache-&gt;last_identity_remap_count == identity_remap_count) {
+	    cache-&gt;last_identity_remap_count == identity_remap_count &amp;&amp;
+	    cache-&gt;last_flags == cache-&gt;flags) {
 		spin_unlock(&amp;cache-&gt;lock);
 		return 0;
 	}
 	cache-&gt;last_used = used;
 	cache-&gt;last_remap_bytes = remap_bytes;
 	cache-&gt;last_identity_remap_count = identity_remap_count;
+	cache-&gt;last_flags = cache-&gt;flags;
 	spin_unlock(&amp;cache-&gt;lock);
 
 	key.objectid = cache-&gt;start;
diff --git a/fs/btrfs/block-group.h b/fs/btrfs/block-group.h
index 436d51a707a9..3e8c3d424481 100644
--- a/fs/btrfs/block-group.h
+++ b/fs/btrfs/block-group.h
@@ -147,6 +147,10 @@ struct btrfs_block_group {
 	 * The last commited identity_remap_count value of this block group.
 	 */
 	u32 last_identity_remap_count;
+	/*
+	 * The last committed flags value for this block group.
+	 */
+	u64 last_flags;
 
 	/*
 	 * If the free space extent count exceeds this number, convert the block
diff --git a/fs/btrfs/free-space-tree.c b/fs/btrfs/free-space-tree.c
index ac092898130f..96d52c031977 100644
--- a/fs/btrfs/free-space-tree.c
+++ b/fs/btrfs/free-space-tree.c
@@ -21,8 +21,7 @@ static int __add_block_group_free_space(struct btrfs_trans_handle *trans,
 					struct btrfs_block_group *block_group,
 					struct btrfs_path *path);
 
-static struct btrfs_root *btrfs_free_space_root(
-				struct btrfs_block_group *block_group)
+struct btrfs_root *btrfs_free_space_root(struct btrfs_block_group *block_group)
 {
 	struct btrfs_key key = {
 		.objectid = BTRFS_FREE_SPACE_TREE_OBJECTID,
@@ -93,7 +92,6 @@ static int add_new_free_space_info(struct btrfs_trans_handle *trans,
 	return 0;
 }
 
-EXPORT_FOR_TESTS
 struct btrfs_free_space_info *btrfs_search_free_space_info(
 		struct btrfs_trans_handle *trans,
 		struct btrfs_block_group *block_group,
diff --git a/fs/btrfs/free-space-tree.h b/fs/btrfs/free-space-tree.h
index ca04fc7cf29e..709730e36888 100644
--- a/fs/btrfs/free-space-tree.h
+++ b/fs/btrfs/free-space-tree.h
@@ -36,12 +36,13 @@ int btrfs_add_to_free_space_tree(struct btrfs_trans_handle *trans,
 int btrfs_remove_from_free_space_tree(struct btrfs_trans_handle *trans,
 				      u64 start, u64 size);
 int btrfs_delete_orphan_free_space_entries(struct btrfs_fs_info *fs_info);
-
-#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
 struct btrfs_free_space_info *
 btrfs_search_free_space_info(struct btrfs_trans_handle *trans,
 			     struct btrfs_block_group *block_group,
 			     struct btrfs_path *path, int cow);
+struct btrfs_root *btrfs_free_space_root(struct btrfs_block_group *block_group);
+
+#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
 int __btrfs_add_to_free_space_tree(struct btrfs_trans_handle *trans,
 				   struct btrfs_block_group *block_group,
 				   struct btrfs_path *path, u64 start, u64 size);
diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index e47234d5a156..143eede52be0 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -3616,7 +3616,7 @@ static noinline_for_stack int relocate_block_group(struct reloc_control *rc)
 		btrfs_btree_balance_dirty(fs_info);
 	}
 
-	if (!err) {
+	if (!err &amp;&amp; !btrfs_fs_incompat(fs_info, REMAP_TREE)) {
 		ret = relocate_file_extent_cluster(rc);
 		if (ret &lt; 0)
 			err = ret;
@@ -3860,6 +3860,90 @@ static const char *stage_to_string(enum reloc_stage stage)
 	return &quot;unknown&quot;;
 }
 
+static int add_remap_tree_entries(struct btrfs_trans_handle *trans,
+				  struct btrfs_path *path,
+				  struct btrfs_key *entries,
+				  unsigned int num_entries)
+{
+	int ret;
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_item_batch batch;
+	u32 *data_sizes;
+	u32 max_items;
+
+	max_items = BTRFS_LEAF_DATA_SIZE(trans-&gt;fs_info) / sizeof(struct btrfs_item);
+
+	data_sizes = kzalloc(sizeof(u32) * min_t(u32, num_entries, max_items),
+			     GFP_NOFS);
+	if (!data_sizes)
+		return -ENOMEM;
+
+	while (true) {
+		batch.keys = entries;
+		batch.data_sizes = data_sizes;
+		batch.total_data_size = 0;
+		batch.nr = min_t(u32, num_entries, max_items);
+
+		ret = btrfs_insert_empty_items(trans, fs_info-&gt;remap_root, path,
+					       &amp;batch);
+		btrfs_release_path(path);
+
+		if (num_entries &lt;= max_items)
+			break;
+
+		num_entries -= max_items;
+		entries += max_items;
+	}
+
+	kfree(data_sizes);
+
+	return ret;
+}
+
+struct space_run {
+	u64 start;
+	u64 end;
+};
+
+static void parse_bitmap(u64 block_size, const unsigned long *bitmap,
+			 unsigned long size, u64 address,
+			 struct space_run *space_runs,
+			 unsigned int *num_space_runs)
+{
+	unsigned long pos, end;
+	u64 run_start, run_length;
+
+	pos = find_first_bit(bitmap, size);
+
+	if (pos == size)
+		return;
+
+	while (true) {
+		end = find_next_zero_bit(bitmap, size, pos);
+
+		run_start = address + (pos * block_size);
+		run_length = (end - pos) * block_size;
+
+		if (*num_space_runs != 0 &amp;&amp;
+		    space_runs[*num_space_runs - 1].end == run_start) {
+			space_runs[*num_space_runs - 1].end += run_length;
+		} else {
+			space_runs[*num_space_runs].start = run_start;
+			space_runs[*num_space_runs].end = run_start + run_length;
+
+			(*num_space_runs)++;
+		}
+
+		if (end == size)
+			break;
+
+		pos = find_next_bit(bitmap, size, end + 1);
+
+		if (pos == size)
+			break;
+	}
+}
+
 static void adjust_block_group_remap_bytes(struct btrfs_trans_handle *trans,
 					   struct btrfs_block_group *bg,
 					   s64 diff)
@@ -3892,6 +3976,188 @@ static void adjust_block_group_remap_bytes(struct btrfs_trans_handle *trans,
 		btrfs_inc_delayed_refs_rsv_bg_updates(fs_info);
 }
 
+static int create_remap_tree_entries(struct btrfs_trans_handle *trans,
+				     struct btrfs_path *path,
+				     struct btrfs_block_group *bg)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_free_space_info *fsi;
+	struct btrfs_key key, found_key;
+	struct extent_buffer *leaf;
+	struct btrfs_root *space_root;
+	u32 extent_count;
+	struct space_run *space_runs = NULL;
+	unsigned int num_space_runs = 0;
+	struct btrfs_key *entries = NULL;
+	unsigned int max_entries, num_entries;
+	int ret;
+
+	mutex_lock(&amp;bg-&gt;free_space_lock);
+
+	if (test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE, &amp;bg-&gt;runtime_flags)) {
+		mutex_unlock(&amp;bg-&gt;free_space_lock);
+
+		ret = btrfs_add_block_group_free_space(trans, bg);
+		if (ret)
+			return ret;
+
+		mutex_lock(&amp;bg-&gt;free_space_lock);
+	}
+
+	fsi = btrfs_search_free_space_info(trans, bg, path, 0);
+	if (IS_ERR(fsi)) {
+		mutex_unlock(&amp;bg-&gt;free_space_lock);
+		return PTR_ERR(fsi);
+	}
+
+	extent_count = btrfs_free_space_extent_count(path-&gt;nodes[0], fsi);
+
+	btrfs_release_path(path);
+
+	space_runs = kmalloc(sizeof(*space_runs) * extent_count, GFP_NOFS);
+	if (!space_runs) {
+		mutex_unlock(&amp;bg-&gt;free_space_lock);
+		return -ENOMEM;
+	}
+
+	key.objectid = bg-&gt;start;
+	key.type = 0;
+	key.offset = 0;
+
+	space_root = btrfs_free_space_root(bg);
+
+	ret = btrfs_search_slot(trans, space_root, &amp;key, path, 0, 0);
+	if (ret &lt; 0) {
+		mutex_unlock(&amp;bg-&gt;free_space_lock);
+		goto out;
+	}
+
+	ret = 0;
+
+	while (true) {
+		leaf = path-&gt;nodes[0];
+
+		btrfs_item_key_to_cpu(leaf, &amp;found_key, path-&gt;slots[0]);
+
+		if (found_key.objectid &gt;= bg-&gt;start + bg-&gt;length)
+			break;
+
+		if (found_key.type == BTRFS_FREE_SPACE_EXTENT_KEY) {
+			if (num_space_runs != 0 &amp;&amp;
+			    space_runs[num_space_runs - 1].end == found_key.objectid) {
+				space_runs[num_space_runs - 1].end =
+					found_key.objectid + found_key.offset;
+			} else {
+				ASSERT(num_space_runs &lt; extent_count);
+
+				space_runs[num_space_runs].start = found_key.objectid;
+				space_runs[num_space_runs].end =
+					found_key.objectid + found_key.offset;
+
+				num_space_runs++;
+			}
+		} else if (found_key.type == BTRFS_FREE_SPACE_BITMAP_KEY) {
+			void *bitmap;
+			unsigned long offset;
+			u32 data_size;
+
+			offset = btrfs_item_ptr_offset(leaf, path-&gt;slots[0]);
+			data_size = btrfs_item_size(leaf, path-&gt;slots[0]);
+
+			if (data_size != 0) {
+				bitmap = kmalloc(data_size, GFP_NOFS);
+				if (!bitmap) {
+					mutex_unlock(&amp;bg-&gt;free_space_lock);
+					ret = -ENOMEM;
+					goto out;
+				}
+
+				read_extent_buffer(leaf, bitmap, offset,
+						   data_size);
+
+				parse_bitmap(fs_info-&gt;sectorsize, bitmap,
+					     data_size * BITS_PER_BYTE,
+					     found_key.objectid, space_runs,
+					     &amp;num_space_runs);
+
+				ASSERT(num_space_runs &lt;= extent_count);
+
+				kfree(bitmap);
+			}
+		}
+
+		path-&gt;slots[0]++;
+
+		if (path-&gt;slots[0] &gt;= btrfs_header_nritems(leaf)) {
+			ret = btrfs_next_leaf(space_root, path);
+			if (ret != 0) {
+				if (ret == 1)
+					ret = 0;
+				break;
+			}
+			leaf = path-&gt;nodes[0];
+		}
+	}
+
+	btrfs_release_path(path);
+
+	mutex_unlock(&amp;bg-&gt;free_space_lock);
+
+	max_entries = extent_count + 2;
+	entries = kmalloc(sizeof(*entries) * max_entries, GFP_NOFS);
+	if (!entries) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	num_entries = 0;
+
+	if (num_space_runs == 0) {
+		entries[num_entries].objectid = bg-&gt;start;
+		entries[num_entries].type = BTRFS_IDENTITY_REMAP_KEY;
+		entries[num_entries].offset = bg-&gt;length;
+		num_entries++;
+	} else {
+		if (space_runs[0].start &gt; bg-&gt;start) {
+			entries[num_entries].objectid = bg-&gt;start;
+			entries[num_entries].type = BTRFS_IDENTITY_REMAP_KEY;
+			entries[num_entries].offset =
+				space_runs[0].start - bg-&gt;start;
+			num_entries++;
+		}
+
+		for (unsigned int i = 1; i &lt; num_space_runs; i++) {
+			entries[num_entries].objectid = space_runs[i - 1].end;
+			entries[num_entries].type = BTRFS_IDENTITY_REMAP_KEY;
+			entries[num_entries].offset =
+				space_runs[i].start - space_runs[i - 1].end;
+			num_entries++;
+		}
+
+		if (space_runs[num_space_runs - 1].end &lt; bg-&gt;start + bg-&gt;length) {
+			entries[num_entries].objectid =
+				space_runs[num_space_runs - 1].end;
+			entries[num_entries].type = BTRFS_IDENTITY_REMAP_KEY;
+			entries[num_entries].offset =
+				bg-&gt;start + bg-&gt;length - space_runs[num_space_runs - 1].end;
+			num_entries++;
+		}
+
+		if (num_entries == 0)
+			goto out;
+	}
+
+	bg-&gt;identity_remap_count = num_entries;
+
+	ret = add_remap_tree_entries(trans, path, entries, num_entries);
+
+out:
+	kfree(entries);
+	kfree(space_runs);
+
+	return ret;
+}
+
 static int remove_chunk_stripes(struct btrfs_trans_handle *trans,
 				struct btrfs_chunk_map *chunk_map,
 				struct btrfs_path *path)
@@ -4038,6 +4304,55 @@ static void adjust_identity_remap_count(struct btrfs_trans_handle *trans,
 		btrfs_mark_bg_fully_remapped(bg, trans);
 }
 
+static int mark_chunk_remapped(struct btrfs_trans_handle *trans,
+			       struct btrfs_path *path, uint64_t start)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_chunk_map *chunk_map;
+	struct btrfs_key key;
+	u64 type;
+	int ret;
+	struct extent_buffer *leaf;
+	struct btrfs_chunk *chunk;
+
+	read_lock(&amp;fs_info-&gt;mapping_tree_lock);
+
+	chunk_map = btrfs_find_chunk_map_nolock(fs_info, start, 1);
+	if (!chunk_map) {
+		read_unlock(&amp;fs_info-&gt;mapping_tree_lock);
+		return -ENOENT;
+	}
+
+	chunk_map-&gt;type |= BTRFS_BLOCK_GROUP_REMAPPED;
+	type = chunk_map-&gt;type;
+
+	read_unlock(&amp;fs_info-&gt;mapping_tree_lock);
+
+	key.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;
+	key.type = BTRFS_CHUNK_ITEM_KEY;
+	key.offset = start;
+
+	ret = btrfs_search_slot(trans, fs_info-&gt;chunk_root, &amp;key, path,
+				0, 1);
+	if (ret == 1) {
+		ret = -ENOENT;
+		goto end;
+	} else if (ret &lt; 0)
+		goto end;
+
+	leaf = path-&gt;nodes[0];
+
+	chunk = btrfs_item_ptr(leaf, path-&gt;slots[0], struct btrfs_chunk);
+	btrfs_set_chunk_type(leaf, chunk, type);
+	btrfs_mark_buffer_dirty(trans, leaf);
+
+	ret = 0;
+end:
+	btrfs_free_chunk_map(chunk_map);
+	btrfs_release_path(path);
+	return ret;
+}
+
 int btrfs_translate_remap(struct btrfs_fs_info *fs_info, u64 *logical,
 			  u64 *length)
 {
@@ -4092,6 +4407,136 @@ int btrfs_translate_remap(struct btrfs_fs_info *fs_info, u64 *logical,
 	return 0;
 }
 
+static int start_block_group_remapping(struct btrfs_fs_info *fs_info,
+				       struct btrfs_path *path,
+				       struct btrfs_block_group *bg)
+{
+	struct btrfs_trans_handle *trans;
+	bool bg_already_dirty = true;
+	int ret, ret2;
+
+	ret = btrfs_cache_block_group(bg, true);
+	if (ret)
+		return ret;
+
+	trans = btrfs_start_transaction(fs_info-&gt;remap_root, 0);
+	if (IS_ERR(trans))
+		return PTR_ERR(trans);
+
+	/* We need to run delayed refs, to make sure FST is up to date. */
+	ret = btrfs_run_delayed_refs(trans, U64_MAX);
+	if (ret) {
+		btrfs_end_transaction(trans);
+		return ret;
+	}
+
+	mutex_lock(&amp;fs_info-&gt;remap_mutex);
+
+	if (bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED) {
+		ret = 0;
+		goto end;
+	}
+
+	ret = create_remap_tree_entries(trans, path, bg);
+	if (unlikely(ret)) {
+		btrfs_abort_transaction(trans, ret);
+		goto end;
+	}
+
+	spin_lock(&amp;bg-&gt;lock);
+	bg-&gt;flags |= BTRFS_BLOCK_GROUP_REMAPPED;
+	spin_unlock(&amp;bg-&gt;lock);
+
+	spin_lock(&amp;trans-&gt;transaction-&gt;dirty_bgs_lock);
+	if (list_empty(&amp;bg-&gt;dirty_list)) {
+		list_add_tail(&amp;bg-&gt;dirty_list,
+			      &amp;trans-&gt;transaction-&gt;dirty_bgs);
+		bg_already_dirty = false;
+		btrfs_get_block_group(bg);
+	}
+	spin_unlock(&amp;trans-&gt;transaction-&gt;dirty_bgs_lock);
+
+	/* Modified block groups are accounted for in the delayed_refs_rsv. */
+	if (!bg_already_dirty)
+		btrfs_inc_delayed_refs_rsv_bg_updates(fs_info);
+
+	ret = mark_chunk_remapped(trans, path, bg-&gt;start);
+	if (unlikely(ret)) {
+		btrfs_abort_transaction(trans, ret);
+		goto end;
+	}
+
+	ret = btrfs_remove_block_group_free_space(trans, bg);
+	if (unlikely(ret)) {
+		btrfs_abort_transaction(trans, ret);
+		goto end;
+	}
+
+	btrfs_remove_free_space_cache(bg);
+
+end:
+	mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+
+	ret2 = btrfs_end_transaction(trans);
+	if (!ret)
+		ret = ret2;
+
+	return ret;
+}
+
+static int do_nonremap_reloc(struct btrfs_fs_info *fs_info, bool verbose,
+			     struct reloc_control *rc)
+{
+	int ret;
+
+	while (1) {
+		enum reloc_stage finishes_stage;
+
+		mutex_lock(&amp;fs_info-&gt;cleaner_mutex);
+		ret = relocate_block_group(rc);
+		mutex_unlock(&amp;fs_info-&gt;cleaner_mutex);
+
+		finishes_stage = rc-&gt;stage;
+		/*
+		 * We may have gotten ENOSPC after we already dirtied some
+		 * extents.  If writeout happens while we&#x27;re relocating a
+		 * different block group we could end up hitting the
+		 * BUG_ON(rc-&gt;stage == UPDATE_DATA_PTRS) in
+		 * btrfs_reloc_cow_block.  Make sure we write everything out
+		 * properly so we don&#x27;t trip over this problem, and then break
+		 * out of the loop if we hit an error.
+		 */
+		if (rc-&gt;stage == MOVE_DATA_EXTENTS &amp;&amp; rc-&gt;found_file_extent) {
+			int wb_ret;
+
+			wb_ret = btrfs_wait_ordered_range(BTRFS_I(rc-&gt;data_inode),
+								0, (u64)-1);
+			if (wb_ret &amp;&amp; ret == 0)
+				ret = wb_ret;
+			invalidate_mapping_pages(rc-&gt;data_inode-&gt;i_mapping,
+							0, -1);
+			rc-&gt;stage = UPDATE_DATA_PTRS;
+		}
+
+		if (ret &lt; 0)
+			return ret;
+
+		if (rc-&gt;extents_found == 0)
+			break;
+
+		if (verbose)
+			btrfs_info(fs_info, &quot;found %llu extents, stage: %s&quot;,
+				   rc-&gt;extents_found,
+				   stage_to_string(finishes_stage));
+	}
+
+	WARN_ON(rc-&gt;block_group-&gt;pinned &gt; 0);
+	WARN_ON(rc-&gt;block_group-&gt;reserved &gt; 0);
+	WARN_ON(rc-&gt;block_group-&gt;used &gt; 0);
+
+	return 0;
+}
+
 /*
  * function to relocate all extents in a block group.
  */
@@ -4102,7 +4547,7 @@ int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start,
 	struct btrfs_root *extent_root = btrfs_extent_root(fs_info, group_start);
 	struct reloc_control *rc;
 	struct inode *inode;
-	struct btrfs_path *path;
+	struct btrfs_path *path = NULL;
 	int ret;
 	bool bg_is_ro = false;
 
@@ -4164,7 +4609,7 @@ int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start,
 	}
 
 	inode = lookup_free_space_inode(rc-&gt;block_group, path);
-	btrfs_free_path(path);
+	btrfs_release_path(path);
 
 	if (!IS_ERR(inode))
 		ret = delete_block_group_cache(rc-&gt;block_group, inode, 0);
@@ -4174,11 +4619,13 @@ int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start,
 	if (ret &amp;&amp; ret != -ENOENT)
 		goto out;
 
-	rc-&gt;data_inode = create_reloc_inode(rc-&gt;block_group);
-	if (IS_ERR(rc-&gt;data_inode)) {
-		ret = PTR_ERR(rc-&gt;data_inode);
-		rc-&gt;data_inode = NULL;
-		goto out;
+	if (!btrfs_fs_incompat(fs_info, REMAP_TREE)) {
+		rc-&gt;data_inode = create_reloc_inode(rc-&gt;block_group);
+		if (IS_ERR(rc-&gt;data_inode)) {
+			ret = PTR_ERR(rc-&gt;data_inode);
+			rc-&gt;data_inode = NULL;
+			goto out;
+		}
 	}
 
 	if (verbose)
@@ -4191,54 +4638,17 @@ int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start,
 	ret = btrfs_zone_finish(rc-&gt;block_group);
 	WARN_ON(ret &amp;&amp; ret != -EAGAIN);
 
-	while (1) {
-		enum reloc_stage finishes_stage;
-
-		mutex_lock(&amp;fs_info-&gt;cleaner_mutex);
-		ret = relocate_block_group(rc);
-		mutex_unlock(&amp;fs_info-&gt;cleaner_mutex);
-
-		finishes_stage = rc-&gt;stage;
-		/*
-		 * We may have gotten ENOSPC after we already dirtied some
-		 * extents.  If writeout happens while we&#x27;re relocating a
-		 * different block group we could end up hitting the
-		 * BUG_ON(rc-&gt;stage == UPDATE_DATA_PTRS) in
-		 * btrfs_reloc_cow_block.  Make sure we write everything out
-		 * properly so we don&#x27;t trip over this problem, and then break
-		 * out of the loop if we hit an error.
-		 */
-		if (rc-&gt;stage == MOVE_DATA_EXTENTS &amp;&amp; rc-&gt;found_file_extent) {
-			int wb_ret;
-
-			wb_ret = btrfs_wait_ordered_range(BTRFS_I(rc-&gt;data_inode), 0,
-							  (u64)-1);
-			if (wb_ret &amp;&amp; ret == 0)
-				ret = wb_ret;
-			invalidate_mapping_pages(rc-&gt;data_inode-&gt;i_mapping,
-						 0, -1);
-			rc-&gt;stage = UPDATE_DATA_PTRS;
-		}
-
-		if (ret &lt; 0)
-			goto out;
-
-		if (rc-&gt;extents_found == 0)
-			break;
-
-		if (verbose)
-			btrfs_info(fs_info, &quot;found %llu extents, stage: %s&quot;,
-				   rc-&gt;extents_found,
-				   stage_to_string(finishes_stage));
+	if (should_relocate_using_remap_tree(bg)) {
+		ret = start_block_group_remapping(fs_info, path, bg);
+	} else {
+		ret = do_nonremap_reloc(fs_info, verbose, rc);
 	}
-
-	WARN_ON(rc-&gt;block_group-&gt;pinned &gt; 0);
-	WARN_ON(rc-&gt;block_group-&gt;reserved &gt; 0);
-	WARN_ON(rc-&gt;block_group-&gt;used &gt; 0);
 out:
 	if (ret &amp;&amp; bg_is_ro)
 		btrfs_dec_block_group_ro(rc-&gt;block_group);
-	iput(rc-&gt;data_inode);
+	if (!btrfs_fs_incompat(fs_info, REMAP_TREE))
+		iput(rc-&gt;data_inode);
+	btrfs_free_path(path);
 	reloc_chunk_end(fs_info);
 out_put_bg:
 	btrfs_put_block_group(bg);
@@ -4432,7 +4842,7 @@ int btrfs_recover_relocation(struct btrfs_fs_info *fs_info)
 
 	btrfs_free_path(path);
 
-	if (ret == 0) {
+	if (ret == 0 &amp;&amp; !btrfs_fs_incompat(fs_info, REMAP_TREE)) {
 		/* cleanup orphan inode in data relocation tree */
 		fs_root = btrfs_grab_root(fs_info-&gt;data_reloc_root);
 		ASSERT(fs_root);
diff --git a/fs/btrfs/relocation.h b/fs/btrfs/relocation.h
index 0f4874f815db..40d0a67f6f07 100644
--- a/fs/btrfs/relocation.h
+++ b/fs/btrfs/relocation.h
@@ -12,6 +12,17 @@ struct btrfs_trans_handle;
 struct btrfs_ordered_extent;
 struct btrfs_pending_snapshot;
 
+static inline bool should_relocate_using_remap_tree(struct btrfs_block_group *bg)
+{
+	if (!btrfs_fs_incompat(bg-&gt;fs_info, REMAP_TREE))
+		return false;
+
+	if (bg-&gt;flags &amp; (BTRFS_BLOCK_GROUP_SYSTEM | BTRFS_BLOCK_GROUP_METADATA_REMAP))
+		return false;
+
+	return true;
+}
+
 int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start,
 			       bool verbose);
 int btrfs_init_reloc_root(struct btrfs_trans_handle *trans, struct btrfs_root *root);
diff --git a/fs/btrfs/space-info.c b/fs/btrfs/space-info.c
index badebe6e0b34..45c4815b3854 100644
--- a/fs/btrfs/space-info.c
+++ b/fs/btrfs/space-info.c
@@ -376,8 +376,13 @@ void btrfs_add_bg_to_space_info(struct btrfs_fs_info *info,
 	factor = btrfs_bg_type_to_factor(block_group-&gt;flags);
 
 	spin_lock(&amp;space_info-&gt;lock);
-	space_info-&gt;total_bytes += block_group-&gt;length;
-	space_info-&gt;disk_total += block_group-&gt;length * factor;
+
+	if (!(block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED) ||
+	    block_group-&gt;identity_remap_count != 0) {
+		space_info-&gt;total_bytes += block_group-&gt;length;
+		space_info-&gt;disk_total += block_group-&gt;length * factor;
+	}
+
 	space_info-&gt;bytes_used += block_group-&gt;used;
 	space_info-&gt;disk_used += block_group-&gt;used * factor;
 	space_info-&gt;bytes_readonly += block_group-&gt;bytes_super;
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 46c5acc96725..caffee6527b2 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -3405,15 +3405,55 @@ int btrfs_remove_chunk(struct btrfs_trans_handle *trans, u64 chunk_offset)
 	return ret;
 }
 
-int btrfs_relocate_chunk(struct btrfs_fs_info *fs_info, u64 chunk_offset,
-			 bool verbose)
+static int btrfs_relocate_chunk_finish(struct btrfs_fs_info *fs_info,
+				       struct btrfs_block_group *bg)
 {
 	struct btrfs_root *root = fs_info-&gt;chunk_root;
 	struct btrfs_trans_handle *trans;
-	struct btrfs_block_group *block_group;
 	u64 length;
 	int ret;
 
+	btrfs_discard_cancel_work(&amp;fs_info-&gt;discard_ctl, bg);
+	length = bg-&gt;length;
+	btrfs_put_block_group(bg);
+
+	/*
+	 * On a zoned file system, discard the whole block group, this will
+	 * trigger a REQ_OP_ZONE_RESET operation on the device zone. If
+	 * resetting the zone fails, don&#x27;t treat it as a fatal problem from the
+	 * filesystem&#x27;s point of view.
+	 */
+	if (btrfs_is_zoned(fs_info)) {
+		ret = btrfs_discard_extent(fs_info, bg-&gt;start, length,
+					   NULL);
+		if (ret)
+			btrfs_info(fs_info,
+				   &quot;failed to reset zone %llu after relocation&quot;,
+				   bg-&gt;start);
+	}
+
+	trans = btrfs_start_trans_remove_block_group(root-&gt;fs_info, bg-&gt;start);
+	if (IS_ERR(trans)) {
+		ret = PTR_ERR(trans);
+		btrfs_handle_fs_error(root-&gt;fs_info, ret, NULL);
+		return ret;
+	}
+
+	/*
+	 * Step two, delete the device extents and the chunk tree entries.
+	 */
+	ret = btrfs_remove_chunk(trans, bg-&gt;start);
+	btrfs_end_transaction(trans);
+
+	return ret;
+}
+
+int btrfs_relocate_chunk(struct btrfs_fs_info *fs_info, u64 chunk_offset,
+			 bool verbose)
+{
+	struct btrfs_block_group *block_group;
+	int ret;
+
 	if (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {
 		btrfs_err(fs_info,
 			  &quot;relocate: not supported on extent tree v2 yet&quot;);
@@ -3451,38 +3491,15 @@ int btrfs_relocate_chunk(struct btrfs_fs_info *fs_info, u64 chunk_offset,
 	block_group = btrfs_lookup_block_group(fs_info, chunk_offset);
 	if (!block_group)
 		return -ENOENT;
-	btrfs_discard_cancel_work(&amp;fs_info-&gt;discard_ctl, block_group);
-	length = block_group-&gt;length;
-	btrfs_put_block_group(block_group);
-
-	/*
-	 * On a zoned file system, discard the whole block group, this will
-	 * trigger a REQ_OP_ZONE_RESET operation on the device zone. If
-	 * resetting the zone fails, don&#x27;t treat it as a fatal problem from the
-	 * filesystem&#x27;s point of view.
-	 */
-	if (btrfs_is_zoned(fs_info)) {
-		ret = btrfs_discard_extent(fs_info, chunk_offset, length, NULL);
-		if (ret)
-			btrfs_info(fs_info,
-				&quot;failed to reset zone %llu after relocation&quot;,
-				chunk_offset);
-	}
 
-	trans = btrfs_start_trans_remove_block_group(root-&gt;fs_info,
-						     chunk_offset);
-	if (IS_ERR(trans)) {
-		ret = PTR_ERR(trans);
-		btrfs_handle_fs_error(root-&gt;fs_info, ret, NULL);
-		return ret;
+	if (should_relocate_using_remap_tree(block_group)) {
+		/* If we&#x27;re relocating using the remap tree we&#x27;re now done. */
+		btrfs_put_block_group(block_group);
+		ret = 0;
+	} else {
+		ret = btrfs_relocate_chunk_finish(fs_info, block_group);
 	}
 
-	/*
-	 * step two, delete the device extents and the
-	 * chunk tree entries
-	 */
-	ret = btrfs_remove_chunk(trans, chunk_offset);
-	btrfs_end_transaction(trans);
 	return ret;
 }
 
@@ -4155,6 +4172,14 @@ static int __btrfs_balance(struct btrfs_fs_info *fs_info)
 		chunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);
 		chunk_type = btrfs_chunk_type(leaf, chunk);
 
+		/* Check if chunk has already been fully relocated. */
+		if (chunk_type &amp; BTRFS_BLOCK_GROUP_REMAPPED &amp;&amp;
+		    btrfs_chunk_num_stripes(leaf, chunk) == 0) {
+			btrfs_release_path(path);
+			mutex_unlock(&amp;fs_info-&gt;reclaim_bgs_lock);
+			goto loop;
+		}
+
 		if (!counting) {
 			spin_lock(&amp;fs_info-&gt;balance_lock);
 			bctl-&gt;stat.considered++;
-- 
2.51.2



---

Add a function btrfs_populate_fully_remapped_bgs_list() which gets
called on mount, which looks for fully remapped block groups
(i.e. identity_remap_count == 0) which haven&#x27;t yet had their chunk
stripes and device extents removed.

This happens when a filesystem is unmounted while async discard has not
yet finished, as otherwise the data range occupied by the chunk stripes
would be permanently unusable.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/block-group.c      | 79 +++++++++++++++++++++++++++++++++++++
 fs/btrfs/block-group.h      |  2 +
 fs/btrfs/disk-io.c          |  9 +++++
 fs/btrfs/free-space-cache.c | 18 +++++++++
 fs/btrfs/relocation.c       |  4 ++
 5 files changed, 112 insertions(+)

diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.c
index 47454c22d6f4..1f5101f40b8c 100644
--- a/fs/btrfs/block-group.c
+++ b/fs/btrfs/block-group.c
@@ -4815,6 +4815,11 @@ void btrfs_mark_bg_fully_remapped(struct btrfs_block_group *bg,
 	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
 
 	if (btrfs_test_opt(fs_info, DISCARD_ASYNC)) {
+		spin_lock(&amp;bg-&gt;lock);
+		set_bit(BLOCK_GROUP_FLAG_STRIPE_REMOVAL_PENDING,
+			&amp;bg-&gt;runtime_flags);
+		spin_unlock(&amp;bg-&gt;lock);
+
 		btrfs_discard_queue_work(&amp;fs_info-&gt;discard_ctl, bg);
 	} else {
 		spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
@@ -4834,3 +4839,77 @@ void btrfs_mark_bg_fully_remapped(struct btrfs_block_group *bg,
 		spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
 	}
 }
+
+/*
+ * Compare the block group and chunk trees, and find any fully-remapped block
+ * groups which haven&#x27;t yet had their chunk stripes and device extents removed,
+ * and put them on the fully_remapped_bgs list so this gets done.
+ *
+ * This happens when a block group becomes fully remapped, i.e. its last
+ * identity mapping is removed, and the volume is unmounted before async
+ * discard has finished. It&#x27;s important this gets done as until it is the
+ * chunk&#x27;s stripes are dead space.
+ */
+int btrfs_populate_fully_remapped_bgs_list(struct btrfs_fs_info *fs_info)
+{
+	struct rb_node *node_bg, *node_chunk;
+
+	node_bg = rb_first_cached(&amp;fs_info-&gt;block_group_cache_tree);
+	node_chunk = rb_first_cached(&amp;fs_info-&gt;mapping_tree);
+
+	while (node_bg &amp;&amp; node_chunk) {
+		struct btrfs_block_group *bg;
+		struct btrfs_chunk_map *map;
+
+		bg = rb_entry(node_bg, struct btrfs_block_group, cache_node);
+		map = rb_entry(node_chunk, struct btrfs_chunk_map, rb_node);
+
+		ASSERT(bg-&gt;start == map-&gt;start);
+
+		if (!(bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED))
+			goto next;
+
+		if (bg-&gt;identity_remap_count != 0)
+			goto next;
+
+		if (map-&gt;num_stripes == 0)
+			goto next;
+
+		spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
+
+		if (list_empty(&amp;bg-&gt;bg_list)) {
+			btrfs_get_block_group(bg);
+			list_add_tail(&amp;bg-&gt;bg_list,
+				      &amp;fs_info-&gt;fully_remapped_bgs);
+		} else {
+			list_move_tail(&amp;bg-&gt;bg_list,
+				       &amp;fs_info-&gt;fully_remapped_bgs);
+		}
+
+		spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+
+		/*
+		 * Ideally we&#x27;d want to call btrfs_discard_queue_work() here,
+		 * but it&#x27;d do nothing as the discard worker hasn&#x27;t been
+		 * started yet.
+		 *
+		 * The block group will get added to the discard list when
+		 * btrfs_handle_fully_remapped_bgs() gets called, when we
+		 * commit the first transaction.
+		 */
+		if (btrfs_test_opt(fs_info, DISCARD_ASYNC)) {
+			spin_lock(&amp;bg-&gt;lock);
+			set_bit(BLOCK_GROUP_FLAG_STRIPE_REMOVAL_PENDING,
+				&amp;bg-&gt;runtime_flags);
+			spin_unlock(&amp;bg-&gt;lock);
+		}
+
+next:
+		node_bg = rb_next(node_bg);
+		node_chunk = rb_next(node_chunk);
+	}
+
+	ASSERT(!node_bg &amp;&amp; !node_chunk);
+
+	return 0;
+}
diff --git a/fs/btrfs/block-group.h b/fs/btrfs/block-group.h
index 3117cebf02f5..ccca6ee517a9 100644
--- a/fs/btrfs/block-group.h
+++ b/fs/btrfs/block-group.h
@@ -94,6 +94,7 @@ enum btrfs_block_group_flags {
 	 */
 	BLOCK_GROUP_FLAG_NEW,
 	BLOCK_GROUP_FLAG_FULLY_REMAPPED,
+	BLOCK_GROUP_FLAG_STRIPE_REMOVAL_PENDING,
 };
 
 enum btrfs_caching_type {
@@ -416,5 +417,6 @@ int btrfs_use_block_group_size_class(struct btrfs_block_group *bg,
 bool btrfs_block_group_should_use_size_class(const struct btrfs_block_group *bg);
 void btrfs_mark_bg_fully_remapped(struct btrfs_block_group *bg,
 				  struct btrfs_trans_handle *trans);
+int btrfs_populate_fully_remapped_bgs_list(struct btrfs_fs_info *fs_info);
 
 #endif /* BTRFS_BLOCK_GROUP_H */
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index ba500e3bf0d8..0491b799148f 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -3613,6 +3613,15 @@ int __cold open_ctree(struct super_block *sb, struct btrfs_fs_devices *fs_device
 		goto fail_sysfs;
 	}
 
+	if (btrfs_fs_incompat(fs_info, REMAP_TREE)) {
+		ret = btrfs_populate_fully_remapped_bgs_list(fs_info);
+		if (ret) {
+			btrfs_err(fs_info,
+			&quot;failed to populate fully_remapped_bgs list: %d&quot;, ret);
+			goto fail_sysfs;
+		}
+	}
+
 	btrfs_zoned_reserve_data_reloc_bg(fs_info);
 	btrfs_free_zone_cache(fs_info);
 
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index e15fa8567f7c..7f7744a78de2 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -3068,6 +3068,7 @@ bool btrfs_is_free_space_trimmed(struct btrfs_block_group *block_group)
 	bool ret = true;
 
 	if (block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED &amp;&amp;
+	    !test_bit(BLOCK_GROUP_FLAG_STRIPE_REMOVAL_PENDING, &amp;block_group-&gt;runtime_flags) &amp;&amp;
 	    block_group-&gt;identity_remap_count == 0) {
 		return true;
 	}
@@ -3849,6 +3850,23 @@ void btrfs_trim_fully_remapped_block_group(struct btrfs_block_group *bg)
 	const u64 max_discard_size = READ_ONCE(discard_ctl-&gt;max_discard_size);
 	u64 end = btrfs_block_group_end(bg);
 
+	if (!test_bit(BLOCK_GROUP_FLAG_STRIPE_REMOVAL_PENDING, &amp;bg-&gt;runtime_flags)) {
+		bg-&gt;discard_cursor = end;
+
+		if (bg-&gt;used == 0) {
+			spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
+			if (!list_empty(&amp;bg-&gt;bg_list)) {
+				list_del_init(&amp;bg-&gt;bg_list);
+				btrfs_put_block_group(bg);
+			}
+			spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+
+			btrfs_mark_bg_unused(bg);
+		}
+
+		return;
+	}
+
 	bytes = end - bg-&gt;discard_cursor;
 
 	if (max_discard_size &amp;&amp;
diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 20cf0f7fd401..c3f1b7828179 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -4785,6 +4785,10 @@ int btrfs_last_identity_remap_gone(struct btrfs_chunk_map *chunk_map,
 
 	btrfs_remove_bg_from_sinfo(bg);
 
+	spin_lock(&amp;bg-&gt;lock);
+	clear_bit(BLOCK_GROUP_FLAG_STRIPE_REMOVAL_PENDING, &amp;bg-&gt;runtime_flags);
+	spin_unlock(&amp;bg-&gt;lock);
+
 	ret = remove_chunk_stripes(trans, chunk_map, path);
 	if (unlikely(ret)) {
 		btrfs_abort_transaction(trans, ret);
-- 
2.51.2



---

Balancing the METADATA_REMAP chunk, i.e. the chunk in which the remap tree
lives, is a special case.

We can&#x27;t use the remap tree itself for this, as then we&#x27;d have no way to
boostrap it on mount. And we can&#x27;t use the pre-remap tree code for this
as it relies on walking the extent tree, and we&#x27;re not creating backrefs
for METADATA_REMAP chunks.

So instead, if a balance would relocate any METADATA_REMAP block groups, mark
those block groups as readonly and COW every leaf of the remap tree.

There&#x27;s more sophisticated ways of doing this, such as only COWing nodes
within a block group that&#x27;s to be relocated, but they&#x27;re fiddly and with
lots of edge cases. Plus it&#x27;s not anticipated that a) the number of
METADATA_REMAP chunks is going to be particularly large, or b) that users will
want to only relocate some of these chunks - the main use case here is
to unbreak RAID conversion and device removal.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/volumes.c | 159 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 155 insertions(+), 4 deletions(-)

diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index b0aef4d489e7..96a3c0752f91 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -4000,8 +4000,11 @@ static bool should_balance_chunk(struct extent_buffer *leaf, struct btrfs_chunk
 	struct btrfs_balance_args *bargs = NULL;
 	u64 chunk_type = btrfs_chunk_type(leaf, chunk);
 
-	if (chunk_type &amp; BTRFS_BLOCK_GROUP_METADATA_REMAP)
-		return false;
+	/* Treat METADATA_REMAP chunks as METADATA. */
+	if (chunk_type &amp; BTRFS_BLOCK_GROUP_METADATA_REMAP) {
+		chunk_type &amp;= ~BTRFS_BLOCK_GROUP_METADATA_REMAP;
+		chunk_type |= BTRFS_BLOCK_GROUP_METADATA;
+	}
 
 	/* type filter */
 	if (!((chunk_type &amp; BTRFS_BLOCK_GROUP_TYPE_MASK) &amp;
@@ -4084,6 +4087,113 @@ static bool should_balance_chunk(struct extent_buffer *leaf, struct btrfs_chunk
 	return true;
 }
 
+struct remap_chunk_info {
+	struct list_head list;
+	u64 offset;
+	struct btrfs_block_group *bg;
+	bool made_ro;
+};
+
+static int cow_remap_tree(struct btrfs_trans_handle *trans,
+			  struct btrfs_path *path)
+{
+	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
+	struct btrfs_key key = { 0 };
+	int ret;
+
+	ret = btrfs_search_slot(trans, fs_info-&gt;remap_root, &amp;key, path, 0, 1);
+	if (ret &lt; 0)
+		return ret;
+
+	while (true) {
+		ret = btrfs_next_leaf(fs_info-&gt;remap_root, path);
+		if (ret &lt; 0) {
+			return ret;
+		} else if (ret &gt; 0) {
+			ret = 0;
+			break;
+		}
+
+		btrfs_item_key_to_cpu(path-&gt;nodes[0], &amp;key, path-&gt;slots[0]);
+
+		btrfs_release_path(path);
+
+		ret = btrfs_search_slot(trans, fs_info-&gt;remap_root, &amp;key, path,
+					0, 1);
+		if (ret &lt; 0)
+			break;
+	}
+
+	return ret;
+}
+
+static int balance_remap_chunks(struct btrfs_fs_info *fs_info,
+				struct btrfs_path *path,
+				struct list_head *chunks)
+{
+	struct remap_chunk_info *rci, *tmp;
+	struct btrfs_trans_handle *trans;
+	int ret;
+
+	list_for_each_entry_safe(rci, tmp, chunks, list) {
+		rci-&gt;bg = btrfs_lookup_block_group(fs_info, rci-&gt;offset);
+		if (!rci-&gt;bg) {
+			list_del(&amp;rci-&gt;list);
+			kfree(rci);
+			continue;
+		}
+
+		ret = btrfs_inc_block_group_ro(rci-&gt;bg, false);
+		if (ret)
+			goto end;
+
+		rci-&gt;made_ro = true;
+	}
+
+	if (list_empty(chunks))
+		return 0;
+
+	trans = btrfs_start_transaction(fs_info-&gt;remap_root, 0);
+	if (IS_ERR(trans)) {
+		ret = PTR_ERR(trans);
+		goto end;
+	}
+
+	mutex_lock(&amp;fs_info-&gt;remap_mutex);
+
+	ret = cow_remap_tree(trans, path);
+
+	mutex_unlock(&amp;fs_info-&gt;remap_mutex);
+
+	btrfs_release_path(path);
+
+	btrfs_commit_transaction(trans);
+
+end:
+	while (!list_empty(chunks)) {
+		bool is_unused;
+
+		rci = list_first_entry(chunks, struct remap_chunk_info, list);
+
+		spin_lock(&amp;rci-&gt;bg-&gt;lock);
+		is_unused = !btrfs_is_block_group_used(rci-&gt;bg);
+		spin_unlock(&amp;rci-&gt;bg-&gt;lock);
+
+		if (is_unused)
+			btrfs_mark_bg_unused(rci-&gt;bg);
+
+		if (rci-&gt;made_ro)
+			btrfs_dec_block_group_ro(rci-&gt;bg);
+
+		btrfs_put_block_group(rci-&gt;bg);
+
+		list_del(&amp;rci-&gt;list);
+		kfree(rci);
+	}
+
+	return ret;
+}
+
 static int __btrfs_balance(struct btrfs_fs_info *fs_info)
 {
 	struct btrfs_balance_control *bctl = fs_info-&gt;balance_ctl;
@@ -4106,6 +4216,9 @@ static int __btrfs_balance(struct btrfs_fs_info *fs_info)
 	u32 count_meta = 0;
 	u32 count_sys = 0;
 	int chunk_reserved = 0;
+	struct remap_chunk_info *rci;
+	unsigned int num_remap_chunks = 0;
+	LIST_HEAD(remap_chunks);
 
 	path = btrfs_alloc_path();
 	if (!path) {
@@ -4204,7 +4317,8 @@ static int __btrfs_balance(struct btrfs_fs_info *fs_info)
 				count_data++;
 			else if (chunk_type &amp; BTRFS_BLOCK_GROUP_SYSTEM)
 				count_sys++;
-			else if (chunk_type &amp; BTRFS_BLOCK_GROUP_METADATA)
+			else if (chunk_type &amp; (BTRFS_BLOCK_GROUP_METADATA |
+					       BTRFS_BLOCK_GROUP_METADATA_REMAP))
 				count_meta++;
 
 			goto loop;
@@ -4224,6 +4338,30 @@ static int __btrfs_balance(struct btrfs_fs_info *fs_info)
 			goto loop;
 		}
 
+		/*
+		 * Balancing METADATA_REMAP chunks takes place separately - add
+		 * the details to a list so it can be processed later.
+		 */
+		if (chunk_type &amp; BTRFS_BLOCK_GROUP_METADATA_REMAP) {
+			mutex_unlock(&amp;fs_info-&gt;reclaim_bgs_lock);
+
+			rci = kmalloc(sizeof(struct remap_chunk_info),
+				      GFP_NOFS);
+			if (!rci) {
+				ret = -ENOMEM;
+				goto error;
+			}
+
+			rci-&gt;offset = found_key.offset;
+			rci-&gt;bg = NULL;
+			rci-&gt;made_ro = false;
+			list_add_tail(&amp;rci-&gt;list, &amp;remap_chunks);
+
+			num_remap_chunks++;
+
+			goto loop;
+		}
+
 		if (!chunk_reserved) {
 			/*
 			 * We may be relocating the only data chunk we have,
@@ -4263,11 +4401,24 @@ static int __btrfs_balance(struct btrfs_fs_info *fs_info)
 		key.offset = found_key.offset - 1;
 	}
 
+	btrfs_release_path(path);
+
 	if (counting) {
-		btrfs_release_path(path);
 		counting = false;
 		goto again;
 	}
+
+	if (!list_empty(&amp;remap_chunks)) {
+		ret = balance_remap_chunks(fs_info, path, &amp;remap_chunks);
+		if (ret == -ENOSPC)
+			enospc_errors++;
+
+		if (!ret) {
+			spin_lock(&amp;fs_info-&gt;balance_lock);
+			bctl-&gt;stat.completed += num_remap_chunks;
+			spin_unlock(&amp;fs_info-&gt;balance_lock);
+		}
+	}
 error:
 	if (enospc_errors) {
 		btrfs_info(fs_info, &quot;%d enospc errors during balance&quot;,
-- 
2.51.2



---

Discard normally works by iterating over the free-space entries of a
block group. This doesn&#x27;t work for fully-remapped block groups, as we
removed their free-space entries when we started relocation.

For sync discard, call btrfs_discard_extent() when we commit the
transaction in which the last identity remap was removed.

For async discard, add a new function btrfs_trim_fully_remapped_block_group()
to be called by the discard worker, which iterates over the block
group&#x27;s range using the normal async discard rules. Once we reach the
end, remove the chunk&#x27;s stripes and device extents to get back its free
space.

Signed-off-by: Mark Harmstone &lt;mark@harmstone.com&gt;
Reviewed-by: Boris Burkov &lt;boris@bur.io&gt;
---
 fs/btrfs/block-group.c      | 29 ++++++++++---------
 fs/btrfs/block-group.h      |  1 +
 fs/btrfs/discard.c          | 57 ++++++++++++++++++++++++++++++++-----
 fs/btrfs/extent-tree.c      |  3 ++
 fs/btrfs/free-space-cache.c | 36 +++++++++++++++++++++++
 fs/btrfs/free-space-cache.h |  1 +
 6 files changed, 107 insertions(+), 20 deletions(-)

diff --git a/fs/btrfs/block-group.c b/fs/btrfs/block-group.c
index 2b3fd80a690f..47454c22d6f4 100644
--- a/fs/btrfs/block-group.c
+++ b/fs/btrfs/block-group.c
@@ -4814,20 +4814,23 @@ void btrfs_mark_bg_fully_remapped(struct btrfs_block_group *bg,
 {
 	struct btrfs_fs_info *fs_info = trans-&gt;fs_info;
 
-	spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
+	if (btrfs_test_opt(fs_info, DISCARD_ASYNC)) {
+		btrfs_discard_queue_work(&amp;fs_info-&gt;discard_ctl, bg);
+	} else {
+		spin_lock(&amp;fs_info-&gt;unused_bgs_lock);
 
-	/*
-	 * The block group might already be on the unused_bgs list, remove it
-	 * if it is. It&#x27;ll get readded after the async discard worker finishes,
-	 * or in btrfs_handle_fully_remapped_bgs() if we&#x27;re not using async
-	 * discard.
-	 */
-	if (!list_empty(&amp;bg-&gt;bg_list))
-		list_del(&amp;bg-&gt;bg_list);
-	else
-		btrfs_get_block_group(bg);
+		/*
+		 * The block group might already be on the unused_bgs list,
+		 * remove it if it is. It&#x27;ll get readded after
+		 * btrfs_handle_fully_remapped_bgs() finishes.
+		 */
+		if (!list_empty(&amp;bg-&gt;bg_list))
+			list_del(&amp;bg-&gt;bg_list);
+		else
+			btrfs_get_block_group(bg);
 
-	list_add_tail(&amp;bg-&gt;bg_list, &amp;fs_info-&gt;fully_remapped_bgs);
+		list_add_tail(&amp;bg-&gt;bg_list, &amp;fs_info-&gt;fully_remapped_bgs);
 
-	spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+		spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
+	}
 }
diff --git a/fs/btrfs/block-group.h b/fs/btrfs/block-group.h
index 3e8c3d424481..3117cebf02f5 100644
--- a/fs/btrfs/block-group.h
+++ b/fs/btrfs/block-group.h
@@ -49,6 +49,7 @@ enum btrfs_discard_state {
 	BTRFS_DISCARD_EXTENTS,
 	BTRFS_DISCARD_BITMAPS,
 	BTRFS_DISCARD_RESET_CURSOR,
+	BTRFS_DISCARD_FULLY_REMAPPED,
 };
 
 /*
diff --git a/fs/btrfs/discard.c b/fs/btrfs/discard.c
index ee5f5b2788e1..a3d7b7752518 100644
--- a/fs/btrfs/discard.c
+++ b/fs/btrfs/discard.c
@@ -215,6 +215,27 @@ static struct btrfs_block_group *find_next_block_group(
 	return ret_block_group;
 }
 
+/*
+ * Returns whether a block group is empty.
+ *
+ * @bg: block group of interest
+ *
+ * &quot;Empty&quot; here means that there are no extents physically located within the
+ * device extents corresponding to this block group.
+ *
+ * For a remapped block group, this means that all of its identity remaps have
+ * been removed. For a non-remapped block group, this means that no extents
+ * have an address within its range, and that nothing has been remapped to be
+ * within it.
+ */
+static bool block_group_is_empty(struct btrfs_block_group *bg)
+{
+	if (bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED)
+		return bg-&gt;identity_remap_count == 0;
+	else
+		return bg-&gt;used == 0 &amp;&amp; bg-&gt;remap_bytes == 0;
+}
+
 /*
  * Look up next block group and set it for use.
  *
@@ -241,8 +262,10 @@ static struct btrfs_block_group *peek_discard_list(
 	block_group = find_next_block_group(discard_ctl, now);
 
 	if (block_group &amp;&amp; now &gt;= block_group-&gt;discard_eligible_time) {
+		bool empty = block_group_is_empty(block_group);
+
 		if (block_group-&gt;discard_index == BTRFS_DISCARD_INDEX_UNUSED &amp;&amp;
-		    block_group-&gt;used != 0) {
+		    !empty) {
 			if (btrfs_is_block_group_data_only(block_group)) {
 				__add_to_discard_list(discard_ctl, block_group);
 				/*
@@ -267,7 +290,15 @@ static struct btrfs_block_group *peek_discard_list(
 		}
 		if (block_group-&gt;discard_state == BTRFS_DISCARD_RESET_CURSOR) {
 			block_group-&gt;discard_cursor = block_group-&gt;start;
-			block_group-&gt;discard_state = BTRFS_DISCARD_EXTENTS;
+
+			if (block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED &amp;&amp;
+			    empty) {
+				block_group-&gt;discard_state =
+					BTRFS_DISCARD_FULLY_REMAPPED;
+			} else {
+				block_group-&gt;discard_state =
+					BTRFS_DISCARD_EXTENTS;
+			}
 		}
 	}
 	if (block_group) {
@@ -373,7 +404,7 @@ void btrfs_discard_queue_work(struct btrfs_discard_ctl *discard_ctl,
 	if (!block_group || !btrfs_test_opt(block_group-&gt;fs_info, DISCARD_ASYNC))
 		return;
 
-	if (block_group-&gt;used == 0 &amp;&amp; block_group-&gt;remap_bytes == 0)
+	if (block_group_is_empty(block_group))
 		add_to_discard_unused_list(discard_ctl, block_group);
 	else
 		add_to_discard_list(discard_ctl, block_group);
@@ -470,7 +501,7 @@ static void btrfs_finish_discard_pass(struct btrfs_discard_ctl *discard_ctl,
 {
 	remove_from_discard_list(discard_ctl, block_group);
 
-	if (block_group-&gt;used == 0) {
+	if (block_group_is_empty(block_group)) {
 		if (btrfs_is_free_space_trimmed(block_group))
 			btrfs_mark_bg_unused(block_group);
 		else
@@ -524,7 +555,8 @@ static void btrfs_discard_workfn(struct work_struct *work)
 	/* Perform discarding */
 	minlen = discard_minlen[discard_index];
 
-	if (discard_state == BTRFS_DISCARD_BITMAPS) {
+	switch (discard_state) {
+	case BTRFS_DISCARD_BITMAPS: {
 		u64 maxlen = 0;
 
 		/*
@@ -541,17 +573,28 @@ static void btrfs_discard_workfn(struct work_struct *work)
 				       btrfs_block_group_end(block_group),
 				       minlen, maxlen, true);
 		discard_ctl-&gt;discard_bitmap_bytes += trimmed;
-	} else {
+
+		break;
+	}
+
+	case BTRFS_DISCARD_FULLY_REMAPPED:
+		btrfs_trim_fully_remapped_block_group(block_group);
+		break;
+
+	default:
 		btrfs_trim_block_group_extents(block_group, &amp;trimmed,
 				       block_group-&gt;discard_cursor,
 				       btrfs_block_group_end(block_group),
 				       minlen, true);
 		discard_ctl-&gt;discard_extent_bytes += trimmed;
+
+		break;
 	}
 
 	/* Determine next steps for a block_group */
 	if (block_group-&gt;discard_cursor &gt;= btrfs_block_group_end(block_group)) {
-		if (discard_state == BTRFS_DISCARD_BITMAPS) {
+		if (discard_state == BTRFS_DISCARD_BITMAPS ||
+		    discard_state == BTRFS_DISCARD_FULLY_REMAPPED) {
 			btrfs_finish_discard_pass(discard_ctl, block_group);
 		} else {
 			block_group-&gt;discard_cursor = block_group-&gt;start;
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 9d68f3fa4fa9..7d010d480f7c 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -2901,6 +2901,9 @@ void btrfs_handle_fully_remapped_bgs(struct btrfs_fs_info *fs_info)
 		list_del_init(&amp;bg-&gt;bg_list);
 		spin_unlock(&amp;fs_info-&gt;unused_bgs_lock);
 
+		btrfs_discard_extent(fs_info, bg-&gt;start, bg-&gt;length,
+				     NULL, false);
+
 		ret = btrfs_complete_bg_remapping(bg);
 		if (ret) {
 			btrfs_put_block_group(bg);
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index 17e79ee3e021..e15fa8567f7c 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -29,6 +29,7 @@
 #include &quot;file-item.h&quot;
 #include &quot;file.h&quot;
 #include &quot;super.h&quot;
+#include &quot;relocation.h&quot;
 
 #define BITS_PER_BITMAP		(PAGE_SIZE * 8UL)
 #define MAX_CACHE_BYTES_PER_GIG	SZ_64K
@@ -3066,6 +3067,11 @@ bool btrfs_is_free_space_trimmed(struct btrfs_block_group *block_group)
 	struct rb_node *node;
 	bool ret = true;
 
+	if (block_group-&gt;flags &amp; BTRFS_BLOCK_GROUP_REMAPPED &amp;&amp;
+	    block_group-&gt;identity_remap_count == 0) {
+		return true;
+	}
+
 	spin_lock(&amp;ctl-&gt;tree_lock);
 	node = rb_first(&amp;ctl-&gt;free_space_offset);
 
@@ -3834,6 +3840,36 @@ static int trim_no_bitmap(struct btrfs_block_group *block_group,
 	return ret;
 }
 
+void btrfs_trim_fully_remapped_block_group(struct btrfs_block_group *bg)
+{
+	struct btrfs_fs_info *fs_info = bg-&gt;fs_info;
+	struct btrfs_discard_ctl *discard_ctl = &amp;fs_info-&gt;discard_ctl;
+	int ret = 0;
+	u64 bytes, trimmed;
+	const u64 max_discard_size = READ_ONCE(discard_ctl-&gt;max_discard_size);
+	u64 end = btrfs_block_group_end(bg);
+
+	bytes = end - bg-&gt;discard_cursor;
+
+	if (max_discard_size &amp;&amp;
+		bytes &gt;= (max_discard_size +
+			BTRFS_ASYNC_DISCARD_MIN_FILTER)) {
+		bytes = max_discard_size;
+	}
+
+	ret = btrfs_discard_extent(fs_info, bg-&gt;discard_cursor, bytes, &amp;trimmed,
+				   false);
+	if (ret)
+		return;
+
+	bg-&gt;discard_cursor += trimmed;
+
+	if (bg-&gt;discard_cursor &lt; end)
+		return;
+
+	btrfs_complete_bg_remapping(bg);
+}
+
 /*
  * If we break out of trimming a bitmap prematurely, we should reset the
  * trimming bit.  In a rather contrived case, it&#x27;s possible to race here so
diff --git a/fs/btrfs/free-space-cache.h b/fs/btrfs/free-space-cache.h
index 9f1dbfdee8ca..33fc3b245648 100644
--- a/fs/btrfs/free-space-cache.h
+++ b/fs/btrfs/free-space-cache.h
@@ -166,6 +166,7 @@ int btrfs_trim_block_group_extents(struct btrfs_block_group *block_group,
 int btrfs_trim_block_group_bitmaps(struct btrfs_block_group *block_group,
 				   u64 *trimmed, u64 start, u64 end, u64 minlen,
 				   u64 maxlen, bool async);
+void btrfs_trim_fully_remapped_block_group(struct btrfs_block_group *bg);
 
 bool btrfs_free_space_cache_v1_active(struct btrfs_fs_info *fs_info);
 int btrfs_set_free_space_cache_v1_active(struct btrfs_fs_info *fs_info, bool active);
-- 
2.51.2



---

On 23/01/2026 10.04 am, Filipe Manana wrote:
&gt; On Wed, Jan 21, 2026 at 10:24\u202fPM David Sterba &lt;dsterba@suse.cz&gt; wrote:
&gt;&gt;
&gt;&gt; On Wed, Jan 07, 2026 at 02:09:00PM +0000, Mark Harmstone wrote:
&gt;&gt;&gt; This is version 8 of the patch series for the new logical remapping tree
&gt;&gt;&gt; feature - see the previous cover letters for more information including
&gt;&gt;&gt; the rationale:
&gt;&gt;&gt;
&gt;&gt;&gt; * RFC: https://lore.kernel.org/all/20250515163641.3449017-1-maharmstone@fb.com/
&gt;&gt;&gt; * Version 1: https://lore.kernel.org/all/20250605162345.2561026-1-maharmstone@fb.com/
&gt;&gt;&gt; * Version 2: https://lore.kernel.org/all/20250813143509.31073-1-mark@harmstone.com/
&gt;&gt;&gt; * Version 3: https://lore.kernel.org/all/20251009112814.13942-1-mark@harmstone.com/
&gt;&gt;&gt; * Version 4: https://lore.kernel.org/all/20251024181227.32228-1-mark@harmstone.com/
&gt;&gt;&gt; * Version 5: https://lore.kernel.org/all/20251110171511.20900-1-mark@harmstone.com/
&gt;&gt;&gt; * Version 6: https://lore.kernel.org/all/20251114184745.9304-1-mark@harmstone.com/
&gt;&gt;&gt; * Version 7: https://lore.kernel.org/all/20251124185335.16556-1-mark@harmstone.com/
&gt;&gt;&gt;
&gt;&gt;&gt; Changes since version 7:
&gt;&gt;&gt; * renamed struct btrfs_remap to struct btrfs_remap_item
&gt;&gt;&gt; * renamed BTRFS_BLOCK_GROUP_FLAGS_REMAP to BTRFS_BLOCK_GROUP_FLAGS_METADATA_REMAP
&gt;&gt;&gt; * added unlikelies
&gt;&gt;&gt; * renamed new commit_* fields in struct btrfs_block_group to last_*, and added
&gt;&gt;&gt;    new patch renaming existing commit_used to last_used to match
&gt;&gt;&gt; * merged do_copy() into copy_remapped_data()
&gt;&gt;&gt; * initialized on-stack struct btrfs_remap_items
&gt;&gt;&gt; * fixed comments
&gt;&gt;&gt; * added other minor changes as suggested by David Sterba
&gt;&gt;&gt;
&gt;&gt;&gt; Mark Harmstone (17):
&gt;&gt;&gt;    btrfs: add definitions and constants for remap-tree
&gt;&gt;&gt;    btrfs: add METADATA_REMAP chunk type
&gt;&gt;&gt;    btrfs: allow remapped chunks to have zero stripes
&gt;&gt;&gt;    btrfs: remove remapped block groups from the free-space tree
&gt;&gt;&gt;    btrfs: don&#x27;t add metadata items for the remap tree to the extent tree
&gt;&gt;&gt;    btrfs: rename struct btrfs_block_group field commit_used to last_used
&gt;&gt;&gt;    btrfs: add extended version of struct block_group_item
&gt;&gt;&gt;    btrfs: allow mounting filesystems with remap-tree incompat flag
&gt;&gt;&gt;    btrfs: redirect I/O for remapped block groups
&gt;&gt;&gt;    btrfs: handle deletions from remapped block group
&gt;&gt;&gt;    btrfs: handle setting up relocation of block group with remap-tree
&gt;&gt;&gt;    btrfs: move existing remaps before relocating block group
&gt;&gt;&gt;    btrfs: replace identity remaps with actual remaps when doing
&gt;&gt;&gt;      relocations
&gt;&gt;&gt;    btrfs: add do_remap param to btrfs_discard_extent()
&gt;&gt;&gt;    btrfs: allow balancing remap tree
&gt;&gt;&gt;    btrfs: handle discarding fully-remapped block groups
&gt;&gt;&gt;    btrfs: populate fully_remapped_bgs_list on mount
&gt;&gt;
&gt;&gt; Patches have been added to for-next. There were many coding style issues
&gt;&gt; which I&#x27;ve tried to fix. As this is a lot of new code it&#x27;ll get updated
&gt;&gt; anyway, I realized that for this kind of initial batch the coding
&gt;&gt; style is quite important as we&#x27;d have to stick with until some random
&gt;&gt; change touches it. Please have a look for the differences. Thanks.

Thanks David.

&gt; This is a huge amount of code and quite critical.
&gt; Shouldn&#x27;t we have test cases in fstests to exercise this feature?
&gt; I didn&#x27;t see any test cases submitted.

It is, but it&#x27;s a no-op if the incompat flag set isn&#x27;t set.

There will be fstests for this before I propose taking it out of 
EXPERIMENTAL.


---

Claude&#x27;s right, and I made this mistake because I was copying the 
&quot;return -EINVAL&quot; a few lines lower down, which also leaks. I&#x27;ll patch 
them both.

On 25/01/2026 12.57 pm, Chris Mason wrote:
&gt; Mark Harmstone &lt;mark@harmstone.com&gt; wrote:
&gt;&gt; Change btrfs_map_block() so that if the block group has the REMAPPED
&gt;&gt; flag set, we call btrfs_translate_remap() to obtain a new address.
&gt;&gt;
&gt;&gt; btrfs_translate_remap() searches the remap tree for a range
&gt;&gt; corresponding to the logical address passed to btrfs_map_block(). If it
&gt;&gt; is within an identity remap, this part of the block group hasn&#x27;t yet
&gt;&gt; been relocated, and so we use the existing address.
&gt;&gt;
&gt;&gt; If it is within an actual remap, we subtract the start of the remap
&gt;&gt; range and add the address of its destination, contained in the item&#x27;s
&gt;&gt; payload.
&gt;&gt;
&gt; 
&gt; Hi everyone,
&gt; 
&gt; Another AI review from linux-next runs:
&gt; 
&gt;&gt; diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
&gt;&gt; --- a/fs/btrfs/volumes.c
&gt;&gt; +++ b/fs/btrfs/volumes.c
&gt;&gt; @@ -6586,6 +6586,24 @@ struct btrfs_io_geometry io_geom = { 0 };
&gt;&gt; 	if (IS_ERR(map))
&gt;&gt; 		return PTR_ERR(map);
&gt;&gt;
&gt;&gt; +	if (map-&gt;type &amp; BTRFS_BLOCK_GROUP_REMAPPED) {
&gt;&gt; +		u64 new_logical = logical;
&gt;&gt; +
&gt;&gt; +		ret = btrfs_translate_remap(fs_info, &amp;new_logical, length);
&gt;&gt; +		if (ret)
&gt;&gt; +			return ret;
&gt;                          ^^^^^^^^^^
&gt; 
&gt; When btrfs_translate_remap() returns an error, does this leak the chunk
&gt; map? The map was obtained via btrfs_get_chunk_map() which increments a
&gt; refcount, and btrfs_get_chunk_map() documents that callers are
&gt; responsible for dropping the reference. The other error paths in this
&gt; function use goto out, which calls btrfs_free_chunk_map(map).
&gt; 
&gt;&gt; +
&gt;&gt; +		if (new_logical != logical) {
&gt;&gt; +			btrfs_free_chunk_map(map);
&gt;&gt; +
&gt;&gt; +			map = btrfs_get_chunk_map(fs_info, new_logical, *length);
&gt;&gt; +			if (IS_ERR(map))
&gt;&gt; +				return PTR_ERR(map);
&gt;&gt; +
&gt;&gt; +			logical = new_logical;
&gt;&gt; +		}
&gt;&gt; +	}
&gt; 
&gt; [ ... ]


</pre>
</details>
<div class="review-comment-signals">Signals: leaked return value</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">David Sterba</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer David Sterba raised no technical concerns, but instead mentioned that he fixed coding style issues in the patches and suggested reviewing them for consistency.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Wed, Jan 07, 2026 at 02:09:00PM +0000, Mark Harmstone wrote:
&gt; This is version 8 of the patch series for the new logical remapping tree
&gt; feature - see the previous cover letters for more information including
&gt; the rationale:
&gt; 
&gt; * RFC: https://lore.kernel.org/all/20250515163641.3449017-1-maharmstone@fb.com/
&gt; * Version 1: https://lore.kernel.org/all/20250605162345.2561026-1-maharmstone@fb.com/
&gt; * Version 2: https://lore.kernel.org/all/20250813143509.31073-1-mark@harmstone.com/
&gt; * Version 3: https://lore.kernel.org/all/20251009112814.13942-1-mark@harmstone.com/
&gt; * Version 4: https://lore.kernel.org/all/20251024181227.32228-1-mark@harmstone.com/
&gt; * Version 5: https://lore.kernel.org/all/20251110171511.20900-1-mark@harmstone.com/
&gt; * Version 6: https://lore.kernel.org/all/20251114184745.9304-1-mark@harmstone.com/
&gt; * Version 7: https://lore.kernel.org/all/20251124185335.16556-1-mark@harmstone.com/
&gt; 
&gt; Changes since version 7:
&gt; * renamed struct btrfs_remap to struct btrfs_remap_item
&gt; * renamed BTRFS_BLOCK_GROUP_FLAGS_REMAP to BTRFS_BLOCK_GROUP_FLAGS_METADATA_REMAP
&gt; * added unlikelies
&gt; * renamed new commit_* fields in struct btrfs_block_group to last_*, and added
&gt;   new patch renaming existing commit_used to last_used to match
&gt; * merged do_copy() into copy_remapped_data()
&gt; * initialized on-stack struct btrfs_remap_items
&gt; * fixed comments
&gt; * added other minor changes as suggested by David Sterba
&gt; 
&gt; Mark Harmstone (17):
&gt;   btrfs: add definitions and constants for remap-tree
&gt;   btrfs: add METADATA_REMAP chunk type
&gt;   btrfs: allow remapped chunks to have zero stripes
&gt;   btrfs: remove remapped block groups from the free-space tree
&gt;   btrfs: don&#x27;t add metadata items for the remap tree to the extent tree
&gt;   btrfs: rename struct btrfs_block_group field commit_used to last_used
&gt;   btrfs: add extended version of struct block_group_item
&gt;   btrfs: allow mounting filesystems with remap-tree incompat flag
&gt;   btrfs: redirect I/O for remapped block groups
&gt;   btrfs: handle deletions from remapped block group
&gt;   btrfs: handle setting up relocation of block group with remap-tree
&gt;   btrfs: move existing remaps before relocating block group
&gt;   btrfs: replace identity remaps with actual remaps when doing
&gt;     relocations
&gt;   btrfs: add do_remap param to btrfs_discard_extent()
&gt;   btrfs: allow balancing remap tree
&gt;   btrfs: handle discarding fully-remapped block groups
&gt;   btrfs: populate fully_remapped_bgs_list on mount

Patches have been added to for-next. There were many coding style issues
which I&#x27;ve tried to fix. As this is a lot of new code it&#x27;ll get updated
anyway, I realized that for this kind of initial batch the coding
style is quite important as we&#x27;d have to stick with until some random
change touches it. Please have a look for the differences. Thanks.
</pre>
</details>
<div class="review-comment-signals">Signals: no technical discussion</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Filipe Manana</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Filipe Manana raised concerns about the lack of test cases for the remap tree feature, suggesting that fstests should be updated to exercise this functionality.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Wed, Jan 21, 2026 at 10:24 PM David Sterba &lt;dsterba@suse.cz&gt; wrote:
&gt;
&gt; On Wed, Jan 07, 2026 at 02:09:00PM +0000, Mark Harmstone wrote:
&gt; &gt; This is version 8 of the patch series for the new logical remapping tree
&gt; &gt; feature - see the previous cover letters for more information including
&gt; &gt; the rationale:
&gt; &gt;
&gt; &gt; * RFC: https://lore.kernel.org/all/20250515163641.3449017-1-maharmstone@fb.com/
&gt; &gt; * Version 1: https://lore.kernel.org/all/20250605162345.2561026-1-maharmstone@fb.com/
&gt; &gt; * Version 2: https://lore.kernel.org/all/20250813143509.31073-1-mark@harmstone.com/
&gt; &gt; * Version 3: https://lore.kernel.org/all/20251009112814.13942-1-mark@harmstone.com/
&gt; &gt; * Version 4: https://lore.kernel.org/all/20251024181227.32228-1-mark@harmstone.com/
&gt; &gt; * Version 5: https://lore.kernel.org/all/20251110171511.20900-1-mark@harmstone.com/
&gt; &gt; * Version 6: https://lore.kernel.org/all/20251114184745.9304-1-mark@harmstone.com/
&gt; &gt; * Version 7: https://lore.kernel.org/all/20251124185335.16556-1-mark@harmstone.com/
&gt; &gt;
&gt; &gt; Changes since version 7:
&gt; &gt; * renamed struct btrfs_remap to struct btrfs_remap_item
&gt; &gt; * renamed BTRFS_BLOCK_GROUP_FLAGS_REMAP to BTRFS_BLOCK_GROUP_FLAGS_METADATA_REMAP
&gt; &gt; * added unlikelies
&gt; &gt; * renamed new commit_* fields in struct btrfs_block_group to last_*, and added
&gt; &gt;   new patch renaming existing commit_used to last_used to match
&gt; &gt; * merged do_copy() into copy_remapped_data()
&gt; &gt; * initialized on-stack struct btrfs_remap_items
&gt; &gt; * fixed comments
&gt; &gt; * added other minor changes as suggested by David Sterba
&gt; &gt;
&gt; &gt; Mark Harmstone (17):
&gt; &gt;   btrfs: add definitions and constants for remap-tree
&gt; &gt;   btrfs: add METADATA_REMAP chunk type
&gt; &gt;   btrfs: allow remapped chunks to have zero stripes
&gt; &gt;   btrfs: remove remapped block groups from the free-space tree
&gt; &gt;   btrfs: don&#x27;t add metadata items for the remap tree to the extent tree
&gt; &gt;   btrfs: rename struct btrfs_block_group field commit_used to last_used
&gt; &gt;   btrfs: add extended version of struct block_group_item
&gt; &gt;   btrfs: allow mounting filesystems with remap-tree incompat flag
&gt; &gt;   btrfs: redirect I/O for remapped block groups
&gt; &gt;   btrfs: handle deletions from remapped block group
&gt; &gt;   btrfs: handle setting up relocation of block group with remap-tree
&gt; &gt;   btrfs: move existing remaps before relocating block group
&gt; &gt;   btrfs: replace identity remaps with actual remaps when doing
&gt; &gt;     relocations
&gt; &gt;   btrfs: add do_remap param to btrfs_discard_extent()
&gt; &gt;   btrfs: allow balancing remap tree
&gt; &gt;   btrfs: handle discarding fully-remapped block groups
&gt; &gt;   btrfs: populate fully_remapped_bgs_list on mount
&gt;
&gt; Patches have been added to for-next. There were many coding style issues
&gt; which I&#x27;ve tried to fix. As this is a lot of new code it&#x27;ll get updated
&gt; anyway, I realized that for this kind of initial batch the coding
&gt; style is quite important as we&#x27;d have to stick with until some random
&gt; change touches it. Please have a look for the differences. Thanks.

This is a huge amount of code and quite critical.
Shouldn&#x27;t we have test cases in fstests to exercise this feature?
I didn&#x27;t see any test cases submitted.

&gt;
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, test cases</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Chris Mason</span>
<a class="date-chip" href="../2026-02-18_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Chris Mason raised several technical concerns about potential bugs and leaks in the patch, specifically regarding NULL pointer dereferences, transaction handle leaks, and missing error handling.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Mark Harmstone &lt;mark@harmstone.com&gt; wrote:
&gt; Balancing the METADATA_REMAP chunk, i.e. the chunk in which the remap tree
&gt; lives, is a special case.
&gt; 
&gt; We can&#x27;t use the remap tree itself for this, as then we&#x27;d have no way to
&gt; boostrap it on mount. And we can&#x27;t use the pre-remap tree code for this
&gt; as it relies on walking the extent tree, and we&#x27;re not creating backrefs
&gt; for METADATA_REMAP chunks.
&gt; 
&gt; So instead, if a balance would relocate any METADATA_REMAP block groups, mark
&gt; those block groups as readonly and COW every leaf of the remap tree.

Hi everyone,

I ran my AI patch review prompts on linux-next, and this one was flagged.   As
we add more btrfs specifics we&#x27;ll probably find some other fun, but this one
seems right to me:

&gt;
&gt; diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
&gt; --- a/fs/btrfs/volumes.c
&gt; +++ b/fs/btrfs/volumes.c

[ ... ]

&gt; +static int balance_remap_chunks(struct btrfs_fs_info *fs_info, struct btrfs_path *path,
&gt; +				struct list_head *chunks)
&gt; +{
&gt; +	struct remap_chunk_info *rci, *tmp;
&gt; +	struct btrfs_trans_handle *trans;
&gt; +	int ret;
&gt; +
&gt; +	list_for_each_entry_safe(rci, tmp, chunks, list) {
&gt; +		rci-&gt;bg = btrfs_lookup_block_group(fs_info, rci-&gt;offset);
&gt; +		if (!rci-&gt;bg) {
&gt; +			list_del(&amp;rci-&gt;list);
&gt; +			kfree(rci);
&gt; +			continue;
&gt; +		}
&gt; +
&gt; +		ret = btrfs_inc_block_group_ro(rci-&gt;bg, false);
&gt; +		if (ret)
&gt; +			goto end;

If btrfs_inc_block_group_ro() fails here, the remaining entries in the
list still have rci-&gt;bg set to NULL (from the initialization in
__btrfs_balance()). The goto jumps to the cleanup loop below.

&gt; +
&gt; +		rci-&gt;made_ro = true;
&gt; +	}

[ ... ]

&gt; +end:
&gt; +	while (!list_empty(chunks)) {
&gt; +		bool is_unused;
&gt; +
&gt; +		rci = list_first_entry(chunks, struct remap_chunk_info, list);
&gt; +
&gt; +		spin_lock(&amp;rci-&gt;bg-&gt;lock);
                         ^^^^^^^^

Can this dereference a NULL pointer? When the loop above exits early
via goto end, the remaining rci entries in the list have rci-&gt;bg == NULL.
The cleanup loop then calls spin_lock(&amp;rci-&gt;bg-&gt;lock) on these entries,
which would crash the kernel.

&gt; +		is_unused = !btrfs_is_block_group_used(rci-&gt;bg);
&gt; +		spin_unlock(&amp;rci-&gt;bg-&gt;lock);
&gt; +
&gt; +		if (is_unused)
&gt; +			btrfs_mark_bg_unused(rci-&gt;bg);
&gt; +
&gt; +		if (rci-&gt;made_ro)
&gt; +			btrfs_dec_block_group_ro(rci-&gt;bg);
&gt; +
&gt; +		btrfs_put_block_group(rci-&gt;bg);
&gt; +
&gt; +		list_del(&amp;rci-&gt;list);
&gt; +		kfree(rci);
&gt; +	}
&gt; +
&gt; +	return ret;
&gt; +}

[ ... ]

&gt; +			rci-&gt;offset = found_key.offset;
&gt; +			rci-&gt;bg = NULL;
                                  ^^^^

This is where rci-&gt;bg is initialized to NULL. If balance_remap_chunks()
fails partway through processing the list, these unprocessed entries
still have bg == NULL when the cleanup loop runs.

[ ... ]



---

Mark Harmstone &lt;mark@harmstone.com&gt; wrote:
&gt; If when relocating a block group we find that `remap_bytes` &gt; 0 in its
&gt; block group item, that means that it has been the destination block
&gt; group for another that has been remapped.
&gt; 
&gt; We need to seach the remap tree for any remap backrefs within this
&gt; range, and move the data to a third block group. This is because
&gt; otherwise btrfs_translate_remap() could end up following an unbounded
&gt; chain of remaps, which would only get worse over time.
&gt; 
&gt; We only relocate one block group at a time, so `remap_bytes` will only
&gt; ever go down while we are doing this. Once we&#x27;re finished we set the
&gt; REMAPPED flag on the block group, which will permanently prevent any
&gt; other data from being moved to within it.

Hi everyone,

One more AI review from linux-next, this looks valid to me:

&gt; diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
&gt; --- a/fs/btrfs/relocation.c
&gt; +++ b/fs/btrfs/relocation.c

[ ... ]

&gt; +static int move_existing_remap(struct btrfs_fs_info *fs_info,
&gt; +			       struct btrfs_path *path,
&gt; +			       struct btrfs_block_group *bg, u64 new_addr,
&gt; +			       u64 length, u64 old_addr)
&gt; +{

[ ... ]

&gt; +	dest_bg = btrfs_lookup_block_group(fs_info, dest_addr);
&gt; +
&gt; +	adjust_block_group_remap_bytes(trans, dest_bg, dest_length);
&gt; +
&gt; +	mutex_lock(&amp;dest_bg-&gt;free_space_lock);
&gt; +	bg_needs_free_space = test_bit(BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE,
&gt; +				       &amp;dest_bg-&gt;runtime_flags);
&gt; +	mutex_unlock(&amp;dest_bg-&gt;free_space_lock);
&gt; +	btrfs_put_block_group(dest_bg);
&gt; +
&gt; +	if (bg_needs_free_space) {
&gt; +		ret = btrfs_add_block_group_free_space(trans, dest_bg);
                                                         ^^^^^^^

Is there a use-after-free here? btrfs_put_block_group() is called above,
which can free the block group if the refcount drops to zero. Then
btrfs_add_block_group_free_space() dereferences dest_bg by calling
mutex_lock(&amp;block_group-&gt;free_space_lock).

Perhaps the btrfs_put_block_group() call should be moved after the
conditional block that uses dest_bg?

&gt; +		if (unlikely(ret))
&gt; +			goto end;
&gt; +	}

[ ... ]

&gt; +static int move_existing_remaps(struct btrfs_fs_info *fs_info,
&gt; +				struct btrfs_block_group *bg,
&gt; +				struct btrfs_path *path)
&gt; +{
&gt; +	int ret;
&gt; +	struct btrfs_key key;
&gt; +	struct extent_buffer *leaf;
&gt; +	struct btrfs_remap_item *remap;
&gt; +	u64 old_addr;
&gt; +
&gt; +	/* Look for backrefs in remap tree. */
&gt; +	while (bg-&gt;remap_bytes &gt; 0) {
&gt; +		key.objectid = bg-&gt;start;
&gt; +		key.type = BTRFS_REMAP_BACKREF_KEY;
&gt; +		key.offset = 0;
&gt; +
&gt; +		ret = btrfs_search_slot(NULL, fs_info-&gt;remap_root, &amp;key, path, 0, 0);
&gt; +		if (ret &lt; 0)
&gt; +			return ret;
&gt; +
&gt; +		leaf = path-&gt;nodes[0];
&gt; +
&gt; +		if (path-&gt;slots[0] &gt;= btrfs_header_nritems(leaf)) {
&gt; +			ret = btrfs_next_leaf(fs_info-&gt;remap_root, path);

[ ... ]

&gt; +			leaf = path-&gt;nodes[0];
&gt; +		}
&gt; +
&gt; +		btrfs_item_key_to_cpu(leaf, &amp;key, path-&gt;slots[0]);
&gt; +
&gt; +		if (key.type != BTRFS_REMAP_BACKREF_KEY) {
&gt; +			path-&gt;slots[0]++;

When the slot is incremented here because the key type does not match,
should the key be re-read from the new slot? The code below reads
the remap item from path-&gt;slots[0] (the incremented slot), but then
passes key.objectid and key.offset (from the old slot) to
move_existing_remap().

If the key at the new slot has different objectid/offset values than
the previous slot, this would pass mismatched address and length values
to move_existing_remap().

&gt; +
&gt; +			if (path-&gt;slots[0] &gt;= btrfs_header_nritems(leaf)) {
&gt; +				ret = btrfs_next_leaf(fs_info-&gt;remap_root, path);

[ ... ]

&gt; +				leaf = path-&gt;nodes[0];
&gt; +			}
&gt; +		}
&gt; +
&gt; +		remap = btrfs_item_ptr(leaf, path-&gt;slots[0], struct btrfs_remap_item);
&gt; +		old_addr = btrfs_remap_address(leaf, remap);
&gt; +
&gt; +		btrfs_release_path(path);
&gt; +
&gt; +		ret = move_existing_remap(fs_info, path, bg, key.objectid,
&gt; +					  key.offset, old_addr);

[ ... ]



---

Mark Harmstone &lt;mark@harmstone.com&gt; wrote:
&gt; Handle the case where we free an extent from a block group that has the
&gt; REMAPPED flag set. Because the remap tree is orthogonal to the extent
&gt; tree, for data this may be within any number of identity remaps or
&gt; actual remaps. If we&#x27;re freeing a metadata node, this will be wholly
&gt; inside one or the other.
&gt; 
&gt; btrfs_remove_extent_from_remap_tree() searches the remap tree for the
&gt; remaps that cover the range in question, then calls
&gt; remove_range_from_remap_tree() for each one, to punch a hole in the
&gt; remap and adjust the free-space tree.
&gt; 
&gt; For an identity remap, remove_range_from_remap_tree() will adjust the
&gt; block group&#x27;s `identity_remap_count` if this changes. If it reaches
&gt; zero we mark the block group as fully remapped.
&gt; 
&gt; For an identity remap, remove_range_from_remap_tree() will adjust the
&gt; block group&#x27;s `identity_remap_count` if this changes. If it reaches
&gt; zero we mark the block group as fully remapped.
&gt; 
&gt; Fully remapped block groups have their chunk stripes removed and their
&gt; device extents freed, which makes the disk space available again to the
&gt; chunk allocator. This happens asynchronously: in the cleaner thread for
&gt; sync discard and nodiscard, and (in a later patch) in the discard worker
&gt; for async discard.

Hi everyone,

Another AI review from my recent linux-next run:

&gt; diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
&gt; --- a/fs/btrfs/relocation.c
&gt; +++ b/fs/btrfs/relocation.c

[ ... ]

&gt; +int btrfs_last_identity_remap_gone(struct btrfs_chunk_map *chunk_map,
&gt; +				   struct btrfs_block_group *bg)
&gt; +{
&gt; +	struct btrfs_fs_info *fs_info = bg-&gt;fs_info;
&gt; +	struct btrfs_trans_handle *trans;
&gt; +	int ret;
&gt; +	unsigned int num_items;
&gt; +	BTRFS_PATH_AUTO_FREE(path);
&gt; +
&gt; +	path = btrfs_alloc_path();
&gt; +	if (!path)
&gt; +		return -ENOMEM;
&gt; +
&gt; +	/*
&gt; +	 * One item for each entry we&#x27;re removing in the dev extents tree, and
&gt; +	 * another for each device. DUP chunks are all on one device,
&gt; +	 * everything else has one device per stripe.
&gt; +	 */
&gt; +	if (bg-&gt;flags &amp; BTRFS_BLOCK_GROUP_DUP)
&gt; +		num_items = chunk_map-&gt;num_stripes + 1;
&gt; +	else
&gt; +		num_items = 2 * chunk_map-&gt;num_stripes;
&gt; +
&gt; +	trans = btrfs_start_transaction_fallback_global_rsv(fs_info-&gt;tree_root, num_items);
&gt; +	if (IS_ERR(trans))
&gt; +		return PTR_ERR(trans);
&gt; +
&gt; +	ret = btrfs_remove_dev_extents(trans, chunk_map);
&gt; +	if (unlikely(ret)) {
&gt; +		btrfs_abort_transaction(trans, ret);
&gt; +		return ret;
&gt; +	}

Can this leak the transaction handle? btrfs_abort_transaction() marks
the transaction as aborted but does not end it. __btrfs_abort_transaction()
has a comment explaining cleanup happens in btrfs_end_transaction().

&gt; +
&gt; +	mutex_lock(&amp;trans-&gt;fs_info-&gt;chunk_mutex);
&gt; +	for (unsigned int i = 0; i &lt; chunk_map-&gt;num_stripes; i++) {
&gt; +		ret = btrfs_update_device(trans, chunk_map-&gt;stripes[i].dev);
&gt; +		if (unlikely(ret)) {
&gt; +			mutex_unlock(&amp;trans-&gt;fs_info-&gt;chunk_mutex);
&gt; +			btrfs_abort_transaction(trans, ret);
&gt; +			return ret;
&gt; +		}

Same question here about leaking the transaction handle.

&gt; +	}
&gt; +	mutex_unlock(&amp;trans-&gt;fs_info-&gt;chunk_mutex);
&gt; +
&gt; +	write_lock(&amp;trans-&gt;fs_info-&gt;mapping_tree_lock);
&gt; +	btrfs_chunk_map_device_clear_bits(chunk_map, CHUNK_ALLOCATED);
&gt; +	write_unlock(&amp;trans-&gt;fs_info-&gt;mapping_tree_lock);
&gt; +
&gt; +	btrfs_remove_bg_from_sinfo(bg);
&gt; +
&gt; +	ret = remove_chunk_stripes(trans, chunk_map, path);
&gt; +	if (unlikely(ret)) {
&gt; +		btrfs_abort_transaction(trans, ret);
&gt; +		return ret;
&gt; +	}

And here as well - does this return path need btrfs_end_transaction()?

&gt; +
&gt; +	ret = btrfs_commit_transaction(trans);
&gt; +	if (ret)
&gt; +		return ret;
&gt; +
&gt; +	return 0;
&gt; +}

[ ... ]

&gt; +static int remove_range_from_remap_tree(struct btrfs_trans_handle *trans,
&gt; +					struct btrfs_path *path,
&gt; +					struct btrfs_block_group *bg,
&gt; +					u64 hole_start, u64 hole_length)
&gt; +{

[ ... ]

&gt; +	if (!is_identity_remap) {
&gt; +		struct btrfs_block_group *dest_bg;
&gt; +
&gt; +		dest_bg = btrfs_lookup_block_group(fs_info, new_addr);
&gt; +		adjust_block_group_remap_bytes(trans, dest_bg, -overlap_length);
&gt; +		btrfs_put_block_group(dest_bg);

btrfs_lookup_block_group() can return NULL if no block group is found
for the address. Every other caller checks for NULL before using the
result. Is a NULL check needed here before passing dest_bg to
adjust_block_group_remap_bytes()? That function does spin_lock(&amp;bg-&gt;lock)
which would crash on a NULL pointer.

&gt; +		ret = btrfs_add_to_free_space_tree(trans,
&gt; +						   hole_start - remap_start + new_addr,
&gt; +						   overlap_length);
&gt; +		if (ret)
&gt; +			return ret;
&gt; +	}

[ ... ]

This is not a bug, but the commit message appears to have a duplicated
paragraph about identity remaps:

    For an identity remap, remove_range_from_remap_tree() will adjust the
    block group&#x27;s `identity_remap_count` if this changes. If it reaches
    zero we mark the block group as fully remapped.

    For an identity remap, remove_range_from_remap_tree() will adjust the
    block group&#x27;s `identity_remap_count` if this changes. If it reaches
    zero we mark the block group as fully remapped.



---

Mark Harmstone &lt;mark@harmstone.com&gt; wrote:
&gt; Change btrfs_map_block() so that if the block group has the REMAPPED
&gt; flag set, we call btrfs_translate_remap() to obtain a new address.
&gt; 
&gt; btrfs_translate_remap() searches the remap tree for a range
&gt; corresponding to the logical address passed to btrfs_map_block(). If it
&gt; is within an identity remap, this part of the block group hasn&#x27;t yet
&gt; been relocated, and so we use the existing address.
&gt; 
&gt; If it is within an actual remap, we subtract the start of the remap
&gt; range and add the address of its destination, contained in the item&#x27;s
&gt; payload.
&gt; 

Hi everyone,

Another AI review from linux-next runs:

&gt; diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
&gt; --- a/fs/btrfs/volumes.c
&gt; +++ b/fs/btrfs/volumes.c
&gt; @@ -6586,6 +6586,24 @@ struct btrfs_io_geometry io_geom = { 0 };
&gt; 	if (IS_ERR(map))
&gt; 		return PTR_ERR(map);
&gt;
&gt; +	if (map-&gt;type &amp; BTRFS_BLOCK_GROUP_REMAPPED) {
&gt; +		u64 new_logical = logical;
&gt; +
&gt; +		ret = btrfs_translate_remap(fs_info, &amp;new_logical, length);
&gt; +		if (ret)
&gt; +			return ret;
                        ^^^^^^^^^^

When btrfs_translate_remap() returns an error, does this leak the chunk
map? The map was obtained via btrfs_get_chunk_map() which increments a
refcount, and btrfs_get_chunk_map() documents that callers are
responsible for dropping the reference. The other error paths in this
function use goto out, which calls btrfs_free_chunk_map(map).

&gt; +
&gt; +		if (new_logical != logical) {
&gt; +			btrfs_free_chunk_map(map);
&gt; +
&gt; +			map = btrfs_get_chunk_map(fs_info, new_logical, *length);
&gt; +			if (IS_ERR(map))
&gt; +				return PTR_ERR(map);
&gt; +
&gt; +			logical = new_logical;
&gt; +		}
&gt; +	}

[ ... ]
</pre>
</details>
<div class="review-comment-signals">Signals: potential bug, leak</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>