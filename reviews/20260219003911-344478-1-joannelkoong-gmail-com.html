<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: [PATCH v1 0/1] iomap: don&#x27;t mark folio uptodate if read IO has bytes pending</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>[PATCH v1 0/1] iomap: don&#x27;t mark folio uptodate if read IO has bytes pending</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/20260219003911.344478-1-joannelkoong@gmail.com/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-24">2026-02-24</a> &bull; <a href="#2026-02-23">2026-02-23</a> &bull; <a href="#2026-02-20">2026-02-20</a> &bull; <a href="#2026-02-19">2026-02-19</a> &bull; <a href="#2026-02-18">2026-02-18</a></div>
    <div class="patch-summary-block"><div class="patch-summary-label">Patch summary</div><div class="patch-summary-text">This patch fixes a bug where a folio is incorrectly marked as uptodate if there are still bytes pending from a read IO operation. The issue occurs when the read_folio() function is called on a folio size that is larger than the actual file size, and the post-eof blocks are zeroed and marked uptodate before the pending bytes are subtracted. The patch prevents this by not marking the folio uptodate if there are still bytes pending from the read IO operation.</div></div>
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-18">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Joanne Koong (author)</span>
<a class="date-chip" href="../2026-02-19_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern that marking the folio uptodate in iomap_set_range_uptodate() can be cleared by the XOR semantics used in folio_end_read(). The author agreed to fix this issue by not marking the folio as uptodate if the read IO has bytes pending, and instead setting it uptodate through iomap_end_read()-&gt;folio_end_read() in the read completion path.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">If a folio has ifs metadata attached to it and the folio is partially
read in through an async IO helper with the rest of it then being read
in through post-EOF zeroing or as inline data, and the helper
successfully finishes the read first, then post-EOF zeroing / reading
inline will mark the folio as uptodate in iomap_set_range_uptodate().

This is a problem because when the read completion path later calls
iomap_read_end(), it will call folio_end_read(), which sets the uptodate
bit using XOR semantics. Calling folio_end_read() on a folio that was
already marked uptodate clears the uptodate bit.

Fix this by not marking the folio as uptodate if the read IO has bytes
pending. The folio uptodate state will be set in the read completion
path through iomap_end_read() -&gt; folio_end_read().

Reported-by: Wei Gao &lt;wegao@suse.com&gt;
Suggested-by: Sasha Levin &lt;sashal@kernel.org&gt;
Tested-by: Wei Gao &lt;wegao@suse.com&gt;
Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Fixes: b2f35ac4146d (&quot;iomap: add caller-provided callbacks for read and readahead&quot;)
---
 fs/iomap/buffered-io.c | 15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 58887513b894..4fc5ce963feb 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -80,18 +80,27 @@ static void iomap_set_range_uptodate(struct folio *folio, size_t off,
 {
 	struct iomap_folio_state *ifs = folio-&gt;private;
 	unsigned long flags;
-	bool uptodate = true;
+	bool mark_uptodate = true;
 
 	if (folio_test_uptodate(folio))
 		return;
 
 	if (ifs) {
 		spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
-		uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
+		/*
+		 * If a read with bytes pending is in progress, we must not call
+		 * folio_mark_uptodate(). The read completion path
+		 * (iomap_read_end()) will call folio_end_read(), which uses XOR
+		 * semantics to set the uptodate bit. If we set it here, the XOR
+		 * in folio_end_read() will clear it, leaving the folio not
+		 * uptodate.
+		 */
+		mark_uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &amp;&amp;
+				!ifs-&gt;read_bytes_pending;
 		spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
 	}
 
-	if (uptodate)
+	if (mark_uptodate)
 		folio_mark_uptodate(folio);
 }
 
-- 
2.47.3</pre>
</details>
</div>
<div class="thread-children">
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Darrick Wong</span>
<a class="date-chip" href="../2026-02-19_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Darrick Wong suggested adding a link to the relevant discussion on linux-fsdevel and CC&#x27;ing stable@vger.kernel.org, as the original patch is now in a released kernel.

Reviewer Darrick Wong noted that the patch is easy to understand and implement, but requested a test be written for it</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">I would add:

Link: https://lore.kernel.org/linux-fsdevel/aYbmy8JdgXwsGaPP@autotest-wegao.qe.prg2.suse.org/
Cc: &lt;stable@vger.kernel.org&gt; # v6.19

since the recent discussion around this was sort of buried in a
different thread, and the original patch is now in a released kernel.

---

Yeah, that makes sense.  How difficult is this to write up as an fstest?

Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;

--D</pre>
</details>
<div class="review-comment-signals">Signals: no clear signal</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2" id="2026-02-19">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Matthew Wilcox</span>
<a class="date-chip" href="../2026-02-19_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-19">2026-02-19</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer expressed frustration that the iomap code has become overly complicated, making it difficult to understand or explain how to fix the issue of marking a folio uptodate when read IO has bytes pending</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">This isn&#x27;t &quot;the xor thing has come back to bite us&quot;.  This is &quot;the iomap
code is now too complicated and I cannot figure out how to explain to
Joanne that there&#x27;s really a simple way to do this&quot;.

I&#x27;m going to have to set aside my current projects and redo the iomap
readahead/read_folio code myself, aren&#x27;t I?</pre>
</details>
<div class="review-comment-signals">Signals: frustration, difficulty understanding</div>
</div>
<div class="thread-children">
<div class="thread-node depth-3">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Darrick Wong</span>
<a class="date-chip" href="../2026-02-19_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-18">2026-02-18</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Darrick Wong expressed confusion about an alternative approach mentioned in the patch description, suggesting that he missed a relevant discussion and requested clarification on what this simpler way is.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Well you could try explaining to me what that simpler way is?

/me gets the sense he&#x27;s missing a discussion somewhere...

--D</pre>
</details>
<div class="review-comment-signals">Signals: confusion, lack of context</div>
</div>
</div>
<div class="thread-node depth-3">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Darrick Wong</span>
<a class="date-chip" href="../2026-02-20_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-20">2026-02-20</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Darrick Wong noted that the read_bytes_pending field has inconsistent behavior across different IO paths, and suggested consolidating the read code into a single function to simplify the logic.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">&lt;willy and I had a chat; this is a clumsy non-AI summary of it&gt;

I started looking at folio read state management in iomap, and made a
few observations that (I hope) match what willy&#x27;s grumpy about.

There are three ways that iomap can be reading into the pagecache:
a) async -&gt;readahead,
b) synchronous -&gt;read_folio (page faults), and
c) synchronous -&gt;read_folio_range (pagecache write).

(Note that (b) can call a different -&gt;read_folio_range than (c), though
all implementations seem to have the same function)

All three of these IO paths share the behavior that they try to fill out
the folio&#x27;s contents and set the corresponding folio/ifs uptodate bits
if that succeeds.  Folio contents can come from anywhere, whether it&#x27;s:

i) zeroing memory,
ii) copying from an inlinedata buffer, or
iii) asynchronously fetching the contents from somewhere

In the case of (c) above, if the read fails then we fail the write, and
if the read succeeds then we start copying to the pagecache.

However, (a) and (b) have this additional read_bytes_pending field in
the ifs that implements some extra tracking.  AFAICT the purpose of this
field is to ensure that we don&#x27;t call folio_end_read prematurely if
there&#x27;s an async read in progress.  This can happen if iomap_iter
returns a negative errno on a partially processed folio, I think?

read_bytes_pending is initialized to the folio_size() at the start of a
read and subtracted from when parts of the folio are supplied, whether
that&#x27;s synchronous zeroing or asynchronous read ioend completion.  When
the field reaches zero, we can then call folio_end_read().

But then there are twists, like the fact that we only call
iomap_read_init() to set read_bytes_pending if we decide to do an
asynchronous read.  Or that iomap_read_end and iomap_finish_folio_read
have awfully similar code.  I think in the case of (i) and (ii) we also
don&#x27;t touch read_pending_bytes at all, and merely set the uptodate bits?

This is confusing to me.  It would be more straightforward (I think) if
we just did it for all cases instead of adding more conditionals.  IOWs,
how hard would it be to consolidate the read code so that there&#x27;s one
function that iomap calls when it has filled out part of a folio.  Is
that possible, even though we shouldn&#x27;t be calling folio_end_read during
a pagecache write?

At the end of the day, however, there&#x27;s a bug in Linus&#x27; tree and we need
to fix it, so Joanne&#x27;s patch is a sufficient bandaid until we can go
clean this up.

--D</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, suggested improvements</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-2" id="2026-02-20">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Joanne Koong (author)</span>
<a class="date-chip" href="../2026-02-20_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-20">2026-02-20</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2, but instead provided a link to prior discussion without addressing the specific feedback.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">This is the link to the prior discussion
https://lore.kernel.org/linux-fsdevel/20251223223018.3295372-1-sashal@kernel.org/T/#mbd61eaa5fd1e8922caa479720232628e39b8c9da

Thanks,
Joanne</pre>
</details>
<div class="review-comment-signals">Signals: lack of direct response, link to prior discussion</div>
</div>
</div>
<div class="thread-node depth-2" id="2026-02-23">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Joanne Koong (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author acknowledged that the read IO has bytes pending issue also applies to async reads, confirming the problem is more widespread than initially thought.

Author clarified that synchronous zeroing does not update read_bytes_pending, explaining the distinction between synchronous and asynchronous read completions.

Author Joanne Koong addressed Darrick Wong&#x27;s concern about consolidating synchronous -&gt;read_folio_range() for buffered writes with the async read logic, explaining that it would add extra overhead and make handling more complicated. She agreed that there are edge cases to consider in the async read path but expressed reservations about manipulating read_bytes_pending from other paths like zeroing and inline reads due to potential race conditions.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">b) is async as well. The code for b) and a) are exactly the same (the
logic in iomap_read_folio_iter())

---

Synchronous zeroing does not update read_bytes_pending, only async
read completions do.

---

imo, I don&#x27;t think the synchronous -&gt;read_folio_range() for buffered
writes should be consolidated with the async read logic. If we have
the synchronous write path setting read_bytes_pending, that adds extra
overhead with having to acquire/release the spinlock for every range
read in. It also makes the handling more complicated (eg now having to
differentiate whether the folio was read in for a read vs. a write).
Synchronous -&gt;read_folio_range() for buffered writes is extremely
simple and self-contained right now and I think it should be kept that
way.

For async reads, I agree that there are a bunch of different edge
cases that arise from i) ii) and iii), and from the fact that a folio
could be composed of a mixture of i) ii) and iii).

The motivation for adding read_bytes_pending was so we could know
which async read finishes last. eg this example scenario: read a 64k
folio where the first and last page are not uptodate but everything in
between is
* -&gt;read_folio_range() for 0 to 4k
* -&gt;read_folio_range() for 60k to 64k
These two async read calls may be two different I/O requests that
complete at different times but only the last finisher should call
folio_end_read().

I don&#x27;t think having the zeroing and inline read paths also
manipulating read_bytes_pending helps here. This was discussed a bit
in [1] but I think it runs into other edge cases / race conditions [2]
that would need to be accounted for and makes some paths more
suboptimal (eg unnecessary ifs allocations and spinlock acquires). But
maybe I&#x27;m missing something here and there is a better approach for
doing this?

Thanks,
Joanne

[1] https://lore.kernel.org/linux-fsdevel/CAJnrk1YcuhKwbZLo-11=umcTzH_OJ+bdwZq5=XjeJo8gb9e5ig@mail.gmail.com/T/#md09648082a96122ec1e541993872e0c43da5105f
[2] https://lore.kernel.org/linux-fsdevel/CAJnrk1YcuhKwbZLo-11=umcTzH_OJ+bdwZq5=XjeJo8gb9e5ig@mail.gmail.com/T/#mdc49b649378798fa9e850c9c6914c8c6af5e2895</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged a broader scope of the issue, clarification, explanation</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-02-24">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Christoph Hellwig</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-24">2026-02-24</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Christoph Hellwig noted that merging the code would be useful, but he hasn&#x27;t found a good way to do it yet, and expressed concern about the range logic in -&gt;read_folio</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Yes.  I&#x27;ve been thinking about that on and off, but unfortunately so far
I&#x27;ve not come up with a good idea how to merge the code.  Doing so would
be very useful for many reasons.

The problem with that isn&#x27;t really async vs sync; -&gt;read_folio clearly
shows you you turn underlying asynchronous logic into a synchronous call.
It&#x27;s really about the range logic, where the writer preparation might
want to only read the head and the tail segments of a folio.

But if we can merge that into the main implementation and have a single
core implementation we&#x27;d be much better off.

Anyone looking for a &quot;little&quot; project? :)</pre>
</details>
<div class="review-comment-signals">Signals: NEEDS_WORK</div>
</div>
</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>