{
  "thread_id": "a0eab8f07873e38fa4c5d958de6b75761d690874.camel@kernel.org",
  "subject": "Re: [LSF/MM/BPF TOPIC] VFS idmappings support in NFS",
  "url": "https://lore.kernel.org/all/a0eab8f07873e38fa4c5d958de6b75761d690874.camel@kernel.org/",
  "dates": {
    "2026-02-18": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton requested an example of how to use VFS idmappings with NFS in a real environment, specifically for the AUTH_SYS case without NFSv4 idmapping involved.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "request_for_clarity",
            "need_for_example"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "IIUC, people mostly use vfs-layer idmappings because they want to remap\nthe uid/gid values of files that get stored on the backing store (disk,\nceph MDS, or whatever).\n\nI've never used idmappings myself much in practice. Could you lay out\nan example of how you would use them with NFS in a real environment so\nI understand the problem better? I'd start by assuming a simple setup\nwith AUTH_SYS and no NFSv4 idmapping involved, since that case should\nbe fairly straightforward.\n\nMixing in AUTH_GSS and real idmapping will be where things get harder,\nso let's not worry about those cases for now.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2, but did not provide a clear resolution signal.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged",
            "agreed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Hi Jeff,\n\nthanks for such a fast reply! ;)",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "The author is addressing a concern about the use case for VFS idmappings in NFS, specifically how it would work when delegating filesystems to containers. The author explains that their project uses idmapped mounts as a way to 'delegate' filesystems to containers and applies the VFS idmap equal to the container's user namespace, making the behavior described by Jeff Layton possible.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "For me, from the point of LXC/Incus project, idmapped mounts are used as\na way to \"delegate\" filesystems (or subtrees) to the containers:\n1. We, of course, assume that container enables user namespaces and\nuser can't mount a filesystem\ninside because it has no FS_USERNS_MOUNT flag set (like in case of Cephfs, NFS,\nCIFS and many others).\n2. At the same time host's system administrator wants to avoid\nremapping between container's user ns and\nsb->s_user_ns (which is init_user_ns for those filesystems). [\nmotivation here is that in many\ncases you may want to have the same subtree to be shared with other\ncontainers and even host users too and\nyou want UIDs to be \"compatible\", i.e UID 1000 in one container and\nUID 1000 in another container should\nland as UID 1000 on the filesystem's inode ]\n\nFor this usecase, when we bind-mount filesystem to container, we apply\nVFS idmap equal to container's\nuser namespace. This makes a behavior I described.\n\nBut this is just one use case. I'm pretty sure there are some more\naround here :)\nI know that folks from Preferred Networks (preferred.jp) are also\ninterested in VFS idmap support in NFS,\nprobably they can share some ideas/use cases too.",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author acknowledged that the NFS server needs to handle path-based UID/GID restrictions, which is a challenge for VFS idmappings support in NFS, and agreed to discuss this further.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged a challenge",
            "agreed to discuss"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Kind regards,\nAlex",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Trond Myklebust",
          "summary": "Reviewer noted that strong authentication in NFS and RPC protocols defeats client-side idmapping schemes because the server cannot know the client's UIDs or GIDs, and suggested that a generic implementation would require exchanging and storing information between client and server to allow file owner/group owner mapping.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "protocol extensions",
            "security model"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I think you do need to worry about those cases. As the NFS and RPC\nprotocols stand today, strong authentication will defeat any client\nside idmapping scheme, because the server can't know what uids or gids\nthe client is using on its end; it just knows about the account that\nwas used to authenticate.\n\nI think if you do want to implement something generic, you're going to\nhave to consider how the client and server can exchange (and store) the\ninformation needed to allow the client to perform the mapping of file\nowners/group owners on its end. The client would presumably also need\nto be in charge of enforcing permissions for such mappings.\nIt would be a very different security model than the one used by NFS\ntoday, and almost certainly require protocol extensions.\n\n-- \nTrond Myklebust\nLinux NFS client maintainer, Hammerspace\ntrondmy@kernel.org, trond.myklebust@hammerspace.com",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton expressed concern about the complexity of implementing VFS idmappings support in NFS, noting that multiple layers could be involved and requesting a clear understanding of a simple use-case before introducing additional complexities.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "complexity",
            "multiple layers"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Oh, we absolutely need to worry about them, but this is a difficult\ntopic to get our arms around. We can potentially have several layers\nthat are doing idmapping, so I want to understand a simple use-case\nfirst. Once that's clear I plan to start throwing in monkey wrenches.",
          "reply_to": "Trond Myklebust",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton expressed uncertainty about the use-case for VFS idmappings in NFS, suggesting that shifting UIDs at a higher level might be sufficient without modifying the protocol.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "uncertainty",
            "lack of understanding"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "That may be, but I still don't fully understand the use-case here.\nMaybe they'd be content with just shifting UIDs at a higher level\nwithout changing the protocol? Without understanding how they intend to\nuse this, it's hard to know what's needed.\n\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Trond Myklebust",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author is responding to Jeff Layton's feedback, acknowledging that their earlier reply may not have clarified the LXC/Incus use case and offering to provide a more detailed explanation.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification sought",
            "more information offered"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Please, let me know if my earlier reply doesn't clarify LXC/Incus use case.\nI can prepare a more detailed explanation with command line/configuration\nexamples with pleasure.",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "The author acknowledges that the approach of keeping NFS protocol changes to a minimum was not acceptable in the past, but is open to revisiting it and proposes an iterative approach where the initial version can be simple and then more complex cases can be added later.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no_problem",
            "look_positively"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "If you ask me, I have no problem or I would say more, I look positively\non the way \"keep it high level & don't touch NFS protocol\" ;-)\nBut I remember a very tight discussion (good context [1]) about Cephfs and\nthis way wasn't considered as acceptable back then (and we had to make\na protocol extension).\nWe can always go iteratively, and first version can be simple and then on-demand\nwe can support more tricky cases if this is acceptable for you guys.\nYou set the rules. ;-)\n\n[1] https://lore.kernel.org/lkml/f3864ed6-8c97-8a7a-f268-dab29eb2fb21@redhat.com/\n\nKind regards,\nAlex",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "The reviewer noted that for NFS, idmapping can be achieved by converting RPC credentials at the client layer, and suggested this approach as an alternative to requiring a protocol extension.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "alternative solution",
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Ok: so you have a process running in a userns as UID 2000 and you want\nto use vfs layer idmapping so that when you create a file as that user\nthat it ends up being owned by UID 1000. Is that basically correct?\n\nTypically, the RPC credentials used in an OPEN or CREATE call is what\ndetermines its ownership (at least until a SETATTR comes in). With\nAUTH_SYS, the credential is just a uid and set of gids.\n\nSo in this case, it sounds like you would need just do that conversion\n(maybe at the RPC client layer?) when issuing an RPC. You don't really\nneed a protocol extension for that case.\n\nAs Trond points out though, AUTH_GSS and NFSv4 idmapping will make this\nmore complex. Once you're using kerberos credentials for\nauthentication, you don't have much control over what the UIDs and GIDs\nwill be on newly-created files, but is that really a problem? As long\nas all of the clients have a consistent view, I wouldn't think so.",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer suggested focusing on a single simple problem in VFS idmappings support for NFS, rather than trying to tackle multiple use-cases at once.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no clear technical objection or suggestion"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Yes, we don't want to focus too much on a single use-case, but I find\nit helpful to focus on a single simple problem first.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "The author is addressing a concern about how VFS idmaps interact with NFS mounts and user namespaces, explaining that the UID mapping works as expected in their specific scenario but acknowledging that the issue of 'caller UID/GID are needed everywhere' still needs to be addressed.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledging a technical challenge",
            "no clear resolution signal"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "In our case, we have a UID 1000 (inside user namespace), which mapped to\nsomething like 10000 + 1000 (in the init_user_ns). And then we have\nNFS mount (sb->s_user_ns = init_user_ns, ofc), so if user UID 1000\n(inside the container)\ncreates a file, it will be 11000, right? But we do bind-mount of that\nNFS mount+VFS idmap,\nso that once file is created it has owner_uid = 1000. (This scenario\nis covered by [1] and [2])\n\n[1] https://docs.kernel.org/filesystems/idmappings.html#example-3\n[2] https://docs.kernel.org/filesystems/idmappings.html#example-3-reconsidered",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author agrees to provide a starting point for the NFS implementation by preparing RFC patches for a simple case, indicating a willingness to move forward with the patch series.",
          "sentiment": "positive",
          "sentiment_signals": [
            "agreement",
            "willingness to progress"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Yes, I could prepare RFC patches before LSF/MM/BPF for that simple case so\nwe have something to start with.",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-19": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "NeilBrown",
          "summary": "The reviewer pointed out that when using krb5 and NFSv3, the mapping between krb5 identity and uid should be consistent on both client and server to ensure correct ownership of files. They also noted that for NFSv4 and idmapper, the kernel idmapping is not needed and the idmapper daemon should run in user-namespace to map from on-the-wire names to app-level uids.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "You also need to consider the conversion when receiving an RPC.\n\nIf you use krb5 and NFSv3 then you really want the mapping between krb5\nidentity and uid to be the same on client and server, so then when an\napplication creates a file and the stats it, it sees that it owns it.\n\nIf I use a krb5 identity in an idmapped NFS filesystem I'll want the\nserver to map the identity to the \"underlying\" uid (was would be stored\nin a local filesystem) and then when the client gets a GETATTR reply,\nthe VFS maps back to the uid seen by the application.\n\nWith NFSv4 and the idmapper you wouldn't need (or want) the kernel\nidmapping to be used at all.  You would want the idmapper deamon to run\nin the user-namespace and map from on-the-wire names to the appropriate\napp-level uids.\nThis would mean that a given NFS mount would need to be an a given user\nnamespace.  Maybe that isn't desired.\n\nIf it is important for a given NFS mount to be available in multiple\nuser namespaces, then the idmapper daemon would need to map to the\nunderlying uid, and the VFS mapping would map that up to the app-level\nuid.\n\nNeilBrown",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        },
        {
          "author": "Kohei Sugihara",
          "summary": "Reviewer Kohei Sugihara expressed interest in the proposed VFS idmappings support in NFS, indicating that his team has a relevant use case they would like to discuss.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no specific technical concerns or suggestions"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Thank you Alex for the proposal and quick follow-ups. We're really\ninterested in this feature and we'd like to share our use case.",
          "reply_to": "NeilBrown",
          "message_date": "2026-02-19"
        },
        {
          "author": "Kohei Sugihara",
          "summary": "Kohei Sugihara noted that NFS is complex due to its variety of mount options and security features, making it challenging to support ID-mapping. He proposed two possible models for handling UID/GID: (a) the NFS client sends the container's UID/GID on the wire and the server stores them as such, or (b) the server stores the host's UID/GID and the client/VFS maps it to the container's UID/GID. Sugihara expressed a preference for model (a) but acknowledged potential security/policy implications.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "complexity",
            "security features"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Our use case is running multi-tenant Kubernetes clusters with\nKubernetes User Namespaces [1]. Basically we need to share a single\nstorage endpoint among multiple pods using ReadWriteMany (RWX) access\nmode. Implementations that support both RWX and ID-mapped mount are\nlimited [2].\n\nNFS is operationally common, so I am interested in supporting NFS for\nID-mapping, but NFS is complex due to its variety of mount options and\nsecurity features as Trond mentioned. We'd like to share our use case\nand define the minimum goal. Our goal is here:\n\n- 1: Mount the same NFS export as a persistent volume from multiple\nKubernetes Pods running on different compute nodes. Each tenant has\nits own exports.\n- 2: UID/GID in a container in the pod can be configurable to an\narbitrary value by runAsUser/runAsGroup (e.g. runAsUser/Group is set\nto 1000).\n- 3: We can access the export from the container as 1000:1000. At\nminimum, ownership should be consistent from the container view (i.e.\nstat shows 1000:1000 for files that the container creates). Today,\nID-mapped mount does not support NFS. The NFS client ends up using the\nhost-mapped uid/gid (e.g. container 1000 becomes host 11000), so the\ncontainer view becomes inconsistent across nodes.\n\nThere are (at least) two possible models here:\na) the NFS client sends 1000:1000 on the wire and the server stores\n1000:1000 (so server-side ownership matches the container uid/gid), or\nb) the server stores the host uid/gid (e.g. 11000:11000) and the\nclient/VFS maps it so that the container still sees 1000:1000.\nMy intuition is that (a) is simpler for a multi-node RWX setup, but it\nmay have security / policy implications depending on how the server\ndoes authorization (especially with sec=sys). I think itâ€™s worth\ndiscussing what the safe and reasonable minimum should be.\n\nIn this case, UID/GID in the host node is not deterministic for the\nprocess in the container due to user_namespaces(7), so we need to do\nID-mapping to unify UID/GID between container and file system. Also,\nwe likely need to consider both request and reply paths (e.g. GETATTR)\nto keep the view consistent.",
          "reply_to": "NeilBrown",
          "message_date": "2026-02-19"
        },
        {
          "author": "Kohei Sugihara",
          "summary": "Reviewer noted that the proposed ID-mapping solution may violate NFS protocol requirements and suggested starting with a small case to test its feasibility, while also considering client-side implementation to cover existing server implementations.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "concerns about consistency"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Neil, thank you for your comment. We initially expected it to be in\nNFSv4. I totally agree with you and exactly our concern is how do we\nmake it consistent with idmapd(8). In the Kubernetes case, we cannot\npass CAP_SYS_ADMIN to allow pods to mount NFS directly, so mount will\nbe done on the host. As you mentioned, we think we can share a single\nNFS export from multiple hosts and pods, so I think introducing\nID-mapping into the VFS layer (with referencing local id-mapping\ntable) is appropriate.\n\nWe can start by picking a small case. My concern was whether this\ncould violate NFS protocol or not, whether things can be done on the\nclient side or not, and this topic is suitable for dealing with this\nas the VFS community. If things can be done on the client side, we can\ncover existing NFS server implementations (e.g. OpenZFS, proprietary\nappliances). I believe this can be applied to recent containerized\nruntime environments, even this small working set.\n\nAdding more context, Kubernetes and the container community actively\nwork on host isolation using the Linux user namespace feature.\nRecently they experienced RCE vulnerabilities on container runtime but\nit could be mitigated by host isolation using the user namespace\nisolation [3]. Along with migrating the runtime environment to user\nnamespace, extending file system support will be worth discussing.\n\nKind regards,\nKohei\n\n[1] https://kubernetes.io/docs/concepts/workloads/pods/user-namespaces/\n[2] https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes\n[3] https://lpc.events/event/19/contributions/2065/",
          "reply_to": "NeilBrown",
          "message_date": "2026-02-19"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-21": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Demi Obenour",
          "summary": "The reviewer noted that the secure case of NFS has similar problems to unprivileged virtiofsd on a system without user namespaces, where there's no way to store files with the UID/GID specified by VFS due to security restrictions. They proposed storing mapped UID and GID as a user.* xattr as a workaround, which requires no special permissions and scales to NFS servers with over 2^16 users.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "The secure case (strong authentication) has similar problems to\nunprivileged virtiofsd on a system with user namespaces disabled.\nIn both cases, there is no way to store the files with the UID/GID/etc\nthat the VFS says they should have.  The server (NFS) or kernel\n(virtiofsd) simply will not (and, for security reasons, *must not*)\nallow this.\n\nI proposed a workaround for virtiofsd [1] that I will also propose\nhere: store the mapped UID and GID as a user.* xattr.  This requires\nno special permissions, and so it completely solves this problem.\nIt is also the only solution I know of that scales to NFS servers\nwith over 2^16 users, which might well exist.\n\nThe only better solution I can think of is to replace the numeric\nUID/GID with hierarchical identifier, such as a Windows-style SID.\nThose are much more complex, though.\n\n[1]: https://gitlab.com/virtio-fs/virtiofsd/-/issues/225\n-- \nSincerely,\nDemi Marie Obenour (she/her/hers)",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-21"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    }
  }
}