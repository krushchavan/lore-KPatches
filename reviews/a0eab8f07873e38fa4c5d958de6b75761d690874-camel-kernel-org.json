{
  "thread_id": "a0eab8f07873e38fa4c5d958de6b75761d690874.camel@kernel.org",
  "subject": "Re: [LSF/MM/BPF TOPIC] VFS idmappings support in NFS",
  "url": "https://lore.kernel.org/all/a0eab8f07873e38fa4c5d958de6b75761d690874.camel@kernel.org/",
  "dates": {
    "2026-02-18": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton asked for an example of how VFS idmappings would be used in NFS, and suggested that the problem might not require a protocol extension if handled at the RPC client layer.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "asked_for_clarification",
            "offered_alternative_solution"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> Dear friends,\n> \n> I would like to propose \"VFS idmappings support in NFS\" as a topic for discussion at the LSF/MM/BPF Summit.\n> \n> Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and cephfs [1] with support/guidance\n> from Christian.\n> \n> This experience with Cephfs & FUSE has shown that VFS idmap semantics, while being very elegant and\n> intuitive for local filesystems, can be quite challenging to combine with network/network-like (e.g. FUSE)\n> FSes. In case of Cephfs we had to modify its protocol (!) (see [2]) as a part of our agreement with\n> ceph folks about the right way to support idmaps.\n> \n> One obstacle here was that cephfs has some features that are not very Linux-wayish, I would say.\n> In particular, system administrator can configure path-based UID/GID restrictions on a *server*-side (Ceph MDS).\n> Basically, you can say \"I expect UID 1000 and GID 2000 for all files under /stuff directory\".\n> The problem here is that these UID/GIDs are taken from a syscall-caller's creds (not from (struct file *)->f_cred)\n> which makes cephfs FDs not very transferable through unix sockets. [3]\n> \n> These path-based UID/GID restrictions mean that server expects client to send UID/GID with every single request,\n> not only for those OPs where UID/GID needs to be written to the disk (mknod, mkdir, symlink, etc).\n> VFS idmaps API is designed to prevent filesystems developers from making a mistakes when supporting FS_ALLOW_IDMAP.\n> For example, (struct mnt_idmap *) is not passed to every single i_op, but instead to only those where it can be\n> used legitimately. Particularly, readlink/listxattr or rmdir are not expected to use idmapping information anyhow.\n> \n> We've seen very similar challenges with FUSE. Not a long time ago on Linux Containers project forum, there\n> was a discussion about mergerfs (a popular FUSE-based filesystem) & VFS idmaps [5]. And I see that this problem\n> of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps adoption in some usecases.\n> Antonio Musumeci (mergerfs maintainer) claimed that in many cases filesystems behind mergerfs may not be fully\n> POSIX and basically, when mergerfs does IO on the underlying FSes it needs to do UID/GID switch to caller's UID/GID\n> (taken from FUSE request header).\n> \n> We don't expect NFS to be any simpler :-) I would say that supporting NFS is a final boss. It would be great\n> to have a deep technical discussion with VFS/FSes maintainers and developers about all these challenges and\n> make some conclusions and identify a right direction/approach to these problems. From my side, I'm going\n> to get more familiar with high-level part of NFS (or even make PoC if time permits), identify challenges,\n> summarize everything and prepare some slides to navigate/plan discussion.\n> \n> [1] cephfs https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> [3] cephfs & f_cred https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> [4] fuse/virtiofs https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> [5]\n> mergerfshttps://discuss.linuxcontainers.org/t/is-it-the-case-that-you-cannot-use-shift-true-for-disk-devices-where-the-source-is-a-mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> \n> Kind regards,\n> Alexander Mikhalitsyn @ futurfusion.io\n\n\nIIUC, people mostly use vfs-layer idmappings because they want to remap\nthe uid/gid values of files that get stored on the backing store (disk,\nceph MDS, or whatever).\n\nI've never used idmappings myself much in practice. Could you lay out\nan example of how you would use them with NFS in a real environment so\nI understand the problem better? I'd start by assuming a simple setup\nwith AUTH_SYS and no NFSv4 idmapping involved, since that case should\nbe fairly straightforward.\n\nMixing in AUTH_GSS and real idmapping will be where things get harder,\nso let's not worry about those cases for now.\n-- \nJeff Layton <jlayton@kernel.org>\n\n\n---\n\nOn Wed, 2026-02-18 at 15:36 +0100, Alexander Mikhalitsyn wrote:\n> Am Mi., 18. Feb. 2026 um 14:49 Uhr schrieb Jeff Layton <jlayton@kernel.org>:\n> > \n> > On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > > Dear friends,\n> > > \n> > > I would like to propose \"VFS idmappings support in NFS\" as a topic for discussion at the LSF/MM/BPF Summit.\n> > > \n> > > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and cephfs [1] with support/guidance\n> > > from Christian.\n> > > \n> > > This experience with Cephfs & FUSE has shown that VFS idmap semantics, while being very elegant and\n> > > intuitive for local filesystems, can be quite challenging to combine with network/network-like (e.g. FUSE)\n> > > FSes. In case of Cephfs we had to modify its protocol (!) (see [2]) as a part of our agreement with\n> > > ceph folks about the right way to support idmaps.\n> > > \n> > > One obstacle here was that cephfs has some features that are not very Linux-wayish, I would say.\n> > > In particular, system administrator can configure path-based UID/GID restrictions on a *server*-side (Ceph MDS).\n> > > Basically, you can say \"I expect UID 1000 and GID 2000 for all files under /stuff directory\".\n> > > The problem here is that these UID/GIDs are taken from a syscall-caller's creds (not from (struct file *)->f_cred)\n> > > which makes cephfs FDs not very transferable through unix sockets. [3]\n> > > \n> > > These path-based UID/GID restrictions mean that server expects client to send UID/GID with every single request,\n> > > not only for those OPs where UID/GID needs to be written to the disk (mknod, mkdir, symlink, etc).\n> > > VFS idmaps API is designed to prevent filesystems developers from making a mistakes when supporting FS_ALLOW_IDMAP.\n> > > For example, (struct mnt_idmap *) is not passed to every single i_op, but instead to only those where it can be\n> > > used legitimately. Particularly, readlink/listxattr or rmdir are not expected to use idmapping information anyhow.\n> > > \n> > > We've seen very similar challenges with FUSE. Not a long time ago on Linux Containers project forum, there\n> > > was a discussion about mergerfs (a popular FUSE-based filesystem) & VFS idmaps [5]. And I see that this problem\n> > > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps adoption in some usecases.\n> > > Antonio Musumeci (mergerfs maintainer) claimed that in many cases filesystems behind mergerfs may not be fully\n> > > POSIX and basically, when mergerfs does IO on the underlying FSes it needs to do UID/GID switch to caller's UID/GID\n> > > (taken from FUSE request header).\n> > > \n> > > We don't expect NFS to be any simpler :-) I would say that supporting NFS is a final boss. It would be great\n> > > to have a deep technical discussion with VFS/FSes maintainers and developers about all these challenges and\n> > > make some conclusions and identify a right direction/approach to these problems. From my side, I'm going\n> > > to get more familiar with high-level part of NFS (or even make PoC if time permits), identify challenges,\n> > > summarize everything and prepare some slides to navigate/plan discussion.\n> > > \n> > > [1] cephfs https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > > [3] cephfs & f_cred https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > > [4] fuse/virtiofs https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > > [5]\n> > > mergerfshttps://discuss.linuxcontainers.org/t/is-it-the-case-that-you-cannot-use-shift-true-for-disk-devices-where-the-source-is-a-mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> > > \n> > > Kind regards,\n> > > Alexander Mikhalitsyn @ futurfusion.io\n> > \n> \n> Hi Jeff,\n> \n> thanks for such a fast reply! ;)\n> \n> > \n> > IIUC, people mostly use vfs-layer idmappings because they want to remap\n> > the uid/gid values of files that get stored on the backing store (disk,\n> > ceph MDS, or whatever).\n> \n> yes, precisely.\n> \n> > \n> > I've never used idmappings myself much in practice. Could you lay out\n> > an example of how you would use them with NFS in a real environment so\n> > I understand the problem better? I'd start by assuming a simple setup\n> > with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> > be fairly straightforward.\n> \n> For me, from the point of LXC/Incus project, idmapped mounts are used as\n> a way to \"delegate\" filesystems (or subtrees) to the containers:\n> 1. We, of course, assume that container enables user namespaces and\n> user can't mount a filesystem\n> inside because it has no FS_USERNS_MOUNT flag set (like in case of Cephfs, NFS,\n> CIFS and many others).\n> 2. At the same time host's system administrator wants to avoid\n> remapping between container's user ns and\n> sb->s_user_ns (which is init_user_ns for those filesystems). [\n> motivation here is that in many\n> cases you may want to have the same subtree to be shared with other\n> containers and even host users too and\n> you want UIDs to be \"compatible\", i.e UID 1000 in one container and\n> UID 1000 in another container should\n> land as UID 1000 on the filesystem's inode ]\n> \n> For this usecase, when we bind-mount filesystem to container, we apply\n> VFS idmap equal to container's\n> user namespace. This makes a behavior I described.\n> \n\nOk: so you have a process running in a userns as UID 2000 and you want\nto use vfs layer idmapping so that when you create a file as that user\nthat it ends up being owned by UID 1000. Is that basically correct?\n\nTypically, the RPC credentials used in an OPEN or CREATE call is what\ndetermines its ownership (at least until a SETATTR comes in). With\nAUTH_SYS, the credential is just a uid and set of gids.\n\nSo in this case, it sounds like you would need just do that conversion\n(maybe at the RPC client layer?) when issuing an RPC. You don't really\nneed a protocol extension for that case.\n\nAs Trond points out though, AUTH_GSS and NFSv4 idmapping will make this\nmore complex. Once you're using kerberos credentials for\nauthentication, you don't have much control over what the UIDs and GIDs\nwill be on newly-created files, but is that really a problem? As long\nas all of the clients have a consistent view, I wouldn't think so.\n\n> But this is just one use case. I'm pretty sure there are some more\n> around here :)\n> I know that folks from Preferred Networks (preferred.jp) are also\n> interested in VFS idmap support in NFS,\n> probably they can share some ideas/use cases too.\n> \n> \n\nYes, we don't want to focus too much on a single use-case, but I find\nit helpful to focus on a single simple problem first.\n-- \nJeff Layton <jlayton@kernel.org>\n",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "The reviewer discussed the challenges of implementing VFS idmappings in NFS, referencing similar issues with Cephfs and FUSE. They proposed a high-level approach to avoid modifying the NFS protocol and suggested starting with a simple case before addressing more complex scenarios.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "NEEDS_WORK",
            "POSITIVE"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Am Mi., 18. Feb. 2026 um 14:49 Uhr schrieb Jeff Layton <jlayton@kernel.org>:\n>\n> On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > Dear friends,\n> >\n> > I would like to propose \"VFS idmappings support in NFS\" as a topic for discussion at the LSF/MM/BPF Summit.\n> >\n> > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and cephfs [1] with support/guidance\n> > from Christian.\n> >\n> > This experience with Cephfs & FUSE has shown that VFS idmap semantics, while being very elegant and\n> > intuitive for local filesystems, can be quite challenging to combine with network/network-like (e.g. FUSE)\n> > FSes. In case of Cephfs we had to modify its protocol (!) (see [2]) as a part of our agreement with\n> > ceph folks about the right way to support idmaps.\n> >\n> > One obstacle here was that cephfs has some features that are not very Linux-wayish, I would say.\n> > In particular, system administrator can configure path-based UID/GID restrictions on a *server*-side (Ceph MDS).\n> > Basically, you can say \"I expect UID 1000 and GID 2000 for all files under /stuff directory\".\n> > The problem here is that these UID/GIDs are taken from a syscall-caller's creds (not from (struct file *)->f_cred)\n> > which makes cephfs FDs not very transferable through unix sockets. [3]\n> >\n> > These path-based UID/GID restrictions mean that server expects client to send UID/GID with every single request,\n> > not only for those OPs where UID/GID needs to be written to the disk (mknod, mkdir, symlink, etc).\n> > VFS idmaps API is designed to prevent filesystems developers from making a mistakes when supporting FS_ALLOW_IDMAP.\n> > For example, (struct mnt_idmap *) is not passed to every single i_op, but instead to only those where it can be\n> > used legitimately. Particularly, readlink/listxattr or rmdir are not expected to use idmapping information anyhow.\n> >\n> > We've seen very similar challenges with FUSE. Not a long time ago on Linux Containers project forum, there\n> > was a discussion about mergerfs (a popular FUSE-based filesystem) & VFS idmaps [5]. And I see that this problem\n> > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps adoption in some usecases.\n> > Antonio Musumeci (mergerfs maintainer) claimed that in many cases filesystems behind mergerfs may not be fully\n> > POSIX and basically, when mergerfs does IO on the underlying FSes it needs to do UID/GID switch to caller's UID/GID\n> > (taken from FUSE request header).\n> >\n> > We don't expect NFS to be any simpler :-) I would say that supporting NFS is a final boss. It would be great\n> > to have a deep technical discussion with VFS/FSes maintainers and developers about all these challenges and\n> > make some conclusions and identify a right direction/approach to these problems. From my side, I'm going\n> > to get more familiar with high-level part of NFS (or even make PoC if time permits), identify challenges,\n> > summarize everything and prepare some slides to navigate/plan discussion.\n> >\n> > [1] cephfs https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > [3] cephfs & f_cred https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > [4] fuse/virtiofs https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > [5]\n> > mergerfshttps://discuss.linuxcontainers.org/t/is-it-the-case-that-you-cannot-use-shift-true-for-disk-devices-where-the-source-is-a-mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> >\n> > Kind regards,\n> > Alexander Mikhalitsyn @ futurfusion.io\n>\n\nHi Jeff,\n\nthanks for such a fast reply! ;)\n\n>\n> IIUC, people mostly use vfs-layer idmappings because they want to remap\n> the uid/gid values of files that get stored on the backing store (disk,\n> ceph MDS, or whatever).\n\nyes, precisely.\n\n>\n> I've never used idmappings myself much in practice. Could you lay out\n> an example of how you would use them with NFS in a real environment so\n> I understand the problem better? I'd start by assuming a simple setup\n> with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> be fairly straightforward.\n\nFor me, from the point of LXC/Incus project, idmapped mounts are used as\na way to \"delegate\" filesystems (or subtrees) to the containers:\n1. We, of course, assume that container enables user namespaces and\nuser can't mount a filesystem\ninside because it has no FS_USERNS_MOUNT flag set (like in case of Cephfs, NFS,\nCIFS and many others).\n2. At the same time host's system administrator wants to avoid\nremapping between container's user ns and\nsb->s_user_ns (which is init_user_ns for those filesystems). [\nmotivation here is that in many\ncases you may want to have the same subtree to be shared with other\ncontainers and even host users too and\nyou want UIDs to be \"compatible\", i.e UID 1000 in one container and\nUID 1000 in another container should\nland as UID 1000 on the filesystem's inode ]\n\nFor this usecase, when we bind-mount filesystem to container, we apply\nVFS idmap equal to container's\nuser namespace. This makes a behavior I described.\n\nBut this is just one use case. I'm pretty sure there are some more\naround here :)\nI know that folks from Preferred Networks (preferred.jp) are also\ninterested in VFS idmap support in NFS,\nprobably they can share some ideas/use cases too.\n\n>\n> Mixing in AUTH_GSS and real idmapping will be where things get harder,\n> so let's not worry about those cases for now.\n> --\n> Jeff Layton <jlayton@kernel.org>\n\nKind regards,\nAlex\n\n\n---\n\nAm Mi., 18. Feb. 2026 um 16:08 Uhr schrieb Jeff Layton <jlayton@kernel.org>:\n>\n> On Wed, 2026-02-18 at 09:37 -0500, Trond Myklebust wrote:\n> > On Wed, 2026-02-18 at 08:49 -0500, Jeff Layton wrote:\n> > > On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > > > Dear friends,\n> > > >\n> > > > I would like to propose \"VFS idmappings support in NFS\" as a topic\n> > > > for discussion at the LSF/MM/BPF Summit.\n> > > >\n> > > > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and\n> > > > cephfs [1] with support/guidance\n> > > > from Christian.\n> > > >\n> > > > This experience with Cephfs & FUSE has shown that VFS idmap\n> > > > semantics, while being very elegant and\n> > > > intuitive for local filesystems, can be quite challenging to\n> > > > combine with network/network-like (e.g. FUSE)\n> > > > FSes. In case of Cephfs we had to modify its protocol (!) (see [2])\n> > > > as a part of our agreement with\n> > > > ceph folks about the right way to support idmaps.\n> > > >\n> > > > One obstacle here was that cephfs has some features that are not\n> > > > very Linux-wayish, I would say.\n> > > > In particular, system administrator can configure path-based\n> > > > UID/GID restrictions on a *server*-side (Ceph MDS).\n> > > > Basically, you can say \"I expect UID 1000 and GID 2000 for all\n> > > > files under /stuff directory\".\n> > > > The problem here is that these UID/GIDs are taken from a syscall-\n> > > > caller's creds (not from (struct file *)->f_cred)\n> > > > which makes cephfs FDs not very transferable through unix sockets.\n> > > > [3]\n> > > >\n> > > > These path-based UID/GID restrictions mean that server expects\n> > > > client to send UID/GID with every single request,\n> > > > not only for those OPs where UID/GID needs to be written to the\n> > > > disk (mknod, mkdir, symlink, etc).\n> > > > VFS idmaps API is designed to prevent filesystems developers from\n> > > > making a mistakes when supporting FS_ALLOW_IDMAP.\n> > > > For example, (struct mnt_idmap *) is not passed to every single\n> > > > i_op, but instead to only those where it can be\n> > > > used legitimately. Particularly, readlink/listxattr or rmdir are\n> > > > not expected to use idmapping information anyhow.\n> > > >\n> > > > We've seen very similar challenges with FUSE. Not a long time ago\n> > > > on Linux Containers project forum, there\n> > > > was a discussion about mergerfs (a popular FUSE-based filesystem) &\n> > > > VFS idmaps [5]. And I see that this problem\n> > > > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps\n> > > > adoption in some usecases.\n> > > > Antonio Musumeci (mergerfs maintainer) claimed that in many cases\n> > > > filesystems behind mergerfs may not be fully\n> > > > POSIX and basically, when mergerfs does IO on the underlying FSes\n> > > > it needs to do UID/GID switch to caller's UID/GID\n> > > > (taken from FUSE request header).\n> > > >\n> > > > We don't expect NFS to be any simpler :-) I would say that\n> > > > supporting NFS is a final boss. It would be great\n> > > > to have a deep technical discussion with VFS/FSes maintainers and\n> > > > developers about all these challenges and\n> > > > make some conclusions and identify a right direction/approach to\n> > > > these problems. From my side, I'm going\n> > > > to get more familiar with high-level part of NFS (or even make PoC\n> > > > if time permits), identify challenges,\n> > > > summarize everything and prepare some slides to navigate/plan\n> > > > discussion.\n> > > >\n> > > > [1] cephfs\n> > > > https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > > > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > > > [3] cephfs & f_cred\n> > > > https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > > > [4] fuse/virtiofs\n> > > > https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > > > [5]\n> > > > mergerfs\n> > > > https://discuss.linuxcontainers.org/t/is-it-the-case-that-you-\n> > > > cannot-use-shift-true-for-disk-devices-where-the-source-is-a-\n> > > > mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> > > >\n> > > > Kind regards,\n> > > > Alexander Mikhalitsyn @ futurfusion.io\n> > >\n> > >\n> > > IIUC, people mostly use vfs-layer idmappings because they want to\n> > > remap\n> > > the uid/gid values of files that get stored on the backing store\n> > > (disk,\n> > > ceph MDS, or whatever).\n> > >\n> > > I've never used idmappings myself much in practice. Could you lay out\n> > > an example of how you would use them with NFS in a real environment\n> > > so\n> > > I understand the problem better? I'd start by assuming a simple setup\n> > > with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> > > be fairly straightforward.\n> > >\n> > > Mixing in AUTH_GSS and real idmapping will be where things get\n> > > harder,\n> > > so let's not worry about those cases for now.\n> >\n> > I think you do need to worry about those cases. As the NFS and RPC\n> > protocols stand today, strong authentication will defeat any client\n> > side idmapping scheme, because the server can't know what uids or gids\n> > the client is using on its end; it just knows about the account that\n> > was used to authenticate.\n> >\n>\n> Oh, we absolutely need to worry about them, but this is a difficult\n> topic to get our arms around. We can potentially have several layers\n> that are doing idmapping, so I want to understand a simple use-case\n> first. Once that's clear I plan to start throwing in monkey wrenches.\n>\n> > I think if you do want to implement something generic, you're going to\n> > have to consider how the client and server can exchange (and store) the\n> > information needed to allow the client to perform the mapping of file\n> > owners/group owners on its end. The client would presumably also need\n> > to be in charge of enforcing permissions for such mappings.\n> > It would be a very different security model than the one used by NFS\n> > today, and almost certainly require protocol extensions.\n>\n> That may be, but I still don't fully understand the use-case here.\n\nPlease, let me know if my earlier reply doesn't clarify LXC/Incus use case.\nI can prepare a more detailed explanation with command line/configuration\nexamples with pleasure.\n\n> Maybe they'd be content with just shifting UIDs at a higher level\n> without changing the protocol? Without understanding how they intend to\n> use this, it's hard to know what's needed.\n\nIf you ask me, I have no problem or I would say more, I look positively\non the way \"keep it high level & don't touch NFS protocol\" ;-)\nBut I remember a very tight discussion (good context [1]) about Cephfs and\nthis way wasn't considered as acceptable back then (and we had to make\na protocol extension).\nWe can always go iteratively, and first version can be simple and then on-demand\nwe can support more tricky cases if this is acceptable for you guys.\nYou set the rules. ;-)\n\n[1] https://lore.kernel.org/lkml/f3864ed6-8c97-8a7a-f268-dab29eb2fb21@redhat.com/\n\nKind regards,\nAlex\n\n>\n> --\n> Jeff Layton <jlayton@kernel.org>\n\n\n---\n\nAm Mi., 18. Feb. 2026 um 17:01 Uhr schrieb Jeff Layton <jlayton@kernel.org>:\n>\n> On Wed, 2026-02-18 at 15:36 +0100, Alexander Mikhalitsyn wrote:\n> > Am Mi., 18. Feb. 2026 um 14:49 Uhr schrieb Jeff Layton <jlayton@kernel.org>:\n> > >\n> > > On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > > > Dear friends,\n> > > >\n> > > > I would like to propose \"VFS idmappings support in NFS\" as a topic for discussion at the LSF/MM/BPF Summit.\n> > > >\n> > > > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and cephfs [1] with support/guidance\n> > > > from Christian.\n> > > >\n> > > > This experience with Cephfs & FUSE has shown that VFS idmap semantics, while being very elegant and\n> > > > intuitive for local filesystems, can be quite challenging to combine with network/network-like (e.g. FUSE)\n> > > > FSes. In case of Cephfs we had to modify its protocol (!) (see [2]) as a part of our agreement with\n> > > > ceph folks about the right way to support idmaps.\n> > > >\n> > > > One obstacle here was that cephfs has some features that are not very Linux-wayish, I would say.\n> > > > In particular, system administrator can configure path-based UID/GID restrictions on a *server*-side (Ceph MDS).\n> > > > Basically, you can say \"I expect UID 1000 and GID 2000 for all files under /stuff directory\".\n> > > > The problem here is that these UID/GIDs are taken from a syscall-caller's creds (not from (struct file *)->f_cred)\n> > > > which makes cephfs FDs not very transferable through unix sockets. [3]\n> > > >\n> > > > These path-based UID/GID restrictions mean that server expects client to send UID/GID with every single request,\n> > > > not only for those OPs where UID/GID needs to be written to the disk (mknod, mkdir, symlink, etc).\n> > > > VFS idmaps API is designed to prevent filesystems developers from making a mistakes when supporting FS_ALLOW_IDMAP.\n> > > > For example, (struct mnt_idmap *) is not passed to every single i_op, but instead to only those where it can be\n> > > > used legitimately. Particularly, readlink/listxattr or rmdir are not expected to use idmapping information anyhow.\n> > > >\n> > > > We've seen very similar challenges with FUSE. Not a long time ago on Linux Containers project forum, there\n> > > > was a discussion about mergerfs (a popular FUSE-based filesystem) & VFS idmaps [5]. And I see that this problem\n> > > > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps adoption in some usecases.\n> > > > Antonio Musumeci (mergerfs maintainer) claimed that in many cases filesystems behind mergerfs may not be fully\n> > > > POSIX and basically, when mergerfs does IO on the underlying FSes it needs to do UID/GID switch to caller's UID/GID\n> > > > (taken from FUSE request header).\n> > > >\n> > > > We don't expect NFS to be any simpler :-) I would say that supporting NFS is a final boss. It would be great\n> > > > to have a deep technical discussion with VFS/FSes maintainers and developers about all these challenges and\n> > > > make some conclusions and identify a right direction/approach to these problems. From my side, I'm going\n> > > > to get more familiar with high-level part of NFS (or even make PoC if time permits), identify challenges,\n> > > > summarize everything and prepare some slides to navigate/plan discussion.\n> > > >\n> > > > [1] cephfs https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > > > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > > > [3] cephfs & f_cred https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > > > [4] fuse/virtiofs https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > > > [5]\n> > > > mergerfshttps://discuss.linuxcontainers.org/t/is-it-the-case-that-you-cannot-use-shift-true-for-disk-devices-where-the-source-is-a-mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> > > >\n> > > > Kind regards,\n> > > > Alexander Mikhalitsyn @ futurfusion.io\n> > >\n> >\n> > Hi Jeff,\n> >\n> > thanks for such a fast reply! ;)\n> >\n> > >\n> > > IIUC, people mostly use vfs-layer idmappings because they want to remap\n> > > the uid/gid values of files that get stored on the backing store (disk,\n> > > ceph MDS, or whatever).\n> >\n> > yes, precisely.\n> >\n> > >\n> > > I've never used idmappings myself much in practice. Could you lay out\n> > > an example of how you would use them with NFS in a real environment so\n> > > I understand the problem better? I'd start by assuming a simple setup\n> > > with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> > > be fairly straightforward.\n> >\n> > For me, from the point of LXC/Incus project, idmapped mounts are used as\n> > a way to \"delegate\" filesystems (or subtrees) to the containers:\n> > 1. We, of course, assume that container enables user namespaces and\n> > user can't mount a filesystem\n> > inside because it has no FS_USERNS_MOUNT flag set (like in case of Cephfs, NFS,\n> > CIFS and many others).\n> > 2. At the same time host's system administrator wants to avoid\n> > remapping between container's user ns and\n> > sb->s_user_ns (which is init_user_ns for those filesystems). [\n> > motivation here is that in many\n> > cases you may want to have the same subtree to be shared with other\n> > containers and even host users too and\n> > you want UIDs to be \"compatible\", i.e UID 1000 in one container and\n> > UID 1000 in another container should\n> > land as UID 1000 on the filesystem's inode ]\n> >\n> > For this usecase, when we bind-mount filesystem to container, we apply\n> > VFS idmap equal to container's\n> > user namespace. This makes a behavior I described.\n> >\n>\n> Ok: so you have a process running in a userns as UID 2000 and you want\n> to use vfs layer idmapping so that when you create a file as that user\n> that it ends up being owned by UID 1000. Is that basically correct?\n\nIn our case, we have a UID 1000 (inside user namespace), which mapped to\nsomething like 10000 + 1000 (in the init_user_ns). And then we have\nNFS mount (sb->s_user_ns = init_user_ns, ofc), so if user UID 1000\n(inside the container)\ncreates a file, it will be 11000, right? But we do bind-mount of that\nNFS mount+VFS idmap,\nso that once file is created it has owner_uid = 1000. (This scenario\nis covered by [1] and [2])\n\n[1] https://docs.kernel.org/filesystems/idmappings.html#example-3\n[2] https://docs.kernel.org/filesystems/idmappings.html#example-3-reconsidered\n\n>\n> Typically, the RPC credentials used in an OPEN or CREATE call is what\n> determines its ownership (at least until a SETATTR comes in). With\n> AUTH_SYS, the credential is just a uid and set of gids.\n>\n> So in this case, it sounds like you would need just do that conversion\n> (maybe at the RPC client layer?) when issuing an RPC. You don't really\n> need a protocol extension for that case.\n>\n> As Trond points out though, AUTH_GSS and NFSv4 idmapping will make this\n> more complex. Once you're using kerberos credentials for\n> authentication, you don't have much control over what the UIDs and GIDs\n> will be on newly-created files, but is that really a problem? As long\n> as all of the clients have a consistent view, I wouldn't think so.\n\nI absolutely agree.\n\n>\n> > But this is just one use case. I'm pretty sure there are some more\n> > around here :)\n> > I know that folks from Preferred Networks (preferred.jp) are also\n> > interested in VFS idmap support in NFS,\n> > probably they can share some ideas/use cases too.\n> >\n> >\n>\n> Yes, we don't want to focus too much on a single use-case, but I find\n> it helpful to focus on a single simple problem first.\n\nYes, I could prepare RFC patches before LSF/MM/BPF for that simple case so\nwe have something to start with.\n\n> --\n> Jeff Layton <jlayton@kernel.org>\n",
          "reply_to": "Jeff Layton",
          "message_date": ""
        },
        {
          "author": "Trond Myklebust",
          "summary": "The reviewer raised concerns about implementing VFS idmappings in NFS due to security implications and the need for protocol extensions.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "security model",
            "protocol extensions"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Wed, 2026-02-18 at 08:49 -0500, Jeff Layton wrote:\n> On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > Dear friends,\n> > \n> > I would like to propose \"VFS idmappings support in NFS\" as a topic\n> > for discussion at the LSF/MM/BPF Summit.\n> > \n> > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and\n> > cephfs [1] with support/guidance\n> > from Christian.\n> > \n> > This experience with Cephfs & FUSE has shown that VFS idmap\n> > semantics, while being very elegant and\n> > intuitive for local filesystems, can be quite challenging to\n> > combine with network/network-like (e.g. FUSE)\n> > FSes. In case of Cephfs we had to modify its protocol (!) (see [2])\n> > as a part of our agreement with\n> > ceph folks about the right way to support idmaps.\n> > \n> > One obstacle here was that cephfs has some features that are not\n> > very Linux-wayish, I would say.\n> > In particular, system administrator can configure path-based\n> > UID/GID restrictions on a *server*-side (Ceph MDS).\n> > Basically, you can say \"I expect UID 1000 and GID 2000 for all\n> > files under /stuff directory\".\n> > The problem here is that these UID/GIDs are taken from a syscall-\n> > caller's creds (not from (struct file *)->f_cred)\n> > which makes cephfs FDs not very transferable through unix sockets.\n> > [3]\n> > \n> > These path-based UID/GID restrictions mean that server expects\n> > client to send UID/GID with every single request,\n> > not only for those OPs where UID/GID needs to be written to the\n> > disk (mknod, mkdir, symlink, etc).\n> > VFS idmaps API is designed to prevent filesystems developers from\n> > making a mistakes when supporting FS_ALLOW_IDMAP.\n> > For example, (struct mnt_idmap *) is not passed to every single\n> > i_op, but instead to only those where it can be\n> > used legitimately. Particularly, readlink/listxattr or rmdir are\n> > not expected to use idmapping information anyhow.\n> > \n> > We've seen very similar challenges with FUSE. Not a long time ago\n> > on Linux Containers project forum, there\n> > was a discussion about mergerfs (a popular FUSE-based filesystem) &\n> > VFS idmaps [5]. And I see that this problem\n> > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps\n> > adoption in some usecases.\n> > Antonio Musumeci (mergerfs maintainer) claimed that in many cases\n> > filesystems behind mergerfs may not be fully\n> > POSIX and basically, when mergerfs does IO on the underlying FSes\n> > it needs to do UID/GID switch to caller's UID/GID\n> > (taken from FUSE request header).\n> > \n> > We don't expect NFS to be any simpler :-) I would say that\n> > supporting NFS is a final boss. It would be great\n> > to have a deep technical discussion with VFS/FSes maintainers and\n> > developers about all these challenges and\n> > make some conclusions and identify a right direction/approach to\n> > these problems. From my side, I'm going\n> > to get more familiar with high-level part of NFS (or even make PoC\n> > if time permits), identify challenges,\n> > summarize everything and prepare some slides to navigate/plan\n> > discussion.\n> > \n> > [1] cephfs\n> > https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > [3] cephfs & f_cred\n> > https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > [4] fuse/virtiofs\n> > https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > [5]\n> > mergerfs\n> > https://discuss.linuxcontainers.org/t/is-it-the-case-that-you-\n> > cannot-use-shift-true-for-disk-devices-where-the-source-is-a-\n> > mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> > \n> > Kind regards,\n> > Alexander Mikhalitsyn @ futurfusion.io\n> \n> \n> IIUC, people mostly use vfs-layer idmappings because they want to\n> remap\n> the uid/gid values of files that get stored on the backing store\n> (disk,\n> ceph MDS, or whatever).\n> \n> I've never used idmappings myself much in practice. Could you lay out\n> an example of how you would use them with NFS in a real environment\n> so\n> I understand the problem better? I'd start by assuming a simple setup\n> with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> be fairly straightforward.\n> \n> Mixing in AUTH_GSS and real idmapping will be where things get\n> harder,\n> so let's not worry about those cases for now.\n\nI think you do need to worry about those cases. As the NFS and RPC\nprotocols stand today, strong authentication will defeat any client\nside idmapping scheme, because the server can't know what uids or gids\nthe client is using on its end; it just knows about the account that\nwas used to authenticate.\n\nI think if you do want to implement something generic, you're going to\nhave to consider how the client and server can exchange (and store) the\ninformation needed to allow the client to perform the mapping of file\nowners/group owners on its end. The client would presumably also need\nto be in charge of enforcing permissions for such mappings.\nIt would be a very different security model than the one used by NFS\ntoday, and almost certainly require protocol extensions.\n\n-- \nTrond Myklebust\nLinux NFS client maintainer, Hammerspace\ntrondmy@kernel.org, trond.myklebust@hammerspace.com\n",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "The reviewer expressed concerns about the complexity of implementing VFS idmappings in NFS and requested a clear understanding of the use-case before proceeding.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "understanding needed"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Wed, 2026-02-18 at 09:37 -0500, Trond Myklebust wrote:\n> On Wed, 2026-02-18 at 08:49 -0500, Jeff Layton wrote:\n> > On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > > Dear friends,\n> > > \n> > > I would like to propose \"VFS idmappings support in NFS\" as a topic\n> > > for discussion at the LSF/MM/BPF Summit.\n> > > \n> > > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and\n> > > cephfs [1] with support/guidance\n> > > from Christian.\n> > > \n> > > This experience with Cephfs & FUSE has shown that VFS idmap\n> > > semantics, while being very elegant and\n> > > intuitive for local filesystems, can be quite challenging to\n> > > combine with network/network-like (e.g. FUSE)\n> > > FSes. In case of Cephfs we had to modify its protocol (!) (see [2])\n> > > as a part of our agreement with\n> > > ceph folks about the right way to support idmaps.\n> > > \n> > > One obstacle here was that cephfs has some features that are not\n> > > very Linux-wayish, I would say.\n> > > In particular, system administrator can configure path-based\n> > > UID/GID restrictions on a *server*-side (Ceph MDS).\n> > > Basically, you can say \"I expect UID 1000 and GID 2000 for all\n> > > files under /stuff directory\".\n> > > The problem here is that these UID/GIDs are taken from a syscall-\n> > > caller's creds (not from (struct file *)->f_cred)\n> > > which makes cephfs FDs not very transferable through unix sockets.\n> > > [3]\n> > > \n> > > These path-based UID/GID restrictions mean that server expects\n> > > client to send UID/GID with every single request,\n> > > not only for those OPs where UID/GID needs to be written to the\n> > > disk (mknod, mkdir, symlink, etc).\n> > > VFS idmaps API is designed to prevent filesystems developers from\n> > > making a mistakes when supporting FS_ALLOW_IDMAP.\n> > > For example, (struct mnt_idmap *) is not passed to every single\n> > > i_op, but instead to only those where it can be\n> > > used legitimately. Particularly, readlink/listxattr or rmdir are\n> > > not expected to use idmapping information anyhow.\n> > > \n> > > We've seen very similar challenges with FUSE. Not a long time ago\n> > > on Linux Containers project forum, there\n> > > was a discussion about mergerfs (a popular FUSE-based filesystem) &\n> > > VFS idmaps [5]. And I see that this problem\n> > > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps\n> > > adoption in some usecases.\n> > > Antonio Musumeci (mergerfs maintainer) claimed that in many cases\n> > > filesystems behind mergerfs may not be fully\n> > > POSIX and basically, when mergerfs does IO on the underlying FSes\n> > > it needs to do UID/GID switch to caller's UID/GID\n> > > (taken from FUSE request header).\n> > > \n> > > We don't expect NFS to be any simpler :-) I would say that\n> > > supporting NFS is a final boss. It would be great\n> > > to have a deep technical discussion with VFS/FSes maintainers and\n> > > developers about all these challenges and\n> > > make some conclusions and identify a right direction/approach to\n> > > these problems. From my side, I'm going\n> > > to get more familiar with high-level part of NFS (or even make PoC\n> > > if time permits), identify challenges,\n> > > summarize everything and prepare some slides to navigate/plan\n> > > discussion.\n> > > \n> > > [1] cephfs\n> > > https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > > [3] cephfs & f_cred\n> > > https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > > [4] fuse/virtiofs\n> > > https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > > [5]\n> > > mergerfs\n> > > https://discuss.linuxcontainers.org/t/is-it-the-case-that-you-\n> > > cannot-use-shift-true-for-disk-devices-where-the-source-is-a-\n> > > mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> > > \n> > > Kind regards,\n> > > Alexander Mikhalitsyn @ futurfusion.io\n> > \n> > \n> > IIUC, people mostly use vfs-layer idmappings because they want to\n> > remap\n> > the uid/gid values of files that get stored on the backing store\n> > (disk,\n> > ceph MDS, or whatever).\n> > \n> > I've never used idmappings myself much in practice. Could you lay out\n> > an example of how you would use them with NFS in a real environment\n> > so\n> > I understand the problem better? I'd start by assuming a simple setup\n> > with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> > be fairly straightforward.\n> > \n> > Mixing in AUTH_GSS and real idmapping will be where things get\n> > harder,\n> > so let's not worry about those cases for now.\n> \n> I think you do need to worry about those cases. As the NFS and RPC\n> protocols stand today, strong authentication will defeat any client\n> side idmapping scheme, because the server can't know what uids or gids\n> the client is using on its end; it just knows about the account that\n> was used to authenticate.\n> \n\nOh, we absolutely need to worry about them, but this is a difficult\ntopic to get our arms around. We can potentially have several layers\nthat are doing idmapping, so I want to understand a simple use-case\nfirst. Once that's clear I plan to start throwing in monkey wrenches.\n\n> I think if you do want to implement something generic, you're going to\n> have to consider how the client and server can exchange (and store) the\n> information needed to allow the client to perform the mapping of file\n> owners/group owners on its end. The client would presumably also need\n> to be in charge of enforcing permissions for such mappings.\n> It would be a very different security model than the one used by NFS\n> today, and almost certainly require protocol extensions.\n\nThat may be, but I still don't fully understand the use-case here.\nMaybe they'd be content with just shifting UIDs at a higher level\nwithout changing the protocol? Without understanding how they intend to\nuse this, it's hard to know what's needed.\n\n-- \nJeff Layton <jlayton@kernel.org>\n",
          "reply_to": "Trond Myklebust",
          "message_date": "2026-02-18"
        }
      ],
      "analysis_source": "llm"
    },
    "2026-02-19": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "NeilBrown",
          "summary": "The reviewer raised concerns about the NFS idmappings support patch, specifically highlighting the need for consideration of RPC conversion and the interaction between kernel idmapping and user-namespace idmapper daemon.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "technical concerns"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Thu, 19 Feb 2026, Jeff Layton wrote:\n> On Wed, 2026-02-18 at 15:36 +0100, Alexander Mikhalitsyn wrote:\n> > Am Mi., 18. Feb. 2026 um 14:49 Uhr schrieb Jeff Layton <jlayton@kernel.org>:\n> > > \n> > > On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > > > Dear friends,\n> > > > \n> > > > I would like to propose \"VFS idmappings support in NFS\" as a topic for discussion at the LSF/MM/BPF Summit.\n> > > > \n> > > > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and cephfs [1] with support/guidance\n> > > > from Christian.\n> > > > \n> > > > This experience with Cephfs & FUSE has shown that VFS idmap semantics, while being very elegant and\n> > > > intuitive for local filesystems, can be quite challenging to combine with network/network-like (e.g. FUSE)\n> > > > FSes. In case of Cephfs we had to modify its protocol (!) (see [2]) as a part of our agreement with\n> > > > ceph folks about the right way to support idmaps.\n> > > > \n> > > > One obstacle here was that cephfs has some features that are not very Linux-wayish, I would say.\n> > > > In particular, system administrator can configure path-based UID/GID restrictions on a *server*-side (Ceph MDS).\n> > > > Basically, you can say \"I expect UID 1000 and GID 2000 for all files under /stuff directory\".\n> > > > The problem here is that these UID/GIDs are taken from a syscall-caller's creds (not from (struct file *)->f_cred)\n> > > > which makes cephfs FDs not very transferable through unix sockets. [3]\n> > > > \n> > > > These path-based UID/GID restrictions mean that server expects client to send UID/GID with every single request,\n> > > > not only for those OPs where UID/GID needs to be written to the disk (mknod, mkdir, symlink, etc).\n> > > > VFS idmaps API is designed to prevent filesystems developers from making a mistakes when supporting FS_ALLOW_IDMAP.\n> > > > For example, (struct mnt_idmap *) is not passed to every single i_op, but instead to only those where it can be\n> > > > used legitimately. Particularly, readlink/listxattr or rmdir are not expected to use idmapping information anyhow.\n> > > > \n> > > > We've seen very similar challenges with FUSE. Not a long time ago on Linux Containers project forum, there\n> > > > was a discussion about mergerfs (a popular FUSE-based filesystem) & VFS idmaps [5]. And I see that this problem\n> > > > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps adoption in some usecases.\n> > > > Antonio Musumeci (mergerfs maintainer) claimed that in many cases filesystems behind mergerfs may not be fully\n> > > > POSIX and basically, when mergerfs does IO on the underlying FSes it needs to do UID/GID switch to caller's UID/GID\n> > > > (taken from FUSE request header).\n> > > > \n> > > > We don't expect NFS to be any simpler :-) I would say that supporting NFS is a final boss. It would be great\n> > > > to have a deep technical discussion with VFS/FSes maintainers and developers about all these challenges and\n> > > > make some conclusions and identify a right direction/approach to these problems. From my side, I'm going\n> > > > to get more familiar with high-level part of NFS (or even make PoC if time permits), identify challenges,\n> > > > summarize everything and prepare some slides to navigate/plan discussion.\n> > > > \n> > > > [1] cephfs https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > > > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > > > [3] cephfs & f_cred https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > > > [4] fuse/virtiofs https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > > > [5]\n> > > > mergerfshttps://discuss.linuxcontainers.org/t/is-it-the-case-that-you-cannot-use-shift-true-for-disk-devices-where-the-source-is-a-mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> > > > \n> > > > Kind regards,\n> > > > Alexander Mikhalitsyn @ futurfusion.io\n> > > \n> > \n> > Hi Jeff,\n> > \n> > thanks for such a fast reply! ;)\n> > \n> > > \n> > > IIUC, people mostly use vfs-layer idmappings because they want to remap\n> > > the uid/gid values of files that get stored on the backing store (disk,\n> > > ceph MDS, or whatever).\n> > \n> > yes, precisely.\n> > \n> > > \n> > > I've never used idmappings myself much in practice. Could you lay out\n> > > an example of how you would use them with NFS in a real environment so\n> > > I understand the problem better? I'd start by assuming a simple setup\n> > > with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> > > be fairly straightforward.\n> > \n> > For me, from the point of LXC/Incus project, idmapped mounts are used as\n> > a way to \"delegate\" filesystems (or subtrees) to the containers:\n> > 1. We, of course, assume that container enables user namespaces and\n> > user can't mount a filesystem\n> > inside because it has no FS_USERNS_MOUNT flag set (like in case of Cephfs, NFS,\n> > CIFS and many others).\n> > 2. At the same time host's system administrator wants to avoid\n> > remapping between container's user ns and\n> > sb->s_user_ns (which is init_user_ns for those filesystems). [\n> > motivation here is that in many\n> > cases you may want to have the same subtree to be shared with other\n> > containers and even host users too and\n> > you want UIDs to be \"compatible\", i.e UID 1000 in one container and\n> > UID 1000 in another container should\n> > land as UID 1000 on the filesystem's inode ]\n> > \n> > For this usecase, when we bind-mount filesystem to container, we apply\n> > VFS idmap equal to container's\n> > user namespace. This makes a behavior I described.\n> > \n> \n> Ok: so you have a process running in a userns as UID 2000 and you want\n> to use vfs layer idmapping so that when you create a file as that user\n> that it ends up being owned by UID 1000. Is that basically correct?\n> \n> Typically, the RPC credentials used in an OPEN or CREATE call is what\n> determines its ownership (at least until a SETATTR comes in). With\n> AUTH_SYS, the credential is just a uid and set of gids.\n> \n> So in this case, it sounds like you would need just do that conversion\n> (maybe at the RPC client layer?) when issuing an RPC. You don't really\n> need a protocol extension for that case.\n\nYou also need to consider the conversion when receiving an RPC.\n\nIf you use krb5 and NFSv3 then you really want the mapping between krb5\nidentity and uid to be the same on client and server, so then when an\napplication creates a file and the stats it, it sees that it owns it.\n\nIf I use a krb5 identity in an idmapped NFS filesystem I'll want the\nserver to map the identity to the \"underlying\" uid (was would be stored\nin a local filesystem) and then when the client gets a GETATTR reply,\nthe VFS maps back to the uid seen by the application.\n\nWith NFSv4 and the idmapper you wouldn't need (or want) the kernel\nidmapping to be used at all.  You would want the idmapper deamon to run\nin the user-namespace and map from on-the-wire names to the appropriate\napp-level uids.\nThis would mean that a given NFS mount would need to be an a given user\nnamespace.  Maybe that isn't desired.\n\nIf it is important for a given NFS mount to be available in multiple\nuser namespaces, then the idmapper daemon would need to map to the\nunderlying uid, and the VFS mapping would map that up to the app-level\nuid.\n\nNeilBrown\n\n\n> \n> As Trond points out though, AUTH_GSS and NFSv4 idmapping will make this\n> more complex. Once you're using kerberos credentials for\n> authentication, you don't have much control over what the UIDs and GIDs\n> will be on newly-created files, but is that really a problem? As long\n> as all of the clients have a consistent view, I wouldn't think so.\n> \n> > But this is just one use case. I'm pretty sure there are some more\n> > around here :)\n> > I know that folks from Preferred Networks (preferred.jp) are also\n> > interested in VFS idmap support in NFS,\n> > probably they can share some ideas/use cases too.\n> > \n> > \n> \n> Yes, we don't want to focus too much on a single use-case, but I find\n> it helpful to focus on a single simple problem first.\n> -- \n> Jeff Layton <jlayton@kernel.org>\n> \n> \n\n",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        },
        {
          "author": "Kohei Sugihara",
          "summary": "Kohei Sugihara shared a use case for VFS idmappings support in NFS, specifically for multi-tenant Kubernetes clusters where they need to share a single storage endpoint among multiple pods using ReadWriteMany (RWX) access mode. They proposed two possible models for handling UID/GID mapping and expressed interest in discussing the safe and reasonable minimum requirements.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "discussing what the safe and reasonable minimum should be"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Thu, Feb 19, 2026 at 9:58AM NeilBrown <neilb@ownmail.net> wrote:\n>\n> On Thu, 19 Feb 2026, Jeff Layton wrote:\n> > On Wed, 2026-02-18 at 15:36 +0100, Alexander Mikhalitsyn wrote:\n> > > Am Mi., 18. Feb. 2026 um 14:49 Uhr schrieb Jeff Layton <jlayton@kernel.org>:\n> > > >\n> > > > On Wed, 2026-02-18 at 13:44 +0100, Alexander Mikhalitsyn wrote:\n> > > > > Dear friends,\n> > > > >\n> > > > > I would like to propose \"VFS idmappings support in NFS\" as a topic for discussion at the LSF/MM/BPF Summit.\n> > > > >\n> > > > > Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and cephfs [1] with support/guidance\n> > > > > from Christian.\n> > > > >\n> > > > > This experience with Cephfs & FUSE has shown that VFS idmap semantics, while being very elegant and\n> > > > > intuitive for local filesystems, can be quite challenging to combine with network/network-like (e.g. FUSE)\n> > > > > FSes. In case of Cephfs we had to modify its protocol (!) (see [2]) as a part of our agreement with\n> > > > > ceph folks about the right way to support idmaps.\n> > > > >\n> > > > > One obstacle here was that cephfs has some features that are not very Linux-wayish, I would say.\n> > > > > In particular, system administrator can configure path-based UID/GID restrictions on a *server*-side (Ceph MDS).\n> > > > > Basically, you can say \"I expect UID 1000 and GID 2000 for all files under /stuff directory\".\n> > > > > The problem here is that these UID/GIDs are taken from a syscall-caller's creds (not from (struct file *)->f_cred)\n> > > > > which makes cephfs FDs not very transferable through unix sockets. [3]\n> > > > >\n> > > > > These path-based UID/GID restrictions mean that server expects client to send UID/GID with every single request,\n> > > > > not only for those OPs where UID/GID needs to be written to the disk (mknod, mkdir, symlink, etc).\n> > > > > VFS idmaps API is designed to prevent filesystems developers from making a mistakes when supporting FS_ALLOW_IDMAP.\n> > > > > For example, (struct mnt_idmap *) is not passed to every single i_op, but instead to only those where it can be\n> > > > > used legitimately. Particularly, readlink/listxattr or rmdir are not expected to use idmapping information anyhow.\n> > > > >\n> > > > > We've seen very similar challenges with FUSE. Not a long time ago on Linux Containers project forum, there\n> > > > > was a discussion about mergerfs (a popular FUSE-based filesystem) & VFS idmaps [5]. And I see that this problem\n> > > > > of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps adoption in some usecases.\n> > > > > Antonio Musumeci (mergerfs maintainer) claimed that in many cases filesystems behind mergerfs may not be fully\n> > > > > POSIX and basically, when mergerfs does IO on the underlying FSes it needs to do UID/GID switch to caller's UID/GID\n> > > > > (taken from FUSE request header).\n> > > > >\n> > > > > We don't expect NFS to be any simpler :-) I would say that supporting NFS is a final boss. It would be great\n> > > > > to have a deep technical discussion with VFS/FSes maintainers and developers about all these challenges and\n> > > > > make some conclusions and identify a right direction/approach to these problems. From my side, I'm going\n> > > > > to get more familiar with high-level part of NFS (or even make PoC if time permits), identify challenges,\n> > > > > summarize everything and prepare some slides to navigate/plan discussion.\n> > > > >\n> > > > > [1] cephfs https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> > > > > [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> > > > > [3] cephfs & f_cred https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> > > > > [4] fuse/virtiofs https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> > > > > [5]\n> > > > > mergerfshttps://discuss.linuxcontainers.org/t/is-it-the-case-that-you-cannot-use-shift-true-for-disk-devices-where-the-source-is-a-mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> > > > >\n> > > > > Kind regards,\n> > > > > Alexander Mikhalitsyn @ futurfusion.io\n> > > >\n> > >\n> > > Hi Jeff,\n> > >\n> > > thanks for such a fast reply! ;)\n> > >\n> > > >\n> > > > IIUC, people mostly use vfs-layer idmappings because they want to remap\n> > > > the uid/gid values of files that get stored on the backing store (disk,\n> > > > ceph MDS, or whatever).\n> > >\n> > > yes, precisely.\n> > >\n> > > >\n> > > > I've never used idmappings myself much in practice. Could you lay out\n> > > > an example of how you would use them with NFS in a real environment so\n> > > > I understand the problem better? I'd start by assuming a simple setup\n> > > > with AUTH_SYS and no NFSv4 idmapping involved, since that case should\n> > > > be fairly straightforward.\n> > >\n> > > For me, from the point of LXC/Incus project, idmapped mounts are used as\n> > > a way to \"delegate\" filesystems (or subtrees) to the containers:\n> > > 1. We, of course, assume that container enables user namespaces and\n> > > user can't mount a filesystem\n> > > inside because it has no FS_USERNS_MOUNT flag set (like in case of Cephfs, NFS,\n> > > CIFS and many others).\n> > > 2. At the same time host's system administrator wants to avoid\n> > > remapping between container's user ns and\n> > > sb->s_user_ns (which is init_user_ns for those filesystems). [\n> > > motivation here is that in many\n> > > cases you may want to have the same subtree to be shared with other\n> > > containers and even host users too and\n> > > you want UIDs to be \"compatible\", i.e UID 1000 in one container and\n> > > UID 1000 in another container should\n> > > land as UID 1000 on the filesystem's inode ]\n> > >\n> > > For this usecase, when we bind-mount filesystem to container, we apply\n> > > VFS idmap equal to container's\n> > > user namespace. This makes a behavior I described.\n> > >\n> >\n> > Ok: so you have a process running in a userns as UID 2000 and you want\n> > to use vfs layer idmapping so that when you create a file as that user\n> > that it ends up being owned by UID 1000. Is that basically correct?\n> >\n> > Typically, the RPC credentials used in an OPEN or CREATE call is what\n> > determines its ownership (at least until a SETATTR comes in). With\n> > AUTH_SYS, the credential is just a uid and set of gids.\n> >\n> > So in this case, it sounds like you would need just do that conversion\n> > (maybe at the RPC client layer?) when issuing an RPC. You don't really\n> > need a protocol extension for that case.\n>\n> You also need to consider the conversion when receiving an RPC.\n>\n> If you use krb5 and NFSv3 then you really want the mapping between krb5\n> identity and uid to be the same on client and server, so then when an\n> application creates a file and the stats it, it sees that it owns it.\n>\n> If I use a krb5 identity in an idmapped NFS filesystem I'll want the\n> server to map the identity to the \"underlying\" uid (was would be stored\n> in a local filesystem) and then when the client gets a GETATTR reply,\n> the VFS maps back to the uid seen by the application.\n\n\nThank you Alex for the proposal and quick follow-ups. We're really\ninterested in this feature and we'd like to share our use case.\n\n> > > But this is just one use case. I'm pretty sure there are some more\n> > > around here :)\n> > > I know that folks from Preferred Networks (preferred.jp) are also\n> > > interested in VFS idmap support in NFS,\n> > > probably they can share some ideas/use cases too.\n\nOur use case is running multi-tenant Kubernetes clusters with\nKubernetes User Namespaces [1]. Basically we need to share a single\nstorage endpoint among multiple pods using ReadWriteMany (RWX) access\nmode. Implementations that support both RWX and ID-mapped mount are\nlimited [2].\n\nNFS is operationally common, so I am interested in supporting NFS for\nID-mapping, but NFS is complex due to its variety of mount options and\nsecurity features as Trond mentioned. We'd like to share our use case\nand define the minimum goal. Our goal is here:\n\n- 1: Mount the same NFS export as a persistent volume from multiple\nKubernetes Pods running on different compute nodes. Each tenant has\nits own exports.\n- 2: UID/GID in a container in the pod can be configurable to an\narbitrary value by runAsUser/runAsGroup (e.g. runAsUser/Group is set\nto 1000).\n- 3: We can access the export from the container as 1000:1000. At\nminimum, ownership should be consistent from the container view (i.e.\nstat shows 1000:1000 for files that the container creates). Today,\nID-mapped mount does not support NFS. The NFS client ends up using the\nhost-mapped uid/gid (e.g. container 1000 becomes host 11000), so the\ncontainer view becomes inconsistent across nodes.\n\nThere are (at least) two possible models here:\na) the NFS client sends 1000:1000 on the wire and the server stores\n1000:1000 (so server-side ownership matches the container uid/gid), or\nb) the server stores the host uid/gid (e.g. 11000:11000) and the\nclient/VFS maps it so that the container still sees 1000:1000.\nMy intuition is that (a) is simpler for a multi-node RWX setup, but it\nmay have security / policy implications depending on how the server\ndoes authorization (especially with sec=sys). I think its worth\ndiscussing what the safe and reasonable minimum should be.\n\nIn this case, UID/GID in the host node is not deterministic for the\nprocess in the container due to user_namespaces(7), so we need to do\nID-mapping to unify UID/GID between container and file system. Also,\nwe likely need to consider both request and reply paths (e.g. GETATTR)\nto keep the view consistent.\n\n> Mixing in AUTH_GSS and real idmapping will be where things get harder,\n> so let's not worry about those cases for now.\nI totally agree with Jeff. We can start a minimum PoC with AUTH_SYS.\n\n> With NFSv4 and the idmapper you wouldn't need (or want) the kernel\n> idmapping to be used at all.  You would want the idmapper deamon to run\n> in the user-namespace and map from on-the-wire names to the appropriate\n> app-level uids.\n> This would mean that a given NFS mount would need to be an a given user\n> namespace.  Maybe that isn't desired.\nNeil, thank you for your comment. We initially expected it to be in\nNFSv4. I totally agree with you and exactly our concern is how do we\nmake it consistent with idmapd(8). In the Kubernetes case, we cannot\npass CAP_SYS_ADMIN to allow pods to mount NFS directly, so mount will\nbe done on the host. As you mentioned, we think we can share a single\nNFS export from multiple hosts and pods, so I think introducing\nID-mapping into the VFS layer (with referencing local id-mapping\ntable) is appropriate.\n\nWe can start by picking a small case. My concern was whether this\ncould violate NFS protocol or not, whether things can be done on the\nclient side or not, and this topic is suitable for dealing with this\nas the VFS community. If things can be done on the client side, we can\ncover existing NFS server implementations (e.g. OpenZFS, proprietary\nappliances). I believe this can be applied to recent containerized\nruntime environments, even this small working set.\n\nAdding more context, Kubernetes and the container community actively\nwork on host isolation using the Linux user namespace feature.\nRecently they experienced RCE vulnerabilities on container runtime but\nit could be mitigated by host isolation using the user namespace\nisolation [3]. Along with migrating the runtime environment to user\nnamespace, extending file system support will be worth discussing.\n\nKind regards,\nKohei\n\n[1] https://kubernetes.io/docs/concepts/workloads/pods/user-namespaces/\n[2] https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes\n[3] https://lpc.events/event/19/contributions/2065/\n",
          "reply_to": "NeilBrown",
          "message_date": "2026-02-19"
        }
      ],
      "analysis_source": "llm"
    },
    "2026-02-21": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Demi Obenour",
          "summary": "The reviewer, Demi Obenour, pointed out that the secure case of VFS idmappings has similar problems to unprivileged virtiofsd on a system with user namespaces disabled, and proposed a workaround by storing mapped UID and GID as a user.* xattr.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On 2/18/26 07:44, Alexander Mikhalitsyn wrote:\n> Dear friends,\n> \n> I would like to propose \"VFS idmappings support in NFS\" as a topic for discussion at the LSF/MM/BPF Summit.\n> \n> Previously, I worked on VFS idmap support for FUSE/virtiofs [2] and cephfs [1] with support/guidance\n> from Christian.\n> \n> This experience with Cephfs & FUSE has shown that VFS idmap semantics, while being very elegant and\n> intuitive for local filesystems, can be quite challenging to combine with network/network-like (e.g. FUSE)\n> FSes. In case of Cephfs we had to modify its protocol (!) (see [2]) as a part of our agreement with\n> ceph folks about the right way to support idmaps.\n> \n> One obstacle here was that cephfs has some features that are not very Linux-wayish, I would say.\n> In particular, system administrator can configure path-based UID/GID restrictions on a *server*-side (Ceph MDS).\n> Basically, you can say \"I expect UID 1000 and GID 2000 for all files under /stuff directory\".\n> The problem here is that these UID/GIDs are taken from a syscall-caller's creds (not from (struct file *)->f_cred)\n> which makes cephfs FDs not very transferable through unix sockets. [3]\n> \n> These path-based UID/GID restrictions mean that server expects client to send UID/GID with every single request,\n> not only for those OPs where UID/GID needs to be written to the disk (mknod, mkdir, symlink, etc).\n> VFS idmaps API is designed to prevent filesystems developers from making a mistakes when supporting FS_ALLOW_IDMAP.\n> For example, (struct mnt_idmap *) is not passed to every single i_op, but instead to only those where it can be\n> used legitimately. Particularly, readlink/listxattr or rmdir are not expected to use idmapping information anyhow.\n> \n> We've seen very similar challenges with FUSE. Not a long time ago on Linux Containers project forum, there\n> was a discussion about mergerfs (a popular FUSE-based filesystem) & VFS idmaps [5]. And I see that this problem\n> of \"caller UID/GID are needed everywhere\" still blocks VFS idmaps adoption in some usecases.\n> Antonio Musumeci (mergerfs maintainer) claimed that in many cases filesystems behind mergerfs may not be fully\n> POSIX and basically, when mergerfs does IO on the underlying FSes it needs to do UID/GID switch to caller's UID/GID\n> (taken from FUSE request header).\n> \n> We don't expect NFS to be any simpler :-) I would say that supporting NFS is a final boss. It would be great\n> to have a deep technical discussion with VFS/FSes maintainers and developers about all these challenges and\n> make some conclusions and identify a right direction/approach to these problems. From my side, I'm going\n> to get more familiar with high-level part of NFS (or even make PoC if time permits), identify challenges,\n> summarize everything and prepare some slides to navigate/plan discussion.\n> \n> [1] cephfs https://lore.kernel.org/linux-fsdevel/20230807132626.182101-1-aleksandr.mikhalitsyn@canonical.com\n> [2] cephfs protocol changes https://github.com/ceph/ceph/pull/52575\n> [3] cephfs & f_cred https://lore.kernel.org/lkml/CAEivzxeZ6fDgYMnjk21qXYz13tHqZa8rP-cZ2jdxkY0eX+dOjw@mail.gmail.com/\n> [4] fuse/virtiofs https://lore.kernel.org/linux-fsdevel/20240903151626.264609-1-aleksandr.mikhalitsyn@canonical.com/\n> [5]\n> mergerfshttps://discuss.linuxcontainers.org/t/is-it-the-case-that-you-cannot-use-shift-true-for-disk-devices-where-the-source-is-a-mergerfs-mount-is-there-a-workaround/25336/11?u=amikhalitsyn\n> \n> Kind regards,\n> Alexander Mikhalitsyn @ futurfusion.io\n\nThe secure case (strong authentication) has similar problems to\nunprivileged virtiofsd on a system with user namespaces disabled.\nIn both cases, there is no way to store the files with the UID/GID/etc\nthat the VFS says they should have.  The server (NFS) or kernel\n(virtiofsd) simply will not (and, for security reasons, *must not*)\nallow this.\n\nI proposed a workaround for virtiofsd [1] that I will also propose\nhere: store the mapped UID and GID as a user.* xattr.  This requires\nno special permissions, and so it completely solves this problem.\nIt is also the only solution I know of that scales to NFS servers\nwith over 2^16 users, which might well exist.\n\nThe only better solution I can think of is to replace the numeric\nUID/GID with hierarchical identifier, such as a Windows-style SID.\nThose are much more complex, though.\n\n[1]: https://gitlab.com/virtio-fs/virtiofsd/-/issues/225\n-- \nSincerely,\nDemi Marie Obenour (she/her/hers)",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-21"
        }
      ],
      "analysis_source": "llm"
    }
  }
}