{
  "thread_id": "a0eab8f07873e38fa4c5d958de6b75761d690874.camel@kernel.org",
  "subject": "Re: [LSF/MM/BPF TOPIC] VFS idmappings support in NFS",
  "url": "https://lore.kernel.org/all/a0eab8f07873e38fa4c5d958de6b75761d690874.camel@kernel.org/",
  "dates": {
    "2026-02-18": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton requested an example of using VFS idmappings with NFS in a real environment, specifically asking for a simple setup with AUTH_SYS and no NFSv4 idmapping involved.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "lack of clear technical objection",
            "request for clarification"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "IIUC, people mostly use vfs-layer idmappings because they want to remap\nthe uid/gid values of files that get stored on the backing store (disk,\nceph MDS, or whatever).\n\nI've never used idmappings myself much in practice. Could you lay out\nan example of how you would use them with NFS in a real environment so\nI understand the problem better? I'd start by assuming a simple setup\nwith AUTH_SYS and no NFSv4 idmapping involved, since that case should\nbe fairly straightforward.\n\nMixing in AUTH_GSS and real idmapping will be where things get harder,\nso let's not worry about those cases for now.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author acknowledged that the NFS server needs to handle path-based UID/GID restrictions, which is a challenge for VFS idmappings support in NFS, and expressed appreciation for Jeff's fast response.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledged",
            "appreciation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Hi Jeff,\n\nthanks for such a fast reply! ;)",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "The author is addressing a concern about the use case for VFS idmappings in NFS, specifically how it applies to containerization and delegation of filesystems. The author explains that their team uses idmapped mounts as a way to delegate filesystems to containers, but notes that this is just one use case and likely not the only challenge with implementing VFS idmaps in NFS.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "For me, from the point of LXC/Incus project, idmapped mounts are used as\na way to \"delegate\" filesystems (or subtrees) to the containers:\n1. We, of course, assume that container enables user namespaces and\nuser can't mount a filesystem\ninside because it has no FS_USERNS_MOUNT flag set (like in case of Cephfs, NFS,\nCIFS and many others).\n2. At the same time host's system administrator wants to avoid\nremapping between container's user ns and\nsb->s_user_ns (which is init_user_ns for those filesystems). [\nmotivation here is that in many\ncases you may want to have the same subtree to be shared with other\ncontainers and even host users too and\nyou want UIDs to be \"compatible\", i.e UID 1000 in one container and\nUID 1000 in another container should\nland as UID 1000 on the filesystem's inode ]\n\nFor this usecase, when we bind-mount filesystem to container, we apply\nVFS idmap equal to container's\nuser namespace. This makes a behavior I described.\n\nBut this is just one use case. I'm pretty sure there are some more\naround here :)\nI know that folks from Preferred Networks (preferred.jp) are also\ninterested in VFS idmap support in NFS,\nprobably they can share some ideas/use cases too.",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author acknowledged a concern about NFS idmappings and the need to handle path-based UID/GID restrictions, agreed to explore solutions in future work.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "acknowledged a concern",
            "agreed to explore"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Kind regards,\nAlex",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Trond Myklebust",
          "summary": "The reviewer pointed out that strong authentication in the NFS and RPC protocols would defeat client-side idmapping schemes because the server cannot know the client's UIDs or GIDs, and suggested that implementing a generic solution would require exchanging and storing information between client and server to allow file owner/group owner mapping, which would likely require protocol extensions.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "protocol extensions",
            "security model change"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "I think you do need to worry about those cases. As the NFS and RPC\nprotocols stand today, strong authentication will defeat any client\nside idmapping scheme, because the server can't know what uids or gids\nthe client is using on its end; it just knows about the account that\nwas used to authenticate.\n\nI think if you do want to implement something generic, you're going to\nhave to consider how the client and server can exchange (and store) the\ninformation needed to allow the client to perform the mapping of file\nowners/group owners on its end. The client would presumably also need\nto be in charge of enforcing permissions for such mappings.\nIt would be a very different security model than the one used by NFS\ntoday, and almost certainly require protocol extensions.\n\n-- \nTrond Myklebust\nLinux NFS client maintainer, Hammerspace\ntrondmy@kernel.org, trond.myklebust@hammerspace.com",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton expressed concerns about the complexity of implementing VFS idmappings support in NFS, suggesting a need for a simple use-case to be established before introducing additional complexities.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "complexity",
            "need for simplicity"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Oh, we absolutely need to worry about them, but this is a difficult\ntopic to get our arms around. We can potentially have several layers\nthat are doing idmapping, so I want to understand a simple use-case\nfirst. Once that's clear I plan to start throwing in monkey wrenches.",
          "reply_to": "Trond Myklebust",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer Jeff Layton expressed uncertainty about the proposed VFS idmappings support in NFS, questioning whether it's necessary to change the protocol and instead suggesting a higher-level UID shifting approach.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "uncertainty",
            "lack of understanding"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "That may be, but I still don't fully understand the use-case here.\nMaybe they'd be content with just shifting UIDs at a higher level\nwithout changing the protocol? Without understanding how they intend to\nuse this, it's hard to know what's needed.\n\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Trond Myklebust",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author acknowledges that their previous reply may not have clarified the LXC/Incus use case and offers to provide additional details, including command line and configuration examples.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledges need for clarification",
            "offers to provide more information"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Please, let me know if my earlier reply doesn't clarify LXC/Incus use case.\nI can prepare a more detailed explanation with command line/configuration\nexamples with pleasure.",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "The author acknowledges a concern that the approach of keeping NFS protocol unchanged may not be acceptable, but suggests going iteratively and starting with a simple version that can be expanded later if needed.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "acknowledges a concern",
            "suggests iterative approach"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "If you ask me, I have no problem or I would say more, I look positively\non the way \"keep it high level & don't touch NFS protocol\" ;-)\nBut I remember a very tight discussion (good context [1]) about Cephfs and\nthis way wasn't considered as acceptable back then (and we had to make\na protocol extension).\nWe can always go iteratively, and first version can be simple and then on-demand\nwe can support more tricky cases if this is acceptable for you guys.\nYou set the rules. ;-)\n\n[1] https://lore.kernel.org/lkml/f3864ed6-8c97-8a7a-f268-dab29eb2fb21@redhat.com/\n\nKind regards,\nAlex",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "The reviewer noted that for NFS, the RPC credentials used in an OPEN or CREATE call determine file ownership, and suggested converting the UID/GID at the RPC client layer instead of requiring a protocol extension.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Ok: so you have a process running in a userns as UID 2000 and you want\nto use vfs layer idmapping so that when you create a file as that user\nthat it ends up being owned by UID 1000. Is that basically correct?\n\nTypically, the RPC credentials used in an OPEN or CREATE call is what\ndetermines its ownership (at least until a SETATTR comes in). With\nAUTH_SYS, the credential is just a uid and set of gids.\n\nSo in this case, it sounds like you would need just do that conversion\n(maybe at the RPC client layer?) when issuing an RPC. You don't really\nneed a protocol extension for that case.\n\nAs Trond points out though, AUTH_GSS and NFSv4 idmapping will make this\nmore complex. Once you're using kerberos credentials for\nauthentication, you don't have much control over what the UIDs and GIDs\nwill be on newly-created files, but is that really a problem? As long\nas all of the clients have a consistent view, I wouldn't think so.",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-18"
        },
        {
          "author": "Jeff Layton",
          "summary": "Reviewer suggested focusing on a single simple problem within the VFS idmappings support in NFS, rather than trying to tackle multiple use-cases at once.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "requested clarification",
            "suggested approach"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Yes, we don't want to focus too much on a single use-case, but I find\nit helpful to focus on a single simple problem first.\n-- \nJeff Layton <jlayton@kernel.org>",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "The author is addressing a concern about how VFS idmaps interact with NFS mounts, specifically when a user inside a container creates a file on an NFS mount that has been bind-mounted to the host's filesystem. The author explains that the file will have an owner UID of 11000 due to the user namespace mapping, but then notes that this is not a problem because the bind-mount ensures that the file's owner UID is set to 1000.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "clarification",
            "explanation"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "In our case, we have a UID 1000 (inside user namespace), which mapped to\nsomething like 10000 + 1000 (in the init_user_ns). And then we have\nNFS mount (sb->s_user_ns = init_user_ns, ofc), so if user UID 1000\n(inside the container)\ncreates a file, it will be 11000, right? But we do bind-mount of that\nNFS mount+VFS idmap,\nso that once file is created it has owner_uid = 1000. (This scenario\nis covered by [1] and [2])\n\n[1] https://docs.kernel.org/filesystems/idmappings.html#example-3\n[2] https://docs.kernel.org/filesystems/idmappings.html#example-3-reconsidered",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        },
        {
          "author": "Alexander Mikhalitsyn (author)",
          "summary": "Author agrees to provide a starting point for the NFS implementation by preparing RFC patches for the simple case, indicating a willingness to address the issue.",
          "sentiment": "positive",
          "sentiment_signals": [
            "agreement",
            "commitment"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "Yes, I could prepare RFC patches before LSF/MM/BPF for that simple case so\nwe have something to start with.",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-18"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-19": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "NeilBrown",
          "summary": "The reviewer noted that when using krb5 and NFSv3, the idmapping between krb5 identity and uid should be consistent on both client and server to ensure correct ownership of files. They also mentioned that for NFSv4, the kernel idmapping is not needed and the idmapper daemon should run in user-namespace to map on-the-wire names to app-level uids.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "considered additional complexity"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "You also need to consider the conversion when receiving an RPC.\n\nIf you use krb5 and NFSv3 then you really want the mapping between krb5\nidentity and uid to be the same on client and server, so then when an\napplication creates a file and the stats it, it sees that it owns it.\n\nIf I use a krb5 identity in an idmapped NFS filesystem I'll want the\nserver to map the identity to the \"underlying\" uid (was would be stored\nin a local filesystem) and then when the client gets a GETATTR reply,\nthe VFS maps back to the uid seen by the application.\n\nWith NFSv4 and the idmapper you wouldn't need (or want) the kernel\nidmapping to be used at all.  You would want the idmapper deamon to run\nin the user-namespace and map from on-the-wire names to the appropriate\napp-level uids.\nThis would mean that a given NFS mount would need to be an a given user\nnamespace.  Maybe that isn't desired.\n\nIf it is important for a given NFS mount to be available in multiple\nuser namespaces, then the idmapper daemon would need to map to the\nunderlying uid, and the VFS mapping would map that up to the app-level\nuid.\n\nNeilBrown",
          "reply_to": "Jeff Layton",
          "message_date": "2026-02-19"
        },
        {
          "author": "Kohei Sugihara",
          "summary": "Reviewer expressed interest in the proposed VFS idmappings support in NFS, indicating a desire to share their own use case.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "no specific technical concerns raised"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Thank you Alex for the proposal and quick follow-ups. We're really\ninterested in this feature and we'd like to share our use case.",
          "reply_to": "NeilBrown",
          "message_date": "2026-02-19"
        },
        {
          "author": "Kohei Sugihara",
          "summary": "Kohei Sugihara noted that NFS is complex due to its variety of mount options and security features, making it challenging to support ID-mapping. He proposed two possible models for achieving consistent ownership: (a) the NFS client sends the container's UID/GID on the wire and the server stores them as such, or (b) the server stores the host's UID/GID and the client/VFS maps it to the container's UID/GID.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "complexity",
            "security implications"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Our use case is running multi-tenant Kubernetes clusters with\nKubernetes User Namespaces [1]. Basically we need to share a single\nstorage endpoint among multiple pods using ReadWriteMany (RWX) access\nmode. Implementations that support both RWX and ID-mapped mount are\nlimited [2].\n\nNFS is operationally common, so I am interested in supporting NFS for\nID-mapping, but NFS is complex due to its variety of mount options and\nsecurity features as Trond mentioned. We'd like to share our use case\nand define the minimum goal. Our goal is here:\n\n- 1: Mount the same NFS export as a persistent volume from multiple\nKubernetes Pods running on different compute nodes. Each tenant has\nits own exports.\n- 2: UID/GID in a container in the pod can be configurable to an\narbitrary value by runAsUser/runAsGroup (e.g. runAsUser/Group is set\nto 1000).\n- 3: We can access the export from the container as 1000:1000. At\nminimum, ownership should be consistent from the container view (i.e.\nstat shows 1000:1000 for files that the container creates). Today,\nID-mapped mount does not support NFS. The NFS client ends up using the\nhost-mapped uid/gid (e.g. container 1000 becomes host 11000), so the\ncontainer view becomes inconsistent across nodes.\n\nThere are (at least) two possible models here:\na) the NFS client sends 1000:1000 on the wire and the server stores\n1000:1000 (so server-side ownership matches the container uid/gid), or\nb) the server stores the host uid/gid (e.g. 11000:11000) and the\nclient/VFS maps it so that the container still sees 1000:1000.\nMy intuition is that (a) is simpler for a multi-node RWX setup, but it\nmay have security / policy implications depending on how the server\ndoes authorization (especially with sec=sys). I think itâ€™s worth\ndiscussing what the safe and reasonable minimum should be.\n\nIn this case, UID/GID in the host node is not deterministic for the\nprocess in the container due to user_namespaces(7), so we need to do\nID-mapping to unify UID/GID between container and file system. Also,\nwe likely need to consider both request and reply paths (e.g. GETATTR)\nto keep the view consistent.",
          "reply_to": "NeilBrown",
          "message_date": "2026-02-19"
        },
        {
          "author": "Kohei Sugihara",
          "summary": "Kohei Sugihara expressed concern that introducing ID-mapping into the VFS layer could potentially violate the NFS protocol, and suggested starting with a small case to ensure client-side implementation is feasible without affecting existing server implementations.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "potential issue"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Neil, thank you for your comment. We initially expected it to be in\nNFSv4. I totally agree with you and exactly our concern is how do we\nmake it consistent with idmapd(8). In the Kubernetes case, we cannot\npass CAP_SYS_ADMIN to allow pods to mount NFS directly, so mount will\nbe done on the host. As you mentioned, we think we can share a single\nNFS export from multiple hosts and pods, so I think introducing\nID-mapping into the VFS layer (with referencing local id-mapping\ntable) is appropriate.\n\nWe can start by picking a small case. My concern was whether this\ncould violate NFS protocol or not, whether things can be done on the\nclient side or not, and this topic is suitable for dealing with this\nas the VFS community. If things can be done on the client side, we can\ncover existing NFS server implementations (e.g. OpenZFS, proprietary\nappliances). I believe this can be applied to recent containerized\nruntime environments, even this small working set.\n\nAdding more context, Kubernetes and the container community actively\nwork on host isolation using the Linux user namespace feature.\nRecently they experienced RCE vulnerabilities on container runtime but\nit could be mitigated by host isolation using the user namespace\nisolation [3]. Along with migrating the runtime environment to user\nnamespace, extending file system support will be worth discussing.\n\nKind regards,\nKohei\n\n[1] https://kubernetes.io/docs/concepts/workloads/pods/user-namespaces/\n[2] https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes\n[3] https://lpc.events/event/19/contributions/2065/",
          "reply_to": "NeilBrown",
          "message_date": "2026-02-19"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-21": {
      "report_file": "2026-02-18_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Demi Obenour",
          "summary": "The reviewer noted that the secure case of NFS has similar problems to unprivileged virtiofsd on a system without user namespaces, where there is no way to store files with the UID/GID specified by VFS due to security restrictions. They proposed storing the mapped UID and GID as a user.* xattr as a workaround, which requires no special permissions and scales to large NFS servers.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "proposed alternative solution"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "The secure case (strong authentication) has similar problems to\nunprivileged virtiofsd on a system with user namespaces disabled.\nIn both cases, there is no way to store the files with the UID/GID/etc\nthat the VFS says they should have.  The server (NFS) or kernel\n(virtiofsd) simply will not (and, for security reasons, *must not*)\nallow this.\n\nI proposed a workaround for virtiofsd [1] that I will also propose\nhere: store the mapped UID and GID as a user.* xattr.  This requires\nno special permissions, and so it completely solves this problem.\nIt is also the only solution I know of that scales to NFS servers\nwith over 2^16 users, which might well exist.\n\nThe only better solution I can think of is to replace the numeric\nUID/GID with hierarchical identifier, such as a Windows-style SID.\nThose are much more complex, though.\n\n[1]: https://gitlab.com/virtio-fs/virtiofsd/-/issues/225\n-- \nSincerely,\nDemi Marie Obenour (she/her/hers)",
          "reply_to": "Alexander Mikhalitsyn",
          "message_date": "2026-02-21"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    }
  }
}