{
  "thread_id": "CAJnrk1YoaHnCmuwQra0XwOxf0aC_PQGby-DT1y_p=YRzotiE-w@mail.gmail.com",
  "subject": "[PATCH v1 03/11] io_uring/kbuf: add support for kernel-managed buffer rings",
  "url": "https://lore.kernel.org/all/CAJnrk1YoaHnCmuwQra0XwOxf0aC_PQGby-DT1y_p=YRzotiE-w@mail.gmail.com/",
  "dates": {
    "2026-02-27": {
      "report_file": "2026-02-27_ollama_llama3.1-8b.html",
      "developer": "Joanne Koong",
      "reviews": [
        {
          "author": "Joanne Koong",
          "summary": "Raised concerns about physical contiguity and allocation methods for kernel-managed buffer rings, suggesting that per-buffer contiguity is necessary for efficient DMA paths. Also questioned the use of io_mem_alloc_compound() and alloc_pages_bulk_node().",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "CONTROVERSIAL"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "",
          "reply_to": "",
          "message_date": "",
          "message_id": ""
        },
        {
          "author": "Pavel Begunkov",
          "summary": "Responded to Joanne's concerns by suggesting extending the uapi for regions and using THP. Also emphasized the importance of not working around capabilities and mm policies.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "NEEDS_WORK"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On 2/27/26 01:12, Joanne Koong wrote:\n...\n>>> Regions shouldn't know anything about your buffers, how it's\n>>> subdivided after, etc.\n> \n> I still think the memory for the buffers should be tied to the ring\n> itself and allocated physically contiguously per buffer. Per-buffer\n> contiguity will enable the most efficient DMA path for servers to send\n> read/write data to local storage or the network. If the buffers for\n> the bufring have to be allocated as one single memory region, the\n> io_mem_alloc_compound() call will fail for this large allocation size.\n> Even if io_mem_alloc_compound() did succeed, this is a waste as the\n> buffer pool as an entity doesn't need to be physically contiguous,\n> just the individual buffers themselves. For fuse, the server\n> configures what buffer pool size it wants to use, depending on what\n> queue depth and max request size it needs. So for most use cases, at\n> least for high-performance servers, allocation will have to fall back\n> to alloc_pages_bulk_node(), which doesn't allocate contiguously. You\n> mentioned in an earlier comment that this \"only violates abstractions\"\n> - which abstractions does this break? The pre-existing behavior\n> already defaults to allocating pages non-contiguously if the mem\n> region can't be allocated fully contiguously.\n\nRegions has uapi (see struct io_uring_region_desc) so that users\ncan operate with them in a unified manner. If you want regions to\nbe allocated in some special way, just extend it.\n\n> Going through registered buffers doesn't help either. Fuse servers can\n> be unprivileged and it's not guaranteed that there are enough huge\n> pages reserved or that another process hasn't taken them or that the\n> server has privileges to pre-reserve pages for the allocation. Also\n\nThere is THP these days. And FWIW, we should be vigilant about not\nusing io_uring to work around capabilities and mm policies. If user\ncan't do it, io_uring shouldn't either. It's also all accounted\nagainst mlock, if the limit is not high enough, you won't be able\nto use this feature at all.\n\n> the 2 MB granularity is inflexible while 1 GB is too much.\n\n-- \nPavel Begunkov\n\n\n",
          "reply_to": "Joanne Koong",
          "message_date": "2026-02-27",
          "message_id": ""
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "The patch adds support for kernel-managed buffer rings in io_uring, but raises concerns about physical contiguity and allocation methods."
    }
  }
}