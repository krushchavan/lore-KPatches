{
  "thread_id": "718a3b0c2275324b9e287af7e4434f55a4a45901.1771529877.git.boris@bur.io",
  "subject": "[PATCH 1/1] btrfs: set BTRFS_ROOT_ORPHAN_CLEANUP during subvol create",
  "url": "https://lore.kernel.org/all/718a3b0c2275324b9e287af7e4434f55a4a45901.1771529877.git.boris@bur.io/",
  "dates": {
    "2026-02-19": {
      "report_file": "2026-02-19_ollama_llama3.1-8b.html",
      "developer": "Boris Burkov",
      "reviews": [
        {
          "author": "Filipe Manana",
          "summary": "Reviewer Filipe Manana requested changes and clarifications on the patch, including adding a stack trace to the changelog, correcting terminology, and providing more information about the decrement of parent->d_lockref.count.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "clarification needed"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Thu, Feb 19, 2026 at 7:38â€¯PM Boris Burkov <boris@bur.io> wrote:\n>\n> We have recently observed a number of subvolumes with broken dentries.\n> ls-ing the parent dir looks like:\n>\n> drwxrwxrwt 1 root root 16 Jan 23 16:49 .\n> drwxr-xr-x 1 root root 24 Jan 23 16:48 ..\n> d????????? ? ?    ?     ?            ? broken_subvol\n>\n> and similarly stat-ing the file fails.\n>\n> In this state, deleting the subvol fails with ENOENT, but attempting to\n> create a new file or subvol over it errors out with EEXIST and even\n> aborts the fs. Which leaves us a bit stuck.\n>\n> dmesg contains a single notable error message reading:\n> \"could not do orphan cleanup -2\"\n>\n> 2 is ENOENT and the error comes from the failure handling path of\n> btrfs_orphan_cleanup(), with the stack leading back up to\n> btrfs_lookup().\n\nPlease include the stack trace in the changelog.\n\n>\n> After some detailed inspection of the internal state, it became clear\n> that:\n> - there are no orphan items for the subvol\n> - the subvol is otherwise healthy looking, it is not half-deleted or\n>   anything, there is no drop progress, etc.\n> - the subvol was created a while ago and first does orphan_cleanup()\n\nWhat do you mean by \"first does\"? The first call to btrfs_orphan_cleanup()?\n\nAlso please use full function name, orphan_cleanup() -> btrfs_orphan_cleanup()\n\n>   much later\n> - after orphan_cleanup fails, btrfs_lookup_dentry() returns -ENOENT,\n\norphan_cleanup -> btrfs_orphan_cleanup()\n\n>   which results in a negative dentry for the subvolume via\n>   d_splice_alias(NULL, dentry), leading to the observed behavior. The\n>   bug can be mitigated by dropping the dentry cache, at which point we\n>   can successfully delete the subvolume if we want.\n>\n> btrfs_orphan_cleanup() does test_and_set_bit(BTRFS_ROOT_ORPHAN_CLEANUP)\n> on the root when it runs, so it cannot run more than once on a given\n> root, so something else must run concurrently. However, the obvious\n> routes to deleting an orphan when nlinks goes to 0 should not be able to\n> run without first doing a lookup into the subvolume, which should run\n> btrfs_orphan_cleanup() and set the bit.\n>\n> The final important observation is that create_subvol() calls\n> d_instantiate_new() but does not set BTRFS_ROOT_ORPHAN_CLEANUP, so if\n> the dentry cache gets dropped, the next lookup into the subvolume will\n> make a real call into btrfs_orphan_cleanup() for the first time. This\n> opens up the possibility of concurrently deleting the inode/orphan items\n> but most typical evict() paths will be holding a reference on the parent\n> dentry (child dentry holds parent->d_lockref.count via dget in\n> d_alloc(), released in __dentry_kill()) and prevent the parent from\n> being removed from the dentry cache.\n>\n> The one exception is delayed iputs. Ordered extent creation calls\n> igrab() on the inode. If the file is unlinked and closed while those\n> refs are held, iput() in __dentry_kill() decrements i_count but does\n> not trigger eviction (i_count > 0). The child dentry is freed and the\n> subvol dentry's d_lockref.count drops to 0, making it evictable while\n> the inode is still alive.\n>\n> Since there are two races (the race between writeback and unlink and\n> the race between lookup and delayed iputs), and there are too many moving\n> parts, the following two diagrams show the complete picture. The first\n> sets us up in a condition where we can evict the subvol dentry and there\n> is a delayed iput on the inode:\n>\n> T1 (task)                    T2 (writeback)                   T3 (OE workqueue)\n>\n> write() // dirty pages\n>                               btrfs_writepages()\n>                                 btrfs_run_delalloc_range()\n>                                   cow_file_range()\n>                                     btrfs_alloc_ordered_extent()\n>                                       igrab() // i_count: 1 -> 1+N\n\nI find this confusing:   1 -> 1 + N ?\n\nShouldn't it be 1 -> 2, meaning the igrab() increased i_count from 1 to 2?\n\n> btrfs_unlink_inode()\n>   btrfs_orphan_add()\n> close()\n>   __dentry_kill()\n>     dentry_unlink_inode()\n>       iput() // 1+N -> N\n>     --parent->d_lockref.count\n\nWhere does this decrement of parent->d_lockref.count happens exactly?\nI don't see it immediately in iput(), or iput_final(). Please put the\nfull call chain.\n\n\n>     // count -> 0\n>                                                                 finish_ordered_fn()\n>                                                                   btrfs_finish_ordered_io()\n>                                                                     btrfs_put_ordered_extent()\n>                                                                       btrfs_add_delayed_iput()\n>\n> Once the delayed iput is pending and the subvol dentry is evictable,\n> the shrinker can free it, causing the next lookup to go through\n> btrfs_lookup() and call btrfs_orphan_cleanup() for the first time.\n> If the cleaner kthread processes the delayed iput concurrently, the\n> two race:\n>\n>   T1 (shrinker)              T2 (cleaner kthread)                          T3 (lookup)\n>\n>   super_cache_scan()\n>     prune_dcache_sb()\n>       __dentry_kill()\n>       // subvol dentry freed\n>                               btrfs_run_delayed_iputs()\n>                                 iput()  // i_count -> 0\n>                                   evict()  // sets I_FREEING\n>                                     btrfs_evict_inode()\n>                                       // truncation loop\n>                                                                             btrfs_lookup()\n>                                                                               btrfs_lookup_dentry()\n>                                                                                 btrfs_orphan_cleanup()\n>                                                                                   // first call (bit never set)\n>                                                                                   btrfs_iget()\n>                                                                                     // blocks on I_FREEING\n>\n>                                       btrfs_orphan_del()\n>                                       // inode freed\n>                                                                                     // returns -ENOENT\n>                                                                                   btrfs_del_orphan_item()\n>                                                                                     // -ENOENT\n>                                                                                 // \"could not do orphan cleanup -2\"\n>                                                                             d_splice_alias(NULL, dentry)\n>                                                                             // negative dentry for valid subvol\n>\n> The most straightforward fix is to ensure the invariant that a dentry\n> for a subvolume can exist if and only if that subvolume has\n> BTRFS_ROOT_ORPHAN_CLEANUP set on its root (and is known to have no\n> orphans or ran btrfs_orphan_cleanup()).\n\nLooks reasonable to me.\n\nThanks!\n\n>\n> Signed-off-by: Boris Burkov <boris@bur.io>\n> ---\n>  fs/btrfs/ioctl.c | 7 +++++++\n>  1 file changed, 7 insertions(+)\n>\n> diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c\n> index b8db877be61cc..77f7db18c6ca5 100644\n> --- a/fs/btrfs/ioctl.c\n> +++ b/fs/btrfs/ioctl.c\n> @@ -672,6 +672,13 @@ static noinline int create_subvol(struct mnt_idmap *idmap,\n>                 goto out;\n>         }\n>\n> +       /*\n> +        * Subvolumes have orphans cleaned on first dentry lookup. A new\n> +        * subvolume cannot have any orphans, so we should set the bit before we\n> +        * add the subvolume dentry to the dentry cache, so that it is in the\n> +        * same state as a subvolume after first lookup.\n> +        */\n> +       set_bit(BTRFS_ROOT_ORPHAN_CLEANUP, &new_root->state);\n>         d_instantiate_new(dentry, new_inode_args.inode);\n>         new_inode_args.inode = NULL;\n>\n> --\n> 2.47.3\n>\n>\n\n",
          "reply_to": "Boris Burkov"
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "This patch sets the BTRFS_ROOT_ORPHAN_CLEANUP flag during subvolume creation to prevent orphan cleanup issues. The issue arises when a subvolume is created and later orphan cleanup fails, leading to broken dentries and preventing deletion or creation of new files/subvolumes over it. The patch addresses two concurrent races that can occur between writeback/unlink and lookup/delayed iputs, ensuring that the subvolume's dentry cache is properly cleaned up."
    }
  }
}