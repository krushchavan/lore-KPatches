<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [RFC PATCH 1/1] iomap: fix race between iomap_set_range_uptodate and folio_end_read</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [RFC PATCH 1/1] iomap: fix race between iomap_set_range_uptodate and folio_end_read</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/CAJnrk1a8E-vf_7ZQKhfTGhE5ENYcAQwtAfS0kcVjCvSq=PhX9g@mail.gmail.com/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-13">2026-02-13</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-13">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Joanne Koong (author)</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer Joanne Koong requested changes to the patch, specifically pointing out a race condition between iomap_set_range_uptodate and folio_end_read.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Move the iomap_readpage_iter() bio read logic into a separate helper
function, iomap_bio_read_folio_range(). This is needed to make iomap
read/readahead more generically usable, especially for filesystems that
do not require CONFIG_BLOCK.

Additionally rename buffered write&#x27;s iomap_read_folio_range() function
to iomap_bio_read_folio_range_sync() to better describe its synchronous
behavior.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/iomap/buffered-io.c | 68 ++++++++++++++++++++++++------------------
 1 file changed, 39 insertions(+), 29 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 9535733ed07a..7e65075b6345 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -367,36 +367,15 @@ struct iomap_readpage_ctx {
 	struct readahead_control *rac;
 };
 
-static int iomap_readpage_iter(struct iomap_iter *iter,
-		struct iomap_readpage_ctx *ctx)
+static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
+		struct iomap_readpage_ctx *ctx, loff_t pos, size_t plen)
 {
+	struct folio *folio = ctx-&gt;cur_folio;
 	const struct iomap *iomap = &amp;iter-&gt;iomap;
-	loff_t pos = iter-&gt;pos;
+	struct iomap_folio_state *ifs = folio-&gt;private;
+	size_t poff = offset_in_folio(folio, pos);
 	loff_t length = iomap_length(iter);
-	struct folio *folio = ctx-&gt;cur_folio;
-	struct iomap_folio_state *ifs;
-	size_t poff, plen;
 	sector_t sector;
-	int ret;
-
-	if (iomap-&gt;type == IOMAP_INLINE) {
-		ret = iomap_read_inline_data(iter, folio);
-		if (ret)
-			return ret;
-		return iomap_iter_advance(iter, length);
-	}
-
-	/* zero post-eof blocks as the page may be mapped */
-	ifs = ifs_alloc(iter-&gt;inode, folio, iter-&gt;flags);
-	iomap_adjust_read_range(iter-&gt;inode, folio, &amp;pos, length, &amp;poff, &amp;plen);
-	if (plen == 0)
-		goto done;
-
-	if (iomap_block_needs_zeroing(iter, pos)) {
-		folio_zero_range(folio, poff, plen);
-		iomap_set_range_uptodate(folio, poff, plen);
-		goto done;
-	}
 
 	ctx-&gt;cur_folio_in_bio = true;
 	if (ifs) {
@@ -435,6 +414,37 @@ static int iomap_readpage_iter(struct iomap_iter *iter,
 		ctx-&gt;bio-&gt;bi_end_io = iomap_read_end_io;
 		bio_add_folio_nofail(ctx-&gt;bio, folio, plen, poff);
 	}
+}
+
+static int iomap_readpage_iter(struct iomap_iter *iter,
+		struct iomap_readpage_ctx *ctx)
+{
+	const struct iomap *iomap = &amp;iter-&gt;iomap;
+	loff_t pos = iter-&gt;pos;
+	loff_t length = iomap_length(iter);
+	struct folio *folio = ctx-&gt;cur_folio;
+	size_t poff, plen;
+	int ret;
+
+	if (iomap-&gt;type == IOMAP_INLINE) {
+		ret = iomap_read_inline_data(iter, folio);
+		if (ret)
+			return ret;
+		return iomap_iter_advance(iter, length);
+	}
+
+	/* zero post-eof blocks as the page may be mapped */
+	ifs_alloc(iter-&gt;inode, folio, iter-&gt;flags);
+	iomap_adjust_read_range(iter-&gt;inode, folio, &amp;pos, length, &amp;poff, &amp;plen);
+	if (plen == 0)
+		goto done;
+
+	if (iomap_block_needs_zeroing(iter, pos)) {
+		folio_zero_range(folio, poff, plen);
+		iomap_set_range_uptodate(folio, poff, plen);
+	} else {
+		iomap_bio_read_folio_range(iter, ctx, pos, plen);
+	}
 
 done:
 	/*
@@ -559,7 +569,7 @@ void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
 }
 EXPORT_SYMBOL_GPL(iomap_readahead);
 
-static int iomap_read_folio_range(const struct iomap_iter *iter,
+static int iomap_bio_read_folio_range_sync(const struct iomap_iter *iter,
 		struct folio *folio, loff_t pos, size_t len)
 {
 	const struct iomap *srcmap = iomap_iter_srcmap(iter);
@@ -572,7 +582,7 @@ static int iomap_read_folio_range(const struct iomap_iter *iter,
 	return submit_bio_wait(&amp;bio);
 }
 #else
-static int iomap_read_folio_range(const struct iomap_iter *iter,
+static int iomap_bio_read_folio_range_sync(const struct iomap_iter *iter,
 		struct folio *folio, loff_t pos, size_t len)
 {
 	WARN_ON_ONCE(1);
@@ -749,7 +759,7 @@ static int __iomap_write_begin(const struct iomap_iter *iter,
 				status = write_ops-&gt;read_folio_range(iter,
 						folio, block_start, plen);
 			else
-				status = iomap_read_folio_range(iter,
+				status = iomap_bio_read_folio_range_sync(iter,
 						folio, block_start, plen);
 			if (status)
 				return status;
-- 
2.47.3



---

Move the read/readahead bio submission logic into a separate helper.
This is needed to make iomap read/readahead more generically usable,
especially for filesystems that do not require CONFIG_BLOCK.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/iomap/buffered-io.c | 30 ++++++++++++++++--------------
 1 file changed, 16 insertions(+), 14 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 7e65075b6345..f8b985bb5a6b 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -367,6 +367,14 @@ struct iomap_readpage_ctx {
 	struct readahead_control *rac;
 };
 
+static void iomap_bio_submit_read(struct iomap_readpage_ctx *ctx)
+{
+	struct bio *bio = ctx-&gt;bio;
+
+	if (bio)
+		submit_bio(bio);
+}
+
 static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 		struct iomap_readpage_ctx *ctx, loff_t pos, size_t plen)
 {
@@ -392,8 +400,7 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 		gfp_t orig_gfp = gfp;
 		unsigned int nr_vecs = DIV_ROUND_UP(length, PAGE_SIZE);
 
-		if (ctx-&gt;bio)
-			submit_bio(ctx-&gt;bio);
+		iomap_bio_submit_read(ctx);
 
 		if (ctx-&gt;rac) /* same as readahead_gfp_mask */
 			gfp |= __GFP_NORETRY | __GFP_NOWARN;
@@ -488,13 +495,10 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
 	while ((ret = iomap_iter(&amp;iter, ops)) &gt; 0)
 		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx);
 
-	if (ctx.bio) {
-		submit_bio(ctx.bio);
-		WARN_ON_ONCE(!ctx.cur_folio_in_bio);
-	} else {
-		WARN_ON_ONCE(ctx.cur_folio_in_bio);
+	iomap_bio_submit_read(&amp;ctx);
+
+	if (!ctx.cur_folio_in_bio)
 		folio_unlock(folio);
-	}
 
 	/*
 	 * Just like mpage_readahead and block_read_full_folio, we always
@@ -560,12 +564,10 @@ void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
 	while (iomap_iter(&amp;iter, ops) &gt; 0)
 		iter.status = iomap_readahead_iter(&amp;iter, &amp;ctx);
 
-	if (ctx.bio)
-		submit_bio(ctx.bio);
-	if (ctx.cur_folio) {
-		if (!ctx.cur_folio_in_bio)
-			folio_unlock(ctx.cur_folio);
-	}
+	iomap_bio_submit_read(&amp;ctx);
+
+	if (ctx.cur_folio &amp;&amp; !ctx.cur_folio_in_bio)
+		folio_unlock(ctx.cur_folio);
 }
 EXPORT_SYMBOL_GPL(iomap_readahead);
 
-- 
2.47.3



---

Store the iomap_readpage_ctx bio generically as a &quot;void *read_ctx&quot;.
This makes the read/readahead interface more generic, which allows it to
be used by filesystems that may not be block-based and may not have
CONFIG_BLOCK set.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/iomap/buffered-io.c | 29 ++++++++++++++---------------
 1 file changed, 14 insertions(+), 15 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index f8b985bb5a6b..b06b532033ad 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -363,13 +363,13 @@ static void iomap_read_end_io(struct bio *bio)
 struct iomap_readpage_ctx {
 	struct folio		*cur_folio;
 	bool			cur_folio_in_bio;
-	struct bio		*bio;
+	void			*read_ctx;
 	struct readahead_control *rac;
 };
 
 static void iomap_bio_submit_read(struct iomap_readpage_ctx *ctx)
 {
-	struct bio *bio = ctx-&gt;bio;
+	struct bio *bio = ctx-&gt;read_ctx;
 
 	if (bio)
 		submit_bio(bio);
@@ -384,6 +384,7 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 	size_t poff = offset_in_folio(folio, pos);
 	loff_t length = iomap_length(iter);
 	sector_t sector;
+	struct bio *bio = ctx-&gt;read_ctx;
 
 	ctx-&gt;cur_folio_in_bio = true;
 	if (ifs) {
@@ -393,9 +394,8 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 	}
 
 	sector = iomap_sector(iomap, pos);
-	if (!ctx-&gt;bio ||
-	    bio_end_sector(ctx-&gt;bio) != sector ||
-	    !bio_add_folio(ctx-&gt;bio, folio, plen, poff)) {
+	if (!bio || bio_end_sector(bio) != sector ||
+	    !bio_add_folio(bio, folio, plen, poff)) {
 		gfp_t gfp = mapping_gfp_constraint(folio-&gt;mapping, GFP_KERNEL);
 		gfp_t orig_gfp = gfp;
 		unsigned int nr_vecs = DIV_ROUND_UP(length, PAGE_SIZE);
@@ -404,22 +404,21 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 
 		if (ctx-&gt;rac) /* same as readahead_gfp_mask */
 			gfp |= __GFP_NORETRY | __GFP_NOWARN;
-		ctx-&gt;bio = bio_alloc(iomap-&gt;bdev, bio_max_segs(nr_vecs),
-				     REQ_OP_READ, gfp);
+		bio = bio_alloc(iomap-&gt;bdev, bio_max_segs(nr_vecs), REQ_OP_READ,
+				     gfp);
 		/*
 		 * If the bio_alloc fails, try it again for a single page to
 		 * avoid having to deal with partial page reads.  This emulates
 		 * what do_mpage_read_folio does.
 		 */
-		if (!ctx-&gt;bio) {
-			ctx-&gt;bio = bio_alloc(iomap-&gt;bdev, 1, REQ_OP_READ,
-					     orig_gfp);
-		}
+		if (!bio)
+			bio = bio_alloc(iomap-&gt;bdev, 1, REQ_OP_READ, orig_gfp);
 		if (ctx-&gt;rac)
-			ctx-&gt;bio-&gt;bi_opf |= REQ_RAHEAD;
-		ctx-&gt;bio-&gt;bi_iter.bi_sector = sector;
-		ctx-&gt;bio-&gt;bi_end_io = iomap_read_end_io;
-		bio_add_folio_nofail(ctx-&gt;bio, folio, plen, poff);
+			bio-&gt;bi_opf |= REQ_RAHEAD;
+		bio-&gt;bi_iter.bi_sector = sector;
+		bio-&gt;bi_end_io = iomap_read_end_io;
+		bio_add_folio_nofail(bio, folio, plen, poff);
+		ctx-&gt;read_ctx = bio;
 	}
 }
 
-- 
2.47.3



---

Iterate over all non-uptodate ranges of a folio mapping in a single call
to iomap_readpage_iter() instead of leaving the partial iteration to the
caller.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/iomap/buffered-io.c | 53 ++++++++++++++++++++----------------------
 1 file changed, 25 insertions(+), 28 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index b06b532033ad..dbe5783ee68c 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -430,6 +430,7 @@ static int iomap_readpage_iter(struct iomap_iter *iter,
 	loff_t length = iomap_length(iter);
 	struct folio *folio = ctx-&gt;cur_folio;
 	size_t poff, plen;
+	loff_t count;
 	int ret;
 
 	if (iomap-&gt;type == IOMAP_INLINE) {
@@ -439,41 +440,35 @@ static int iomap_readpage_iter(struct iomap_iter *iter,
 		return iomap_iter_advance(iter, length);
 	}
 
-	/* zero post-eof blocks as the page may be mapped */
 	ifs_alloc(iter-&gt;inode, folio, iter-&gt;flags);
-	iomap_adjust_read_range(iter-&gt;inode, folio, &amp;pos, length, &amp;poff, &amp;plen);
-	if (plen == 0)
-		goto done;
 
-	if (iomap_block_needs_zeroing(iter, pos)) {
-		folio_zero_range(folio, poff, plen);
-		iomap_set_range_uptodate(folio, poff, plen);
-	} else {
-		iomap_bio_read_folio_range(iter, ctx, pos, plen);
-	}
+	length = min_t(loff_t, length,
+			folio_size(folio) - offset_in_folio(folio, pos));
+	while (length) {
+		iomap_adjust_read_range(iter-&gt;inode, folio, &amp;pos, length, &amp;poff,
+				&amp;plen);
 
-done:
-	/*
-	 * Move the caller beyond our range so that it keeps making progress.
-	 * For that, we have to include any leading non-uptodate ranges, but
-	 * we can skip trailing ones as they will be handled in the next
-	 * iteration.
-	 */
-	length = pos - iter-&gt;pos + plen;
-	return iomap_iter_advance(iter, length);
-}
+		count = pos - iter-&gt;pos + plen;
+		if (WARN_ON_ONCE(count &gt; length))
+			return -EIO;
 
-static int iomap_read_folio_iter(struct iomap_iter *iter,
-		struct iomap_readpage_ctx *ctx)
-{
-	int ret;
+		if (plen == 0)
+			return iomap_iter_advance(iter, count);
 
-	while (iomap_length(iter)) {
-		ret = iomap_readpage_iter(iter, ctx);
+		/* zero post-eof blocks as the page may be mapped */
+		if (iomap_block_needs_zeroing(iter, pos)) {
+			folio_zero_range(folio, poff, plen);
+			iomap_set_range_uptodate(folio, poff, plen);
+		} else {
+			iomap_bio_read_folio_range(iter, ctx, pos, plen);
+		}
+
+		ret = iomap_iter_advance(iter, count);
 		if (ret)
 			return ret;
+		length -= count;
+		pos = iter-&gt;pos;
 	}
-
 	return 0;
 }
 
@@ -492,7 +487,7 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
 	trace_iomap_readpage(iter.inode, 1);
 
 	while ((ret = iomap_iter(&amp;iter, ops)) &gt; 0)
-		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx);
+		iter.status = iomap_readpage_iter(&amp;iter, &amp;ctx);
 
 	iomap_bio_submit_read(&amp;ctx);
 
@@ -522,6 +517,8 @@ static int iomap_readahead_iter(struct iomap_iter *iter,
 		}
 		if (!ctx-&gt;cur_folio) {
 			ctx-&gt;cur_folio = readahead_folio(ctx-&gt;rac);
+			if (WARN_ON_ONCE(!ctx-&gt;cur_folio))
+				return -EINVAL;
 			ctx-&gt;cur_folio_in_bio = false;
 		}
 		ret = iomap_readpage_iter(iter, ctx);
-- 
2.47.3



---

-&gt;readpage was deprecated and reads are now on folios.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
---
 fs/iomap/buffered-io.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index dbe5783ee68c..23601373573e 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -422,7 +422,7 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 	}
 }
 
-static int iomap_readpage_iter(struct iomap_iter *iter,
+static int iomap_read_folio_iter(struct iomap_iter *iter,
 		struct iomap_readpage_ctx *ctx)
 {
 	const struct iomap *iomap = &amp;iter-&gt;iomap;
@@ -487,7 +487,7 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
 	trace_iomap_readpage(iter.inode, 1);
 
 	while ((ret = iomap_iter(&amp;iter, ops)) &gt; 0)
-		iter.status = iomap_readpage_iter(&amp;iter, &amp;ctx);
+		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx);
 
 	iomap_bio_submit_read(&amp;ctx);
 
@@ -521,7 +521,7 @@ static int iomap_readahead_iter(struct iomap_iter *iter,
 				return -EINVAL;
 			ctx-&gt;cur_folio_in_bio = false;
 		}
-		ret = iomap_readpage_iter(iter, ctx);
+		ret = iomap_read_folio_iter(iter, ctx);
 		if (ret)
 			return ret;
 	}
-- 
2.47.3



---

-&gt;readpage was deprecated and reads are now on folios.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
---
 fs/iomap/buffered-io.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 23601373573e..09e65771a947 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -360,14 +360,14 @@ static void iomap_read_end_io(struct bio *bio)
 	bio_put(bio);
 }
 
-struct iomap_readpage_ctx {
+struct iomap_read_folio_ctx {
 	struct folio		*cur_folio;
 	bool			cur_folio_in_bio;
 	void			*read_ctx;
 	struct readahead_control *rac;
 };
 
-static void iomap_bio_submit_read(struct iomap_readpage_ctx *ctx)
+static void iomap_bio_submit_read(struct iomap_read_folio_ctx *ctx)
 {
 	struct bio *bio = ctx-&gt;read_ctx;
 
@@ -376,7 +376,7 @@ static void iomap_bio_submit_read(struct iomap_readpage_ctx *ctx)
 }
 
 static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
-		struct iomap_readpage_ctx *ctx, loff_t pos, size_t plen)
+		struct iomap_read_folio_ctx *ctx, loff_t pos, size_t plen)
 {
 	struct folio *folio = ctx-&gt;cur_folio;
 	const struct iomap *iomap = &amp;iter-&gt;iomap;
@@ -423,7 +423,7 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 }
 
 static int iomap_read_folio_iter(struct iomap_iter *iter,
-		struct iomap_readpage_ctx *ctx)
+		struct iomap_read_folio_ctx *ctx)
 {
 	const struct iomap *iomap = &amp;iter-&gt;iomap;
 	loff_t pos = iter-&gt;pos;
@@ -479,7 +479,7 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
 		.pos		= folio_pos(folio),
 		.len		= folio_size(folio),
 	};
-	struct iomap_readpage_ctx ctx = {
+	struct iomap_read_folio_ctx ctx = {
 		.cur_folio	= folio,
 	};
 	int ret;
@@ -504,7 +504,7 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
 EXPORT_SYMBOL_GPL(iomap_read_folio);
 
 static int iomap_readahead_iter(struct iomap_iter *iter,
-		struct iomap_readpage_ctx *ctx)
+		struct iomap_read_folio_ctx *ctx)
 {
 	int ret;
 
@@ -551,7 +551,7 @@ void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
 		.pos	= readahead_pos(rac),
 		.len	= readahead_length(rac),
 	};
-	struct iomap_readpage_ctx ctx = {
+	struct iomap_read_folio_ctx ctx = {
 		.rac	= rac,
 	};
 
-- 
2.47.3



---

Instead of incrementing read_bytes_pending for every folio range read in
(which requires acquiring the spinlock to do so), set read_bytes_pending
to the folio size when the first range is asynchronously read in, keep
track of how many bytes total are asynchronously read in, and adjust
read_bytes_pending accordingly after issuing requests to read in all the
necessary ranges.

iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
value for pending bytes necessarily indicates the folio is in the bio.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/iomap/buffered-io.c | 87 ++++++++++++++++++++++++++++++++----------
 1 file changed, 66 insertions(+), 21 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 09e65771a947..4e6258fdb915 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -362,7 +362,6 @@ static void iomap_read_end_io(struct bio *bio)
 
 struct iomap_read_folio_ctx {
 	struct folio		*cur_folio;
-	bool			cur_folio_in_bio;
 	void			*read_ctx;
 	struct readahead_control *rac;
 };
@@ -380,19 +379,11 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 {
 	struct folio *folio = ctx-&gt;cur_folio;
 	const struct iomap *iomap = &amp;iter-&gt;iomap;
-	struct iomap_folio_state *ifs = folio-&gt;private;
 	size_t poff = offset_in_folio(folio, pos);
 	loff_t length = iomap_length(iter);
 	sector_t sector;
 	struct bio *bio = ctx-&gt;read_ctx;
 
-	ctx-&gt;cur_folio_in_bio = true;
-	if (ifs) {
-		spin_lock_irq(&amp;ifs-&gt;state_lock);
-		ifs-&gt;read_bytes_pending += plen;
-		spin_unlock_irq(&amp;ifs-&gt;state_lock);
-	}
-
 	sector = iomap_sector(iomap, pos);
 	if (!bio || bio_end_sector(bio) != sector ||
 	    !bio_add_folio(bio, folio, plen, poff)) {
@@ -422,8 +413,57 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 	}
 }
 
+static void iomap_read_init(struct folio *folio)
+{
+	struct iomap_folio_state *ifs = folio-&gt;private;
+
+	if (ifs) {
+		size_t len = folio_size(folio);
+
+		spin_lock_irq(&amp;ifs-&gt;state_lock);
+		ifs-&gt;read_bytes_pending += len;
+		spin_unlock_irq(&amp;ifs-&gt;state_lock);
+	}
+}
+
+static void iomap_read_end(struct folio *folio, size_t bytes_pending)
+{
+	struct iomap_folio_state *ifs;
+
+	/*
+	 * If there are no bytes pending, this means we are responsible for
+	 * unlocking the folio here, since no IO helper has taken ownership of
+	 * it.
+	 */
+	if (!bytes_pending) {
+		folio_unlock(folio);
+		return;
+	}
+
+	ifs = folio-&gt;private;
+	if (ifs) {
+		bool end_read, uptodate;
+		size_t bytes_accounted = folio_size(folio) - bytes_pending;
+
+		spin_lock_irq(&amp;ifs-&gt;state_lock);
+		ifs-&gt;read_bytes_pending -= bytes_accounted;
+		/*
+		 * If !ifs-&gt;read_bytes_pending, this means all pending reads
+		 * by the IO helper have already completed, which means we need
+		 * to end the folio read here. If ifs-&gt;read_bytes_pending != 0,
+		 * the IO helper will end the folio read.
+		 */
+		end_read = !ifs-&gt;read_bytes_pending;
+		if (end_read)
+			uptodate = ifs_is_fully_uptodate(folio, ifs);
+		spin_unlock_irq(&amp;ifs-&gt;state_lock);
+		if (end_read)
+			folio_end_read(folio, uptodate);
+	}
+}
+
 static int iomap_read_folio_iter(struct iomap_iter *iter,
-		struct iomap_read_folio_ctx *ctx)
+		struct iomap_read_folio_ctx *ctx, size_t *bytes_pending)
 {
 	const struct iomap *iomap = &amp;iter-&gt;iomap;
 	loff_t pos = iter-&gt;pos;
@@ -460,6 +500,9 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
 			folio_zero_range(folio, poff, plen);
 			iomap_set_range_uptodate(folio, poff, plen);
 		} else {
+			if (!*bytes_pending)
+				iomap_read_init(folio);
+			*bytes_pending += plen;
 			iomap_bio_read_folio_range(iter, ctx, pos, plen);
 		}
 
@@ -482,17 +525,18 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
 	struct iomap_read_folio_ctx ctx = {
 		.cur_folio	= folio,
 	};
+	size_t bytes_pending = 0;
 	int ret;
 
 	trace_iomap_readpage(iter.inode, 1);
 
 	while ((ret = iomap_iter(&amp;iter, ops)) &gt; 0)
-		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx);
+		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx,
+				&amp;bytes_pending);
 
 	iomap_bio_submit_read(&amp;ctx);
 
-	if (!ctx.cur_folio_in_bio)
-		folio_unlock(folio);
+	iomap_read_end(folio, bytes_pending);
 
 	/*
 	 * Just like mpage_readahead and block_read_full_folio, we always
@@ -504,24 +548,23 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
 EXPORT_SYMBOL_GPL(iomap_read_folio);
 
 static int iomap_readahead_iter(struct iomap_iter *iter,
-		struct iomap_read_folio_ctx *ctx)
+		struct iomap_read_folio_ctx *ctx, size_t *cur_bytes_pending)
 {
 	int ret;
 
 	while (iomap_length(iter)) {
 		if (ctx-&gt;cur_folio &amp;&amp;
 		    offset_in_folio(ctx-&gt;cur_folio, iter-&gt;pos) == 0) {
-			if (!ctx-&gt;cur_folio_in_bio)
-				folio_unlock(ctx-&gt;cur_folio);
+			iomap_read_end(ctx-&gt;cur_folio, *cur_bytes_pending);
 			ctx-&gt;cur_folio = NULL;
 		}
 		if (!ctx-&gt;cur_folio) {
 			ctx-&gt;cur_folio = readahead_folio(ctx-&gt;rac);
 			if (WARN_ON_ONCE(!ctx-&gt;cur_folio))
 				return -EINVAL;
-			ctx-&gt;cur_folio_in_bio = false;
+			*cur_bytes_pending = 0;
 		}
-		ret = iomap_read_folio_iter(iter, ctx);
+		ret = iomap_read_folio_iter(iter, ctx, cur_bytes_pending);
 		if (ret)
 			return ret;
 	}
@@ -554,16 +597,18 @@ void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
 	struct iomap_read_folio_ctx ctx = {
 		.rac	= rac,
 	};
+	size_t cur_bytes_pending;
 
 	trace_iomap_readahead(rac-&gt;mapping-&gt;host, readahead_count(rac));
 
 	while (iomap_iter(&amp;iter, ops) &gt; 0)
-		iter.status = iomap_readahead_iter(&amp;iter, &amp;ctx);
+		iter.status = iomap_readahead_iter(&amp;iter, &amp;ctx,
+					&amp;cur_bytes_pending);
 
 	iomap_bio_submit_read(&amp;ctx);
 
-	if (ctx.cur_folio &amp;&amp; !ctx.cur_folio_in_bio)
-		folio_unlock(ctx.cur_folio);
+	if (ctx.cur_folio)
+		iomap_read_end(ctx.cur_folio, cur_bytes_pending);
 }
 EXPORT_SYMBOL_GPL(iomap_readahead);
 
-- 
2.47.3



---

Advance iter to the correct position before calling an IO helper to read
in a folio range. This allows the helper to reliably use iter-&gt;pos to
determine the starting offset for reading.

This will simplify the interface for reading in folio ranges when iomap
read/readahead supports caller-provided callbacks.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Suggested-by: Christoph Hellwig &lt;hch@lst.de&gt;
---
 fs/iomap/buffered-io.c | 21 +++++++++++++--------
 1 file changed, 13 insertions(+), 8 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 4e6258fdb915..82bdf7c5e03c 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -375,10 +375,11 @@ static void iomap_bio_submit_read(struct iomap_read_folio_ctx *ctx)
 }
 
 static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
-		struct iomap_read_folio_ctx *ctx, loff_t pos, size_t plen)
+		struct iomap_read_folio_ctx *ctx, size_t plen)
 {
 	struct folio *folio = ctx-&gt;cur_folio;
 	const struct iomap *iomap = &amp;iter-&gt;iomap;
+	loff_t pos = iter-&gt;pos;
 	size_t poff = offset_in_folio(folio, pos);
 	loff_t length = iomap_length(iter);
 	sector_t sector;
@@ -470,7 +471,7 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
 	loff_t length = iomap_length(iter);
 	struct folio *folio = ctx-&gt;cur_folio;
 	size_t poff, plen;
-	loff_t count;
+	loff_t pos_diff;
 	int ret;
 
 	if (iomap-&gt;type == IOMAP_INLINE) {
@@ -488,12 +489,16 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
 		iomap_adjust_read_range(iter-&gt;inode, folio, &amp;pos, length, &amp;poff,
 				&amp;plen);
 
-		count = pos - iter-&gt;pos + plen;
-		if (WARN_ON_ONCE(count &gt; length))
+		pos_diff = pos - iter-&gt;pos;
+		if (WARN_ON_ONCE(pos_diff + plen &gt; length))
 			return -EIO;
 
+		ret = iomap_iter_advance(iter, pos_diff);
+		if (ret)
+			return ret;
+
 		if (plen == 0)
-			return iomap_iter_advance(iter, count);
+			return 0;
 
 		/* zero post-eof blocks as the page may be mapped */
 		if (iomap_block_needs_zeroing(iter, pos)) {
@@ -503,13 +508,13 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
 			if (!*bytes_pending)
 				iomap_read_init(folio);
 			*bytes_pending += plen;
-			iomap_bio_read_folio_range(iter, ctx, pos, plen);
+			iomap_bio_read_folio_range(iter, ctx, plen);
 		}
 
-		ret = iomap_iter_advance(iter, count);
+		ret = iomap_iter_advance(iter, plen);
 		if (ret)
 			return ret;
-		length -= count;
+		length -= pos_diff + plen;
 		pos = iter-&gt;pos;
 	}
 	return 0;
-- 
2.47.3



---

Add caller-provided callbacks for read and readahead so that it can be
used generically, especially by filesystems that are not block-based.

In particular, this:
* Modifies the read and readahead interface to take in a
  struct iomap_read_folio_ctx that is publicly defined as:

  struct iomap_read_folio_ctx {
	const struct iomap_read_ops *ops;
	struct folio *cur_folio;
	struct readahead_control *rac;
	void *read_ctx;
  };

  where struct iomap_read_ops is defined as:

  struct iomap_read_ops {
      int (*read_folio_range)(const struct iomap_iter *iter,
                             struct iomap_read_folio_ctx *ctx,
                             size_t len);
      void (*read_submit)(struct iomap_read_folio_ctx *ctx);
  };

  read_folio_range() reads in the folio range and is required by the
  caller to provide. read_submit() is optional and is used for
  submitting any pending read requests.

* Modifies existing filesystems that use iomap for read and readahead to
  use the new API, through the new statically inlined helpers
  iomap_bio_read_folio() and iomap_bio_readahead(). There is no change
  in functionality for those filesystems.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
---
 .../filesystems/iomap/operations.rst          | 44 +++++++++++++
 block/fops.c                                  |  5 +-
 fs/erofs/data.c                               |  5 +-
 fs/gfs2/aops.c                                |  6 +-
 fs/iomap/buffered-io.c                        | 55 ++++++++--------
 fs/xfs/xfs_aops.c                             |  5 +-
 fs/zonefs/file.c                              |  5 +-
 include/linux/iomap.h                         | 63 ++++++++++++++++++-
 8 files changed, 149 insertions(+), 39 deletions(-)

diff --git a/Documentation/filesystems/iomap/operations.rst b/Documentation/filesystems/iomap/operations.rst
index 067ed8e14ef3..cef3c3e76e9e 100644
--- a/Documentation/filesystems/iomap/operations.rst
+++ b/Documentation/filesystems/iomap/operations.rst
@@ -135,6 +135,28 @@ These ``struct kiocb`` flags are significant for buffered I/O with iomap:
 
  * ``IOCB_DONTCACHE``: Turns on ``IOMAP_DONTCACHE``.
 
+``struct iomap_read_ops``
+--------------------------
+
+.. code-block:: c
+
+ struct iomap_read_ops {
+     int (*read_folio_range)(const struct iomap_iter *iter,
+                             struct iomap_read_folio_ctx *ctx, size_t len);
+     void (*submit_read)(struct iomap_read_folio_ctx *ctx);
+ };
+
+iomap calls these functions:
+
+  - ``read_folio_range``: Called to read in the range. This must be provided
+    by the caller. The caller is responsible for calling
+    iomap_finish_folio_read() after reading in the folio range. This should be
+    done even if an error is encountered during the read. This returns 0 on
+    success or a negative error on failure.
+
+  - ``submit_read``: Submit any pending read requests. This function is
+    optional.
+
 Internal per-Folio State
 ------------------------
 
@@ -182,6 +204,28 @@ The ``flags`` argument to ``-&gt;iomap_begin`` will be set to zero.
 The pagecache takes whatever locks it needs before calling the
 filesystem.
 
+Both ``iomap_readahead`` and ``iomap_read_folio`` pass in a ``struct
+iomap_read_folio_ctx``:
+
+.. code-block:: c
+
+ struct iomap_read_folio_ctx {
+    const struct iomap_read_ops *ops;
+    struct folio *cur_folio;
+    struct readahead_control *rac;
+    void *read_ctx;
+ };
+
+``iomap_readahead`` must set:
+ * ``ops-&gt;read_folio_range()`` and ``rac``
+
+``iomap_read_folio`` must set:
+ * ``ops-&gt;read_folio_range()`` and ``cur_folio``
+
+``ops-&gt;submit_read()`` and ``read_ctx`` are optional. ``read_ctx`` is used to
+pass in any custom data the caller needs accessible in the ops callbacks for
+fulfilling reads.
+
 Buffered Writes
 ---------------
 
diff --git a/block/fops.c b/block/fops.c
index ddbc69c0922b..a2c2391d8dfa 100644
--- a/block/fops.c
+++ b/block/fops.c
@@ -533,12 +533,13 @@ const struct address_space_operations def_blk_aops = {
 #else /* CONFIG_BUFFER_HEAD */
 static int blkdev_read_folio(struct file *file, struct folio *folio)
 {
-	return iomap_read_folio(folio, &amp;blkdev_iomap_ops);
+	iomap_bio_read_folio(folio, &amp;blkdev_iomap_ops);
+	return 0;
 }
 
 static void blkdev_readahead(struct readahead_control *rac)
 {
-	iomap_readahead(rac, &amp;blkdev_iomap_ops);
+	iomap_bio_readahead(rac, &amp;blkdev_iomap_ops);
 }
 
 static ssize_t blkdev_writeback_range(struct iomap_writepage_ctx *wpc,
diff --git a/fs/erofs/data.c b/fs/erofs/data.c
index 3b1ba571c728..be4191b33321 100644
--- a/fs/erofs/data.c
+++ b/fs/erofs/data.c
@@ -371,7 +371,8 @@ static int erofs_read_folio(struct file *file, struct folio *folio)
 {
 	trace_erofs_read_folio(folio, true);
 
-	return iomap_read_folio(folio, &amp;erofs_iomap_ops);
+	iomap_bio_read_folio(folio, &amp;erofs_iomap_ops);
+	return 0;
 }
 
 static void erofs_readahead(struct readahead_control *rac)
@@ -379,7 +380,7 @@ static void erofs_readahead(struct readahead_control *rac)
 	trace_erofs_readahead(rac-&gt;mapping-&gt;host, readahead_index(rac),
 					readahead_count(rac), true);
 
-	return iomap_readahead(rac, &amp;erofs_iomap_ops);
+	iomap_bio_readahead(rac, &amp;erofs_iomap_ops);
 }
 
 static sector_t erofs_bmap(struct address_space *mapping, sector_t block)
diff --git a/fs/gfs2/aops.c b/fs/gfs2/aops.c
index 47d74afd63ac..38d4f343187a 100644
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@ -424,11 +424,11 @@ static int gfs2_read_folio(struct file *file, struct folio *folio)
 	struct inode *inode = folio-&gt;mapping-&gt;host;
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
-	int error;
+	int error = 0;
 
 	if (!gfs2_is_jdata(ip) ||
 	    (i_blocksize(inode) == PAGE_SIZE &amp;&amp; !folio_buffers(folio))) {
-		error = iomap_read_folio(folio, &amp;gfs2_iomap_ops);
+		iomap_bio_read_folio(folio, &amp;gfs2_iomap_ops);
 	} else if (gfs2_is_stuffed(ip)) {
 		error = stuffed_read_folio(ip, folio);
 	} else {
@@ -503,7 +503,7 @@ static void gfs2_readahead(struct readahead_control *rac)
 	else if (gfs2_is_jdata(ip))
 		mpage_readahead(rac, gfs2_block_map);
 	else
-		iomap_readahead(rac, &amp;gfs2_iomap_ops);
+		iomap_bio_readahead(rac, &amp;gfs2_iomap_ops);
 }
 
 /**
diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 82bdf7c5e03c..9e1f1f0f8bf1 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -328,8 +328,8 @@ static int iomap_read_inline_data(const struct iomap_iter *iter,
 }
 
 #ifdef CONFIG_BLOCK
-static void iomap_finish_folio_read(struct folio *folio, size_t off,
-		size_t len, int error)
+void iomap_finish_folio_read(struct folio *folio, size_t off, size_t len,
+		int error)
 {
 	struct iomap_folio_state *ifs = folio-&gt;private;
 	bool uptodate = !error;
@@ -349,6 +349,7 @@ static void iomap_finish_folio_read(struct folio *folio, size_t off,
 	if (finished)
 		folio_end_read(folio, uptodate);
 }
+EXPORT_SYMBOL_GPL(iomap_finish_folio_read);
 
 static void iomap_read_end_io(struct bio *bio)
 {
@@ -360,12 +361,6 @@ static void iomap_read_end_io(struct bio *bio)
 	bio_put(bio);
 }
 
-struct iomap_read_folio_ctx {
-	struct folio		*cur_folio;
-	void			*read_ctx;
-	struct readahead_control *rac;
-};
-
 static void iomap_bio_submit_read(struct iomap_read_folio_ctx *ctx)
 {
 	struct bio *bio = ctx-&gt;read_ctx;
@@ -374,7 +369,7 @@ static void iomap_bio_submit_read(struct iomap_read_folio_ctx *ctx)
 		submit_bio(bio);
 }
 
-static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
+static int iomap_bio_read_folio_range(const struct iomap_iter *iter,
 		struct iomap_read_folio_ctx *ctx, size_t plen)
 {
 	struct folio *folio = ctx-&gt;cur_folio;
@@ -412,8 +407,15 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
 		bio_add_folio_nofail(bio, folio, plen, poff);
 		ctx-&gt;read_ctx = bio;
 	}
+	return 0;
 }
 
+const struct iomap_read_ops iomap_bio_read_ops = {
+	.read_folio_range	= iomap_bio_read_folio_range,
+	.submit_read		= iomap_bio_submit_read,
+};
+EXPORT_SYMBOL_GPL(iomap_bio_read_ops);
+
 static void iomap_read_init(struct folio *folio)
 {
 	struct iomap_folio_state *ifs = folio-&gt;private;
@@ -508,7 +510,9 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
 			if (!*bytes_pending)
 				iomap_read_init(folio);
 			*bytes_pending += plen;
-			iomap_bio_read_folio_range(iter, ctx, plen);
+			ret = ctx-&gt;ops-&gt;read_folio_range(iter, ctx, plen);
+			if (ret)
+				return ret;
 		}
 
 		ret = iomap_iter_advance(iter, plen);
@@ -520,26 +524,25 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
 	return 0;
 }
 
-int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
+int iomap_read_folio(const struct iomap_ops *ops,
+		struct iomap_read_folio_ctx *ctx)
 {
+	struct folio *folio = ctx-&gt;cur_folio;
 	struct iomap_iter iter = {
 		.inode		= folio-&gt;mapping-&gt;host,
 		.pos		= folio_pos(folio),
 		.len		= folio_size(folio),
 	};
-	struct iomap_read_folio_ctx ctx = {
-		.cur_folio	= folio,
-	};
 	size_t bytes_pending = 0;
 	int ret;
 
 	trace_iomap_readpage(iter.inode, 1);
 
 	while ((ret = iomap_iter(&amp;iter, ops)) &gt; 0)
-		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx,
-				&amp;bytes_pending);
+		iter.status = iomap_read_folio_iter(&amp;iter, ctx, &amp;bytes_pending);
 
-	iomap_bio_submit_read(&amp;ctx);
+	if (ctx-&gt;ops-&gt;submit_read)
+		ctx-&gt;ops-&gt;submit_read(ctx);
 
 	iomap_read_end(folio, bytes_pending);
 
@@ -579,8 +582,8 @@ static int iomap_readahead_iter(struct iomap_iter *iter,
 
 /**
  * iomap_readahead - Attempt to read pages from a file.
- * @rac: Describes the pages to be read.
  * @ops: The operations vector for the filesystem.
+ * @ctx: The ctx used for issuing readahead.
  *
  * This function is for filesystems to call to implement their readahead
  * address_space operation.
@@ -592,28 +595,28 @@ static int iomap_readahead_iter(struct iomap_iter *iter,
  * function is called with memalloc_nofs set, so allocations will not cause
  * the filesystem to be reentered.
  */
-void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
+void iomap_readahead(const struct iomap_ops *ops,
+		struct iomap_read_folio_ctx *ctx)
 {
+	struct readahead_control *rac = ctx-&gt;rac;
 	struct iomap_iter iter = {
 		.inode	= rac-&gt;mapping-&gt;host,
 		.pos	= readahead_pos(rac),
 		.len	= readahead_length(rac),
 	};
-	struct iomap_read_folio_ctx ctx = {
-		.rac	= rac,
-	};
 	size_t cur_bytes_pending;
 
 	trace_iomap_readahead(rac-&gt;mapping-&gt;host, readahead_count(rac));
 
 	while (iomap_iter(&amp;iter, ops) &gt; 0)
-		iter.status = iomap_readahead_iter(&amp;iter, &amp;ctx,
+		iter.status = iomap_readahead_iter(&amp;iter, ctx,
 					&amp;cur_bytes_pending);
 
-	iomap_bio_submit_read(&amp;ctx);
+	if (ctx-&gt;ops-&gt;submit_read)
+		ctx-&gt;ops-&gt;submit_read(ctx);
 
-	if (ctx.cur_folio)
-		iomap_read_end(ctx.cur_folio, cur_bytes_pending);
+	if (ctx-&gt;cur_folio)
+		iomap_read_end(ctx-&gt;cur_folio, cur_bytes_pending);
 }
 EXPORT_SYMBOL_GPL(iomap_readahead);
 
diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
index a26f79815533..0c2ed00733f2 100644
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@ -742,14 +742,15 @@ xfs_vm_read_folio(
 	struct file		*unused,
 	struct folio		*folio)
 {
-	return iomap_read_folio(folio, &amp;xfs_read_iomap_ops);
+	iomap_bio_read_folio(folio, &amp;xfs_read_iomap_ops);
+	return 0;
 }
 
 STATIC void
 xfs_vm_readahead(
 	struct readahead_control	*rac)
 {
-	iomap_readahead(rac, &amp;xfs_read_iomap_ops);
+	iomap_bio_readahead(rac, &amp;xfs_read_iomap_ops);
 }
 
 static int
diff --git a/fs/zonefs/file.c b/fs/zonefs/file.c
index fd3a5922f6c3..4d6e7eb52966 100644
--- a/fs/zonefs/file.c
+++ b/fs/zonefs/file.c
@@ -112,12 +112,13 @@ static const struct iomap_ops zonefs_write_iomap_ops = {
 
 static int zonefs_read_folio(struct file *unused, struct folio *folio)
 {
-	return iomap_read_folio(folio, &amp;zonefs_read_iomap_ops);
+	iomap_bio_read_folio(folio, &amp;zonefs_read_iomap_ops);
+	return 0;
 }
 
 static void zonefs_readahead(struct readahead_control *rac)
 {
-	iomap_readahead(rac, &amp;zonefs_read_iomap_ops);
+	iomap_bio_readahead(rac, &amp;zonefs_read_iomap_ops);
 }
 
 /*
diff --git a/include/linux/iomap.h b/include/linux/iomap.h
index 4469b2318b08..37435b912755 100644
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@ -16,6 +16,7 @@ struct inode;
 struct iomap_iter;
 struct iomap_dio;
 struct iomap_writepage_ctx;
+struct iomap_read_folio_ctx;
 struct iov_iter;
 struct kiocb;
 struct page;
@@ -337,8 +338,10 @@ static inline bool iomap_want_unshare_iter(const struct iomap_iter *iter)
 ssize_t iomap_file_buffered_write(struct kiocb *iocb, struct iov_iter *from,
 		const struct iomap_ops *ops,
 		const struct iomap_write_ops *write_ops, void *private);
-int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops);
-void iomap_readahead(struct readahead_control *, const struct iomap_ops *ops);
+int iomap_read_folio(const struct iomap_ops *ops,
+		struct iomap_read_folio_ctx *ctx);
+void iomap_readahead(const struct iomap_ops *ops,
+		struct iomap_read_folio_ctx *ctx);
 bool iomap_is_partially_uptodate(struct folio *, size_t from, size_t count);
 struct folio *iomap_get_folio(struct iomap_iter *iter, loff_t pos, size_t len);
 bool iomap_release_folio(struct folio *folio, gfp_t gfp_flags);
@@ -465,6 +468,8 @@ ssize_t iomap_add_to_ioend(struct iomap_writepage_ctx *wpc, struct folio *folio,
 		loff_t pos, loff_t end_pos, unsigned int dirty_len);
 int iomap_ioend_writeback_submit(struct iomap_writepage_ctx *wpc, int error);
 
+void iomap_finish_folio_read(struct folio *folio, size_t off, size_t len,
+		int error);
 void iomap_start_folio_write(struct inode *inode, struct folio *folio,
 		size_t len);
 void iomap_finish_folio_write(struct inode *inode, struct folio *folio,
@@ -473,6 +478,34 @@ void iomap_finish_folio_write(struct inode *inode, struct folio *folio,
 int iomap_writeback_folio(struct iomap_writepage_ctx *wpc, struct folio *folio);
 int iomap_writepages(struct iomap_writepage_ctx *wpc);
 
+struct iomap_read_folio_ctx {
+	const struct iomap_read_ops *ops;
+	struct folio		*cur_folio;
+	struct readahead_control *rac;
+	void			*read_ctx;
+};
+
+struct iomap_read_ops {
+	/*
+	 * Read in a folio range.
+	 *
+	 * The caller is responsible for calling iomap_finish_folio_read() after
+	 * reading in the folio range. This should be done even if an error is
+	 * encountered during the read.
+	 *
+	 * Returns 0 on success or a negative error on failure.
+	 */
+	int (*read_folio_range)(const struct iomap_iter *iter,
+			struct iomap_read_folio_ctx *ctx, size_t len);
+
+	/*
+	 * Submit any pending read requests.
+	 *
+	 * This is optional.
+	 */
+	void (*submit_read)(struct iomap_read_folio_ctx *ctx);
+};
+
 /*
  * Flags for direct I/O -&gt;end_io:
  */
@@ -538,4 +571,30 @@ int iomap_swapfile_activate(struct swap_info_struct *sis,
 
 extern struct bio_set iomap_ioend_bioset;
 
+#ifdef CONFIG_BLOCK
+extern const struct iomap_read_ops iomap_bio_read_ops;
+
+static inline void iomap_bio_read_folio(struct folio *folio,
+		const struct iomap_ops *ops)
+{
+	struct iomap_read_folio_ctx ctx = {
+		.ops		= &amp;iomap_bio_read_ops,
+		.cur_folio	= folio,
+	};
+
+	iomap_read_folio(ops, &amp;ctx);
+}
+
+static inline void iomap_bio_readahead(struct readahead_control *rac,
+		const struct iomap_ops *ops)
+{
+	struct iomap_read_folio_ctx ctx = {
+		.ops		= &amp;iomap_bio_read_ops,
+		.rac		= rac,
+	};
+
+	iomap_readahead(ops, &amp;ctx);
+}
+#endif /* CONFIG_BLOCK */
+
 #endif /* LINUX_IOMAP_H */
-- 
2.47.3



---

From: Christoph Hellwig &lt;hch@lst.de&gt; [1]

Move bio logic in the buffered io code into its own file and remove
CONFIG_BLOCK gating for iomap read/readahead.

[1] https://lore.kernel.org/linux-fsdevel/aMK2GuumUf93ep99@infradead.org/

Signed-off-by: Christoph Hellwig &lt;hch@lst.de&gt;
Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/iomap/Makefile      |  3 +-
 fs/iomap/bio.c         | 88 ++++++++++++++++++++++++++++++++++++++++++
 fs/iomap/buffered-io.c | 88 +-----------------------------------------
 fs/iomap/internal.h    | 12 ++++++
 4 files changed, 103 insertions(+), 88 deletions(-)
 create mode 100644 fs/iomap/bio.c

diff --git a/fs/iomap/Makefile b/fs/iomap/Makefile
index f7e1c8534c46..a572b8808524 100644
--- a/fs/iomap/Makefile
+++ b/fs/iomap/Makefile
@@ -14,5 +14,6 @@ iomap-y				+= trace.o \
 iomap-$(CONFIG_BLOCK)		+= direct-io.o \
 				   ioend.o \
 				   fiemap.o \
-				   seek.o
+				   seek.o \
+				   bio.o
 iomap-$(CONFIG_SWAP)		+= swapfile.o
diff --git a/fs/iomap/bio.c b/fs/iomap/bio.c
new file mode 100644
index 000000000000..fc045f2e4c45
--- /dev/null
+++ b/fs/iomap/bio.c
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2010 Red Hat, Inc.
+ * Copyright (C) 2016-2023 Christoph Hellwig.
+ */
+#include &lt;linux/iomap.h&gt;
+#include &lt;linux/pagemap.h&gt;
+#include &quot;internal.h&quot;
+#include &quot;trace.h&quot;
+
+static void iomap_read_end_io(struct bio *bio)
+{
+	int error = blk_status_to_errno(bio-&gt;bi_status);
+	struct folio_iter fi;
+
+	bio_for_each_folio_all(fi, bio)
+		iomap_finish_folio_read(fi.folio, fi.offset, fi.length, error);
+	bio_put(bio);
+}
+
+static void iomap_bio_submit_read(struct iomap_read_folio_ctx *ctx)
+{
+	struct bio *bio = ctx-&gt;read_ctx;
+
+	if (bio)
+		submit_bio(bio);
+}
+
+static int iomap_bio_read_folio_range(const struct iomap_iter *iter,
+		struct iomap_read_folio_ctx *ctx, size_t plen)
+{
+	struct folio *folio = ctx-&gt;cur_folio;
+	const struct iomap *iomap = &amp;iter-&gt;iomap;
+	loff_t pos = iter-&gt;pos;
+	size_t poff = offset_in_folio(folio, pos);
+	loff_t length = iomap_length(iter);
+	sector_t sector;
+	struct bio *bio = ctx-&gt;read_ctx;
+
+	sector = iomap_sector(iomap, pos);
+	if (!bio || bio_end_sector(bio) != sector ||
+	    !bio_add_folio(bio, folio, plen, poff)) {
+		gfp_t gfp = mapping_gfp_constraint(folio-&gt;mapping, GFP_KERNEL);
+		gfp_t orig_gfp = gfp;
+		unsigned int nr_vecs = DIV_ROUND_UP(length, PAGE_SIZE);
+
+		if (bio)
+			submit_bio(bio);
+
+		if (ctx-&gt;rac) /* same as readahead_gfp_mask */
+			gfp |= __GFP_NORETRY | __GFP_NOWARN;
+		bio = bio_alloc(iomap-&gt;bdev, bio_max_segs(nr_vecs), REQ_OP_READ,
+				     gfp);
+		/*
+		 * If the bio_alloc fails, try it again for a single page to
+		 * avoid having to deal with partial page reads.  This emulates
+		 * what do_mpage_read_folio does.
+		 */
+		if (!bio)
+			bio = bio_alloc(iomap-&gt;bdev, 1, REQ_OP_READ, orig_gfp);
+		if (ctx-&gt;rac)
+			bio-&gt;bi_opf |= REQ_RAHEAD;
+		bio-&gt;bi_iter.bi_sector = sector;
+		bio-&gt;bi_end_io = iomap_read_end_io;
+		bio_add_folio_nofail(bio, folio, plen, poff);
+		ctx-&gt;read_ctx = bio;
+	}
+	return 0;
+}
+
+const struct iomap_read_ops iomap_bio_read_ops = {
+	.read_folio_range = iomap_bio_read_folio_range,
+	.submit_read = iomap_bio_submit_read,
+};
+EXPORT_SYMBOL_GPL(iomap_bio_read_ops);
+
+int iomap_bio_read_folio_range_sync(const struct iomap_iter *iter,
+		struct folio *folio, loff_t pos, size_t len)
+{
+	const struct iomap *srcmap = iomap_iter_srcmap(iter);
+	struct bio_vec bvec;
+	struct bio bio;
+
+	bio_init(&amp;bio, srcmap-&gt;bdev, &amp;bvec, 1, REQ_OP_READ);
+	bio.bi_iter.bi_sector = iomap_sector(srcmap, pos);
+	bio_add_folio_nofail(&amp;bio, folio, len, offset_in_folio(folio, pos));
+	return submit_bio_wait(&amp;bio);
+}
diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 9e1f1f0f8bf1..86c8094e5cc8 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -8,6 +8,7 @@
 #include &lt;linux/writeback.h&gt;
 #include &lt;linux/swap.h&gt;
 #include &lt;linux/migrate.h&gt;
+#include &quot;internal.h&quot;
 #include &quot;trace.h&quot;
 
 #include &quot;../internal.h&quot;
@@ -327,7 +328,6 @@ static int iomap_read_inline_data(const struct iomap_iter *iter,
 	return 0;
 }
 
-#ifdef CONFIG_BLOCK
 void iomap_finish_folio_read(struct folio *folio, size_t off, size_t len,
 		int error)
 {
@@ -351,71 +351,6 @@ void iomap_finish_folio_read(struct folio *folio, size_t off, size_t len,
 }
 EXPORT_SYMBOL_GPL(iomap_finish_folio_read);
 
-static void iomap_read_end_io(struct bio *bio)
-{
-	int error = blk_status_to_errno(bio-&gt;bi_status);
-	struct folio_iter fi;
-
-	bio_for_each_folio_all(fi, bio)
-		iomap_finish_folio_read(fi.folio, fi.offset, fi.length, error);
-	bio_put(bio);
-}
-
-static void iomap_bio_submit_read(struct iomap_read_folio_ctx *ctx)
-{
-	struct bio *bio = ctx-&gt;read_ctx;
-
-	if (bio)
-		submit_bio(bio);
-}
-
-static int iomap_bio_read_folio_range(const struct iomap_iter *iter,
-		struct iomap_read_folio_ctx *ctx, size_t plen)
-{
-	struct folio *folio = ctx-&gt;cur_folio;
-	const struct iomap *iomap = &amp;iter-&gt;iomap;
-	loff_t pos = iter-&gt;pos;
-	size_t poff = offset_in_folio(folio, pos);
-	loff_t length = iomap_length(iter);
-	sector_t sector;
-	struct bio *bio = ctx-&gt;read_ctx;
-
-	sector = iomap_sector(iomap, pos);
-	if (!bio || bio_end_sector(bio) != sector ||
-	    !bio_add_folio(bio, folio, plen, poff)) {
-		gfp_t gfp = mapping_gfp_constraint(folio-&gt;mapping, GFP_KERNEL);
-		gfp_t orig_gfp = gfp;
-		unsigned int nr_vecs = DIV_ROUND_UP(length, PAGE_SIZE);
-
-		iomap_bio_submit_read(ctx);
-
-		if (ctx-&gt;rac) /* same as readahead_gfp_mask */
-			gfp |= __GFP_NORETRY | __GFP_NOWARN;
-		bio = bio_alloc(iomap-&gt;bdev, bio_max_segs(nr_vecs), REQ_OP_READ,
-				     gfp);
-		/*
-		 * If the bio_alloc fails, try it again for a single page to
-		 * avoid having to deal with partial page reads.  This emulates
-		 * what do_mpage_read_folio does.
-		 */
-		if (!bio)
-			bio = bio_alloc(iomap-&gt;bdev, 1, REQ_OP_READ, orig_gfp);
-		if (ctx-&gt;rac)
-			bio-&gt;bi_opf |= REQ_RAHEAD;
-		bio-&gt;bi_iter.bi_sector = sector;
-		bio-&gt;bi_end_io = iomap_read_end_io;
-		bio_add_folio_nofail(bio, folio, plen, poff);
-		ctx-&gt;read_ctx = bio;
-	}
-	return 0;
-}
-
-const struct iomap_read_ops iomap_bio_read_ops = {
-	.read_folio_range	= iomap_bio_read_folio_range,
-	.submit_read		= iomap_bio_submit_read,
-};
-EXPORT_SYMBOL_GPL(iomap_bio_read_ops);
-
 static void iomap_read_init(struct folio *folio)
 {
 	struct iomap_folio_state *ifs = folio-&gt;private;
@@ -620,27 +555,6 @@ void iomap_readahead(const struct iomap_ops *ops,
 }
 EXPORT_SYMBOL_GPL(iomap_readahead);
 
-static int iomap_bio_read_folio_range_sync(const struct iomap_iter *iter,
-		struct folio *folio, loff_t pos, size_t len)
-{
-	const struct iomap *srcmap = iomap_iter_srcmap(iter);
-	struct bio_vec bvec;
-	struct bio bio;
-
-	bio_init(&amp;bio, srcmap-&gt;bdev, &amp;bvec, 1, REQ_OP_READ);
-	bio.bi_iter.bi_sector = iomap_sector(srcmap, pos);
-	bio_add_folio_nofail(&amp;bio, folio, len, offset_in_folio(folio, pos));
-	return submit_bio_wait(&amp;bio);
-}
-#else
-static int iomap_bio_read_folio_range_sync(const struct iomap_iter *iter,
-		struct folio *folio, loff_t pos, size_t len)
-{
-	WARN_ON_ONCE(1);
-	return -EIO;
-}
-#endif /* CONFIG_BLOCK */
-
 /*
  * iomap_is_partially_uptodate checks whether blocks within a folio are
  * uptodate or not.
diff --git a/fs/iomap/internal.h b/fs/iomap/internal.h
index d05cb3aed96e..3a4e4aad2bd1 100644
--- a/fs/iomap/internal.h
+++ b/fs/iomap/internal.h
@@ -6,4 +6,16 @@
 
 u32 iomap_finish_ioend_direct(struct iomap_ioend *ioend);
 
+#ifdef CONFIG_BLOCK
+int iomap_bio_read_folio_range_sync(const struct iomap_iter *iter,
+		struct folio *folio, loff_t pos, size_t len);
+#else
+static inline int iomap_bio_read_folio_range_sync(const struct iomap_iter *iter,
+		struct folio *folio, loff_t pos, size_t len)
+{
+	WARN_ON_ONCE(1);
+	return -EIO;
+}
+#endif /* CONFIG_BLOCK */
+
 #endif /* _IOMAP_INTERNAL_H */
-- 
2.47.3



---

No errors are propagated in iomap_read_folio(). Change
iomap_read_folio() to a void return to make this clearer to callers.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/iomap/buffered-io.c | 9 +--------
 include/linux/iomap.h  | 2 +-
 2 files changed, 2 insertions(+), 9 deletions(-)

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 86c8094e5cc8..f9ae72713f74 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -459,7 +459,7 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
 	return 0;
 }
 
-int iomap_read_folio(const struct iomap_ops *ops,
+void iomap_read_folio(const struct iomap_ops *ops,
 		struct iomap_read_folio_ctx *ctx)
 {
 	struct folio *folio = ctx-&gt;cur_folio;
@@ -480,13 +480,6 @@ int iomap_read_folio(const struct iomap_ops *ops,
 		ctx-&gt;ops-&gt;submit_read(ctx);
 
 	iomap_read_end(folio, bytes_pending);
-
-	/*
-	 * Just like mpage_readahead and block_read_full_folio, we always
-	 * return 0 and just set the folio error flag on errors.  This
-	 * should be cleaned up throughout the stack eventually.
-	 */
-	return 0;
 }
 EXPORT_SYMBOL_GPL(iomap_read_folio);
 
diff --git a/include/linux/iomap.h b/include/linux/iomap.h
index 37435b912755..6d864b446b6e 100644
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@ -338,7 +338,7 @@ static inline bool iomap_want_unshare_iter(const struct iomap_iter *iter)
 ssize_t iomap_file_buffered_write(struct kiocb *iocb, struct iov_iter *from,
 		const struct iomap_ops *ops,
 		const struct iomap_write_ops *write_ops, void *private);
-int iomap_read_folio(const struct iomap_ops *ops,
+void iomap_read_folio(const struct iomap_ops *ops,
 		struct iomap_read_folio_ctx *ctx);
 void iomap_readahead(const struct iomap_ops *ops,
 		struct iomap_read_folio_ctx *ctx);
-- 
2.47.3



---

Read folio data into the page cache using iomap. This gives us granular
uptodate tracking for large folios, which optimizes how much data needs
to be read in. If some portions of the folio are already uptodate (eg
through a prior write), we only need to read in the non-uptodate
portions.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/fuse/file.c | 80 +++++++++++++++++++++++++++++++++++---------------
 1 file changed, 56 insertions(+), 24 deletions(-)

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 4adcf09d4b01..db93c83ee4a3 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -828,23 +828,69 @@ static int fuse_do_readfolio(struct file *file, struct folio *folio,
 	return 0;
 }
 
+static int fuse_iomap_begin(struct inode *inode, loff_t offset, loff_t length,
+			    unsigned int flags, struct iomap *iomap,
+			    struct iomap *srcmap)
+{
+	iomap-&gt;type = IOMAP_MAPPED;
+	iomap-&gt;length = length;
+	iomap-&gt;offset = offset;
+	return 0;
+}
+
+static const struct iomap_ops fuse_iomap_ops = {
+	.iomap_begin	= fuse_iomap_begin,
+};
+
+struct fuse_fill_read_data {
+	struct file *file;
+};
+
+static int fuse_iomap_read_folio_range_async(const struct iomap_iter *iter,
+					     struct iomap_read_folio_ctx *ctx,
+					     size_t len)
+{
+	struct fuse_fill_read_data *data = ctx-&gt;read_ctx;
+	struct folio *folio = ctx-&gt;cur_folio;
+	loff_t pos =  iter-&gt;pos;
+	size_t off = offset_in_folio(folio, pos);
+	struct file *file = data-&gt;file;
+	int ret;
+
+	/*
+	 *  for non-readahead read requests, do reads synchronously since
+	 *  it&#x27;s not guaranteed that the server can handle out-of-order reads
+	 */
+	ret = fuse_do_readfolio(file, folio, off, len);
+	iomap_finish_folio_read(folio, off, len, ret);
+	return ret;
+}
+
+static const struct iomap_read_ops fuse_iomap_read_ops = {
+	.read_folio_range = fuse_iomap_read_folio_range_async,
+};
+
 static int fuse_read_folio(struct file *file, struct folio *folio)
 {
 	struct inode *inode = folio-&gt;mapping-&gt;host;
-	int err;
+	struct fuse_fill_read_data data = {
+		.file = file,
+	};
+	struct iomap_read_folio_ctx ctx = {
+		.cur_folio = folio,
+		.ops = &amp;fuse_iomap_read_ops,
+		.read_ctx = &amp;data,
 
-	err = -EIO;
-	if (fuse_is_bad(inode))
-		goto out;
+	};
 
-	err = fuse_do_readfolio(file, folio, 0, folio_size(folio));
-	if (!err)
-		folio_mark_uptodate(folio);
+	if (fuse_is_bad(inode)) {
+		folio_unlock(folio);
+		return -EIO;
+	}
 
+	iomap_read_folio(&amp;fuse_iomap_ops, &amp;ctx);
 	fuse_invalidate_atime(inode);
- out:
-	folio_unlock(folio);
-	return err;
+	return 0;
 }
 
 static int fuse_iomap_read_folio_range(const struct iomap_iter *iter,
@@ -1394,20 +1440,6 @@ static const struct iomap_write_ops fuse_iomap_write_ops = {
 	.read_folio_range = fuse_iomap_read_folio_range,
 };
 
-static int fuse_iomap_begin(struct inode *inode, loff_t offset, loff_t length,
-			    unsigned int flags, struct iomap *iomap,
-			    struct iomap *srcmap)
-{
-	iomap-&gt;type = IOMAP_MAPPED;
-	iomap-&gt;length = length;
-	iomap-&gt;offset = offset;
-	return 0;
-}
-
-static const struct iomap_ops fuse_iomap_ops = {
-	.iomap_begin	= fuse_iomap_begin,
-};
-
 static ssize_t fuse_cache_write_iter(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *file = iocb-&gt;ki_filp;
-- 
2.47.3



---

Do readahead in fuse using iomap. This gives us granular uptodate
tracking for large folios, which optimizes how much data needs to be
read in. If some portions of the folio are already uptodate (eg through
a prior write), we only need to read in the non-uptodate portions.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/fuse/file.c | 220 ++++++++++++++++++++++++++++---------------------
 1 file changed, 124 insertions(+), 96 deletions(-)

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index db93c83ee4a3..7c9c00784e33 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -844,8 +844,65 @@ static const struct iomap_ops fuse_iomap_ops = {
 
 struct fuse_fill_read_data {
 	struct file *file;
+
+	/* Fields below are used if sending the read request asynchronously */
+	struct fuse_conn *fc;
+	struct fuse_io_args *ia;
+	unsigned int nr_bytes;
 };
 
+/* forward declarations */
+static bool fuse_folios_need_send(struct fuse_conn *fc, loff_t pos,
+				  unsigned len, struct fuse_args_pages *ap,
+				  unsigned cur_bytes, bool write);
+static void fuse_send_readpages(struct fuse_io_args *ia, struct file *file,
+				unsigned int count, bool async);
+
+static int fuse_handle_readahead(struct folio *folio,
+				 struct readahead_control *rac,
+				 struct fuse_fill_read_data *data, loff_t pos,
+				 size_t len)
+{
+	struct fuse_io_args *ia = data-&gt;ia;
+	size_t off = offset_in_folio(folio, pos);
+	struct fuse_conn *fc = data-&gt;fc;
+	struct fuse_args_pages *ap;
+	unsigned int nr_pages;
+
+	if (ia &amp;&amp; fuse_folios_need_send(fc, pos, len, &amp;ia-&gt;ap, data-&gt;nr_bytes,
+					false)) {
+		fuse_send_readpages(ia, data-&gt;file, data-&gt;nr_bytes,
+				    fc-&gt;async_read);
+		data-&gt;nr_bytes = 0;
+		data-&gt;ia = NULL;
+		ia = NULL;
+	}
+	if (!ia) {
+		if (fc-&gt;num_background &gt;= fc-&gt;congestion_threshold &amp;&amp;
+		    rac-&gt;ra-&gt;async_size &gt;= readahead_count(rac))
+			/*
+			 * Congested and only async pages left, so skip the
+			 * rest.
+			 */
+			return -EAGAIN;
+
+		nr_pages = min(fc-&gt;max_pages, readahead_count(rac));
+		data-&gt;ia = fuse_io_alloc(NULL, nr_pages);
+		if (!data-&gt;ia)
+			return -ENOMEM;
+		ia = data-&gt;ia;
+	}
+	folio_get(folio);
+	ap = &amp;ia-&gt;ap;
+	ap-&gt;folios[ap-&gt;num_folios] = folio;
+	ap-&gt;descs[ap-&gt;num_folios].offset = off;
+	ap-&gt;descs[ap-&gt;num_folios].length = len;
+	data-&gt;nr_bytes += len;
+	ap-&gt;num_folios++;
+
+	return 0;
+}
+
 static int fuse_iomap_read_folio_range_async(const struct iomap_iter *iter,
 					     struct iomap_read_folio_ctx *ctx,
 					     size_t len)
@@ -857,17 +914,39 @@ static int fuse_iomap_read_folio_range_async(const struct iomap_iter *iter,
 	struct file *file = data-&gt;file;
 	int ret;
 
-	/*
-	 *  for non-readahead read requests, do reads synchronously since
-	 *  it&#x27;s not guaranteed that the server can handle out-of-order reads
-	 */
-	ret = fuse_do_readfolio(file, folio, off, len);
-	iomap_finish_folio_read(folio, off, len, ret);
+	if (ctx-&gt;rac) {
+		ret = fuse_handle_readahead(folio, ctx-&gt;rac, data, pos, len);
+		/*
+		 * If fuse_handle_readahead was successful, fuse_readpages_end
+		 * will do the iomap_finish_folio_read, else we need to call it
+		 * here
+		 */
+		if (ret)
+			iomap_finish_folio_read(folio, off, len, ret);
+	} else {
+		/*
+		 *  for non-readahead read requests, do reads synchronously
+		 *  since it&#x27;s not guaranteed that the server can handle
+		 *  out-of-order reads
+		 */
+		ret = fuse_do_readfolio(file, folio, off, len);
+		iomap_finish_folio_read(folio, off, len, ret);
+	}
 	return ret;
 }
 
+static void fuse_iomap_read_submit(struct iomap_read_folio_ctx *ctx)
+{
+	struct fuse_fill_read_data *data = ctx-&gt;read_ctx;
+
+	if (data-&gt;ia)
+		fuse_send_readpages(data-&gt;ia, data-&gt;file, data-&gt;nr_bytes,
+				    data-&gt;fc-&gt;async_read);
+}
+
 static const struct iomap_read_ops fuse_iomap_read_ops = {
 	.read_folio_range = fuse_iomap_read_folio_range_async,
+	.submit_read = fuse_iomap_read_submit,
 };
 
 static int fuse_read_folio(struct file *file, struct folio *folio)
@@ -929,7 +1008,8 @@ static void fuse_readpages_end(struct fuse_mount *fm, struct fuse_args *args,
 	}
 
 	for (i = 0; i &lt; ap-&gt;num_folios; i++) {
-		folio_end_read(ap-&gt;folios[i], !err);
+		iomap_finish_folio_read(ap-&gt;folios[i], ap-&gt;descs[i].offset,
+					ap-&gt;descs[i].length, err);
 		folio_put(ap-&gt;folios[i]);
 	}
 	if (ia-&gt;ff)
@@ -939,7 +1019,7 @@ static void fuse_readpages_end(struct fuse_mount *fm, struct fuse_args *args,
 }
 
 static void fuse_send_readpages(struct fuse_io_args *ia, struct file *file,
-				unsigned int count)
+				unsigned int count, bool async)
 {
 	struct fuse_file *ff = file-&gt;private_data;
 	struct fuse_mount *fm = ff-&gt;fm;
@@ -961,7 +1041,7 @@ static void fuse_send_readpages(struct fuse_io_args *ia, struct file *file,
 
 	fuse_read_args_fill(ia, file, pos, count, FUSE_READ);
 	ia-&gt;read.attr_ver = fuse_get_attr_version(fm-&gt;fc);
-	if (fm-&gt;fc-&gt;async_read) {
+	if (async) {
 		ia-&gt;ff = fuse_file_get(ff);
 		ap-&gt;args.end = fuse_readpages_end;
 		err = fuse_simple_background(fm, &amp;ap-&gt;args, GFP_KERNEL);
@@ -978,81 +1058,20 @@ static void fuse_readahead(struct readahead_control *rac)
 {
 	struct inode *inode = rac-&gt;mapping-&gt;host;
 	struct fuse_conn *fc = get_fuse_conn(inode);
-	unsigned int max_pages, nr_pages;
-	struct folio *folio = NULL;
+	struct fuse_fill_read_data data = {
+		.file = rac-&gt;file,
+		.fc = fc,
+	};
+	struct iomap_read_folio_ctx ctx = {
+		.ops = &amp;fuse_iomap_read_ops,
+		.rac = rac,
+		.read_ctx = &amp;data
+	};
 
 	if (fuse_is_bad(inode))
 		return;
 
-	max_pages = min_t(unsigned int, fc-&gt;max_pages,
-			fc-&gt;max_read / PAGE_SIZE);
-
-	/*
-	 * This is only accurate the first time through, since readahead_folio()
-	 * doesn&#x27;t update readahead_count() from the previous folio until the
-	 * next call.  Grab nr_pages here so we know how many pages we&#x27;re going
-	 * to have to process.  This means that we will exit here with
-	 * readahead_count() == folio_nr_pages(last_folio), but we will have
-	 * consumed all of the folios, and read_pages() will call
-	 * readahead_folio() again which will clean up the rac.
-	 */
-	nr_pages = readahead_count(rac);
-
-	while (nr_pages) {
-		struct fuse_io_args *ia;
-		struct fuse_args_pages *ap;
-		unsigned cur_pages = min(max_pages, nr_pages);
-		unsigned int pages = 0;
-
-		if (fc-&gt;num_background &gt;= fc-&gt;congestion_threshold &amp;&amp;
-		    rac-&gt;ra-&gt;async_size &gt;= readahead_count(rac))
-			/*
-			 * Congested and only async pages left, so skip the
-			 * rest.
-			 */
-			break;
-
-		ia = fuse_io_alloc(NULL, cur_pages);
-		if (!ia)
-			break;
-		ap = &amp;ia-&gt;ap;
-
-		while (pages &lt; cur_pages) {
-			unsigned int folio_pages;
-
-			/*
-			 * This returns a folio with a ref held on it.
-			 * The ref needs to be held until the request is
-			 * completed, since the splice case (see
-			 * fuse_try_move_page()) drops the ref after it&#x27;s
-			 * replaced in the page cache.
-			 */
-			if (!folio)
-				folio =  __readahead_folio(rac);
-
-			folio_pages = folio_nr_pages(folio);
-			if (folio_pages &gt; cur_pages - pages) {
-				/*
-				 * Large folios belonging to fuse will never
-				 * have more pages than max_pages.
-				 */
-				WARN_ON(!pages);
-				break;
-			}
-
-			ap-&gt;folios[ap-&gt;num_folios] = folio;
-			ap-&gt;descs[ap-&gt;num_folios].length = folio_size(folio);
-			ap-&gt;num_folios++;
-			pages += folio_pages;
-			folio = NULL;
-		}
-		fuse_send_readpages(ia, rac-&gt;file, pages &lt;&lt; PAGE_SHIFT);
-		nr_pages -= pages;
-	}
-	if (folio) {
-		folio_end_read(folio, false);
-		folio_put(folio);
-	}
+	iomap_readahead(&amp;fuse_iomap_ops, &amp;ctx);
 }
 
 static ssize_t fuse_cache_read_iter(struct kiocb *iocb, struct iov_iter *to)
@@ -2083,7 +2102,7 @@ struct fuse_fill_wb_data {
 	struct fuse_file *ff;
 	unsigned int max_folios;
 	/*
-	 * nr_bytes won&#x27;t overflow since fuse_writepage_need_send() caps
+	 * nr_bytes won&#x27;t overflow since fuse_folios_need_send() caps
 	 * wb requests to never exceed fc-&gt;max_pages (which has an upper bound
 	 * of U16_MAX).
 	 */
@@ -2128,14 +2147,15 @@ static void fuse_writepages_send(struct inode *inode,
 	spin_unlock(&amp;fi-&gt;lock);
 }
 
-static bool fuse_writepage_need_send(struct fuse_conn *fc, loff_t pos,
-				     unsigned len, struct fuse_args_pages *ap,
-				     struct fuse_fill_wb_data *data)
+static bool fuse_folios_need_send(struct fuse_conn *fc, loff_t pos,
+				  unsigned len, struct fuse_args_pages *ap,
+				  unsigned cur_bytes, bool write)
 {
 	struct folio *prev_folio;
 	struct fuse_folio_desc prev_desc;
-	unsigned bytes = data-&gt;nr_bytes + len;
+	unsigned bytes = cur_bytes + len;
 	loff_t prev_pos;
+	size_t max_bytes = write ? fc-&gt;max_write : fc-&gt;max_read;
 
 	WARN_ON(!ap-&gt;num_folios);
 
@@ -2143,8 +2163,7 @@ static bool fuse_writepage_need_send(struct fuse_conn *fc, loff_t pos,
 	if ((bytes + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT &gt; fc-&gt;max_pages)
 		return true;
 
-	/* Reached max write bytes */
-	if (bytes &gt; fc-&gt;max_write)
+	if (bytes &gt; max_bytes)
 		return true;
 
 	/* Discontinuity */
@@ -2154,11 +2173,6 @@ static bool fuse_writepage_need_send(struct fuse_conn *fc, loff_t pos,
 	if (prev_pos != pos)
 		return true;
 
-	/* Need to grow the pages array?  If so, did the expansion fail? */
-	if (ap-&gt;num_folios == data-&gt;max_folios &amp;&amp;
-	    !fuse_pages_realloc(data, fc-&gt;max_pages))
-		return true;
-
 	return false;
 }
 
@@ -2182,10 +2196,24 @@ static ssize_t fuse_iomap_writeback_range(struct iomap_writepage_ctx *wpc,
 			return -EIO;
 	}
 
-	if (wpa &amp;&amp; fuse_writepage_need_send(fc, pos, len, ap, data)) {
-		fuse_writepages_send(inode, data);
-		data-&gt;wpa = NULL;
-		data-&gt;nr_bytes = 0;
+	if (wpa) {
+		bool send = fuse_folios_need_send(fc, pos, len, ap,
+						  data-&gt;nr_bytes, true);
+
+		if (!send) {
+			/*
+			 * Need to grow the pages array?  If so, did the
+			 * expansion fail?
+			 */
+			send = (ap-&gt;num_folios == data-&gt;max_folios) &amp;&amp;
+				!fuse_pages_realloc(data, fc-&gt;max_pages);
+		}
+
+		if (send) {
+			fuse_writepages_send(inode, data);
+			data-&gt;wpa = NULL;
+			data-&gt;nr_bytes = 0;
+		}
 	}
 
 	if (data-&gt;wpa == NULL) {
-- 
2.47.3



---

Now that fuse is integrated with iomap for read/readahead, we can remove
the workaround that was added in commit bd24d2108e9c (&quot;fuse: fix fuseblk
i_blkbits for iomap partial writes&quot;), which was previously needed to
avoid a race condition where an iomap partial write may be overwritten
by a read if blocksize &lt; PAGE_SIZE. Now that fuse does iomap
read/readahead, this is protected against since there is granular
uptodate tracking of blocks, which means this workaround can be removed.

Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
Reviewed-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
---
 fs/fuse/dir.c    |  2 +-
 fs/fuse/fuse_i.h |  8 --------
 fs/fuse/inode.c  | 13 +------------
 3 files changed, 2 insertions(+), 21 deletions(-)

diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index 5c569c3cb53f..ebee7e0b1cd3 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -1199,7 +1199,7 @@ static void fuse_fillattr(struct mnt_idmap *idmap, struct inode *inode,
 	if (attr-&gt;blksize != 0)
 		blkbits = ilog2(attr-&gt;blksize);
 	else
-		blkbits = fc-&gt;blkbits;
+		blkbits = inode-&gt;i_sb-&gt;s_blocksize_bits;
 
 	stat-&gt;blksize = 1 &lt;&lt; blkbits;
 }
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index cc428d04be3e..1647eb7ca6fa 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -975,14 +975,6 @@ struct fuse_conn {
 		/* Request timeout (in jiffies). 0 = no timeout */
 		unsigned int req_timeout;
 	} timeout;
-
-	/*
-	 * This is a workaround until fuse uses iomap for reads.
-	 * For fuseblk servers, this represents the blocksize passed in at
-	 * mount time and for regular fuse servers, this is equivalent to
-	 * inode-&gt;i_blkbits.
-	 */
-	u8 blkbits;
 };
 
 /*
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 7485a41af892..a1b9e8587155 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -292,7 +292,7 @@ void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,
 	if (attr-&gt;blksize)
 		fi-&gt;cached_i_blkbits = ilog2(attr-&gt;blksize);
 	else
-		fi-&gt;cached_i_blkbits = fc-&gt;blkbits;
+		fi-&gt;cached_i_blkbits = inode-&gt;i_sb-&gt;s_blocksize_bits;
 
 	/*
 	 * Don&#x27;t set the sticky bit in i_mode, unless we want the VFS
@@ -1810,21 +1810,10 @@ int fuse_fill_super_common(struct super_block *sb, struct fuse_fs_context *ctx)
 		err = -EINVAL;
 		if (!sb_set_blocksize(sb, ctx-&gt;blksize))
 			goto err;
-		/*
-		 * This is a workaround until fuse hooks into iomap for reads.
-		 * Use PAGE_SIZE for the blocksize else if the writeback cache
-		 * is enabled, buffered writes go through iomap and a read may
-		 * overwrite partially written data if blocksize &lt; PAGE_SIZE
-		 */
-		fc-&gt;blkbits = sb-&gt;s_blocksize_bits;
-		if (ctx-&gt;blksize != PAGE_SIZE &amp;&amp;
-		    !sb_set_blocksize(sb, PAGE_SIZE))
-			goto err;
 #endif
 	} else {
 		sb-&gt;s_blocksize = PAGE_SIZE;
 		sb-&gt;s_blocksize_bits = PAGE_SHIFT;
-		fc-&gt;blkbits = sb-&gt;s_blocksize_bits;
 	}
 
 	sb-&gt;s_subtype = ctx-&gt;subtype;
-- 
2.47.3



---

On Thu, Oct 23, 2025 at 12:30 PM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt;
&gt; On Thu, Sep 25, 2025 at 05:26:02PM -0700, Joanne Koong wrote:
&gt; &gt; Instead of incrementing read_bytes_pending for every folio range read in
&gt; &gt; (which requires acquiring the spinlock to do so), set read_bytes_pending
&gt; &gt; to the folio size when the first range is asynchronously read in, keep
&gt; &gt; track of how many bytes total are asynchronously read in, and adjust
&gt; &gt; read_bytes_pending accordingly after issuing requests to read in all the
&gt; &gt; necessary ranges.
&gt; &gt;
&gt; &gt; iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
&gt; &gt; value for pending bytes necessarily indicates the folio is in the bio.
&gt; &gt;
&gt; &gt; Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
&gt; &gt; Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
&gt; &gt; ---
&gt;
&gt; Hi Joanne,
&gt;
&gt; I was throwing some extra testing at the vfs-6.19.iomap branch since the
&gt; little merge conflict thing with iomap_iter_advance(). I end up hitting
&gt; what appears to be a lockup on XFS with 1k FSB (-bsize=1k) running
&gt; generic/051. It reproduces fairly reliably within a few iterations or so
&gt; and seems to always stall during a read for a dedupe operation:
&gt;
&gt; task:fsstress        state:D stack:0     pid:12094 tgid:12094 ppid:12091  task_flags:0x400140 flags:0x00080003
&gt; Call Trace:
&gt;  &lt;TASK&gt;
&gt;  __schedule+0x2fc/0x7a0
&gt;  schedule+0x27/0x80
&gt;  io_schedule+0x46/0x70
&gt;  folio_wait_bit_common+0x12b/0x310
&gt;  ? __pfx_wake_page_function+0x10/0x10
&gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt;  filemap_read_folio+0x85/0xd0
&gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt;  do_read_cache_folio+0x7c/0x1b0
&gt;  vfs_dedupe_file_range_compare.constprop.0+0xaf/0x2d0
&gt;  __generic_remap_file_range_prep+0x276/0x2a0
&gt;  generic_remap_file_range_prep+0x10/0x20
&gt;  xfs_reflink_remap_prep+0x22c/0x300 [xfs]
&gt;  xfs_file_remap_range+0x84/0x360 [xfs]
&gt;  vfs_dedupe_file_range_one+0x1b2/0x1d0
&gt;  ? remap_verify_area+0x46/0x140
&gt;  vfs_dedupe_file_range+0x162/0x220
&gt;  do_vfs_ioctl+0x4d1/0x940
&gt;  __x64_sys_ioctl+0x75/0xe0
&gt;  do_syscall_64+0x84/0x800
&gt;  ? do_syscall_64+0xbb/0x800
&gt;  ? avc_has_perm_noaudit+0x6b/0xf0
&gt;  ? _copy_to_user+0x31/0x40
&gt;  ? cp_new_stat+0x130/0x170
&gt;  ? __do_sys_newfstat+0x44/0x70
&gt;  ? do_syscall_64+0xbb/0x800
&gt;  ? do_syscall_64+0xbb/0x800
&gt;  ? clear_bhb_loop+0x30/0x80
&gt;  ? clear_bhb_loop+0x30/0x80
&gt;  entry_SYSCALL_64_after_hwframe+0x76/0x7e
&gt; RIP: 0033:0x7fe6bbd9a14d
&gt; RSP: 002b:00007ffde72cd4e0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
&gt; RAX: ffffffffffffffda RBX: 0000000000000068 RCX: 00007fe6bbd9a14d
&gt; RDX: 000000000a1394b0 RSI: 00000000c0189436 RDI: 0000000000000004
&gt; RBP: 00007ffde72cd530 R08: 0000000000001000 R09: 000000000a11a3fc
&gt; R10: 000000000001d6c0 R11: 0000000000000246 R12: 000000000a12cfb0
&gt; R13: 000000000a12ba10 R14: 000000000a14e610 R15: 0000000000019000
&gt;  &lt;/TASK&gt;
&gt;
&gt; It wasn&#x27;t immediately clear to me what the issue was so I bisected and
&gt; it landed on this patch. It kind of looks like we&#x27;re failing to unlock a
&gt; folio at some point and then tripping over it later..? I can kill the
&gt; fsstress process but then the umount ultimately gets stuck tossing
&gt; pagecache [1], so the mount still ends up stuck indefinitely. Anyways,
&gt; I&#x27;ll poke at it some more but I figure you might be able to make sense
&gt; of this faster than I can.
&gt;
&gt; Brian

Hi Brian,

Thanks for your report and the repro instructions. I will look into
this and report back what I find.

Thanks,
Joanne
&gt;
&gt; [1] umount stack trace:
&gt;
&gt; task:umount          state:D stack:0     pid:12216 tgid:12216 ppid:2514   task_flags:0x400100 flags:0x00080001
&gt; Call Trace:
&gt;  &lt;TASK&gt;
&gt;  __schedule+0x2fc/0x7a0
&gt;  schedule+0x27/0x80
&gt;  io_schedule+0x46/0x70
&gt;  folio_wait_bit_common+0x12b/0x310
&gt;  ? __pfx_wake_page_function+0x10/0x10
&gt;  truncate_inode_pages_range+0x42a/0x4d0
&gt;  xfs_fs_evict_inode+0x1f/0x30 [xfs]
&gt;  evict+0x112/0x290
&gt;  evict_inodes+0x209/0x230
&gt;  generic_shutdown_super+0x42/0x100
&gt;  kill_block_super+0x1a/0x40
&gt;  xfs_kill_sb+0x12/0x20 [xfs]
&gt;  deactivate_locked_super+0x33/0xb0
&gt;  cleanup_mnt+0xba/0x150
&gt;  task_work_run+0x5c/0x90
&gt;  exit_to_user_mode_loop+0x12f/0x170
&gt;  do_syscall_64+0x1af/0x800
&gt;  ? vfs_statx+0x80/0x160
&gt;  ? do_statx+0x62/0xa0
&gt;  ? __x64_sys_statx+0xaf/0x100
&gt;  ? do_syscall_64+0xbb/0x800
&gt;  ? __x64_sys_statx+0xaf/0x100
&gt;  ? do_syscall_64+0xbb/0x800
&gt;  ? count_memcg_events+0xdd/0x1b0
&gt;  ? handle_mm_fault+0x220/0x340
&gt;  ? do_user_addr_fault+0x2c3/0x7f0
&gt;  ? clear_bhb_loop+0x30/0x80
&gt;  ? clear_bhb_loop+0x30/0x80
&gt;  entry_SYSCALL_64_after_hwframe+0x76/0x7e
&gt; RIP: 0033:0x7fdd641ed5ab
&gt; RSP: 002b:00007ffd671182e8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
&gt; RAX: 0000000000000000 RBX: 0000559b3e2056b0 RCX: 00007fdd641ed5ab
&gt; RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000559b3e205ac0
&gt; RBP: 00007ffd671183c0 R08: 0000000000000000 R09: 0000000000000000
&gt; R10: 0000000000000103 R11: 0000000000000246 R12: 0000559b3e2057b8
&gt; R13: 0000000000000000 R14: 0000559b3e205ac0 R15: 0000000000000000
&gt;  &lt;/TASK&gt;
&gt;


---

On Thu, Oct 23, 2025 at 5:01 PM Joanne Koong &lt;joannelkoong@gmail.com&gt; wrote:
&gt;
&gt; On Thu, Oct 23, 2025 at 12:30 PM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt; &gt;
&gt; &gt; On Thu, Sep 25, 2025 at 05:26:02PM -0700, Joanne Koong wrote:
&gt; &gt; &gt; Instead of incrementing read_bytes_pending for every folio range read in
&gt; &gt; &gt; (which requires acquiring the spinlock to do so), set read_bytes_pending
&gt; &gt; &gt; to the folio size when the first range is asynchronously read in, keep
&gt; &gt; &gt; track of how many bytes total are asynchronously read in, and adjust
&gt; &gt; &gt; read_bytes_pending accordingly after issuing requests to read in all the
&gt; &gt; &gt; necessary ranges.
&gt; &gt; &gt;
&gt; &gt; &gt; iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
&gt; &gt; &gt; value for pending bytes necessarily indicates the folio is in the bio.
&gt; &gt; &gt;
&gt; &gt; &gt; Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
&gt; &gt; &gt; Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
&gt; &gt; &gt; ---
&gt; &gt;
&gt; &gt; Hi Joanne,
&gt; &gt;
&gt; &gt; I was throwing some extra testing at the vfs-6.19.iomap branch since the
&gt; &gt; little merge conflict thing with iomap_iter_advance(). I end up hitting
&gt; &gt; what appears to be a lockup on XFS with 1k FSB (-bsize=1k) running
&gt; &gt; generic/051. It reproduces fairly reliably within a few iterations or so
&gt; &gt; and seems to always stall during a read for a dedupe operation:
&gt; &gt;
&gt; &gt; task:fsstress        state:D stack:0     pid:12094 tgid:12094 ppid:12091  task_flags:0x400140 flags:0x00080003
&gt; &gt; Call Trace:
&gt; &gt;  &lt;TASK&gt;
&gt; &gt;  __schedule+0x2fc/0x7a0
&gt; &gt;  schedule+0x27/0x80
&gt; &gt;  io_schedule+0x46/0x70
&gt; &gt;  folio_wait_bit_common+0x12b/0x310
&gt; &gt;  ? __pfx_wake_page_function+0x10/0x10
&gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt;  filemap_read_folio+0x85/0xd0
&gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt;  do_read_cache_folio+0x7c/0x1b0
&gt; &gt;  vfs_dedupe_file_range_compare.constprop.0+0xaf/0x2d0
&gt; &gt;  __generic_remap_file_range_prep+0x276/0x2a0
&gt; &gt;  generic_remap_file_range_prep+0x10/0x20
&gt; &gt;  xfs_reflink_remap_prep+0x22c/0x300 [xfs]
&gt; &gt;  xfs_file_remap_range+0x84/0x360 [xfs]
&gt; &gt;  vfs_dedupe_file_range_one+0x1b2/0x1d0
&gt; &gt;  ? remap_verify_area+0x46/0x140
&gt; &gt;  vfs_dedupe_file_range+0x162/0x220
&gt; &gt;  do_vfs_ioctl+0x4d1/0x940
&gt; &gt;  __x64_sys_ioctl+0x75/0xe0
&gt; &gt;  do_syscall_64+0x84/0x800
&gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt;  ? avc_has_perm_noaudit+0x6b/0xf0
&gt; &gt;  ? _copy_to_user+0x31/0x40
&gt; &gt;  ? cp_new_stat+0x130/0x170
&gt; &gt;  ? __do_sys_newfstat+0x44/0x70
&gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt;  entry_SYSCALL_64_after_hwframe+0x76/0x7e
&gt; &gt; RIP: 0033:0x7fe6bbd9a14d
&gt; &gt; RSP: 002b:00007ffde72cd4e0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
&gt; &gt; RAX: ffffffffffffffda RBX: 0000000000000068 RCX: 00007fe6bbd9a14d
&gt; &gt; RDX: 000000000a1394b0 RSI: 00000000c0189436 RDI: 0000000000000004
&gt; &gt; RBP: 00007ffde72cd530 R08: 0000000000001000 R09: 000000000a11a3fc
&gt; &gt; R10: 000000000001d6c0 R11: 0000000000000246 R12: 000000000a12cfb0
&gt; &gt; R13: 000000000a12ba10 R14: 000000000a14e610 R15: 0000000000019000
&gt; &gt;  &lt;/TASK&gt;
&gt; &gt;
&gt; &gt; It wasn&#x27;t immediately clear to me what the issue was so I bisected and
&gt; &gt; it landed on this patch. It kind of looks like we&#x27;re failing to unlock a
&gt; &gt; folio at some point and then tripping over it later..? I can kill the
&gt; &gt; fsstress process but then the umount ultimately gets stuck tossing
&gt; &gt; pagecache [1], so the mount still ends up stuck indefinitely. Anyways,
&gt; &gt; I&#x27;ll poke at it some more but I figure you might be able to make sense
&gt; &gt; of this faster than I can.
&gt; &gt;
&gt; &gt; Brian
&gt;
&gt; Hi Brian,
&gt;
&gt; Thanks for your report and the repro instructions. I will look into
&gt; this and report back what I find.

This is the fix:

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 4e6258fdb915..aa46fec8362d 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -445,6 +445,9 @@ static void iomap_read_end(struct folio *folio,
size_t bytes_pending)
                bool end_read, uptodate;
                size_t bytes_accounted = folio_size(folio) - bytes_pending;

+               if (!bytes_accounted)
+                       return;
+
                spin_lock_irq(&amp;ifs-&gt;state_lock);


What I missed was that if all the bytes in the folio are non-uptodate
and need to read in by the filesystem, then there&#x27;s a bug where the
read will be ended on the folio twice (in iomap_read_end() and when
the filesystem calls iomap_finish_folio_write(), when only the
filesystem should end the read), which does 2 folio unlocks which ends
up locking the folio. Looking at the writeback patch that does a
similar optimization [1], I miss the same thing there.

I&#x27;ll fix up both. Thanks for catching this and bisecting it down to
this patch. Sorry for the trouble.

Thanks,
Joanne

[1] https://lore.kernel.org/linux-fsdevel/20251009225611.3744728-4-joannelkoong@gmail.com/
&gt;
&gt; Thanks,
&gt; Joanne
&gt; &gt;


---

On Fri, Oct 24, 2025 at 10:21 AM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt;
&gt; On Fri, Oct 24, 2025 at 09:25:13AM -0700, Joanne Koong wrote:
&gt; &gt; What I missed was that if all the bytes in the folio are non-uptodate
&gt; &gt; and need to read in by the filesystem, then there&#x27;s a bug where the
&gt; &gt; read will be ended on the folio twice (in iomap_read_end() and when
&gt; &gt; the filesystem calls iomap_finish_folio_write(), when only the
&gt; &gt; filesystem should end the read), which does 2 folio unlocks which ends
&gt; &gt; up locking the folio. Looking at the writeback patch that does a
&gt; &gt; similar optimization [1], I miss the same thing there.
&gt;
&gt; folio_unlock() contains:
&gt;         VM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);
&gt;
&gt; Feels like more filesystem people should be enabling CONFIG_DEBUG_VM
&gt; when testing (excluding performance testing of course; it&#x27;ll do ugly
&gt; things to your performance numbers).

Point taken. It looks like there&#x27;s a bunch of other memory debugging
configs as well. Do you recommend enabling all of these when testing?
Do you have a particular .config you use for when you run tests?

Thanks,
Joanne


---

On Fri, Oct 24, 2025 at 10:10 AM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt;
&gt; On Fri, Oct 24, 2025 at 09:25:13AM -0700, Joanne Koong wrote:
&gt; &gt; On Thu, Oct 23, 2025 at 5:01 PM Joanne Koong &lt;joannelkoong@gmail.com&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Thu, Oct 23, 2025 at 12:30 PM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; On Thu, Sep 25, 2025 at 05:26:02PM -0700, Joanne Koong wrote:
&gt; &gt; &gt; &gt; &gt; Instead of incrementing read_bytes_pending for every folio range read in
&gt; &gt; &gt; &gt; &gt; (which requires acquiring the spinlock to do so), set read_bytes_pending
&gt; &gt; &gt; &gt; &gt; to the folio size when the first range is asynchronously read in, keep
&gt; &gt; &gt; &gt; &gt; track of how many bytes total are asynchronously read in, and adjust
&gt; &gt; &gt; &gt; &gt; read_bytes_pending accordingly after issuing requests to read in all the
&gt; &gt; &gt; &gt; &gt; necessary ranges.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
&gt; &gt; &gt; &gt; &gt; value for pending bytes necessarily indicates the folio is in the bio.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
&gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Hi Joanne,
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; I was throwing some extra testing at the vfs-6.19.iomap branch since the
&gt; &gt; &gt; &gt; little merge conflict thing with iomap_iter_advance(). I end up hitting
&gt; &gt; &gt; &gt; what appears to be a lockup on XFS with 1k FSB (-bsize=1k) running
&gt; &gt; &gt; &gt; generic/051. It reproduces fairly reliably within a few iterations or so
&gt; &gt; &gt; &gt; and seems to always stall during a read for a dedupe operation:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; task:fsstress        state:D stack:0     pid:12094 tgid:12094 ppid:12091  task_flags:0x400140 flags:0x00080003
&gt; &gt; &gt; &gt; Call Trace:
&gt; &gt; &gt; &gt;  &lt;TASK&gt;
&gt; &gt; &gt; &gt;  __schedule+0x2fc/0x7a0
&gt; &gt; &gt; &gt;  schedule+0x27/0x80
&gt; &gt; &gt; &gt;  io_schedule+0x46/0x70
&gt; &gt; &gt; &gt;  folio_wait_bit_common+0x12b/0x310
&gt; &gt; &gt; &gt;  ? __pfx_wake_page_function+0x10/0x10
&gt; &gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt; &gt;  filemap_read_folio+0x85/0xd0
&gt; &gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt; &gt;  do_read_cache_folio+0x7c/0x1b0
&gt; &gt; &gt; &gt;  vfs_dedupe_file_range_compare.constprop.0+0xaf/0x2d0
&gt; &gt; &gt; &gt;  __generic_remap_file_range_prep+0x276/0x2a0
&gt; &gt; &gt; &gt;  generic_remap_file_range_prep+0x10/0x20
&gt; &gt; &gt; &gt;  xfs_reflink_remap_prep+0x22c/0x300 [xfs]
&gt; &gt; &gt; &gt;  xfs_file_remap_range+0x84/0x360 [xfs]
&gt; &gt; &gt; &gt;  vfs_dedupe_file_range_one+0x1b2/0x1d0
&gt; &gt; &gt; &gt;  ? remap_verify_area+0x46/0x140
&gt; &gt; &gt; &gt;  vfs_dedupe_file_range+0x162/0x220
&gt; &gt; &gt; &gt;  do_vfs_ioctl+0x4d1/0x940
&gt; &gt; &gt; &gt;  __x64_sys_ioctl+0x75/0xe0
&gt; &gt; &gt; &gt;  do_syscall_64+0x84/0x800
&gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt;  ? avc_has_perm_noaudit+0x6b/0xf0
&gt; &gt; &gt; &gt;  ? _copy_to_user+0x31/0x40
&gt; &gt; &gt; &gt;  ? cp_new_stat+0x130/0x170
&gt; &gt; &gt; &gt;  ? __do_sys_newfstat+0x44/0x70
&gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt; &gt;  entry_SYSCALL_64_after_hwframe+0x76/0x7e
&gt; &gt; &gt; &gt; RIP: 0033:0x7fe6bbd9a14d
&gt; &gt; &gt; &gt; RSP: 002b:00007ffde72cd4e0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
&gt; &gt; &gt; &gt; RAX: ffffffffffffffda RBX: 0000000000000068 RCX: 00007fe6bbd9a14d
&gt; &gt; &gt; &gt; RDX: 000000000a1394b0 RSI: 00000000c0189436 RDI: 0000000000000004
&gt; &gt; &gt; &gt; RBP: 00007ffde72cd530 R08: 0000000000001000 R09: 000000000a11a3fc
&gt; &gt; &gt; &gt; R10: 000000000001d6c0 R11: 0000000000000246 R12: 000000000a12cfb0
&gt; &gt; &gt; &gt; R13: 000000000a12ba10 R14: 000000000a14e610 R15: 0000000000019000
&gt; &gt; &gt; &gt;  &lt;/TASK&gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; It wasn&#x27;t immediately clear to me what the issue was so I bisected and
&gt; &gt; &gt; &gt; it landed on this patch. It kind of looks like we&#x27;re failing to unlock a
&gt; &gt; &gt; &gt; folio at some point and then tripping over it later..? I can kill the
&gt; &gt; &gt; &gt; fsstress process but then the umount ultimately gets stuck tossing
&gt; &gt; &gt; &gt; pagecache [1], so the mount still ends up stuck indefinitely. Anyways,
&gt; &gt; &gt; &gt; I&#x27;ll poke at it some more but I figure you might be able to make sense
&gt; &gt; &gt; &gt; of this faster than I can.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Brian
&gt; &gt; &gt;
&gt; &gt; &gt; Hi Brian,
&gt; &gt; &gt;
&gt; &gt; &gt; Thanks for your report and the repro instructions. I will look into
&gt; &gt; &gt; this and report back what I find.
&gt; &gt;
&gt; &gt; This is the fix:
&gt; &gt;
&gt; &gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; &gt; index 4e6258fdb915..aa46fec8362d 100644
&gt; &gt; --- a/fs/iomap/buffered-io.c
&gt; &gt; +++ b/fs/iomap/buffered-io.c
&gt; &gt; @@ -445,6 +445,9 @@ static void iomap_read_end(struct folio *folio,
&gt; &gt; size_t bytes_pending)
&gt; &gt;                 bool end_read, uptodate;
&gt; &gt;                 size_t bytes_accounted = folio_size(folio) - bytes_pending;
&gt; &gt;
&gt; &gt; +               if (!bytes_accounted)
&gt; &gt; +                       return;
&gt; &gt; +
&gt; &gt;                 spin_lock_irq(&amp;ifs-&gt;state_lock);
&gt; &gt;
&gt; &gt;
&gt; &gt; What I missed was that if all the bytes in the folio are non-uptodate
&gt; &gt; and need to read in by the filesystem, then there&#x27;s a bug where the
&gt; &gt; read will be ended on the folio twice (in iomap_read_end() and when
&gt; &gt; the filesystem calls iomap_finish_folio_write(), when only the
&gt; &gt; filesystem should end the read), which does 2 folio unlocks which ends
&gt; &gt; up locking the folio. Looking at the writeback patch that does a
&gt; &gt; similar optimization [1], I miss the same thing there.
&gt; &gt;
&gt;
&gt; Makes sense.. though a short comment wouldn&#x27;t hurt in there. ;) I found
&gt; myself a little confused by the accounted vs. pending naming when
&gt; reading through that code. If I follow correctly, the intent is to refer
&gt; to the additional bytes accounted to read_bytes_pending via the init
&gt; (where it just accounts the whole folio up front) and pending refers to
&gt; submitted I/O.
&gt;
&gt; Presumably that extra accounting doubly serves as the typical &quot;don&#x27;t
&gt; complete the op before the submitter is done processing&quot; extra
&gt; reference, except in this full submit case of course. If so, that&#x27;s
&gt; subtle enough in my mind that a sentence or two on it wouldn&#x27;t hurt..

I will add some a comment about this :) That&#x27;s a good point about the
naming, maybe &quot;bytes_submitted&quot; and &quot;bytes_unsubmitted&quot; is a lot less
confusing than &quot;bytes_pending&quot; and &quot;bytes_accounted&quot;.

Thanks,
Joanne

&gt;
&gt; &gt; I&#x27;ll fix up both. Thanks for catching this and bisecting it down to
&gt; &gt; this patch. Sorry for the trouble.
&gt; &gt;
&gt;
&gt; No prob. Thanks for the fix!
&gt;
&gt; Brian
&gt;
&gt; &gt; Thanks,
&gt; &gt; Joanne
&gt; &gt;
&gt; &gt; [1] https://lore.kernel.org/linux-fsdevel/20251009225611.3744728-4-joannelkoong@gmail.com/
&gt; &gt; &gt;
&gt; &gt; &gt; Thanks,
&gt; &gt; &gt; Joanne
&gt; &gt; &gt; &gt;
&gt; &gt;
&gt;


---

On Fri, Oct 24, 2025 at 12:48 PM Joanne Koong &lt;joannelkoong@gmail.com&gt; wrote:
&gt;
&gt; On Fri, Oct 24, 2025 at 10:10 AM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt; &gt;
&gt; &gt; On Fri, Oct 24, 2025 at 09:25:13AM -0700, Joanne Koong wrote:
&gt; &gt; &gt; On Thu, Oct 23, 2025 at 5:01 PM Joanne Koong &lt;joannelkoong@gmail.com&gt; wrote:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; On Thu, Oct 23, 2025 at 12:30 PM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; On Thu, Sep 25, 2025 at 05:26:02PM -0700, Joanne Koong wrote:
&gt; &gt; &gt; &gt; &gt; &gt; Instead of incrementing read_bytes_pending for every folio range read in
&gt; &gt; &gt; &gt; &gt; &gt; (which requires acquiring the spinlock to do so), set read_bytes_pending
&gt; &gt; &gt; &gt; &gt; &gt; to the folio size when the first range is asynchronously read in, keep
&gt; &gt; &gt; &gt; &gt; &gt; track of how many bytes total are asynchronously read in, and adjust
&gt; &gt; &gt; &gt; &gt; &gt; read_bytes_pending accordingly after issuing requests to read in all the
&gt; &gt; &gt; &gt; &gt; &gt; necessary ranges.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
&gt; &gt; &gt; &gt; &gt; &gt; value for pending bytes necessarily indicates the folio is in the bio.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
&gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Hi Joanne,
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; I was throwing some extra testing at the vfs-6.19.iomap branch since the
&gt; &gt; &gt; &gt; &gt; little merge conflict thing with iomap_iter_advance(). I end up hitting
&gt; &gt; &gt; &gt; &gt; what appears to be a lockup on XFS with 1k FSB (-bsize=1k) running
&gt; &gt; &gt; &gt; &gt; generic/051. It reproduces fairly reliably within a few iterations or so
&gt; &gt; &gt; &gt; &gt; and seems to always stall during a read for a dedupe operation:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; task:fsstress        state:D stack:0     pid:12094 tgid:12094 ppid:12091  task_flags:0x400140 flags:0x00080003
&gt; &gt; &gt; &gt; &gt; Call Trace:
&gt; &gt; &gt; &gt; &gt;  &lt;TASK&gt;
&gt; &gt; &gt; &gt; &gt;  __schedule+0x2fc/0x7a0
&gt; &gt; &gt; &gt; &gt;  schedule+0x27/0x80
&gt; &gt; &gt; &gt; &gt;  io_schedule+0x46/0x70
&gt; &gt; &gt; &gt; &gt;  folio_wait_bit_common+0x12b/0x310
&gt; &gt; &gt; &gt; &gt;  ? __pfx_wake_page_function+0x10/0x10
&gt; &gt; &gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt; &gt; &gt;  filemap_read_folio+0x85/0xd0
&gt; &gt; &gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt; &gt; &gt;  do_read_cache_folio+0x7c/0x1b0
&gt; &gt; &gt; &gt; &gt;  vfs_dedupe_file_range_compare.constprop.0+0xaf/0x2d0
&gt; &gt; &gt; &gt; &gt;  __generic_remap_file_range_prep+0x276/0x2a0
&gt; &gt; &gt; &gt; &gt;  generic_remap_file_range_prep+0x10/0x20
&gt; &gt; &gt; &gt; &gt;  xfs_reflink_remap_prep+0x22c/0x300 [xfs]
&gt; &gt; &gt; &gt; &gt;  xfs_file_remap_range+0x84/0x360 [xfs]
&gt; &gt; &gt; &gt; &gt;  vfs_dedupe_file_range_one+0x1b2/0x1d0
&gt; &gt; &gt; &gt; &gt;  ? remap_verify_area+0x46/0x140
&gt; &gt; &gt; &gt; &gt;  vfs_dedupe_file_range+0x162/0x220
&gt; &gt; &gt; &gt; &gt;  do_vfs_ioctl+0x4d1/0x940
&gt; &gt; &gt; &gt; &gt;  __x64_sys_ioctl+0x75/0xe0
&gt; &gt; &gt; &gt; &gt;  do_syscall_64+0x84/0x800
&gt; &gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt; &gt;  ? avc_has_perm_noaudit+0x6b/0xf0
&gt; &gt; &gt; &gt; &gt;  ? _copy_to_user+0x31/0x40
&gt; &gt; &gt; &gt; &gt;  ? cp_new_stat+0x130/0x170
&gt; &gt; &gt; &gt; &gt;  ? __do_sys_newfstat+0x44/0x70
&gt; &gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt; &gt; &gt;  entry_SYSCALL_64_after_hwframe+0x76/0x7e
&gt; &gt; &gt; &gt; &gt; RIP: 0033:0x7fe6bbd9a14d
&gt; &gt; &gt; &gt; &gt; RSP: 002b:00007ffde72cd4e0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
&gt; &gt; &gt; &gt; &gt; RAX: ffffffffffffffda RBX: 0000000000000068 RCX: 00007fe6bbd9a14d
&gt; &gt; &gt; &gt; &gt; RDX: 000000000a1394b0 RSI: 00000000c0189436 RDI: 0000000000000004
&gt; &gt; &gt; &gt; &gt; RBP: 00007ffde72cd530 R08: 0000000000001000 R09: 000000000a11a3fc
&gt; &gt; &gt; &gt; &gt; R10: 000000000001d6c0 R11: 0000000000000246 R12: 000000000a12cfb0
&gt; &gt; &gt; &gt; &gt; R13: 000000000a12ba10 R14: 000000000a14e610 R15: 0000000000019000
&gt; &gt; &gt; &gt; &gt;  &lt;/TASK&gt;
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; It wasn&#x27;t immediately clear to me what the issue was so I bisected and
&gt; &gt; &gt; &gt; &gt; it landed on this patch. It kind of looks like we&#x27;re failing to unlock a
&gt; &gt; &gt; &gt; &gt; folio at some point and then tripping over it later..? I can kill the
&gt; &gt; &gt; &gt; &gt; fsstress process but then the umount ultimately gets stuck tossing
&gt; &gt; &gt; &gt; &gt; pagecache [1], so the mount still ends up stuck indefinitely. Anyways,
&gt; &gt; &gt; &gt; &gt; I&#x27;ll poke at it some more but I figure you might be able to make sense
&gt; &gt; &gt; &gt; &gt; of this faster than I can.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Brian
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Hi Brian,
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thanks for your report and the repro instructions. I will look into
&gt; &gt; &gt; &gt; this and report back what I find.
&gt; &gt; &gt;
&gt; &gt; &gt; This is the fix:
&gt; &gt; &gt;
&gt; &gt; &gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; &gt; &gt; index 4e6258fdb915..aa46fec8362d 100644
&gt; &gt; &gt; --- a/fs/iomap/buffered-io.c
&gt; &gt; &gt; +++ b/fs/iomap/buffered-io.c
&gt; &gt; &gt; @@ -445,6 +445,9 @@ static void iomap_read_end(struct folio *folio,
&gt; &gt; &gt; size_t bytes_pending)
&gt; &gt; &gt;                 bool end_read, uptodate;
&gt; &gt; &gt;                 size_t bytes_accounted = folio_size(folio) - bytes_pending;
&gt; &gt; &gt;
&gt; &gt; &gt; +               if (!bytes_accounted)
&gt; &gt; &gt; +                       return;
&gt; &gt; &gt; +
&gt; &gt; &gt;                 spin_lock_irq(&amp;ifs-&gt;state_lock);
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; What I missed was that if all the bytes in the folio are non-uptodate
&gt; &gt; &gt; and need to read in by the filesystem, then there&#x27;s a bug where the
&gt; &gt; &gt; read will be ended on the folio twice (in iomap_read_end() and when
&gt; &gt; &gt; the filesystem calls iomap_finish_folio_write(), when only the
&gt; &gt; &gt; filesystem should end the read), which does 2 folio unlocks which ends
&gt; &gt; &gt; up locking the folio. Looking at the writeback patch that does a
&gt; &gt; &gt; similar optimization [1], I miss the same thing there.
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; Makes sense.. though a short comment wouldn&#x27;t hurt in there. ;) I found
&gt; &gt; myself a little confused by the accounted vs. pending naming when
&gt; &gt; reading through that code. If I follow correctly, the intent is to refer
&gt; &gt; to the additional bytes accounted to read_bytes_pending via the init
&gt; &gt; (where it just accounts the whole folio up front) and pending refers to
&gt; &gt; submitted I/O.
&gt; &gt;
&gt; &gt; Presumably that extra accounting doubly serves as the typical &quot;don&#x27;t
&gt; &gt; complete the op before the submitter is done processing&quot; extra
&gt; &gt; reference, except in this full submit case of course. If so, that&#x27;s
&gt; &gt; subtle enough in my mind that a sentence or two on it wouldn&#x27;t hurt..
&gt;
&gt; I will add some a comment about this :) That&#x27;s a good point about the
&gt; naming, maybe &quot;bytes_submitted&quot; and &quot;bytes_unsubmitted&quot; is a lot less
&gt; confusing than &quot;bytes_pending&quot; and &quot;bytes_accounted&quot;.

Thinking about this some more, bytes_unsubmitted sounds even more
confusing, so maybe bytes_nonsubmitted or bytes_not_submitted. I&#x27;ll
think about this some more but kept it as pending/accounted for now.

The fix for this bug is here [1].

Thanks,
Joanne

[1] https://lore.kernel.org/linux-fsdevel/20251024215008.3844068-1-joannelkoong@gmail.com/

&gt;
&gt; Thanks,
&gt; Joanne
&gt;
&gt; &gt;
&gt; &gt; &gt; I&#x27;ll fix up both. Thanks for catching this and bisecting it down to
&gt; &gt; &gt; this patch. Sorry for the trouble.
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; No prob. Thanks for the fix!
&gt; &gt;
&gt; &gt; Brian
&gt; &gt;
&gt; &gt; &gt; Thanks,
&gt; &gt; &gt; Joanne
&gt; &gt; &gt;
&gt; &gt; &gt; [1] https://lore.kernel.org/linux-fsdevel/20251009225611.3744728-4-joannelkoong@gmail.com/
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thanks,
&gt; &gt; &gt; &gt; Joanne
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt;


---

On Fri, Oct 24, 2025 at 1:59 PM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt;
&gt; On Fri, Oct 24, 2025 at 12:22:32PM -0700, Joanne Koong wrote:
&gt; &gt; &gt; Feels like more filesystem people should be enabling CONFIG_DEBUG_VM
&gt; &gt; &gt; when testing (excluding performance testing of course; it&#x27;ll do ugly
&gt; &gt; &gt; things to your performance numbers).
&gt; &gt;
&gt; &gt; Point taken. It looks like there&#x27;s a bunch of other memory debugging
&gt; &gt; configs as well. Do you recommend enabling all of these when testing?
&gt; &gt; Do you have a particular .config you use for when you run tests?
&gt;
&gt; Our Kconfig is far too ornate.  We could do with a &quot;recommended for
&gt; kernel developers&quot; profile.  Here&#x27;s what I&#x27;m currently using, though I
&gt; know it&#x27;s changed over time:
&gt;
&gt; CONFIG_X86_DEBUGCTLMSR=y
&gt; CONFIG_PM_DEBUG=y
&gt; CONFIG_PM_SLEEP_DEBUG=y
&gt; CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
&gt; CONFIG_BLK_DEBUG_FS=y
&gt; CONFIG_PNP_DEBUG_MESSAGES=y
&gt; CONFIG_SCSI_DEBUG=m
&gt; CONFIG_EXT4_DEBUG=y
&gt; CONFIG_JFS_DEBUG=y
&gt; CONFIG_XFS_DEBUG=y
&gt; CONFIG_BTRFS_DEBUG=y
&gt; CONFIG_UFS_DEBUG=y
&gt; CONFIG_DEBUG_BUGVERBOSE=y
&gt; CONFIG_DEBUG_KERNEL=y
&gt; CONFIG_DEBUG_MISC=y
&gt; CONFIG_DEBUG_INFO=y
&gt; CONFIG_DEBUG_INFO_DWARF4=y
&gt; CONFIG_DEBUG_INFO_COMPRESSED_NONE=y
&gt; CONFIG_DEBUG_FS=y
&gt; CONFIG_DEBUG_FS_ALLOW_ALL=y
&gt; CONFIG_ARCH_HAS_EARLY_DEBUG=y
&gt; CONFIG_SLUB_DEBUG=y
&gt; CONFIG_ARCH_HAS_DEBUG_WX=y
&gt; CONFIG_HAVE_DEBUG_KMEMLEAK=y
&gt; CONFIG_SHRINKER_DEBUG=y
&gt; CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE=y
&gt; CONFIG_DEBUG_VM_IRQSOFF=y
&gt; CONFIG_DEBUG_VM=y
&gt; CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
&gt; CONFIG_DEBUG_MEMORY_INIT=y
&gt; CONFIG_LOCK_DEBUGGING_SUPPORT=y
&gt; CONFIG_DEBUG_RT_MUTEXES=y
&gt; CONFIG_DEBUG_SPINLOCK=y
&gt; CONFIG_DEBUG_MUTEXES=y
&gt; CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
&gt; CONFIG_DEBUG_RWSEMS=y
&gt; CONFIG_DEBUG_LOCK_ALLOC=y
&gt; CONFIG_DEBUG_LIST=y
&gt; CONFIG_X86_DEBUG_FPU=y
&gt; CONFIG_FAULT_INJECTION_DEBUG_FS=y
&gt;
&gt; (output from grep DEBUG .build/.config |grep -v ^#)

Thank you, I&#x27;ll copy this.
&gt;


---

On Tue, Dec 23, 2025 at 2:30 PM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt;

Hi Sasha,

Thanks for your patch and for the detailed writeup.

&gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt;
&gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt; set the uptodate bit and clear the locked bit:
&gt;
&gt;   Thread A (read completion):          Thread B (concurrent write):
&gt;   --------------------------------     --------------------------------
&gt;   iomap_finish_folio_read()
&gt;     spin_lock(state_lock)
&gt;     ifs_set_range_uptodate() -&gt; true
&gt;     spin_unlock(state_lock)
&gt;                                        iomap_set_range_uptodate()
&gt;                                          spin_lock(state_lock)
&gt;                                          ifs_set_range_uptodate() -&gt; true
&gt;                                          spin_unlock(state_lock)
&gt;                                          folio_mark_uptodate(folio)
&gt;     folio_end_read(folio, true)
&gt;       folio_xor_flags()  // XOR CLEARS uptodate!

The part I&#x27;m confused about here is how this can happen between a
concurrent read and write. My understanding is that the folio is
locked when the read occurs and locked when the write occurs and both
locks get dropped only when the read or write finishes. Looking at
iomap code, I see iomap_set_range_uptodate() getting called in
__iomap_write_begin() and __iomap_write_end() for the writes, but in
both those places the folio lock is held while this is called. I&#x27;m not
seeing how the read and write race in the diagram can happen, but
maybe I&#x27;m missing something here?

&gt;
&gt; Result: folio is NOT uptodate, but ifs says all blocks ARE uptodate.

Ah I see the WARN_ON_ONCE() in ifs_free:
        WARN_ON_ONCE(ifs_is_fully_uptodate(folio, ifs) !=
                        folio_test_uptodate(folio));

Just to confirm, are you seeing that the folio is not marked uptodate
but the ifs blocks are? Or are the ifs blocks not uptodate but the
folio is?

&gt;
&gt; Fix by checking read_bytes_pending in iomap_set_range_uptodate() under the
&gt; lock. If a read is in progress, skip calling folio_mark_uptodate() - the
&gt; read completion path will handle it via folio_end_read().
&gt;
&gt; The warning was triggered during FUSE-based filesystem (e.g., NTFS-3G)
&gt; unmount when the LTP writev03 test was run:
&gt;
&gt;   WARNING: fs/iomap/buffered-io.c at ifs_free
&gt;   Call trace:
&gt;    ifs_free
&gt;    iomap_invalidate_folio
&gt;    truncate_cleanup_folio
&gt;    truncate_inode_pages_range
&gt;    truncate_inode_pages_final
&gt;    fuse_evict_inode
&gt;    ...
&gt;    fuse_kill_sb_blk
&gt;
&gt; Fixes: 7a4847e54cc1 (&quot;iomap: use folio_end_read()&quot;)
&gt; Assisted-by: claude-opus-4-5-20251101
&gt; Signed-off-by: Sasha Levin &lt;sashal@kernel.org&gt;
&gt; ---
&gt;  fs/fuse/dev.c          |  3 +-
&gt;  fs/fuse/file.c         |  6 ++--
&gt;  fs/iomap/buffered-io.c | 65 +++++++++++++++++++++++++++++++++++++++---
&gt;  include/linux/iomap.h  |  2 ++
&gt;  4 files changed, 68 insertions(+), 8 deletions(-)
&gt;
&gt; diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
&gt; index 6d59cbc877c6..50e84e913589 100644
&gt; --- a/fs/fuse/dev.c
&gt; +++ b/fs/fuse/dev.c
&gt; @@ -11,6 +11,7 @@
&gt;  #include &quot;fuse_dev_i.h&quot;
&gt;
&gt;  #include &lt;linux/init.h&gt;
&gt; +#include &lt;linux/iomap.h&gt;
&gt;  #include &lt;linux/module.h&gt;
&gt;  #include &lt;linux/poll.h&gt;
&gt;  #include &lt;linux/sched/signal.h&gt;
&gt; @@ -1820,7 +1821,7 @@ static int fuse_notify_store(struct fuse_conn *fc, unsigned int size,
&gt;                 if (!folio_test_uptodate(folio) &amp;&amp; !err &amp;&amp; offset == 0 &amp;&amp;
&gt;                     (nr_bytes == folio_size(folio) || file_size == end)) {
&gt;                         folio_zero_segment(folio, nr_bytes, folio_size(folio));
&gt; -                       folio_mark_uptodate(folio);
&gt; +                       iomap_set_range_uptodate(folio, 0, folio_size(folio));
&gt;                 }
&gt;                 folio_unlock(folio);
&gt;                 folio_put(folio);
&gt; diff --git a/fs/fuse/file.c b/fs/fuse/file.c
&gt; index 01bc894e9c2b..3abe38416199 100644
&gt; --- a/fs/fuse/file.c
&gt; +++ b/fs/fuse/file.c
&gt; @@ -1216,13 +1216,13 @@ static ssize_t fuse_send_write_pages(struct fuse_io_args *ia,
&gt;                 struct folio *folio = ap-&gt;folios[i];
&gt;
&gt;                 if (err) {
&gt; -                       folio_clear_uptodate(folio);
&gt; +                       iomap_clear_folio_uptodate(folio);
&gt;                 } else {
&gt;                         if (count &gt;= folio_size(folio) - offset)
&gt;                                 count -= folio_size(folio) - offset;
&gt;                         else {
&gt;                                 if (short_write)
&gt; -                                       folio_clear_uptodate(folio);
&gt; +                                       iomap_clear_folio_uptodate(folio);
&gt;                                 count = 0;
&gt;                         }
&gt;                         offset = 0;
&gt; @@ -1305,7 +1305,7 @@ static ssize_t fuse_fill_write_pages(struct fuse_io_args *ia,
&gt;
&gt;                 /* If we copied full folio, mark it uptodate */
&gt;                 if (tmp == folio_size(folio))
&gt; -                       folio_mark_uptodate(folio);
&gt; +                       iomap_set_range_uptodate(folio, 0, folio_size(folio));
&gt;
&gt;                 if (folio_test_uptodate(folio)) {
&gt;                         folio_unlock(folio);
&gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; index e5c1ca440d93..7ceda24cf6a7 100644
&gt; --- a/fs/iomap/buffered-io.c
&gt; +++ b/fs/iomap/buffered-io.c
&gt; @@ -74,8 +74,7 @@ static bool ifs_set_range_uptodate(struct folio *folio,
&gt;         return ifs_is_fully_uptodate(folio, ifs);
&gt;  }
&gt;
&gt; -static void iomap_set_range_uptodate(struct folio *folio, size_t off,
&gt; -               size_t len)
&gt; +void iomap_set_range_uptodate(struct folio *folio, size_t off, size_t len)
&gt;  {
&gt;         struct iomap_folio_state *ifs = folio-&gt;private;
&gt;         unsigned long flags;
&gt; @@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio *folio, size_t off,
&gt;         if (ifs) {
&gt;                 spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt;                 uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt; +               /*
&gt; +                * If a read is in progress, we must NOT call folio_mark_uptodate
&gt; +                * here. The read completion path (iomap_finish_folio_read or
&gt; +                * iomap_read_end) will call folio_end_read() which uses XOR
&gt; +                * semantics to set the uptodate bit. If we set it here, the XOR
&gt; +                * in folio_end_read() will clear it, leaving the folio not
&gt; +                * uptodate while the ifs says all blocks are uptodate.
&gt; +                */
&gt; +               if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
&gt; +                       uptodate = false;

Does the warning you saw in ifs_free() still go away without the
changes here to iomap_set_range_uptodate() or is this change here
necessary?  I&#x27;m asking mostly because I&#x27;m not seeing how
iomap_set_range_uptodate() can be called while the read is in
progress, as the logic should be already protected by the folio locks.

&gt;                 spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;         }
&gt;
&gt;         if (uptodate)
&gt;                 folio_mark_uptodate(folio);
&gt;  }
&gt; +EXPORT_SYMBOL_GPL(iomap_set_range_uptodate);
&gt; +
&gt; +void iomap_clear_folio_uptodate(struct folio *folio)
&gt; +{
&gt; +       struct iomap_folio_state *ifs = folio-&gt;private;
&gt; +
&gt; +       if (ifs) {
&gt; +               struct inode *inode = folio-&gt;mapping-&gt;host;
&gt; +               unsigned int nr_blocks = i_blocks_per_folio(inode, folio);
&gt; +               unsigned long flags;
&gt; +
&gt; +               spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt; +               /*
&gt; +                * If a read is in progress, don&#x27;t clear the uptodate state.
&gt; +                * The read completion path will handle the folio state, and
&gt; +                * clearing here would race with iomap_finish_folio_read()
&gt; +                * potentially causing ifs/folio uptodate state mismatch.
&gt; +                */
&gt; +               if (ifs-&gt;read_bytes_pending) {
&gt; +                       spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt; +                       return;
&gt; +               }
&gt; +               bitmap_clear(ifs-&gt;state, 0, nr_blocks);
&gt; +               spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt; +       }
&gt; +       folio_clear_uptodate(folio);
&gt; +}
&gt; +EXPORT_SYMBOL_GPL(iomap_clear_folio_uptodate);
&gt;
&gt;  /*
&gt;   * Find the next dirty block in the folio. end_blk is inclusive.
&gt; @@ -399,8 +436,17 @@ void iomap_finish_folio_read(struct folio *folio, size_t off, size_t len,
&gt;                 spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;         }
&gt;
&gt; -       if (finished)
&gt; +       if (finished) {
&gt; +               /*
&gt; +                * If uptodate is true but the folio is already marked uptodate,
&gt; +                * folio_end_read&#x27;s XOR semantics would clear the uptodate bit.
&gt; +                * This should never happen because iomap_set_range_uptodate()
&gt; +                * skips calling folio_mark_uptodate() when read_bytes_pending
&gt; +                * is non-zero, ensuring only the read completion path sets it.
&gt; +                */
&gt; +               WARN_ON_ONCE(uptodate &amp;&amp; folio_test_uptodate(folio));

Matthew pointed out in another thread [1] that folio_end_read() has
already the warnings against double-unlocks or double-uptodates
in-built:

        VM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);
        VM_BUG_ON_FOLIO(success &amp;&amp; folio_test_uptodate(folio), folio);

but imo the WARN_ON_ONCE() here is nice to have too, as I don&#x27;t think
most builds enable CONFIG_DEBUG_VM.

[1] https://lore.kernel.org/linux-fsdevel/aPu1ilw6Tq6tKPrf@casper.infradead.org/

Thanks,
Joanne
&gt;                 folio_end_read(folio, uptodate);
&gt; +       }
&gt;  }
&gt;  EXPORT_SYMBOL_GPL(iomap_finish_folio_read);
&gt;
&gt; @@ -481,8 +527,19 @@ static void iomap_read_end(struct folio *folio, size_t bytes_submitted)
&gt;                 if (end_read)
&gt;                         uptodate = ifs_is_fully_uptodate(folio, ifs);
&gt;                 spin_unlock_irq(&amp;ifs-&gt;state_lock);
&gt; -               if (end_read)
&gt; +               if (end_read) {
&gt; +                       /*
&gt; +                        * If uptodate is true but the folio is already marked
&gt; +                        * uptodate, folio_end_read&#x27;s XOR semantics would clear
&gt; +                        * the uptodate bit. This should never happen because
&gt; +                        * iomap_set_range_uptodate() skips calling
&gt; +                        * folio_mark_uptodate() when read_bytes_pending is
&gt; +                        * non-zero, ensuring only the read completion path
&gt; +                        * sets it.
&gt; +                        */
&gt; +                       WARN_ON_ONCE(uptodate &amp;&amp; folio_test_uptodate(folio));
&gt;                         folio_end_read(folio, uptodate);
&gt; +               }
&gt;         } else if (!bytes_submitted) {
&gt;                 /*
&gt;                  * If there were no bytes submitted, this means we are
&gt; diff --git a/include/linux/iomap.h b/include/linux/iomap.h
&gt; index 520e967cb501..3c2ad88d16b6 100644
&gt; --- a/include/linux/iomap.h
&gt; +++ b/include/linux/iomap.h
&gt; @@ -345,6 +345,8 @@ void iomap_read_folio(const struct iomap_ops *ops,
&gt;  void iomap_readahead(const struct iomap_ops *ops,
&gt;                 struct iomap_read_folio_ctx *ctx);
&gt;  bool iomap_is_partially_uptodate(struct folio *, size_t from, size_t count);
&gt; +void iomap_set_range_uptodate(struct folio *folio, size_t off, size_t len);
&gt; +void iomap_clear_folio_uptodate(struct folio *folio);
&gt;  struct folio *iomap_get_folio(struct iomap_iter *iter, loff_t pos, size_t len);
&gt;  bool iomap_release_folio(struct folio *folio, gfp_t gfp_flags);
&gt;  void iomap_invalidate_folio(struct folio *folio, size_t offset, size_t len);
&gt; --
&gt; 2.51.0
&gt;


---

On Wed, Dec 24, 2025 at 1:21 PM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt;
&gt; On Wed, Dec 24, 2025 at 05:27:03PM +0000, Matthew Wilcox wrote:
&gt; &gt;
&gt; &gt; WARNING: fs/iomap/buffered-io.c:254 at ifs_free+0x130/0x148, CPU#0: msync04/406
&gt; &gt;
&gt; &gt;That&#x27;s this one:
&gt; &gt;
&gt; &gt;        WARN_ON_ONCE(ifs_is_fully_uptodate(folio, ifs) !=
&gt; &gt;                        folio_test_uptodate(folio));
&gt; &gt;
&gt; &gt;which would be fully explained by fuse calling folio_clear_uptodate()
&gt; &gt;in fuse_send_write_pages().  I have come to believe that allowing
&gt; &gt;filesystems to call folio_clear_uptodate() is just dangerous.  It
&gt; &gt;causes assertions to fire all over the place (eg if the page is mapped
&gt; &gt;into memory, the MM contains assertions that it must be uptodate).
&gt; &gt;
&gt; &gt;So I think the first step is simply to delete the folio_clear_uptodate()
&gt; &gt;calls in fuse:

Hmm... this fuse_perform_write() call path is for writethrough. In
writethrough, fuse first writes the data to the page cache and then to
the server. I think because we&#x27;re doing the writes in that order (eg
first to the page cache, then the server), the clear uptodate is
needed if the server write is a short write or an error since we can&#x27;t
revert the page cache data back to its original content (eg we want to
write 2 KB starting at offset 0, the folio representing that in the
page cache is uptodate, we retrieve that folio and write 2 KB to it,
then when we try writing it to the server, the server can only write
out 1 KB, where now there&#x27;s a discrepancy between the page cache
contents and the disk contents, where we&#x27;re unable to make these
consistent by undoing the page cache write for the chunk between 1 KB
and 2 KB). If we could switch the ordering and write it to the server
first and then to the page cache, then we could get rid of the clear
uptodates, but to switch this ordering requires a bigger change where
we&#x27;d need to add support for copying out data from a userspace iter to
the server (currently, only copying out data from folios are
supported). I&#x27;m happy to work on this though if you think we should
try our best to fully eradicate folio_clear_uptodate() from fuse.

There&#x27;s also another folio_clear_uptodate() call in
fuse_try_move_folio() in fuse/dev.c when the server gifts pages to the
kernel through vmsplice. This one I think is needed else
folio_end_read() will xor uptodate state of an already uptodate folio
(commit 76a51ac (&quot;fuse: clear PG_uptodate when using a stolen page&quot;)
says a bit more about this).

&gt; [snip]
&gt;
&gt; Here&#x27;s the log of a run with the change you&#x27;ve provided applied: https://qa-reports.linaro.org/lkft/sashal-linus-next/build/v6.18-rc7-13807-g26a15474eb13/testrun/30620754/suite/log-parser-test/test/exception-warning-fsiomapbuffered-io-at-ifs_free/log

Hmm, I think this WARN_ON_ONCE is getting triggered from the
folio_mark_uptodate() call in fuse_fill_write_pages().

This is happening because iomap integration hasn&#x27;t (yet) been added to
the fuse writethrough path, as it&#x27;s not necessary / urgent (whereas
for buffered writes, it is in order for fuse to use large folios). imo
updating the folio uptodate/dirty state but not the bitmap is
logically fine as the worst outcome from this is that we miss being
able to skip some extra read calls that we could saved if we did add
the iomap bitmap integration. However, I didn&#x27;t realize there&#x27;s a
WARN_ON_ONCE checking the ifs uptodate bitmap state (but curiously no
WARN_ON_ONCE checking the ifs dirty bitmap state).

With that said, I think it makes sense to either a) do the
iomap_set_range_uptodate() / iomap_clear_folio_uptodate() bitmap
updating you proposed as a fix for this WARN_ON_ONCE for now to
unblock things, until iomap integration gets added to the fuse
writethrough path, which I&#x27;ll now prioritize, or b) remove that
warning. The warning does seem otherwise useful though so it seems
like we should probably just go with a).

Thanks,
Joanne

&gt;
&gt; --
&gt; Thanks,
&gt; Sasha


---

On Fri, Feb 6, 2026 at 11:16 PM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt;
&gt; On Tue, Dec 23, 2025 at 08:31:57PM -0500, Sasha Levin wrote:
&gt; &gt; On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt; &gt; &gt; On Tue, Dec 23, 2025 at 2:30 PM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Hi Sasha,
&gt; &gt; &gt;
&gt; &gt; &gt; Thanks for your patch and for the detailed writeup.
&gt; &gt;
&gt; &gt; Thanks for looking into this!
&gt; &gt;
&gt; &gt; &gt; &gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt; &gt; &gt; &gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt; &gt; &gt; &gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt; &gt; &gt; &gt; set the uptodate bit and clear the locked bit:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;   Thread A (read completion):          Thread B (concurrent write):
&gt; &gt; &gt; &gt;   --------------------------------     --------------------------------
&gt; &gt; &gt; &gt;   iomap_finish_folio_read()
&gt; &gt; &gt; &gt;     spin_lock(state_lock)
&gt; &gt; &gt; &gt;     ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt;     spin_unlock(state_lock)
&gt; &gt; &gt; &gt;                                        iomap_set_range_uptodate()
&gt; &gt; &gt; &gt;                                          spin_lock(state_lock)
&gt; &gt; &gt; &gt;                                          ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt;                                          spin_unlock(state_lock)
&gt; &gt; &gt; &gt;                                          folio_mark_uptodate(folio)
&gt; &gt; &gt; &gt;     folio_end_read(folio, true)
&gt; &gt; &gt; &gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt; &gt; &gt;
&gt; &gt; &gt; The part I&#x27;m confused about here is how this can happen between a
&gt; &gt; &gt; concurrent read and write. My understanding is that the folio is
&gt; &gt; &gt; locked when the read occurs and locked when the write occurs and both
&gt; &gt; &gt; locks get dropped only when the read or write finishes. Looking at
&gt; &gt; &gt; iomap code, I see iomap_set_range_uptodate() getting called in
&gt; &gt; &gt; __iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt; &gt; &gt; both those places the folio lock is held while this is called. I&#x27;m not
&gt; &gt; &gt; seeing how the read and write race in the diagram can happen, but
&gt; &gt; &gt; maybe I&#x27;m missing something here?
&gt; &gt;
&gt; &gt; Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
&gt; &gt; access. Looking at this again, I suspect that FUSE was calling
&gt; &gt; folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
&gt; &gt; ifs bits. For example, in fuse_send_write_pages() on write error, it calls
&gt; &gt; folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
&gt; &gt; showing all blocks uptodate?
&gt;
&gt; Hi Sasha
&gt; On PowerPC with 64KB page size, msync04 fails with SIGBUS on NTFS-FUSE. The issue stems from a state inconsistency between
&gt; the iomap_folio_state (ifs) bitmap and the folio&#x27;s Uptodate flag.
&gt; tst_test.c:1985: TINFO: === Testing on ntfs ===
&gt; tst_test.c:1290: TINFO: Formatting /dev/loop0 with ntfs opts=&#x27;&#x27; extra opts=&#x27;&#x27;
&gt; Failed to set locale, using default &#x27;C&#x27;.
&gt; The partition start sector was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; The number of sectors per track was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; The number of heads was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; To boot from a device, Windows needs the &#x27;partition start sector&#x27;, the &#x27;sectors per track&#x27; and the &#x27;number of heads&#x27; to be set.
&gt; Windows will not be able to boot from this device.
&gt; tst_test.c:1302: TINFO: Mounting /dev/loop0 to /tmp/LTP_msy3ljVxi/msync04 fstyp=ntfs flags=0
&gt; tst_test.c:1302: TINFO: Trying FUSE...
&gt; tst_test.c:1953: TBROK: Test killed by SIGBUS!
&gt;
&gt; Root Cause Analysis: When a page fault triggers fuse_read_folio, the iomap_read_folio_iter handles the request. For a 64KB page,
&gt; after fetching 4KB via fuse_iomap_read_folio_range_async, the remaining 60KB (61440 bytes) is zero-filled via iomap_block_needs_zeroing,
&gt; then iomap_set_range_uptodate marks the folio as Uptodate globally, after folio_xor_flags folio&#x27;s uptodate become 0 again, finally trigger
&gt; an SIGBUS issue in filemap_fault.

Hi Wei,

Thanks for your report. afaict, this scenario occurs only if the
server is a fuseblk server with a block size different from the memory
page size and if the file size is less than the size of the folio
being read in.

Could you verify that this snippet from Sasha&#x27;s patch fixes the issue?:

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index e5c1ca440d93..7ceda24cf6a7 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio
*folio, size_t off,
  if (ifs) {
          spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
          uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
          + /*
          + * If a read is in progress, we must NOT call folio_mark_uptodate
          + * here. The read completion path (iomap_finish_folio_read or
          + * iomap_read_end) will call folio_end_read() which uses XOR
          + * semantics to set the uptodate bit. If we set it here, the XOR
          + * in folio_end_read() will clear it, leaving the folio not
          + * uptodate while the ifs says all blocks are uptodate.
          + */
         + if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
                   + uptodate = false;
        spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
  }

Thanks,
Joanne

&gt;
&gt; So your iomap_set_range_uptodate patch can fix above failed case since it block mark folio&#x27;s uptodate to 1.
&gt; Hope my findings are helpful.
&gt;
&gt; &gt;
&gt; &gt; --
&gt; &gt; Thanks,
&gt; &gt; Sasha
&gt; &gt;


---

On Mon, Feb 9, 2026 at 4:12 PM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt;
&gt; On Mon, Feb 09, 2026 at 11:08:50AM -0800, Joanne Koong wrote:
&gt; &gt; On Fri, Feb 6, 2026 at 11:16 PM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Tue, Dec 23, 2025 at 08:31:57PM -0500, Sasha Levin wrote:
&gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 2:30 PM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Hi Sasha,
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Thanks for your patch and for the detailed writeup.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thanks for looking into this!
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt; &gt; &gt; &gt; &gt; &gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt; &gt; &gt; &gt; &gt; &gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt; &gt; &gt; &gt; &gt; &gt; set the uptodate bit and clear the locked bit:
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;   Thread A (read completion):          Thread B (concurrent write):
&gt; &gt; &gt; &gt; &gt; &gt;   --------------------------------     --------------------------------
&gt; &gt; &gt; &gt; &gt; &gt;   iomap_finish_folio_read()
&gt; &gt; &gt; &gt; &gt; &gt;     spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt;     ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt; &gt;     spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt;                                        iomap_set_range_uptodate()
&gt; &gt; &gt; &gt; &gt; &gt;                                          spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt;                                          ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt; &gt;                                          spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt;                                          folio_mark_uptodate(folio)
&gt; &gt; &gt; &gt; &gt; &gt;     folio_end_read(folio, true)
&gt; &gt; &gt; &gt; &gt; &gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; The part I&#x27;m confused about here is how this can happen between a
&gt; &gt; &gt; &gt; &gt; concurrent read and write. My understanding is that the folio is
&gt; &gt; &gt; &gt; &gt; locked when the read occurs and locked when the write occurs and both
&gt; &gt; &gt; &gt; &gt; locks get dropped only when the read or write finishes. Looking at
&gt; &gt; &gt; &gt; &gt; iomap code, I see iomap_set_range_uptodate() getting called in
&gt; &gt; &gt; &gt; &gt; __iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt; &gt; &gt; &gt; &gt; both those places the folio lock is held while this is called. I&#x27;m not
&gt; &gt; &gt; &gt; &gt; seeing how the read and write race in the diagram can happen, but
&gt; &gt; &gt; &gt; &gt; maybe I&#x27;m missing something here?
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
&gt; &gt; &gt; &gt; access. Looking at this again, I suspect that FUSE was calling
&gt; &gt; &gt; &gt; folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
&gt; &gt; &gt; &gt; ifs bits. For example, in fuse_send_write_pages() on write error, it calls
&gt; &gt; &gt; &gt; folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
&gt; &gt; &gt; &gt; showing all blocks uptodate?
&gt; &gt; &gt;
&gt; &gt; &gt; Hi Sasha
&gt; &gt; &gt; On PowerPC with 64KB page size, msync04 fails with SIGBUS on NTFS-FUSE. The issue stems from a state inconsistency between
&gt; &gt; &gt; the iomap_folio_state (ifs) bitmap and the folio&#x27;s Uptodate flag.
&gt; &gt; &gt; tst_test.c:1985: TINFO: === Testing on ntfs ===
&gt; &gt; &gt; tst_test.c:1290: TINFO: Formatting /dev/loop0 with ntfs opts=&#x27;&#x27; extra opts=&#x27;&#x27;
&gt; &gt; &gt; Failed to set locale, using default &#x27;C&#x27;.
&gt; &gt; &gt; The partition start sector was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; The number of sectors per track was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; The number of heads was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; To boot from a device, Windows needs the &#x27;partition start sector&#x27;, the &#x27;sectors per track&#x27; and the &#x27;number of heads&#x27; to be set.
&gt; &gt; &gt; Windows will not be able to boot from this device.
&gt; &gt; &gt; tst_test.c:1302: TINFO: Mounting /dev/loop0 to /tmp/LTP_msy3ljVxi/msync04 fstyp=ntfs flags=0
&gt; &gt; &gt; tst_test.c:1302: TINFO: Trying FUSE...
&gt; &gt; &gt; tst_test.c:1953: TBROK: Test killed by SIGBUS!
&gt; &gt; &gt;
&gt; &gt; &gt; Root Cause Analysis: When a page fault triggers fuse_read_folio, the iomap_read_folio_iter handles the request. For a 64KB page,
&gt; &gt; &gt; after fetching 4KB via fuse_iomap_read_folio_range_async, the remaining 60KB (61440 bytes) is zero-filled via iomap_block_needs_zeroing,
&gt; &gt; &gt; then iomap_set_range_uptodate marks the folio as Uptodate globally, after folio_xor_flags folio&#x27;s uptodate become 0 again, finally trigger
&gt; &gt; &gt; an SIGBUS issue in filemap_fault.
&gt; &gt;
&gt; &gt; Hi Wei,
&gt; &gt;
&gt; &gt; Thanks for your report. afaict, this scenario occurs only if the
&gt; &gt; server is a fuseblk server with a block size different from the memory
&gt; &gt; page size and if the file size is less than the size of the folio
&gt; &gt; being read in.
&gt; Thanks for checking this and give quick feedback :)
&gt; &gt;
&gt; &gt; Could you verify that this snippet from Sasha&#x27;s patch fixes the issue?:
&gt; Yes, Sasha&#x27;s patch can fixes the issue.

I think just those lines I pasted from Sasha&#x27;s patch is the relevant
fix. Could you verify that just those lines (without the changes
from the rest of his patch) fixes the issue?

Thanks,
Joanne


&gt; &gt;
&gt; &gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; &gt; index e5c1ca440d93..7ceda24cf6a7 100644
&gt; &gt; --- a/fs/iomap/buffered-io.c
&gt; &gt; +++ b/fs/iomap/buffered-io.c
&gt; &gt; @@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio
&gt; &gt; *folio, size_t off,
&gt; &gt;   if (ifs) {
&gt; &gt;           spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt; &gt;           uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt; &gt;           + /*
&gt; &gt;           + * If a read is in progress, we must NOT call folio_mark_uptodate
&gt; &gt;           + * here. The read completion path (iomap_finish_folio_read or
&gt; &gt;           + * iomap_read_end) will call folio_end_read() which uses XOR
&gt; &gt;           + * semantics to set the uptodate bit. If we set it here, the XOR
&gt; &gt;           + * in folio_end_read() will clear it, leaving the folio not
&gt; &gt;           + * uptodate while the ifs says all blocks are uptodate.
&gt; &gt;           + */
&gt; &gt;          + if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
&gt; &gt;                    + uptodate = false;
&gt; &gt;         spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt; &gt;   }
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Joanne
&gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; So your iomap_set_range_uptodate patch can fix above failed case since it block mark folio&#x27;s uptodate to 1.
&gt; &gt; &gt; Hope my findings are helpful.
&gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; --
&gt; &gt; &gt; &gt; Thanks,
&gt; &gt; &gt; &gt; Sasha
&gt; &gt; &gt; &gt;


---

On Mon, Feb 9, 2026 at 4:40 PM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt;
&gt; On Mon, Feb 09, 2026 at 04:20:01PM -0800, Joanne Koong wrote:
&gt; &gt; On Mon, Feb 9, 2026 at 4:12 PM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Mon, Feb 09, 2026 at 11:08:50AM -0800, Joanne Koong wrote:
&gt; &gt; &gt; &gt; On Fri, Feb 6, 2026 at 11:16 PM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 08:31:57PM -0500, Sasha Levin wrote:
&gt; &gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 2:30 PM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Sasha,
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Thanks for your patch and for the detailed writeup.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Thanks for looking into this!
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; set the uptodate bit and clear the locked bit:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;   Thread A (read completion):          Thread B (concurrent write):
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;   --------------------------------     --------------------------------
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;   iomap_finish_folio_read()
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                        iomap_set_range_uptodate()
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          folio_mark_uptodate(folio)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     folio_end_read(folio, true)
&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; The part I&#x27;m confused about here is how this can happen between a
&gt; &gt; &gt; &gt; &gt; &gt; &gt; concurrent read and write. My understanding is that the folio is
&gt; &gt; &gt; &gt; &gt; &gt; &gt; locked when the read occurs and locked when the write occurs and both
&gt; &gt; &gt; &gt; &gt; &gt; &gt; locks get dropped only when the read or write finishes. Looking at
&gt; &gt; &gt; &gt; &gt; &gt; &gt; iomap code, I see iomap_set_range_uptodate() getting called in
&gt; &gt; &gt; &gt; &gt; &gt; &gt; __iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt; &gt; &gt; &gt; &gt; &gt; &gt; both those places the folio lock is held while this is called. I&#x27;m not
&gt; &gt; &gt; &gt; &gt; &gt; &gt; seeing how the read and write race in the diagram can happen, but
&gt; &gt; &gt; &gt; &gt; &gt; &gt; maybe I&#x27;m missing something here?
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
&gt; &gt; &gt; &gt; &gt; &gt; access. Looking at this again, I suspect that FUSE was calling
&gt; &gt; &gt; &gt; &gt; &gt; folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
&gt; &gt; &gt; &gt; &gt; &gt; ifs bits. For example, in fuse_send_write_pages() on write error, it calls
&gt; &gt; &gt; &gt; &gt; &gt; folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
&gt; &gt; &gt; &gt; &gt; &gt; showing all blocks uptodate?
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Hi Sasha
&gt; &gt; &gt; &gt; &gt; On PowerPC with 64KB page size, msync04 fails with SIGBUS on NTFS-FUSE. The issue stems from a state inconsistency between
&gt; &gt; &gt; &gt; &gt; the iomap_folio_state (ifs) bitmap and the folio&#x27;s Uptodate flag.
&gt; &gt; &gt; &gt; &gt; tst_test.c:1985: TINFO: === Testing on ntfs ===
&gt; &gt; &gt; &gt; &gt; tst_test.c:1290: TINFO: Formatting /dev/loop0 with ntfs opts=&#x27;&#x27; extra opts=&#x27;&#x27;
&gt; &gt; &gt; &gt; &gt; Failed to set locale, using default &#x27;C&#x27;.
&gt; &gt; &gt; &gt; &gt; The partition start sector was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; &gt; &gt; The number of sectors per track was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; &gt; &gt; The number of heads was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; &gt; &gt; To boot from a device, Windows needs the &#x27;partition start sector&#x27;, the &#x27;sectors per track&#x27; and the &#x27;number of heads&#x27; to be set.
&gt; &gt; &gt; &gt; &gt; Windows will not be able to boot from this device.
&gt; &gt; &gt; &gt; &gt; tst_test.c:1302: TINFO: Mounting /dev/loop0 to /tmp/LTP_msy3ljVxi/msync04 fstyp=ntfs flags=0
&gt; &gt; &gt; &gt; &gt; tst_test.c:1302: TINFO: Trying FUSE...
&gt; &gt; &gt; &gt; &gt; tst_test.c:1953: TBROK: Test killed by SIGBUS!
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Root Cause Analysis: When a page fault triggers fuse_read_folio, the iomap_read_folio_iter handles the request. For a 64KB page,
&gt; &gt; &gt; &gt; &gt; after fetching 4KB via fuse_iomap_read_folio_range_async, the remaining 60KB (61440 bytes) is zero-filled via iomap_block_needs_zeroing,
&gt; &gt; &gt; &gt; &gt; then iomap_set_range_uptodate marks the folio as Uptodate globally, after folio_xor_flags folio&#x27;s uptodate become 0 again, finally trigger
&gt; &gt; &gt; &gt; &gt; an SIGBUS issue in filemap_fault.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Hi Wei,
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thanks for your report. afaict, this scenario occurs only if the
&gt; &gt; &gt; &gt; server is a fuseblk server with a block size different from the memory
&gt; &gt; &gt; &gt; page size and if the file size is less than the size of the folio
&gt; &gt; &gt; &gt; being read in.
&gt; &gt; &gt; Thanks for checking this and give quick feedback :)
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Could you verify that this snippet from Sasha&#x27;s patch fixes the issue?:
&gt; &gt; &gt; Yes, Sasha&#x27;s patch can fixes the issue.
&gt; &gt;
&gt; &gt; I think just those lines I pasted from Sasha&#x27;s patch is the relevant
&gt; &gt; fix. Could you verify that just those lines (without the changes
&gt; &gt; from the rest of his patch) fixes the issue?
&gt; Yes, i just add two lines change in iomap_set_range_uptodate can fixes
&gt; the issue.

Great, thank you for confirming.

Sasha, would you mind submitting this snippet of your patch as the fix
for the EOF zeroing issue? I think it could be restructured to

diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 1fe19b4ee2f4..412e661871f8 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -87,7 +87,16 @@ static void iomap_set_range_uptodate(struct folio
*folio, size_t off,

        if (ifs) {
                spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
-               uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
+               /*
+                * If a read is in progress, we must NOT call
folio_mark_uptodate.
+                * The read completion path (iomap_finish_folio_read or
+                * iomap_read_end) will call folio_end_read() which uses XOR
+                * semantics to set the uptodate bit. If we set it here, the XOR
+                * in folio_end_read() will clear it, leaving the folio not
+                * uptodate.
+                */
+               uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &amp;&amp;
+                       !ifs-&gt;read_bytes_pending;
                spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
        }

to be a bit more concise.

If you&#x27;re busy and don&#x27;t have the bandwidth, I&#x27;m happy to forward the
patch on your behalf with your Signed-off-by / authorship.

Thanks,
Joanne
&gt; +               if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
&gt; +                       uptodate = false;
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Joanne
&gt; &gt;
&gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; &gt; &gt; &gt; index e5c1ca440d93..7ceda24cf6a7 100644
&gt; &gt; &gt; &gt; --- a/fs/iomap/buffered-io.c
&gt; &gt; &gt; &gt; +++ b/fs/iomap/buffered-io.c
&gt; &gt; &gt; &gt; @@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio
&gt; &gt; &gt; &gt; *folio, size_t off,
&gt; &gt; &gt; &gt;   if (ifs) {
&gt; &gt; &gt; &gt;           spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt; &gt; &gt; &gt;           uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt; &gt; &gt; &gt;           + /*
&gt; &gt; &gt; &gt;           + * If a read is in progress, we must NOT call folio_mark_uptodate
&gt; &gt; &gt; &gt;           + * here. The read completion path (iomap_finish_folio_read or
&gt; &gt; &gt; &gt;           + * iomap_read_end) will call folio_end_read() which uses XOR
&gt; &gt; &gt; &gt;           + * semantics to set the uptodate bit. If we set it here, the XOR
&gt; &gt; &gt; &gt;           + * in folio_end_read() will clear it, leaving the folio not
&gt; &gt; &gt; &gt;           + * uptodate while the ifs says all blocks are uptodate.
&gt; &gt; &gt; &gt;           + */
&gt; &gt; &gt; &gt;          + if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
&gt; &gt; &gt; &gt;                    + uptodate = false;
&gt; &gt; &gt; &gt;         spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt; &gt; &gt; &gt;   }
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thanks,
&gt; &gt; &gt; &gt; Joanne
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; So your iomap_set_range_uptodate patch can fix above failed case since it block mark folio&#x27;s uptodate to 1.
&gt; &gt; &gt; &gt; &gt; Hope my findings are helpful.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; --
&gt; &gt; &gt; &gt; &gt; &gt; Thanks,
&gt; &gt; &gt; &gt; &gt; &gt; Sasha
&gt; &gt; &gt; &gt; &gt; &gt;


---

On Tue, Feb 10, 2026 at 7:11 PM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt;
&gt; On Tue, Feb 10, 2026 at 02:18:06PM -0800, Joanne Koong wrote:
&gt; &gt;                 spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt; &gt; -               uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt; &gt; +               /*
&gt; &gt; +                * If a read is in progress, we must NOT call
&gt; &gt; folio_mark_uptodate.
&gt; &gt; +                * The read completion path (iomap_finish_folio_read or
&gt; &gt; +                * iomap_read_end) will call folio_end_read() which uses XOR
&gt; &gt; +                * semantics to set the uptodate bit. If we set it here, the XOR
&gt; &gt; +                * in folio_end_read() will clear it, leaving the folio not
&gt; &gt; +                * uptodate.
&gt; &gt; +                */
&gt; &gt; +               uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &amp;&amp;
&gt; &gt; +                       !ifs-&gt;read_bytes_pending;
&gt; &gt;                 spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;
&gt; This can&#x27;t possibly be the right fix.  There&#x27;s some horrible confusion
&gt; here.  It should not be possible to have read bytes pending _and_ the
&gt; entire folio be uptodate.  That&#x27;s an invariant that should always be
&gt; maintained.

ifs-&gt;read_bytes_pending gets initialized to the folio size, but if the
file being read in is smaller than the size of the folio, then we
reach this scenario because the file has been read in but
ifs-&gt;read_bytes_pending is still a positive value because it
represents the bytes between the end of the file and the end of the
folio. If the folio size is 16k and the file size is 4k:
  a) ifs-&gt;read_bytes_pending gets initialized to 16k
  b) -&gt;read_folio_range() is called for the 4k read
  c) the 4k read succeeds, ifs-&gt;read_bytes_pending is now 12k and the
0 to 4k range is marked uptodate
  d) the post-eof blocks are zeroed and marked uptodate in the call to
iomap_set_range_uptodate()
  e) iomap_set_range_uptodate() sees all the ranges are marked
uptodate and it marks the folio uptodate
  f) iomap_read_end() gets called to subtract the 12k from
ifs-&gt;read_bytes_pending. it too sees all the ranges are marked
uptodate and marks the folio uptodate

The same scenario could happen for IOMAP_INLINE mappings if part of
the folio is read in through -&gt;read_folio_range() and then the rest is
read in as inline data.

An alternative solution is to not have zeroed-out / inlined mappings
call iomap_read_end(), eg something like this [1], but this adds
additional complexity and doesn&#x27;t work if there&#x27;s additional mappings
for the folio after a non-IOMAP_MAPPED mapping.

Is there a better approach that I&#x27;m missing?

Thanks,
Joanne

[1] https://github.com/joannekoong/linux/commit/de48d3c29db8ae654300341e3eec12497df54673


---

On Wed, Feb 11, 2026 at 1:03 PM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt;
&gt; On Wed, Feb 11, 2026 at 11:33:05AM -0800, Joanne Koong wrote:
&gt; &gt; ifs-&gt;read_bytes_pending gets initialized to the folio size, but if the
&gt; &gt; file being read in is smaller than the size of the folio, then we
&gt; &gt; reach this scenario because the file has been read in but
&gt; &gt; ifs-&gt;read_bytes_pending is still a positive value because it
&gt; &gt; represents the bytes between the end of the file and the end of the
&gt; &gt; folio. If the folio size is 16k and the file size is 4k:
&gt; &gt;   a) ifs-&gt;read_bytes_pending gets initialized to 16k
&gt; &gt;   b) -&gt;read_folio_range() is called for the 4k read
&gt; &gt;   c) the 4k read succeeds, ifs-&gt;read_bytes_pending is now 12k and the
&gt; &gt; 0 to 4k range is marked uptodate
&gt; &gt;   d) the post-eof blocks are zeroed and marked uptodate in the call to
&gt; &gt; iomap_set_range_uptodate()
&gt;
&gt; This is the bug then.  If they&#x27;re marked uptodate, read_bytes_pending
&gt; should be decremented at the same time.  Now, I appreciate that
&gt; iomap_set_range_uptodate() is called both from iomap_read_folio_iter()
&gt; and __iomap_write_begin(), and it can&#x27;t decrement read_bytes_pending
&gt; in the latter case.  Perhaps a flag or a second length parameter is
&gt; the solution?

I don&#x27;t think it&#x27;s enough to decrement read_bytes_pending by the
zeroed/read-inline length because there&#x27;s these two edge cases:
a) some blocks in the folio were already uptodate from the very
beginning and skipped for IO but not decremented yet from
ifs-&gt;read_bytes_pending, which means in iomap_read_end(),
ifs-&gt;read_bytes_pending would be &gt; 0 and the uptodate flag could get
XORed again. This means we need to also decrement read_bytes_pending
by bytes_submitted as well for this case
b) the async -&gt;read_folio_range() callback finishes after the
zeroing&#x27;s read_bytes_pending decrement and calls folio_end_read(), so
we need to assign ctx-&gt;cur_folio to NULL

I think the code would have to look something like [1] (this is
similar to the alternative approach I mentioned in my previous reply
but fixed up to cover some more edge cases).

Thanks,
Joanne

[1] https://github.com/joannekoong/linux/commit/b42f47726433a8130e8c27d1b43b16e27dfd6960

&gt;
&gt; &gt;   e) iomap_set_range_uptodate() sees all the ranges are marked
&gt; &gt; uptodate and it marks the folio uptodate
&gt; &gt;   f) iomap_read_end() gets called to subtract the 12k from
&gt; &gt; ifs-&gt;read_bytes_pending. it too sees all the ranges are marked
&gt; &gt; uptodate and marks the folio uptodate
&gt; &gt;
&gt; &gt; The same scenario could happen for IOMAP_INLINE mappings if part of
&gt; &gt; the folio is read in through -&gt;read_folio_range() and then the rest is
&gt; &gt; read in as inline data.
&gt;
&gt; This is basically the same case as post-eof.
&gt;
&gt; &gt; An alternative solution is to not have zeroed-out / inlined mappings
&gt; &gt; call iomap_read_end(), eg something like this [1], but this adds
&gt; &gt; additional complexity and doesn&#x27;t work if there&#x27;s additional mappings
&gt; &gt; for the folio after a non-IOMAP_MAPPED mapping.

(I was wrong about it not working for cases where&#x27;s additional
mappings after a non-IOMAP_MAPPED mapping, since both
inline-read/zeroing are no-ops if the entire folio is already
uptodate)

 &gt; &gt;
&gt; &gt; Is there a better approach that I&#x27;m missing?
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Joanne
&gt; &gt;
&gt; &gt; [1] https://github.com/joannekoong/linux/commit/de48d3c29db8ae654300341e3eec12497df54673


---

On Thu, Feb 12, 2026 at 11:31 AM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt;
&gt; On Wed, Feb 11, 2026 at 03:13:48PM -0800, Joanne Koong wrote:
&gt; &gt; On Wed, Feb 11, 2026 at 1:03 PM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Wed, Feb 11, 2026 at 11:33:05AM -0800, Joanne Koong wrote:
&gt; &gt; &gt; &gt; ifs-&gt;read_bytes_pending gets initialized to the folio size, but if the
&gt; &gt; &gt; &gt; file being read in is smaller than the size of the folio, then we
&gt; &gt; &gt; &gt; reach this scenario because the file has been read in but
&gt; &gt; &gt; &gt; ifs-&gt;read_bytes_pending is still a positive value because it
&gt; &gt; &gt; &gt; represents the bytes between the end of the file and the end of the
&gt; &gt; &gt; &gt; folio. If the folio size is 16k and the file size is 4k:
&gt; &gt; &gt; &gt;   a) ifs-&gt;read_bytes_pending gets initialized to 16k
&gt; &gt; &gt; &gt;   b) -&gt;read_folio_range() is called for the 4k read
&gt; &gt; &gt; &gt;   c) the 4k read succeeds, ifs-&gt;read_bytes_pending is now 12k and the
&gt; &gt; &gt; &gt; 0 to 4k range is marked uptodate
&gt; &gt; &gt; &gt;   d) the post-eof blocks are zeroed and marked uptodate in the call to
&gt; &gt; &gt; &gt; iomap_set_range_uptodate()
&gt; &gt; &gt;
&gt; &gt; &gt; This is the bug then.  If they&#x27;re marked uptodate, read_bytes_pending
&gt; &gt; &gt; should be decremented at the same time.  Now, I appreciate that
&gt; &gt; &gt; iomap_set_range_uptodate() is called both from iomap_read_folio_iter()
&gt; &gt; &gt; and __iomap_write_begin(), and it can&#x27;t decrement read_bytes_pending
&gt; &gt; &gt; in the latter case.  Perhaps a flag or a second length parameter is
&gt; &gt; &gt; the solution?
&gt; &gt;
&gt; &gt; I don&#x27;t think it&#x27;s enough to decrement read_bytes_pending by the
&gt; &gt; zeroed/read-inline length because there&#x27;s these two edge cases:
&gt; &gt; a) some blocks in the folio were already uptodate from the very
&gt; &gt; beginning and skipped for IO but not decremented yet from
&gt; &gt; ifs-&gt;read_bytes_pending, which means in iomap_read_end(),
&gt; &gt; ifs-&gt;read_bytes_pending would be &gt; 0 and the uptodate flag could get
&gt; &gt; XORed again. This means we need to also decrement read_bytes_pending
&gt; &gt; by bytes_submitted as well for this case
&gt;
&gt; Hm, that&#x27;s a good one.  It can&#x27;t happen for readahead, but it can happen
&gt; if we start out by writing to some blocks of a folio, then call
&gt; read_folio to get the remaining blocks uptodate.  We could avoid it
&gt; happening by initialising read_bytes_pending to folio_size() -
&gt; bitmap_weight(ifs-&gt;uptodate) * block_size.

This is an interesting idea but if we do this then I think this adds
some more edge cases. For example, the range being inlined or zeroed
may have some already uptodate blocks (eg from a prior buffered write)
so we&#x27;ll need to calculate how many already-existing uptodate bytes
there are in that range to avoid over-decrementing
ifs-&gt;read_bytes_pending. I think we would also have to move the
ifs_alloc() and iomap_read_init() calls to the very beginning of
iomap_read_folio_iter() before any iomap_read_inline_data() call
because there could be the case where a folio has an ifs that was
allocated from a prior write, so if we call iomap_finish_folio_read()
after iomap_read_inline_data(), the folio&#x27;s ifs-&gt;read_bytes_pending
now must be initialized before the inline read. Whereas before, we had
some more optimal behavior with being able to entirely skip the ifs
allocation and read initialization if the entire folio gets read
inline.

&gt;
&gt; &gt; b) the async -&gt;read_folio_range() callback finishes after the
&gt; &gt; zeroing&#x27;s read_bytes_pending decrement and calls folio_end_read(), so
&gt; &gt; we need to assign ctx-&gt;cur_folio to NULL
&gt;
&gt; If we return &#x27;finished&#x27; from iomap_finish_folio_read(), we can handle
&gt; this?

I think there is still this scenario:
- -&gt;read_folio gets called on an 8k-size folio for a 4k-size file
- iomap_read_init() is called, ifs-&gt;read_bytes_pending is now 8k
- make async -&gt;read_folio_range() call to read in 4k
- iomap zeroes out folio from 4k to 8k, then calls
iomap_finish_folio_read() with off = 4k and len = 4k
- in iomap_finish_folio_read(), decrement ifs-&gt;read_bytes_pending by
len. ifs-&gt;read_bytes_pending is now 4k
- async -&gt;read_folio_range() completes read, calls
iomap_finish_folio_read() with off=0 and len = 4k, which now
decrements ifs-&gt;read_bytes_pending by 4k. read_bytes_pending is now 0,
so folio_end_read() gets called. folio should now not be touched by
iomap
- iomap still has valid ctx-&gt;cur_folio, and calls iomap_read_end on
ctx-&gt;cur_folio

This is the same issue as the one in
https://lore.kernel.org/linux-fsdevel/20260126224107.2182262-2-joannelkoong@gmail.com/

We could always set ctx-&gt;cur_folio to NULL after inline/zeroing calls
iomap_finish_folio_read() regardless of whether it actually ended the
read or not, but then this runs into issues for zeroing. The zeroing
can be triggered by non-EOF cases, eg if the first mapping is an
IOMAP_HOLE and then the rest of hte folio is mapped. We may still need
to read in the rest of the folio, so we can&#x27;t just set ctx-&gt;cur_folio
to NULL. i guess one workaround is to explicitly check if the zeroing
is for IOMAP_MAPPED types and if so then always set ctx-&gt;cur_folio to
NULL, but I think this just gets uglier / more complex to understand
and I&#x27;m not sure if there&#x27;s other edge cases I&#x27;m missing that we&#x27;d
need to account for. One other idea is to try avoiding the
iomap_end_read() call for non-error cases if we use your
bitmap_weight() idea above, then it wouldn&#x27;t matter in that scenario
above if ctx-&gt;cur_folio points to a folio that already had read ended
on it. But I think that also just makes the code harder to
read/understand.

The original patch seemed cleanest to me, maybe if we renamed uptodate
to mark_uptodate, it&#x27;d be more appetible?  eg

@@ -80,18 +80,19 @@ static void iomap_set_range_uptodate(struct folio
*folio, size_t off,
 {
        struct iomap_folio_state *ifs = folio-&gt;private;
        unsigned long flags;
-       bool uptodate = true;
+       bool mark_uptodate = true;

        if (folio_test_uptodate(folio))
                return;

        if (ifs) {
                spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
-               uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
+               mark_uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &amp;&amp;
+                       !ifs-&gt;read_bytes_pending;
                spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
        }

-       if (uptodate)
+       if (mark_uptodate)
                folio_mark_uptodate(folio);
 }


Thanks,
Joanne

&gt;
&gt; &gt; I think the code would have to look something like [1] (this is
&gt; &gt; similar to the alternative approach I mentioned in my previous reply
&gt; &gt; but fixed up to cover some more edge cases).
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Joanne
&gt; &gt;
&gt; &gt; [1] https://github.com/joannekoong/linux/commit/b42f47726433a8130e8c27d1b43b16e27dfd6960
&gt;
&gt; I think we can do everything we need with a suitably modified
&gt; iomap_finish_folio_read() rather than the new iomap_finish_read_range().

</pre>
</details>
<div class="review-comment-signals">Signals: race condition, requested changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Christian Brauner</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Christian Brauner applied the patch series to his vfs-6.19.iomap branch and suggested that reviewers report any remaining bugs in a new review, allowing the original patch series to be dropped.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Thu, 25 Sep 2025 17:25:55 -0700, Joanne Koong wrote:
&gt; This series adds fuse iomap support for buffered reads and readahead.
&gt; This is needed so that granular uptodate tracking can be used in fuse when
&gt; large folios are enabled so that only the non-uptodate portions of the folio
&gt; need to be read in instead of having to read in the entire folio. It also is
&gt; needed in order to turn on large folios for servers that use the writeback
&gt; cache since otherwise there is a race condition that may lead to data
&gt; corruption if there is a partial write, then a read and the read happens
&gt; before the write has undergone writeback, since otherwise the folio will not
&gt; be marked uptodate from the partial write so the read will read in the entire
&gt; folio from disk, which will overwrite the partial write.
&gt; 
&gt; [...]

Applied to the vfs-6.19.iomap branch of the vfs/vfs.git tree.
Patches in the vfs-6.19.iomap branch should appear in linux-next soon.

Please report any outstanding bugs that were missed during review in a
new review to the original patch series allowing us to drop it.

It&#x27;s encouraged to provide Acked-bys and Reviewed-bys even though the
patch has now been applied. If possible patch trailers will be updated.

Note that commit hashes shown below are subject to change due to rebase,
trailer updates or similar. If in doubt, please check the listed branch.

tree:   https://git.kernel.org/pub/scm/linux/kernel/git/vfs/vfs.git
branch: vfs-6.19.iomap

[01/14] iomap: move bio read logic into helper function
        https://git.kernel.org/vfs/vfs/c/4b1f54633425
[02/14] iomap: move read/readahead bio submission logic into helper function
        https://git.kernel.org/vfs/vfs/c/22159441469a
[03/14] iomap: store read/readahead bio generically
        https://git.kernel.org/vfs/vfs/c/7c732b99c04f
[04/14] iomap: iterate over folio mapping in iomap_readpage_iter()
        https://git.kernel.org/vfs/vfs/c/3b404627d3e2
[05/14] iomap: rename iomap_readpage_iter() to iomap_read_folio_iter()
        https://git.kernel.org/vfs/vfs/c/bf8b9f4ce6a9
[06/14] iomap: rename iomap_readpage_ctx struct to iomap_read_folio_ctx
        https://git.kernel.org/vfs/vfs/c/abea60c60330
[07/14] iomap: track pending read bytes more optimally
        https://git.kernel.org/vfs/vfs/c/13cc90f6c38e
[08/14] iomap: set accurate iter-&gt;pos when reading folio ranges
        https://git.kernel.org/vfs/vfs/c/63adb033604e
[09/14] iomap: add caller-provided callbacks for read and readahead
        https://git.kernel.org/vfs/vfs/c/56b6f5d3792b
[10/14] iomap: move buffered io bio logic into new file
        https://git.kernel.org/vfs/vfs/c/80cd9857c47f
[11/14] iomap: make iomap_read_folio() a void return
        https://git.kernel.org/vfs/vfs/c/434651f1a9b7
[12/14] fuse: use iomap for read_folio
        https://git.kernel.org/vfs/vfs/c/12cae30dc565
[13/14] fuse: use iomap for readahead
        https://git.kernel.org/vfs/vfs/c/0853f58ed0b4
[14/14] fuse: remove fc-&gt;blkbits workaround for partial writes
        https://git.kernel.org/vfs/vfs/c/bb944dc82db1
</pre>
</details>
<div class="review-comment-signals">Signals: no specific technical concerns mentioned</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Brian Foster</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Brian Foster reported a potential lockup issue on XFS with 1k FSB (-bsize=1k) running generic/051, which landed on patch 07/14 after bisecting. He also suggested adding comments to clarify the naming conventions for accounted and pending read bytes.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Thu, Sep 25, 2025 at 05:26:02PM -0700, Joanne Koong wrote:
&gt; Instead of incrementing read_bytes_pending for every folio range read in
&gt; (which requires acquiring the spinlock to do so), set read_bytes_pending
&gt; to the folio size when the first range is asynchronously read in, keep
&gt; track of how many bytes total are asynchronously read in, and adjust
&gt; read_bytes_pending accordingly after issuing requests to read in all the
&gt; necessary ranges.
&gt; 
&gt; iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
&gt; value for pending bytes necessarily indicates the folio is in the bio.
&gt; 
&gt; Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
&gt; Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
&gt; ---

Hi Joanne,

I was throwing some extra testing at the vfs-6.19.iomap branch since the
little merge conflict thing with iomap_iter_advance(). I end up hitting
what appears to be a lockup on XFS with 1k FSB (-bsize=1k) running
generic/051. It reproduces fairly reliably within a few iterations or so
and seems to always stall during a read for a dedupe operation:

task:fsstress        state:D stack:0     pid:12094 tgid:12094 ppid:12091  task_flags:0x400140 flags:0x00080003
Call Trace:
 &lt;TASK&gt;
 __schedule+0x2fc/0x7a0
 schedule+0x27/0x80
 io_schedule+0x46/0x70
 folio_wait_bit_common+0x12b/0x310
 ? __pfx_wake_page_function+0x10/0x10
 ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
 filemap_read_folio+0x85/0xd0
 ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
 do_read_cache_folio+0x7c/0x1b0
 vfs_dedupe_file_range_compare.constprop.0+0xaf/0x2d0
 __generic_remap_file_range_prep+0x276/0x2a0
 generic_remap_file_range_prep+0x10/0x20
 xfs_reflink_remap_prep+0x22c/0x300 [xfs]
 xfs_file_remap_range+0x84/0x360 [xfs]
 vfs_dedupe_file_range_one+0x1b2/0x1d0
 ? remap_verify_area+0x46/0x140
 vfs_dedupe_file_range+0x162/0x220
 do_vfs_ioctl+0x4d1/0x940
 __x64_sys_ioctl+0x75/0xe0
 do_syscall_64+0x84/0x800
 ? do_syscall_64+0xbb/0x800
 ? avc_has_perm_noaudit+0x6b/0xf0
 ? _copy_to_user+0x31/0x40
 ? cp_new_stat+0x130/0x170
 ? __do_sys_newfstat+0x44/0x70
 ? do_syscall_64+0xbb/0x800
 ? do_syscall_64+0xbb/0x800
 ? clear_bhb_loop+0x30/0x80
 ? clear_bhb_loop+0x30/0x80
 entry_SYSCALL_64_after_hwframe+0x76/0x7e
RIP: 0033:0x7fe6bbd9a14d
RSP: 002b:00007ffde72cd4e0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 0000000000000068 RCX: 00007fe6bbd9a14d
RDX: 000000000a1394b0 RSI: 00000000c0189436 RDI: 0000000000000004
RBP: 00007ffde72cd530 R08: 0000000000001000 R09: 000000000a11a3fc
R10: 000000000001d6c0 R11: 0000000000000246 R12: 000000000a12cfb0
R13: 000000000a12ba10 R14: 000000000a14e610 R15: 0000000000019000
 &lt;/TASK&gt;

It wasn&#x27;t immediately clear to me what the issue was so I bisected and
it landed on this patch. It kind of looks like we&#x27;re failing to unlock a
folio at some point and then tripping over it later..? I can kill the
fsstress process but then the umount ultimately gets stuck tossing
pagecache [1], so the mount still ends up stuck indefinitely. Anyways,
I&#x27;ll poke at it some more but I figure you might be able to make sense
of this faster than I can.

Brian

[1] umount stack trace: 

task:umount          state:D stack:0     pid:12216 tgid:12216 ppid:2514   task_flags:0x400100 flags:0x00080001
Call Trace:
 &lt;TASK&gt;
 __schedule+0x2fc/0x7a0
 schedule+0x27/0x80
 io_schedule+0x46/0x70
 folio_wait_bit_common+0x12b/0x310
 ? __pfx_wake_page_function+0x10/0x10
 truncate_inode_pages_range+0x42a/0x4d0
 xfs_fs_evict_inode+0x1f/0x30 [xfs]
 evict+0x112/0x290
 evict_inodes+0x209/0x230
 generic_shutdown_super+0x42/0x100
 kill_block_super+0x1a/0x40
 xfs_kill_sb+0x12/0x20 [xfs]
 deactivate_locked_super+0x33/0xb0
 cleanup_mnt+0xba/0x150
 task_work_run+0x5c/0x90
 exit_to_user_mode_loop+0x12f/0x170
 do_syscall_64+0x1af/0x800
 ? vfs_statx+0x80/0x160
 ? do_statx+0x62/0xa0
 ? __x64_sys_statx+0xaf/0x100
 ? do_syscall_64+0xbb/0x800
 ? __x64_sys_statx+0xaf/0x100
 ? do_syscall_64+0xbb/0x800
 ? count_memcg_events+0xdd/0x1b0
 ? handle_mm_fault+0x220/0x340
 ? do_user_addr_fault+0x2c3/0x7f0
 ? clear_bhb_loop+0x30/0x80
 ? clear_bhb_loop+0x30/0x80
 entry_SYSCALL_64_after_hwframe+0x76/0x7e
RIP: 0033:0x7fdd641ed5ab
RSP: 002b:00007ffd671182e8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
RAX: 0000000000000000 RBX: 0000559b3e2056b0 RCX: 00007fdd641ed5ab
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000559b3e205ac0
RBP: 00007ffd671183c0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000103 R11: 0000000000000246 R12: 0000559b3e2057b8
R13: 0000000000000000 R14: 0000559b3e205ac0 R15: 0000000000000000
 &lt;/TASK&gt;

&gt;  fs/iomap/buffered-io.c | 87 ++++++++++++++++++++++++++++++++----------
&gt;  1 file changed, 66 insertions(+), 21 deletions(-)
&gt; 
&gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; index 09e65771a947..4e6258fdb915 100644
&gt; --- a/fs/iomap/buffered-io.c
&gt; +++ b/fs/iomap/buffered-io.c
&gt; @@ -362,7 +362,6 @@ static void iomap_read_end_io(struct bio *bio)
&gt;  
&gt;  struct iomap_read_folio_ctx {
&gt;  	struct folio		*cur_folio;
&gt; -	bool			cur_folio_in_bio;
&gt;  	void			*read_ctx;
&gt;  	struct readahead_control *rac;
&gt;  };
&gt; @@ -380,19 +379,11 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
&gt;  {
&gt;  	struct folio *folio = ctx-&gt;cur_folio;
&gt;  	const struct iomap *iomap = &amp;iter-&gt;iomap;
&gt; -	struct iomap_folio_state *ifs = folio-&gt;private;
&gt;  	size_t poff = offset_in_folio(folio, pos);
&gt;  	loff_t length = iomap_length(iter);
&gt;  	sector_t sector;
&gt;  	struct bio *bio = ctx-&gt;read_ctx;
&gt;  
&gt; -	ctx-&gt;cur_folio_in_bio = true;
&gt; -	if (ifs) {
&gt; -		spin_lock_irq(&amp;ifs-&gt;state_lock);
&gt; -		ifs-&gt;read_bytes_pending += plen;
&gt; -		spin_unlock_irq(&amp;ifs-&gt;state_lock);
&gt; -	}
&gt; -
&gt;  	sector = iomap_sector(iomap, pos);
&gt;  	if (!bio || bio_end_sector(bio) != sector ||
&gt;  	    !bio_add_folio(bio, folio, plen, poff)) {
&gt; @@ -422,8 +413,57 @@ static void iomap_bio_read_folio_range(const struct iomap_iter *iter,
&gt;  	}
&gt;  }
&gt;  
&gt; +static void iomap_read_init(struct folio *folio)
&gt; +{
&gt; +	struct iomap_folio_state *ifs = folio-&gt;private;
&gt; +
&gt; +	if (ifs) {
&gt; +		size_t len = folio_size(folio);
&gt; +
&gt; +		spin_lock_irq(&amp;ifs-&gt;state_lock);
&gt; +		ifs-&gt;read_bytes_pending += len;
&gt; +		spin_unlock_irq(&amp;ifs-&gt;state_lock);
&gt; +	}
&gt; +}
&gt; +
&gt; +static void iomap_read_end(struct folio *folio, size_t bytes_pending)
&gt; +{
&gt; +	struct iomap_folio_state *ifs;
&gt; +
&gt; +	/*
&gt; +	 * If there are no bytes pending, this means we are responsible for
&gt; +	 * unlocking the folio here, since no IO helper has taken ownership of
&gt; +	 * it.
&gt; +	 */
&gt; +	if (!bytes_pending) {
&gt; +		folio_unlock(folio);
&gt; +		return;
&gt; +	}
&gt; +
&gt; +	ifs = folio-&gt;private;
&gt; +	if (ifs) {
&gt; +		bool end_read, uptodate;
&gt; +		size_t bytes_accounted = folio_size(folio) - bytes_pending;
&gt; +
&gt; +		spin_lock_irq(&amp;ifs-&gt;state_lock);
&gt; +		ifs-&gt;read_bytes_pending -= bytes_accounted;
&gt; +		/*
&gt; +		 * If !ifs-&gt;read_bytes_pending, this means all pending reads
&gt; +		 * by the IO helper have already completed, which means we need
&gt; +		 * to end the folio read here. If ifs-&gt;read_bytes_pending != 0,
&gt; +		 * the IO helper will end the folio read.
&gt; +		 */
&gt; +		end_read = !ifs-&gt;read_bytes_pending;
&gt; +		if (end_read)
&gt; +			uptodate = ifs_is_fully_uptodate(folio, ifs);
&gt; +		spin_unlock_irq(&amp;ifs-&gt;state_lock);
&gt; +		if (end_read)
&gt; +			folio_end_read(folio, uptodate);
&gt; +	}
&gt; +}
&gt; +
&gt;  static int iomap_read_folio_iter(struct iomap_iter *iter,
&gt; -		struct iomap_read_folio_ctx *ctx)
&gt; +		struct iomap_read_folio_ctx *ctx, size_t *bytes_pending)
&gt;  {
&gt;  	const struct iomap *iomap = &amp;iter-&gt;iomap;
&gt;  	loff_t pos = iter-&gt;pos;
&gt; @@ -460,6 +500,9 @@ static int iomap_read_folio_iter(struct iomap_iter *iter,
&gt;  			folio_zero_range(folio, poff, plen);
&gt;  			iomap_set_range_uptodate(folio, poff, plen);
&gt;  		} else {
&gt; +			if (!*bytes_pending)
&gt; +				iomap_read_init(folio);
&gt; +			*bytes_pending += plen;
&gt;  			iomap_bio_read_folio_range(iter, ctx, pos, plen);
&gt;  		}
&gt;  
&gt; @@ -482,17 +525,18 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
&gt;  	struct iomap_read_folio_ctx ctx = {
&gt;  		.cur_folio	= folio,
&gt;  	};
&gt; +	size_t bytes_pending = 0;
&gt;  	int ret;
&gt;  
&gt;  	trace_iomap_readpage(iter.inode, 1);
&gt;  
&gt;  	while ((ret = iomap_iter(&amp;iter, ops)) &gt; 0)
&gt; -		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx);
&gt; +		iter.status = iomap_read_folio_iter(&amp;iter, &amp;ctx,
&gt; +				&amp;bytes_pending);
&gt;  
&gt;  	iomap_bio_submit_read(&amp;ctx);
&gt;  
&gt; -	if (!ctx.cur_folio_in_bio)
&gt; -		folio_unlock(folio);
&gt; +	iomap_read_end(folio, bytes_pending);
&gt;  
&gt;  	/*
&gt;  	 * Just like mpage_readahead and block_read_full_folio, we always
&gt; @@ -504,24 +548,23 @@ int iomap_read_folio(struct folio *folio, const struct iomap_ops *ops)
&gt;  EXPORT_SYMBOL_GPL(iomap_read_folio);
&gt;  
&gt;  static int iomap_readahead_iter(struct iomap_iter *iter,
&gt; -		struct iomap_read_folio_ctx *ctx)
&gt; +		struct iomap_read_folio_ctx *ctx, size_t *cur_bytes_pending)
&gt;  {
&gt;  	int ret;
&gt;  
&gt;  	while (iomap_length(iter)) {
&gt;  		if (ctx-&gt;cur_folio &amp;&amp;
&gt;  		    offset_in_folio(ctx-&gt;cur_folio, iter-&gt;pos) == 0) {
&gt; -			if (!ctx-&gt;cur_folio_in_bio)
&gt; -				folio_unlock(ctx-&gt;cur_folio);
&gt; +			iomap_read_end(ctx-&gt;cur_folio, *cur_bytes_pending);
&gt;  			ctx-&gt;cur_folio = NULL;
&gt;  		}
&gt;  		if (!ctx-&gt;cur_folio) {
&gt;  			ctx-&gt;cur_folio = readahead_folio(ctx-&gt;rac);
&gt;  			if (WARN_ON_ONCE(!ctx-&gt;cur_folio))
&gt;  				return -EINVAL;
&gt; -			ctx-&gt;cur_folio_in_bio = false;
&gt; +			*cur_bytes_pending = 0;
&gt;  		}
&gt; -		ret = iomap_read_folio_iter(iter, ctx);
&gt; +		ret = iomap_read_folio_iter(iter, ctx, cur_bytes_pending);
&gt;  		if (ret)
&gt;  			return ret;
&gt;  	}
&gt; @@ -554,16 +597,18 @@ void iomap_readahead(struct readahead_control *rac, const struct iomap_ops *ops)
&gt;  	struct iomap_read_folio_ctx ctx = {
&gt;  		.rac	= rac,
&gt;  	};
&gt; +	size_t cur_bytes_pending;
&gt;  
&gt;  	trace_iomap_readahead(rac-&gt;mapping-&gt;host, readahead_count(rac));
&gt;  
&gt;  	while (iomap_iter(&amp;iter, ops) &gt; 0)
&gt; -		iter.status = iomap_readahead_iter(&amp;iter, &amp;ctx);
&gt; +		iter.status = iomap_readahead_iter(&amp;iter, &amp;ctx,
&gt; +					&amp;cur_bytes_pending);
&gt;  
&gt;  	iomap_bio_submit_read(&amp;ctx);
&gt;  
&gt; -	if (ctx.cur_folio &amp;&amp; !ctx.cur_folio_in_bio)
&gt; -		folio_unlock(ctx.cur_folio);
&gt; +	if (ctx.cur_folio)
&gt; +		iomap_read_end(ctx.cur_folio, cur_bytes_pending);
&gt;  }
&gt;  EXPORT_SYMBOL_GPL(iomap_readahead);
&gt;  
&gt; -- 
&gt; 2.47.3
&gt; 
&gt; 



---

On Fri, Oct 24, 2025 at 09:25:13AM -0700, Joanne Koong wrote:
&gt; On Thu, Oct 23, 2025 at 5:01\u202fPM Joanne Koong &lt;joannelkoong@gmail.com&gt; wrote:
&gt; &gt;
&gt; &gt; On Thu, Oct 23, 2025 at 12:30\u202fPM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Thu, Sep 25, 2025 at 05:26:02PM -0700, Joanne Koong wrote:
&gt; &gt; &gt; &gt; Instead of incrementing read_bytes_pending for every folio range read in
&gt; &gt; &gt; &gt; (which requires acquiring the spinlock to do so), set read_bytes_pending
&gt; &gt; &gt; &gt; to the folio size when the first range is asynchronously read in, keep
&gt; &gt; &gt; &gt; track of how many bytes total are asynchronously read in, and adjust
&gt; &gt; &gt; &gt; read_bytes_pending accordingly after issuing requests to read in all the
&gt; &gt; &gt; &gt; necessary ranges.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
&gt; &gt; &gt; &gt; value for pending bytes necessarily indicates the folio is in the bio.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
&gt; &gt; &gt; &gt; Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
&gt; &gt; &gt; &gt; ---
&gt; &gt; &gt;
&gt; &gt; &gt; Hi Joanne,
&gt; &gt; &gt;
&gt; &gt; &gt; I was throwing some extra testing at the vfs-6.19.iomap branch since the
&gt; &gt; &gt; little merge conflict thing with iomap_iter_advance(). I end up hitting
&gt; &gt; &gt; what appears to be a lockup on XFS with 1k FSB (-bsize=1k) running
&gt; &gt; &gt; generic/051. It reproduces fairly reliably within a few iterations or so
&gt; &gt; &gt; and seems to always stall during a read for a dedupe operation:
&gt; &gt; &gt;
&gt; &gt; &gt; task:fsstress        state:D stack:0     pid:12094 tgid:12094 ppid:12091  task_flags:0x400140 flags:0x00080003
&gt; &gt; &gt; Call Trace:
&gt; &gt; &gt;  &lt;TASK&gt;
&gt; &gt; &gt;  __schedule+0x2fc/0x7a0
&gt; &gt; &gt;  schedule+0x27/0x80
&gt; &gt; &gt;  io_schedule+0x46/0x70
&gt; &gt; &gt;  folio_wait_bit_common+0x12b/0x310
&gt; &gt; &gt;  ? __pfx_wake_page_function+0x10/0x10
&gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt;  filemap_read_folio+0x85/0xd0
&gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt;  do_read_cache_folio+0x7c/0x1b0
&gt; &gt; &gt;  vfs_dedupe_file_range_compare.constprop.0+0xaf/0x2d0
&gt; &gt; &gt;  __generic_remap_file_range_prep+0x276/0x2a0
&gt; &gt; &gt;  generic_remap_file_range_prep+0x10/0x20
&gt; &gt; &gt;  xfs_reflink_remap_prep+0x22c/0x300 [xfs]
&gt; &gt; &gt;  xfs_file_remap_range+0x84/0x360 [xfs]
&gt; &gt; &gt;  vfs_dedupe_file_range_one+0x1b2/0x1d0
&gt; &gt; &gt;  ? remap_verify_area+0x46/0x140
&gt; &gt; &gt;  vfs_dedupe_file_range+0x162/0x220
&gt; &gt; &gt;  do_vfs_ioctl+0x4d1/0x940
&gt; &gt; &gt;  __x64_sys_ioctl+0x75/0xe0
&gt; &gt; &gt;  do_syscall_64+0x84/0x800
&gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt;  ? avc_has_perm_noaudit+0x6b/0xf0
&gt; &gt; &gt;  ? _copy_to_user+0x31/0x40
&gt; &gt; &gt;  ? cp_new_stat+0x130/0x170
&gt; &gt; &gt;  ? __do_sys_newfstat+0x44/0x70
&gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt;  entry_SYSCALL_64_after_hwframe+0x76/0x7e
&gt; &gt; &gt; RIP: 0033:0x7fe6bbd9a14d
&gt; &gt; &gt; RSP: 002b:00007ffde72cd4e0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
&gt; &gt; &gt; RAX: ffffffffffffffda RBX: 0000000000000068 RCX: 00007fe6bbd9a14d
&gt; &gt; &gt; RDX: 000000000a1394b0 RSI: 00000000c0189436 RDI: 0000000000000004
&gt; &gt; &gt; RBP: 00007ffde72cd530 R08: 0000000000001000 R09: 000000000a11a3fc
&gt; &gt; &gt; R10: 000000000001d6c0 R11: 0000000000000246 R12: 000000000a12cfb0
&gt; &gt; &gt; R13: 000000000a12ba10 R14: 000000000a14e610 R15: 0000000000019000
&gt; &gt; &gt;  &lt;/TASK&gt;
&gt; &gt; &gt;
&gt; &gt; &gt; It wasn&#x27;t immediately clear to me what the issue was so I bisected and
&gt; &gt; &gt; it landed on this patch. It kind of looks like we&#x27;re failing to unlock a
&gt; &gt; &gt; folio at some point and then tripping over it later..? I can kill the
&gt; &gt; &gt; fsstress process but then the umount ultimately gets stuck tossing
&gt; &gt; &gt; pagecache [1], so the mount still ends up stuck indefinitely. Anyways,
&gt; &gt; &gt; I&#x27;ll poke at it some more but I figure you might be able to make sense
&gt; &gt; &gt; of this faster than I can.
&gt; &gt; &gt;
&gt; &gt; &gt; Brian
&gt; &gt;
&gt; &gt; Hi Brian,
&gt; &gt;
&gt; &gt; Thanks for your report and the repro instructions. I will look into
&gt; &gt; this and report back what I find.
&gt; 
&gt; This is the fix:
&gt; 
&gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; index 4e6258fdb915..aa46fec8362d 100644
&gt; --- a/fs/iomap/buffered-io.c
&gt; +++ b/fs/iomap/buffered-io.c
&gt; @@ -445,6 +445,9 @@ static void iomap_read_end(struct folio *folio,
&gt; size_t bytes_pending)
&gt;                 bool end_read, uptodate;
&gt;                 size_t bytes_accounted = folio_size(folio) - bytes_pending;
&gt; 
&gt; +               if (!bytes_accounted)
&gt; +                       return;
&gt; +
&gt;                 spin_lock_irq(&amp;ifs-&gt;state_lock);
&gt; 
&gt; 
&gt; What I missed was that if all the bytes in the folio are non-uptodate
&gt; and need to read in by the filesystem, then there&#x27;s a bug where the
&gt; read will be ended on the folio twice (in iomap_read_end() and when
&gt; the filesystem calls iomap_finish_folio_write(), when only the
&gt; filesystem should end the read), which does 2 folio unlocks which ends
&gt; up locking the folio. Looking at the writeback patch that does a
&gt; similar optimization [1], I miss the same thing there.
&gt; 

Makes sense.. though a short comment wouldn&#x27;t hurt in there. ;) I found
myself a little confused by the accounted vs. pending naming when
reading through that code. If I follow correctly, the intent is to refer
to the additional bytes accounted to read_bytes_pending via the init
(where it just accounts the whole folio up front) and pending refers to
submitted I/O.

Presumably that extra accounting doubly serves as the typical &quot;don&#x27;t
complete the op before the submitter is done processing&quot; extra
reference, except in this full submit case of course. If so, that&#x27;s
subtle enough in my mind that a sentence or two on it wouldn&#x27;t hurt..

&gt; I&#x27;ll fix up both. Thanks for catching this and bisecting it down to
&gt; this patch. Sorry for the trouble.
&gt; 

No prob. Thanks for the fix!

Brian

&gt; Thanks,
&gt; Joanne
&gt; 
&gt; [1] https://lore.kernel.org/linux-fsdevel/20251009225611.3744728-4-joannelkoong@gmail.com/
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Joanne
&gt; &gt; &gt;
&gt; 



---

On Fri, Oct 24, 2025 at 02:55:20PM -0700, Joanne Koong wrote:
&gt; On Fri, Oct 24, 2025 at 12:48\u202fPM Joanne Koong &lt;joannelkoong@gmail.com&gt; wrote:
&gt; &gt;
&gt; &gt; On Fri, Oct 24, 2025 at 10:10\u202fAM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; On Fri, Oct 24, 2025 at 09:25:13AM -0700, Joanne Koong wrote:
&gt; &gt; &gt; &gt; On Thu, Oct 23, 2025 at 5:01\u202fPM Joanne Koong &lt;joannelkoong@gmail.com&gt; wrote:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; On Thu, Oct 23, 2025 at 12:30\u202fPM Brian Foster &lt;bfoster@redhat.com&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; On Thu, Sep 25, 2025 at 05:26:02PM -0700, Joanne Koong wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Instead of incrementing read_bytes_pending for every folio range read in
&gt; &gt; &gt; &gt; &gt; &gt; &gt; (which requires acquiring the spinlock to do so), set read_bytes_pending
&gt; &gt; &gt; &gt; &gt; &gt; &gt; to the folio size when the first range is asynchronously read in, keep
&gt; &gt; &gt; &gt; &gt; &gt; &gt; track of how many bytes total are asynchronously read in, and adjust
&gt; &gt; &gt; &gt; &gt; &gt; &gt; read_bytes_pending accordingly after issuing requests to read in all the
&gt; &gt; &gt; &gt; &gt; &gt; &gt; necessary ranges.
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; iomap_read_folio_ctx-&gt;cur_folio_in_bio can be removed since a non-zero
&gt; &gt; &gt; &gt; &gt; &gt; &gt; value for pending bytes necessarily indicates the folio is in the bio.
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Joanne Koong &lt;joannelkoong@gmail.com&gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; Suggested-by: &quot;Darrick J. Wong&quot; &lt;djwong@kernel.org&gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; ---
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Hi Joanne,
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; I was throwing some extra testing at the vfs-6.19.iomap branch since the
&gt; &gt; &gt; &gt; &gt; &gt; little merge conflict thing with iomap_iter_advance(). I end up hitting
&gt; &gt; &gt; &gt; &gt; &gt; what appears to be a lockup on XFS with 1k FSB (-bsize=1k) running
&gt; &gt; &gt; &gt; &gt; &gt; generic/051. It reproduces fairly reliably within a few iterations or so
&gt; &gt; &gt; &gt; &gt; &gt; and seems to always stall during a read for a dedupe operation:
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; task:fsstress        state:D stack:0     pid:12094 tgid:12094 ppid:12091  task_flags:0x400140 flags:0x00080003
&gt; &gt; &gt; &gt; &gt; &gt; Call Trace:
&gt; &gt; &gt; &gt; &gt; &gt;  &lt;TASK&gt;
&gt; &gt; &gt; &gt; &gt; &gt;  __schedule+0x2fc/0x7a0
&gt; &gt; &gt; &gt; &gt; &gt;  schedule+0x27/0x80
&gt; &gt; &gt; &gt; &gt; &gt;  io_schedule+0x46/0x70
&gt; &gt; &gt; &gt; &gt; &gt;  folio_wait_bit_common+0x12b/0x310
&gt; &gt; &gt; &gt; &gt; &gt;  ? __pfx_wake_page_function+0x10/0x10
&gt; &gt; &gt; &gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt; &gt; &gt; &gt;  filemap_read_folio+0x85/0xd0
&gt; &gt; &gt; &gt; &gt; &gt;  ? __pfx_xfs_vm_read_folio+0x10/0x10 [xfs]
&gt; &gt; &gt; &gt; &gt; &gt;  do_read_cache_folio+0x7c/0x1b0
&gt; &gt; &gt; &gt; &gt; &gt;  vfs_dedupe_file_range_compare.constprop.0+0xaf/0x2d0
&gt; &gt; &gt; &gt; &gt; &gt;  __generic_remap_file_range_prep+0x276/0x2a0
&gt; &gt; &gt; &gt; &gt; &gt;  generic_remap_file_range_prep+0x10/0x20
&gt; &gt; &gt; &gt; &gt; &gt;  xfs_reflink_remap_prep+0x22c/0x300 [xfs]
&gt; &gt; &gt; &gt; &gt; &gt;  xfs_file_remap_range+0x84/0x360 [xfs]
&gt; &gt; &gt; &gt; &gt; &gt;  vfs_dedupe_file_range_one+0x1b2/0x1d0
&gt; &gt; &gt; &gt; &gt; &gt;  ? remap_verify_area+0x46/0x140
&gt; &gt; &gt; &gt; &gt; &gt;  vfs_dedupe_file_range+0x162/0x220
&gt; &gt; &gt; &gt; &gt; &gt;  do_vfs_ioctl+0x4d1/0x940
&gt; &gt; &gt; &gt; &gt; &gt;  __x64_sys_ioctl+0x75/0xe0
&gt; &gt; &gt; &gt; &gt; &gt;  do_syscall_64+0x84/0x800
&gt; &gt; &gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt; &gt; &gt;  ? avc_has_perm_noaudit+0x6b/0xf0
&gt; &gt; &gt; &gt; &gt; &gt;  ? _copy_to_user+0x31/0x40
&gt; &gt; &gt; &gt; &gt; &gt;  ? cp_new_stat+0x130/0x170
&gt; &gt; &gt; &gt; &gt; &gt;  ? __do_sys_newfstat+0x44/0x70
&gt; &gt; &gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt; &gt; &gt;  ? do_syscall_64+0xbb/0x800
&gt; &gt; &gt; &gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt; &gt; &gt; &gt;  ? clear_bhb_loop+0x30/0x80
&gt; &gt; &gt; &gt; &gt; &gt;  entry_SYSCALL_64_after_hwframe+0x76/0x7e
&gt; &gt; &gt; &gt; &gt; &gt; RIP: 0033:0x7fe6bbd9a14d
&gt; &gt; &gt; &gt; &gt; &gt; RSP: 002b:00007ffde72cd4e0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
&gt; &gt; &gt; &gt; &gt; &gt; RAX: ffffffffffffffda RBX: 0000000000000068 RCX: 00007fe6bbd9a14d
&gt; &gt; &gt; &gt; &gt; &gt; RDX: 000000000a1394b0 RSI: 00000000c0189436 RDI: 0000000000000004
&gt; &gt; &gt; &gt; &gt; &gt; RBP: 00007ffde72cd530 R08: 0000000000001000 R09: 000000000a11a3fc
&gt; &gt; &gt; &gt; &gt; &gt; R10: 000000000001d6c0 R11: 0000000000000246 R12: 000000000a12cfb0
&gt; &gt; &gt; &gt; &gt; &gt; R13: 000000000a12ba10 R14: 000000000a14e610 R15: 0000000000019000
&gt; &gt; &gt; &gt; &gt; &gt;  &lt;/TASK&gt;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; It wasn&#x27;t immediately clear to me what the issue was so I bisected and
&gt; &gt; &gt; &gt; &gt; &gt; it landed on this patch. It kind of looks like we&#x27;re failing to unlock a
&gt; &gt; &gt; &gt; &gt; &gt; folio at some point and then tripping over it later..? I can kill the
&gt; &gt; &gt; &gt; &gt; &gt; fsstress process but then the umount ultimately gets stuck tossing
&gt; &gt; &gt; &gt; &gt; &gt; pagecache [1], so the mount still ends up stuck indefinitely. Anyways,
&gt; &gt; &gt; &gt; &gt; &gt; I&#x27;ll poke at it some more but I figure you might be able to make sense
&gt; &gt; &gt; &gt; &gt; &gt; of this faster than I can.
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Brian
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Hi Brian,
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Thanks for your report and the repro instructions. I will look into
&gt; &gt; &gt; &gt; &gt; this and report back what I find.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; This is the fix:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; &gt; &gt; &gt; index 4e6258fdb915..aa46fec8362d 100644
&gt; &gt; &gt; &gt; --- a/fs/iomap/buffered-io.c
&gt; &gt; &gt; &gt; +++ b/fs/iomap/buffered-io.c
&gt; &gt; &gt; &gt; @@ -445,6 +445,9 @@ static void iomap_read_end(struct folio *folio,
&gt; &gt; &gt; &gt; size_t bytes_pending)
&gt; &gt; &gt; &gt;                 bool end_read, uptodate;
&gt; &gt; &gt; &gt;                 size_t bytes_accounted = folio_size(folio) - bytes_pending;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; +               if (!bytes_accounted)
&gt; &gt; &gt; &gt; +                       return;
&gt; &gt; &gt; &gt; +
&gt; &gt; &gt; &gt;                 spin_lock_irq(&amp;ifs-&gt;state_lock);
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; What I missed was that if all the bytes in the folio are non-uptodate
&gt; &gt; &gt; &gt; and need to read in by the filesystem, then there&#x27;s a bug where the
&gt; &gt; &gt; &gt; read will be ended on the folio twice (in iomap_read_end() and when
&gt; &gt; &gt; &gt; the filesystem calls iomap_finish_folio_write(), when only the
&gt; &gt; &gt; &gt; filesystem should end the read), which does 2 folio unlocks which ends
&gt; &gt; &gt; &gt; up locking the folio. Looking at the writeback patch that does a
&gt; &gt; &gt; &gt; similar optimization [1], I miss the same thing there.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; Makes sense.. though a short comment wouldn&#x27;t hurt in there. ;) I found
&gt; &gt; &gt; myself a little confused by the accounted vs. pending naming when
&gt; &gt; &gt; reading through that code. If I follow correctly, the intent is to refer
&gt; &gt; &gt; to the additional bytes accounted to read_bytes_pending via the init
&gt; &gt; &gt; (where it just accounts the whole folio up front) and pending refers to
&gt; &gt; &gt; submitted I/O.
&gt; &gt; &gt;
&gt; &gt; &gt; Presumably that extra accounting doubly serves as the typical &quot;don&#x27;t
&gt; &gt; &gt; complete the op before the submitter is done processing&quot; extra
&gt; &gt; &gt; reference, except in this full submit case of course. If so, that&#x27;s
&gt; &gt; &gt; subtle enough in my mind that a sentence or two on it wouldn&#x27;t hurt..
&gt; &gt;
&gt; &gt; I will add some a comment about this :) That&#x27;s a good point about the
&gt; &gt; naming, maybe &quot;bytes_submitted&quot; and &quot;bytes_unsubmitted&quot; is a lot less
&gt; &gt; confusing than &quot;bytes_pending&quot; and &quot;bytes_accounted&quot;.
&gt; 
&gt; Thinking about this some more, bytes_unsubmitted sounds even more
&gt; confusing, so maybe bytes_nonsubmitted or bytes_not_submitted. I&#x27;ll
&gt; think about this some more but kept it as pending/accounted for now.
&gt; 

bytes_submitted sounds better than pending to me, not sure about
unsubmitted or whatever. As long as there&#x27;s a sentence or two that
explains what accounted means in the end helper, though, that seems
reasonable enough to me.

Brian

&gt; The fix for this bug is here [1].
&gt; 
&gt; Thanks,
&gt; Joanne
&gt; 
&gt; [1] https://lore.kernel.org/linux-fsdevel/20251024215008.3844068-1-joannelkoong@gmail.com/
&gt; 
&gt; &gt;
&gt; &gt; Thanks,
&gt; &gt; Joanne
&gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; &gt; I&#x27;ll fix up both. Thanks for catching this and bisecting it down to
&gt; &gt; &gt; &gt; this patch. Sorry for the trouble.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; No prob. Thanks for the fix!
&gt; &gt; &gt;
&gt; &gt; &gt; Brian
&gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thanks,
&gt; &gt; &gt; &gt; Joanne
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; [1] https://lore.kernel.org/linux-fsdevel/20251009225611.3744728-4-joannelkoong@gmail.com/
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Thanks,
&gt; &gt; &gt; &gt; &gt; Joanne
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt;
&gt; 

</pre>
</details>
<div class="review-comment-signals">Signals: potential bug, requested changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Matthew Wilcox</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Matthew Wilcox pointed out that the patch does not correctly fix the race between iomap_set_range_uptodate and folio_end_read, suggesting that read_bytes_pending should be decremented at the same time as marking a range uptodate. He also proposed several alternative solutions to address this issue.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Fri, Oct 24, 2025 at 09:25:13AM -0700, Joanne Koong wrote:
&gt; What I missed was that if all the bytes in the folio are non-uptodate
&gt; and need to read in by the filesystem, then there&#x27;s a bug where the
&gt; read will be ended on the folio twice (in iomap_read_end() and when
&gt; the filesystem calls iomap_finish_folio_write(), when only the
&gt; filesystem should end the read), which does 2 folio unlocks which ends
&gt; up locking the folio. Looking at the writeback patch that does a
&gt; similar optimization [1], I miss the same thing there.

folio_unlock() contains:
        VM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);

Feels like more filesystem people should be enabling CONFIG_DEBUG_VM
when testing (excluding performance testing of course; it&#x27;ll do ugly
things to your performance numbers).


---

On Fri, Oct 24, 2025 at 12:22:32PM -0700, Joanne Koong wrote:
&gt; &gt; Feels like more filesystem people should be enabling CONFIG_DEBUG_VM
&gt; &gt; when testing (excluding performance testing of course; it&#x27;ll do ugly
&gt; &gt; things to your performance numbers).
&gt; 
&gt; Point taken. It looks like there&#x27;s a bunch of other memory debugging
&gt; configs as well. Do you recommend enabling all of these when testing?
&gt; Do you have a particular .config you use for when you run tests?

Our Kconfig is far too ornate.  We could do with a &quot;recommended for
kernel developers&quot; profile.  Here&#x27;s what I&#x27;m currently using, though I
know it&#x27;s changed over time:

CONFIG_X86_DEBUGCTLMSR=y
CONFIG_PM_DEBUG=y
CONFIG_PM_SLEEP_DEBUG=y
CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
CONFIG_BLK_DEBUG_FS=y
CONFIG_PNP_DEBUG_MESSAGES=y
CONFIG_SCSI_DEBUG=m
CONFIG_EXT4_DEBUG=y
CONFIG_JFS_DEBUG=y
CONFIG_XFS_DEBUG=y
CONFIG_BTRFS_DEBUG=y
CONFIG_UFS_DEBUG=y
CONFIG_DEBUG_BUGVERBOSE=y
CONFIG_DEBUG_KERNEL=y
CONFIG_DEBUG_MISC=y
CONFIG_DEBUG_INFO=y
CONFIG_DEBUG_INFO_DWARF4=y
CONFIG_DEBUG_INFO_COMPRESSED_NONE=y
CONFIG_DEBUG_FS=y
CONFIG_DEBUG_FS_ALLOW_ALL=y
CONFIG_ARCH_HAS_EARLY_DEBUG=y
CONFIG_SLUB_DEBUG=y
CONFIG_ARCH_HAS_DEBUG_WX=y
CONFIG_HAVE_DEBUG_KMEMLEAK=y
CONFIG_SHRINKER_DEBUG=y
CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE=y
CONFIG_DEBUG_VM_IRQSOFF=y
CONFIG_DEBUG_VM=y
CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
CONFIG_DEBUG_MEMORY_INIT=y
CONFIG_LOCK_DEBUGGING_SUPPORT=y
CONFIG_DEBUG_RT_MUTEXES=y
CONFIG_DEBUG_SPINLOCK=y
CONFIG_DEBUG_MUTEXES=y
CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
CONFIG_DEBUG_RWSEMS=y
CONFIG_DEBUG_LOCK_ALLOC=y
CONFIG_DEBUG_LIST=y
CONFIG_X86_DEBUG_FPU=y
CONFIG_FAULT_INJECTION_DEBUG_FS=y

(output from grep DEBUG .build/.config |grep -v ^#)


---

On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt; On Tue, Dec 23, 2025 at 2:30\u202fPM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt; &gt;
&gt; 
&gt; Hi Sasha,
&gt; 
&gt; Thanks for your patch and for the detailed writeup.

The important line to note is:

Assisted-by: claude-opus-4-5-20251101

So Sasha has produced a very convincingly worded writeup that&#x27;s
hallucinated.



---

On Wed, Dec 24, 2025 at 10:43:58AM -0500, Sasha Levin wrote:
&gt; On Wed, Dec 24, 2025 at 02:10:19AM +0000, Matthew Wilcox wrote:
&gt; &gt; So Sasha has produced a very convincingly worded writeup that&#x27;s
&gt; &gt; hallucinated.
&gt; 
&gt; And spent a few hours trying to figure it out so I could unblock testing, but
&gt; sure - thanks.

When you produce a convincingly worded writeup that&#x27;s utterly wrong,
and have a reputation for using AI, that&#x27;s the kind of reaction you&#x27;re
going to get.

&gt; Here&#x27;s the full log:
&gt; https://qa-reports.linaro.org/lkft/sashal-linus-next/build/v6.18-rc7-13806-gb927546677c8/testrun/30618654/suite/log-parser-test/test/exception-warning-fsiomapbuffered-io-at-ifs_free/log
&gt; , happy to test any patches you might have.

That&#x27;s actually much more helpful because it removes your incorrect
assumptions about what&#x27;s going on.

 WARNING: fs/iomap/buffered-io.c:254 at ifs_free+0x130/0x148, CPU#0: msync04/406

That&#x27;s this one:

        WARN_ON_ONCE(ifs_is_fully_uptodate(folio, ifs) !=
                        folio_test_uptodate(folio));

which would be fully explained by fuse calling folio_clear_uptodate()
in fuse_send_write_pages().  I have come to believe that allowing
filesystems to call folio_clear_uptodate() is just dangerous.  It
causes assertions to fire all over the place (eg if the page is mapped
into memory, the MM contains assertions that it must be uptodate).

So I think the first step is simply to delete the folio_clear_uptodate()
calls in fuse:

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 01bc894e9c2b..b819ede407d5 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -1194,7 +1194,6 @@ static ssize_t fuse_send_write_pages(struct fuse_io_args *ia,
 	struct fuse_file *ff = file-&gt;private_data;
 	struct fuse_mount *fm = ff-&gt;fm;
 	unsigned int offset, i;
-	bool short_write;
 	int err;
 
 	for (i = 0; i &lt; ap-&gt;num_folios; i++)
@@ -1209,22 +1208,16 @@ static ssize_t fuse_send_write_pages(struct fuse_io_args *ia,
 	if (!err &amp;&amp; ia-&gt;write.out.size &gt; count)
 		err = -EIO;
 
-	short_write = ia-&gt;write.out.size &lt; count;
 	offset = ap-&gt;descs[0].offset;
 	count = ia-&gt;write.out.size;
 	for (i = 0; i &lt; ap-&gt;num_folios; i++) {
 		struct folio *folio = ap-&gt;folios[i];
 
-		if (err) {
-			folio_clear_uptodate(folio);
-		} else {
+		if (!err) {
 			if (count &gt;= folio_size(folio) - offset)
 				count -= folio_size(folio) - offset;
-			else {
-				if (short_write)
-					folio_clear_uptodate(folio);
+			else
 				count = 0;
-			}
 			offset = 0;
 		}
 		if (ia-&gt;write.folio_locked &amp;&amp; (i == ap-&gt;num_folios - 1))


---

On Tue, Feb 10, 2026 at 02:18:06PM -0800, Joanne Koong wrote:
&gt;                 spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt; -               uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt; +               /*
&gt; +                * If a read is in progress, we must NOT call
&gt; folio_mark_uptodate.
&gt; +                * The read completion path (iomap_finish_folio_read or
&gt; +                * iomap_read_end) will call folio_end_read() which uses XOR
&gt; +                * semantics to set the uptodate bit. If we set it here, the XOR
&gt; +                * in folio_end_read() will clear it, leaving the folio not
&gt; +                * uptodate.
&gt; +                */
&gt; +               uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &amp;&amp;
&gt; +                       !ifs-&gt;read_bytes_pending;
&gt;                 spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);

This can&#x27;t possibly be the right fix.  There&#x27;s some horrible confusion
here.  It should not be possible to have read bytes pending _and_ the
entire folio be uptodate.  That&#x27;s an invariant that should always be
maintained.


---

On Wed, Feb 11, 2026 at 11:33:05AM -0800, Joanne Koong wrote:
&gt; ifs-&gt;read_bytes_pending gets initialized to the folio size, but if the
&gt; file being read in is smaller than the size of the folio, then we
&gt; reach this scenario because the file has been read in but
&gt; ifs-&gt;read_bytes_pending is still a positive value because it
&gt; represents the bytes between the end of the file and the end of the
&gt; folio. If the folio size is 16k and the file size is 4k:
&gt;   a) ifs-&gt;read_bytes_pending gets initialized to 16k
&gt;   b) -&gt;read_folio_range() is called for the 4k read
&gt;   c) the 4k read succeeds, ifs-&gt;read_bytes_pending is now 12k and the
&gt; 0 to 4k range is marked uptodate
&gt;   d) the post-eof blocks are zeroed and marked uptodate in the call to
&gt; iomap_set_range_uptodate()

This is the bug then.  If they&#x27;re marked uptodate, read_bytes_pending
should be decremented at the same time.  Now, I appreciate that
iomap_set_range_uptodate() is called both from iomap_read_folio_iter()
and __iomap_write_begin(), and it can&#x27;t decrement read_bytes_pending
in the latter case.  Perhaps a flag or a second length parameter is
the solution?

&gt;   e) iomap_set_range_uptodate() sees all the ranges are marked
&gt; uptodate and it marks the folio uptodate
&gt;   f) iomap_read_end() gets called to subtract the 12k from
&gt; ifs-&gt;read_bytes_pending. it too sees all the ranges are marked
&gt; uptodate and marks the folio uptodate
&gt; 
&gt; The same scenario could happen for IOMAP_INLINE mappings if part of
&gt; the folio is read in through -&gt;read_folio_range() and then the rest is
&gt; read in as inline data.

This is basically the same case as post-eof.

&gt; An alternative solution is to not have zeroed-out / inlined mappings
&gt; call iomap_read_end(), eg something like this [1], but this adds
&gt; additional complexity and doesn&#x27;t work if there&#x27;s additional mappings
&gt; for the folio after a non-IOMAP_MAPPED mapping.
&gt; 
&gt; Is there a better approach that I&#x27;m missing?
&gt; 
&gt; Thanks,
&gt; Joanne
&gt; 
&gt; [1] https://github.com/joannekoong/linux/commit/de48d3c29db8ae654300341e3eec12497df54673


---

On Wed, Feb 11, 2026 at 03:13:48PM -0800, Joanne Koong wrote:
&gt; On Wed, Feb 11, 2026 at 1:03\u202fPM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
&gt; &gt;
&gt; &gt; On Wed, Feb 11, 2026 at 11:33:05AM -0800, Joanne Koong wrote:
&gt; &gt; &gt; ifs-&gt;read_bytes_pending gets initialized to the folio size, but if the
&gt; &gt; &gt; file being read in is smaller than the size of the folio, then we
&gt; &gt; &gt; reach this scenario because the file has been read in but
&gt; &gt; &gt; ifs-&gt;read_bytes_pending is still a positive value because it
&gt; &gt; &gt; represents the bytes between the end of the file and the end of the
&gt; &gt; &gt; folio. If the folio size is 16k and the file size is 4k:
&gt; &gt; &gt;   a) ifs-&gt;read_bytes_pending gets initialized to 16k
&gt; &gt; &gt;   b) -&gt;read_folio_range() is called for the 4k read
&gt; &gt; &gt;   c) the 4k read succeeds, ifs-&gt;read_bytes_pending is now 12k and the
&gt; &gt; &gt; 0 to 4k range is marked uptodate
&gt; &gt; &gt;   d) the post-eof blocks are zeroed and marked uptodate in the call to
&gt; &gt; &gt; iomap_set_range_uptodate()
&gt; &gt;
&gt; &gt; This is the bug then.  If they&#x27;re marked uptodate, read_bytes_pending
&gt; &gt; should be decremented at the same time.  Now, I appreciate that
&gt; &gt; iomap_set_range_uptodate() is called both from iomap_read_folio_iter()
&gt; &gt; and __iomap_write_begin(), and it can&#x27;t decrement read_bytes_pending
&gt; &gt; in the latter case.  Perhaps a flag or a second length parameter is
&gt; &gt; the solution?
&gt; 
&gt; I don&#x27;t think it&#x27;s enough to decrement read_bytes_pending by the
&gt; zeroed/read-inline length because there&#x27;s these two edge cases:
&gt; a) some blocks in the folio were already uptodate from the very
&gt; beginning and skipped for IO but not decremented yet from
&gt; ifs-&gt;read_bytes_pending, which means in iomap_read_end(),
&gt; ifs-&gt;read_bytes_pending would be &gt; 0 and the uptodate flag could get
&gt; XORed again. This means we need to also decrement read_bytes_pending
&gt; by bytes_submitted as well for this case

Hm, that&#x27;s a good one.  It can&#x27;t happen for readahead, but it can happen
if we start out by writing to some blocks of a folio, then call
read_folio to get the remaining blocks uptodate.  We could avoid it
happening by initialising read_bytes_pending to folio_size() -
bitmap_weight(ifs-&gt;uptodate) * block_size.

&gt; b) the async -&gt;read_folio_range() callback finishes after the
&gt; zeroing&#x27;s read_bytes_pending decrement and calls folio_end_read(), so
&gt; we need to assign ctx-&gt;cur_folio to NULL

If we return &#x27;finished&#x27; from iomap_finish_folio_read(), we can handle
this?

&gt; I think the code would have to look something like [1] (this is
&gt; similar to the alternative approach I mentioned in my previous reply
&gt; but fixed up to cover some more edge cases).
&gt; 
&gt; Thanks,
&gt; Joanne
&gt; 
&gt; [1] https://github.com/joannekoong/linux/commit/b42f47726433a8130e8c27d1b43b16e27dfd6960

I think we can do everything we need with a suitably modified
iomap_finish_folio_read() rather than the new iomap_finish_read_range().
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, alternative solutions</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Darrick Wong</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer suggested splitting VM debug checks into cheap and expensive ones, allowing for a kconfig option to enable only the cheap checks without significantly increasing fstests time.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Fri, Oct 24, 2025 at 09:59:01PM +0100, Matthew Wilcox wrote:
&gt; On Fri, Oct 24, 2025 at 12:22:32PM -0700, Joanne Koong wrote:
&gt; &gt; &gt; Feels like more filesystem people should be enabling CONFIG_DEBUG_VM
&gt; &gt; &gt; when testing (excluding performance testing of course; it&#x27;ll do ugly
&gt; &gt; &gt; things to your performance numbers).
&gt; &gt; 
&gt; &gt; Point taken. It looks like there&#x27;s a bunch of other memory debugging
&gt; &gt; configs as well. Do you recommend enabling all of these when testing?
&gt; &gt; Do you have a particular .config you use for when you run tests?
&gt; 
&gt; Our Kconfig is far too ornate.  We could do with a &quot;recommended for
&gt; kernel developers&quot; profile.  Here&#x27;s what I&#x27;m currently using, though I
&gt; know it&#x27;s changed over time:

Is there any chance you could split the VM debug checks into cheap and
expensive ones, and create another kconfig option so that we could do
the cheap checks without having fstests take a lot longer?

You could also implement shenanigans like the following:
https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/commit/?h=djwong-wtf&amp;id=b739fff870384fd239abfd99ecee6bc47640794d

To enable the expensive checks at runtime.

(Yeah, I know, this is probably a 2 year project + bikeshed score of at
least 30...)

--D

&gt; CONFIG_X86_DEBUGCTLMSR=y
&gt; CONFIG_PM_DEBUG=y
&gt; CONFIG_PM_SLEEP_DEBUG=y
&gt; CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
&gt; CONFIG_BLK_DEBUG_FS=y
&gt; CONFIG_PNP_DEBUG_MESSAGES=y
&gt; CONFIG_SCSI_DEBUG=m
&gt; CONFIG_EXT4_DEBUG=y
&gt; CONFIG_JFS_DEBUG=y
&gt; CONFIG_XFS_DEBUG=y
&gt; CONFIG_BTRFS_DEBUG=y
&gt; CONFIG_UFS_DEBUG=y
&gt; CONFIG_DEBUG_BUGVERBOSE=y
&gt; CONFIG_DEBUG_KERNEL=y
&gt; CONFIG_DEBUG_MISC=y
&gt; CONFIG_DEBUG_INFO=y
&gt; CONFIG_DEBUG_INFO_DWARF4=y
&gt; CONFIG_DEBUG_INFO_COMPRESSED_NONE=y
&gt; CONFIG_DEBUG_FS=y
&gt; CONFIG_DEBUG_FS_ALLOW_ALL=y
&gt; CONFIG_ARCH_HAS_EARLY_DEBUG=y
&gt; CONFIG_SLUB_DEBUG=y
&gt; CONFIG_ARCH_HAS_DEBUG_WX=y
&gt; CONFIG_HAVE_DEBUG_KMEMLEAK=y
&gt; CONFIG_SHRINKER_DEBUG=y
&gt; CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE=y
&gt; CONFIG_DEBUG_VM_IRQSOFF=y
&gt; CONFIG_DEBUG_VM=y
&gt; CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
&gt; CONFIG_DEBUG_MEMORY_INIT=y
&gt; CONFIG_LOCK_DEBUGGING_SUPPORT=y
&gt; CONFIG_DEBUG_RT_MUTEXES=y
&gt; CONFIG_DEBUG_SPINLOCK=y
&gt; CONFIG_DEBUG_MUTEXES=y
&gt; CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
&gt; CONFIG_DEBUG_RWSEMS=y
&gt; CONFIG_DEBUG_LOCK_ALLOC=y
&gt; CONFIG_DEBUG_LIST=y
&gt; CONFIG_X86_DEBUG_FPU=y
&gt; CONFIG_FAULT_INJECTION_DEBUG_FS=y
&gt; 
&gt; (output from grep DEBUG .build/.config |grep -v ^#)
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Sasha Levin</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Sasha Levin raised concerns about a potential race condition between iomap_set_range_uptodate and folio_end_read, which was triggered by the FUSE iomap patchset. He provided a fix that checks read_bytes_pending under the state_lock in iomap_set_range_uptodate to prevent concurrent access.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Hi Joanne,

While testing with your FUSE iomap patchset that recently landed upstream,
I ran into a warning in ifs_free() where the folio&#x27;s uptodate flag didn&#x27;t
match the ifs per-block uptodate bitmap. The warning was triggered during
FUSE-based filesystem unmount when running the LTP writev03 test.

After some investigation, I believe the root cause is a race condition
that has existed since commit 7a4847e54cc1 (&quot;iomap: use folio_end_read()&quot;)
but was difficult to trigger until now. The issue is that folio_end_read()
uses XOR semantics to set the uptodate bit, so if iomap_set_range_uptodate()
calls folio_mark_uptodate() while a read is in progress, the subsequent
folio_end_read() will XOR and clear the uptodate bit.

The FUSE iomap enablement seems to have created the right conditions to
expose this race - likely due to different file extent patterns in
FUSE-based filesystems (like NTFS-3G) compared to native filesystems
like XFS/ext4.

The fix checks read_bytes_pending under the state_lock in
iomap_set_range_uptodate() and skips calling folio_mark_uptodate() if a
read is in progress, letting the read completion path handle it.

I&#x27;m not very familiar with the iomap internals, so I&#x27;d really appreciate
your review and feedback on whether this approach is correct.

Thanks,
Sasha

Sasha Levin (1):
  iomap: fix race between iomap_set_range_uptodate and folio_end_read

 fs/fuse/dev.c          |  3 +-
 fs/fuse/file.c         |  6 ++--
 fs/iomap/buffered-io.c | 65 +++++++++++++++++++++++++++++++++++++++---
 include/linux/iomap.h  |  2 ++
 4 files changed, 68 insertions(+), 8 deletions(-)

-- 
2.51.0



---

When iomap uses large folios, per-block uptodate tracking is managed via
iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
to become inconsistent with the folio&#x27;s uptodate flag.

The race occurs because folio_end_read() uses XOR semantics to atomically
set the uptodate bit and clear the locked bit:

  Thread A (read completion):          Thread B (concurrent write):
  --------------------------------     --------------------------------
  iomap_finish_folio_read()
    spin_lock(state_lock)
    ifs_set_range_uptodate() -&gt; true
    spin_unlock(state_lock)
                                       iomap_set_range_uptodate()
                                         spin_lock(state_lock)
                                         ifs_set_range_uptodate() -&gt; true
                                         spin_unlock(state_lock)
                                         folio_mark_uptodate(folio)
    folio_end_read(folio, true)
      folio_xor_flags()  // XOR CLEARS uptodate!

Result: folio is NOT uptodate, but ifs says all blocks ARE uptodate.

Fix by checking read_bytes_pending in iomap_set_range_uptodate() under the
lock. If a read is in progress, skip calling folio_mark_uptodate() - the
read completion path will handle it via folio_end_read().

The warning was triggered during FUSE-based filesystem (e.g., NTFS-3G)
unmount when the LTP writev03 test was run:

  WARNING: fs/iomap/buffered-io.c at ifs_free
  Call trace:
   ifs_free
   iomap_invalidate_folio
   truncate_cleanup_folio
   truncate_inode_pages_range
   truncate_inode_pages_final
   fuse_evict_inode
   ...
   fuse_kill_sb_blk

Fixes: 7a4847e54cc1 (&quot;iomap: use folio_end_read()&quot;)
Assisted-by: claude-opus-4-5-20251101
Signed-off-by: Sasha Levin &lt;sashal@kernel.org&gt;
---
 fs/fuse/dev.c          |  3 +-
 fs/fuse/file.c         |  6 ++--
 fs/iomap/buffered-io.c | 65 +++++++++++++++++++++++++++++++++++++++---
 include/linux/iomap.h  |  2 ++
 4 files changed, 68 insertions(+), 8 deletions(-)

diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index 6d59cbc877c6..50e84e913589 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -11,6 +11,7 @@
 #include &quot;fuse_dev_i.h&quot;
 
 #include &lt;linux/init.h&gt;
+#include &lt;linux/iomap.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/poll.h&gt;
 #include &lt;linux/sched/signal.h&gt;
@@ -1820,7 +1821,7 @@ static int fuse_notify_store(struct fuse_conn *fc, unsigned int size,
 		if (!folio_test_uptodate(folio) &amp;&amp; !err &amp;&amp; offset == 0 &amp;&amp;
 		    (nr_bytes == folio_size(folio) || file_size == end)) {
 			folio_zero_segment(folio, nr_bytes, folio_size(folio));
-			folio_mark_uptodate(folio);
+			iomap_set_range_uptodate(folio, 0, folio_size(folio));
 		}
 		folio_unlock(folio);
 		folio_put(folio);
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 01bc894e9c2b..3abe38416199 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -1216,13 +1216,13 @@ static ssize_t fuse_send_write_pages(struct fuse_io_args *ia,
 		struct folio *folio = ap-&gt;folios[i];
 
 		if (err) {
-			folio_clear_uptodate(folio);
+			iomap_clear_folio_uptodate(folio);
 		} else {
 			if (count &gt;= folio_size(folio) - offset)
 				count -= folio_size(folio) - offset;
 			else {
 				if (short_write)
-					folio_clear_uptodate(folio);
+					iomap_clear_folio_uptodate(folio);
 				count = 0;
 			}
 			offset = 0;
@@ -1305,7 +1305,7 @@ static ssize_t fuse_fill_write_pages(struct fuse_io_args *ia,
 
 		/* If we copied full folio, mark it uptodate */
 		if (tmp == folio_size(folio))
-			folio_mark_uptodate(folio);
+			iomap_set_range_uptodate(folio, 0, folio_size(folio));
 
 		if (folio_test_uptodate(folio)) {
 			folio_unlock(folio);
diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index e5c1ca440d93..7ceda24cf6a7 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -74,8 +74,7 @@ static bool ifs_set_range_uptodate(struct folio *folio,
 	return ifs_is_fully_uptodate(folio, ifs);
 }
 
-static void iomap_set_range_uptodate(struct folio *folio, size_t off,
-		size_t len)
+void iomap_set_range_uptodate(struct folio *folio, size_t off, size_t len)
 {
 	struct iomap_folio_state *ifs = folio-&gt;private;
 	unsigned long flags;
@@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio *folio, size_t off,
 	if (ifs) {
 		spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
 		uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
+		/*
+		 * If a read is in progress, we must NOT call folio_mark_uptodate
+		 * here. The read completion path (iomap_finish_folio_read or
+		 * iomap_read_end) will call folio_end_read() which uses XOR
+		 * semantics to set the uptodate bit. If we set it here, the XOR
+		 * in folio_end_read() will clear it, leaving the folio not
+		 * uptodate while the ifs says all blocks are uptodate.
+		 */
+		if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
+			uptodate = false;
 		spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
 	}
 
 	if (uptodate)
 		folio_mark_uptodate(folio);
 }
+EXPORT_SYMBOL_GPL(iomap_set_range_uptodate);
+
+void iomap_clear_folio_uptodate(struct folio *folio)
+{
+	struct iomap_folio_state *ifs = folio-&gt;private;
+
+	if (ifs) {
+		struct inode *inode = folio-&gt;mapping-&gt;host;
+		unsigned int nr_blocks = i_blocks_per_folio(inode, folio);
+		unsigned long flags;
+
+		spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
+		/*
+		 * If a read is in progress, don&#x27;t clear the uptodate state.
+		 * The read completion path will handle the folio state, and
+		 * clearing here would race with iomap_finish_folio_read()
+		 * potentially causing ifs/folio uptodate state mismatch.
+		 */
+		if (ifs-&gt;read_bytes_pending) {
+			spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
+			return;
+		}
+		bitmap_clear(ifs-&gt;state, 0, nr_blocks);
+		spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
+	}
+	folio_clear_uptodate(folio);
+}
+EXPORT_SYMBOL_GPL(iomap_clear_folio_uptodate);
 
 /*
  * Find the next dirty block in the folio. end_blk is inclusive.
@@ -399,8 +436,17 @@ void iomap_finish_folio_read(struct folio *folio, size_t off, size_t len,
 		spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
 	}
 
-	if (finished)
+	if (finished) {
+		/*
+		 * If uptodate is true but the folio is already marked uptodate,
+		 * folio_end_read&#x27;s XOR semantics would clear the uptodate bit.
+		 * This should never happen because iomap_set_range_uptodate()
+		 * skips calling folio_mark_uptodate() when read_bytes_pending
+		 * is non-zero, ensuring only the read completion path sets it.
+		 */
+		WARN_ON_ONCE(uptodate &amp;&amp; folio_test_uptodate(folio));
 		folio_end_read(folio, uptodate);
+	}
 }
 EXPORT_SYMBOL_GPL(iomap_finish_folio_read);
 
@@ -481,8 +527,19 @@ static void iomap_read_end(struct folio *folio, size_t bytes_submitted)
 		if (end_read)
 			uptodate = ifs_is_fully_uptodate(folio, ifs);
 		spin_unlock_irq(&amp;ifs-&gt;state_lock);
-		if (end_read)
+		if (end_read) {
+			/*
+			 * If uptodate is true but the folio is already marked
+			 * uptodate, folio_end_read&#x27;s XOR semantics would clear
+			 * the uptodate bit. This should never happen because
+			 * iomap_set_range_uptodate() skips calling
+			 * folio_mark_uptodate() when read_bytes_pending is
+			 * non-zero, ensuring only the read completion path
+			 * sets it.
+			 */
+			WARN_ON_ONCE(uptodate &amp;&amp; folio_test_uptodate(folio));
 			folio_end_read(folio, uptodate);
+		}
 	} else if (!bytes_submitted) {
 		/*
 		 * If there were no bytes submitted, this means we are
diff --git a/include/linux/iomap.h b/include/linux/iomap.h
index 520e967cb501..3c2ad88d16b6 100644
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@ -345,6 +345,8 @@ void iomap_read_folio(const struct iomap_ops *ops,
 void iomap_readahead(const struct iomap_ops *ops,
 		struct iomap_read_folio_ctx *ctx);
 bool iomap_is_partially_uptodate(struct folio *, size_t from, size_t count);
+void iomap_set_range_uptodate(struct folio *folio, size_t off, size_t len);
+void iomap_clear_folio_uptodate(struct folio *folio);
 struct folio *iomap_get_folio(struct iomap_iter *iter, loff_t pos, size_t len);
 bool iomap_release_folio(struct folio *folio, gfp_t gfp_flags);
 void iomap_invalidate_folio(struct folio *folio, size_t offset, size_t len);
-- 
2.51.0



---

On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt;On Tue, Dec 23, 2025 at 2:30\u202fPM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt;&gt;
&gt;
&gt;Hi Sasha,
&gt;
&gt;Thanks for your patch and for the detailed writeup.

Thanks for looking into this!

&gt;&gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt;&gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt;&gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt;&gt;
&gt;&gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt;&gt; set the uptodate bit and clear the locked bit:
&gt;&gt;
&gt;&gt;   Thread A (read completion):          Thread B (concurrent write):
&gt;&gt;   --------------------------------     --------------------------------
&gt;&gt;   iomap_finish_folio_read()
&gt;&gt;     spin_lock(state_lock)
&gt;&gt;     ifs_set_range_uptodate() -&gt; true
&gt;&gt;     spin_unlock(state_lock)
&gt;&gt;                                        iomap_set_range_uptodate()
&gt;&gt;                                          spin_lock(state_lock)
&gt;&gt;                                          ifs_set_range_uptodate() -&gt; true
&gt;&gt;                                          spin_unlock(state_lock)
&gt;&gt;                                          folio_mark_uptodate(folio)
&gt;&gt;     folio_end_read(folio, true)
&gt;&gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt;
&gt;The part I&#x27;m confused about here is how this can happen between a
&gt;concurrent read and write. My understanding is that the folio is
&gt;locked when the read occurs and locked when the write occurs and both
&gt;locks get dropped only when the read or write finishes. Looking at
&gt;iomap code, I see iomap_set_range_uptodate() getting called in
&gt;__iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt;both those places the folio lock is held while this is called. I&#x27;m not
&gt;seeing how the read and write race in the diagram can happen, but
&gt;maybe I&#x27;m missing something here?

Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
access. Looking at this again, I suspect that FUSE was calling
folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
ifs bits. For example, in fuse_send_write_pages() on write error, it calls
folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
showing all blocks uptodate?

&gt;&gt;
&gt;&gt; Result: folio is NOT uptodate, but ifs says all blocks ARE uptodate.
&gt;
&gt;Ah I see the WARN_ON_ONCE() in ifs_free:
&gt;        WARN_ON_ONCE(ifs_is_fully_uptodate(folio, ifs) !=
&gt;                        folio_test_uptodate(folio));
&gt;
&gt;Just to confirm, are you seeing that the folio is not marked uptodate
&gt;but the ifs blocks are? Or are the ifs blocks not uptodate but the
&gt;folio is?

The former: folio is NOT uptodate but ifs shows all blocks ARE uptodate
(state=0xffff with 16 blocks)

&gt;&gt;
&gt;&gt; Fix by checking read_bytes_pending in iomap_set_range_uptodate() under the
&gt;&gt; lock. If a read is in progress, skip calling folio_mark_uptodate() - the
&gt;&gt; read completion path will handle it via folio_end_read().
&gt;&gt;
&gt;&gt; The warning was triggered during FUSE-based filesystem (e.g., NTFS-3G)
&gt;&gt; unmount when the LTP writev03 test was run:
&gt;&gt;
&gt;&gt;   WARNING: fs/iomap/buffered-io.c at ifs_free
&gt;&gt;   Call trace:
&gt;&gt;    ifs_free
&gt;&gt;    iomap_invalidate_folio
&gt;&gt;    truncate_cleanup_folio
&gt;&gt;    truncate_inode_pages_range
&gt;&gt;    truncate_inode_pages_final
&gt;&gt;    fuse_evict_inode
&gt;&gt;    ...
&gt;&gt;    fuse_kill_sb_blk
&gt;&gt;
&gt;&gt; Fixes: 7a4847e54cc1 (&quot;iomap: use folio_end_read()&quot;)
&gt;&gt; Assisted-by: claude-opus-4-5-20251101
&gt;&gt; Signed-off-by: Sasha Levin &lt;sashal@kernel.org&gt;
&gt;&gt; ---
&gt;&gt;  fs/fuse/dev.c          |  3 +-
&gt;&gt;  fs/fuse/file.c         |  6 ++--
&gt;&gt;  fs/iomap/buffered-io.c | 65 +++++++++++++++++++++++++++++++++++++++---
&gt;&gt;  include/linux/iomap.h  |  2 ++
&gt;&gt;  4 files changed, 68 insertions(+), 8 deletions(-)
&gt;&gt;
&gt;&gt; diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
&gt;&gt; index 6d59cbc877c6..50e84e913589 100644
&gt;&gt; --- a/fs/fuse/dev.c
&gt;&gt; +++ b/fs/fuse/dev.c
&gt;&gt; @@ -11,6 +11,7 @@
&gt;&gt;  #include &quot;fuse_dev_i.h&quot;
&gt;&gt;
&gt;&gt;  #include &lt;linux/init.h&gt;
&gt;&gt; +#include &lt;linux/iomap.h&gt;
&gt;&gt;  #include &lt;linux/module.h&gt;
&gt;&gt;  #include &lt;linux/poll.h&gt;
&gt;&gt;  #include &lt;linux/sched/signal.h&gt;
&gt;&gt; @@ -1820,7 +1821,7 @@ static int fuse_notify_store(struct fuse_conn *fc, unsigned int size,
&gt;&gt;                 if (!folio_test_uptodate(folio) &amp;&amp; !err &amp;&amp; offset == 0 &amp;&amp;
&gt;&gt;                     (nr_bytes == folio_size(folio) || file_size == end)) {
&gt;&gt;                         folio_zero_segment(folio, nr_bytes, folio_size(folio));
&gt;&gt; -                       folio_mark_uptodate(folio);
&gt;&gt; +                       iomap_set_range_uptodate(folio, 0, folio_size(folio));
&gt;&gt;                 }
&gt;&gt;                 folio_unlock(folio);
&gt;&gt;                 folio_put(folio);
&gt;&gt; diff --git a/fs/fuse/file.c b/fs/fuse/file.c
&gt;&gt; index 01bc894e9c2b..3abe38416199 100644
&gt;&gt; --- a/fs/fuse/file.c
&gt;&gt; +++ b/fs/fuse/file.c
&gt;&gt; @@ -1216,13 +1216,13 @@ static ssize_t fuse_send_write_pages(struct fuse_io_args *ia,
&gt;&gt;                 struct folio *folio = ap-&gt;folios[i];
&gt;&gt;
&gt;&gt;                 if (err) {
&gt;&gt; -                       folio_clear_uptodate(folio);
&gt;&gt; +                       iomap_clear_folio_uptodate(folio);
&gt;&gt;                 } else {
&gt;&gt;                         if (count &gt;= folio_size(folio) - offset)
&gt;&gt;                                 count -= folio_size(folio) - offset;
&gt;&gt;                         else {
&gt;&gt;                                 if (short_write)
&gt;&gt; -                                       folio_clear_uptodate(folio);
&gt;&gt; +                                       iomap_clear_folio_uptodate(folio);
&gt;&gt;                                 count = 0;
&gt;&gt;                         }
&gt;&gt;                         offset = 0;
&gt;&gt; @@ -1305,7 +1305,7 @@ static ssize_t fuse_fill_write_pages(struct fuse_io_args *ia,
&gt;&gt;
&gt;&gt;                 /* If we copied full folio, mark it uptodate */
&gt;&gt;                 if (tmp == folio_size(folio))
&gt;&gt; -                       folio_mark_uptodate(folio);
&gt;&gt; +                       iomap_set_range_uptodate(folio, 0, folio_size(folio));
&gt;&gt;
&gt;&gt;                 if (folio_test_uptodate(folio)) {
&gt;&gt;                         folio_unlock(folio);
&gt;&gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt;&gt; index e5c1ca440d93..7ceda24cf6a7 100644
&gt;&gt; --- a/fs/iomap/buffered-io.c
&gt;&gt; +++ b/fs/iomap/buffered-io.c
&gt;&gt; @@ -74,8 +74,7 @@ static bool ifs_set_range_uptodate(struct folio *folio,
&gt;&gt;         return ifs_is_fully_uptodate(folio, ifs);
&gt;&gt;  }
&gt;&gt;
&gt;&gt; -static void iomap_set_range_uptodate(struct folio *folio, size_t off,
&gt;&gt; -               size_t len)
&gt;&gt; +void iomap_set_range_uptodate(struct folio *folio, size_t off, size_t len)
&gt;&gt;  {
&gt;&gt;         struct iomap_folio_state *ifs = folio-&gt;private;
&gt;&gt;         unsigned long flags;
&gt;&gt; @@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio *folio, size_t off,
&gt;&gt;         if (ifs) {
&gt;&gt;                 spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt;&gt;                 uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt;&gt; +               /*
&gt;&gt; +                * If a read is in progress, we must NOT call folio_mark_uptodate
&gt;&gt; +                * here. The read completion path (iomap_finish_folio_read or
&gt;&gt; +                * iomap_read_end) will call folio_end_read() which uses XOR
&gt;&gt; +                * semantics to set the uptodate bit. If we set it here, the XOR
&gt;&gt; +                * in folio_end_read() will clear it, leaving the folio not
&gt;&gt; +                * uptodate while the ifs says all blocks are uptodate.
&gt;&gt; +                */
&gt;&gt; +               if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
&gt;&gt; +                       uptodate = false;
&gt;
&gt;Does the warning you saw in ifs_free() still go away without the
&gt;changes here to iomap_set_range_uptodate() or is this change here
&gt;necessary?  I&#x27;m asking mostly because I&#x27;m not seeing how
&gt;iomap_set_range_uptodate() can be called while the read is in
&gt;progress, as the logic should be already protected by the folio locks.

Yes, the warning goes away even without this part. I don&#x27;t think that this is
necessary - I just kept it while figuring out the race.

&gt;&gt;                 spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;&gt;         }
&gt;&gt;
&gt;&gt;         if (uptodate)
&gt;&gt;                 folio_mark_uptodate(folio);
&gt;&gt;  }
&gt;&gt; +EXPORT_SYMBOL_GPL(iomap_set_range_uptodate);
&gt;&gt; +
&gt;&gt; +void iomap_clear_folio_uptodate(struct folio *folio)
&gt;&gt; +{
&gt;&gt; +       struct iomap_folio_state *ifs = folio-&gt;private;
&gt;&gt; +
&gt;&gt; +       if (ifs) {
&gt;&gt; +               struct inode *inode = folio-&gt;mapping-&gt;host;
&gt;&gt; +               unsigned int nr_blocks = i_blocks_per_folio(inode, folio);
&gt;&gt; +               unsigned long flags;
&gt;&gt; +
&gt;&gt; +               spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt;&gt; +               /*
&gt;&gt; +                * If a read is in progress, don&#x27;t clear the uptodate state.
&gt;&gt; +                * The read completion path will handle the folio state, and
&gt;&gt; +                * clearing here would race with iomap_finish_folio_read()
&gt;&gt; +                * potentially causing ifs/folio uptodate state mismatch.
&gt;&gt; +                */
&gt;&gt; +               if (ifs-&gt;read_bytes_pending) {
&gt;&gt; +                       spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;&gt; +                       return;
&gt;&gt; +               }
&gt;&gt; +               bitmap_clear(ifs-&gt;state, 0, nr_blocks);
&gt;&gt; +               spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;&gt; +       }
&gt;&gt; +       folio_clear_uptodate(folio);
&gt;&gt; +}
&gt;&gt; +EXPORT_SYMBOL_GPL(iomap_clear_folio_uptodate);
&gt;&gt;
&gt;&gt;  /*
&gt;&gt;   * Find the next dirty block in the folio. end_blk is inclusive.
&gt;&gt; @@ -399,8 +436,17 @@ void iomap_finish_folio_read(struct folio *folio, size_t off, size_t len,
&gt;&gt;                 spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;&gt;         }
&gt;&gt;
&gt;&gt; -       if (finished)
&gt;&gt; +       if (finished) {
&gt;&gt; +               /*
&gt;&gt; +                * If uptodate is true but the folio is already marked uptodate,
&gt;&gt; +                * folio_end_read&#x27;s XOR semantics would clear the uptodate bit.
&gt;&gt; +                * This should never happen because iomap_set_range_uptodate()
&gt;&gt; +                * skips calling folio_mark_uptodate() when read_bytes_pending
&gt;&gt; +                * is non-zero, ensuring only the read completion path sets it.
&gt;&gt; +                */
&gt;&gt; +               WARN_ON_ONCE(uptodate &amp;&amp; folio_test_uptodate(folio));
&gt;
&gt;Matthew pointed out in another thread [1] that folio_end_read() has
&gt;already the warnings against double-unlocks or double-uptodates
&gt;in-built:
&gt;
&gt;        VM_BUG_ON_FOLIO(!folio_test_locked(folio), folio);
&gt;        VM_BUG_ON_FOLIO(success &amp;&amp; folio_test_uptodate(folio), folio);
&gt;
&gt;but imo the WARN_ON_ONCE() here is nice to have too, as I don&#x27;t think
&gt;most builds enable CONFIG_DEBUG_VM.
&gt;
&gt;[1] https://lore.kernel.org/linux-fsdevel/aPu1ilw6Tq6tKPrf@casper.infradead.org/
&gt;
&gt;Thanks,
&gt;Joanne
&gt;&gt;                 folio_end_read(folio, uptodate);
&gt;&gt; +       }
&gt;&gt;  }
&gt;&gt;  EXPORT_SYMBOL_GPL(iomap_finish_folio_read);
&gt;&gt;
&gt;&gt; @@ -481,8 +527,19 @@ static void iomap_read_end(struct folio *folio, size_t bytes_submitted)
&gt;&gt;                 if (end_read)
&gt;&gt;                         uptodate = ifs_is_fully_uptodate(folio, ifs);
&gt;&gt;                 spin_unlock_irq(&amp;ifs-&gt;state_lock);
&gt;&gt; -               if (end_read)
&gt;&gt; +               if (end_read) {
&gt;&gt; +                       /*
&gt;&gt; +                        * If uptodate is true but the folio is already marked
&gt;&gt; +                        * uptodate, folio_end_read&#x27;s XOR semantics would clear
&gt;&gt; +                        * the uptodate bit. This should never happen because
&gt;&gt; +                        * iomap_set_range_uptodate() skips calling
&gt;&gt; +                        * folio_mark_uptodate() when read_bytes_pending is
&gt;&gt; +                        * non-zero, ensuring only the read completion path
&gt;&gt; +                        * sets it.
&gt;&gt; +                        */
&gt;&gt; +                       WARN_ON_ONCE(uptodate &amp;&amp; folio_test_uptodate(folio));
&gt;&gt;                         folio_end_read(folio, uptodate);
&gt;&gt; +               }
&gt;&gt;         } else if (!bytes_submitted) {
&gt;&gt;                 /*
&gt;&gt;                  * If there were no bytes submitted, this means we are
&gt;&gt; diff --git a/include/linux/iomap.h b/include/linux/iomap.h
&gt;&gt; index 520e967cb501..3c2ad88d16b6 100644
&gt;&gt; --- a/include/linux/iomap.h
&gt;&gt; +++ b/include/linux/iomap.h
&gt;&gt; @@ -345,6 +345,8 @@ void iomap_read_folio(const struct iomap_ops *ops,
&gt;&gt;  void iomap_readahead(const struct iomap_ops *ops,
&gt;&gt;                 struct iomap_read_folio_ctx *ctx);
&gt;&gt;  bool iomap_is_partially_uptodate(struct folio *, size_t from, size_t count);
&gt;&gt; +void iomap_set_range_uptodate(struct folio *folio, size_t off, size_t len);
&gt;&gt; +void iomap_clear_folio_uptodate(struct folio *folio);
&gt;&gt;  struct folio *iomap_get_folio(struct iomap_iter *iter, loff_t pos, size_t len);
&gt;&gt;  bool iomap_release_folio(struct folio *folio, gfp_t gfp_flags);
&gt;&gt;  void iomap_invalidate_folio(struct folio *folio, size_t offset, size_t len);
&gt;&gt; --
&gt;&gt; 2.51.0
&gt;&gt;

-- 
Thanks,
Sasha


---

On Wed, Dec 24, 2025 at 02:10:19AM +0000, Matthew Wilcox wrote:
&gt;On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt;&gt; On Tue, Dec 23, 2025 at 2:30\u202fPM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt;&gt; &gt;
&gt;&gt;
&gt;&gt; Hi Sasha,
&gt;&gt;
&gt;&gt; Thanks for your patch and for the detailed writeup.
&gt;
&gt;The important line to note is:
&gt;
&gt;Assisted-by: claude-opus-4-5-20251101
&gt;
&gt;So Sasha has produced a very convincingly worded writeup that&#x27;s
&gt;hallucinated.

And spent a few hours trying to figure it out so I could unblock testing, but
sure - thanks.

Here&#x27;s the full log:
https://qa-reports.linaro.org/lkft/sashal-linus-next/build/v6.18-rc7-13806-gb927546677c8/testrun/30618654/suite/log-parser-test/test/exception-warning-fsiomapbuffered-io-at-ifs_free/log
, happy to test any patches you might have.

-- 
Thanks,
Sasha


---

On Wed, Dec 24, 2025 at 05:27:03PM +0000, Matthew Wilcox wrote:
&gt;On Wed, Dec 24, 2025 at 10:43:58AM -0500, Sasha Levin wrote:
&gt;&gt; On Wed, Dec 24, 2025 at 02:10:19AM +0000, Matthew Wilcox wrote:
&gt;&gt; &gt; So Sasha has produced a very convincingly worded writeup that&#x27;s
&gt;&gt; &gt; hallucinated.
&gt;&gt;
&gt;&gt; And spent a few hours trying to figure it out so I could unblock testing, but
&gt;&gt; sure - thanks.
&gt;
&gt;When you produce a convincingly worded writeup that&#x27;s utterly wrong,
&gt;and have a reputation for using AI, that&#x27;s the kind of reaction you&#x27;re
&gt;going to get.

A rude and unprofessional one?

&gt;&gt; Here&#x27;s the full log:
&gt;&gt; https://qa-reports.linaro.org/lkft/sashal-linus-next/build/v6.18-rc7-13806-gb927546677c8/testrun/30618654/suite/log-parser-test/test/exception-warning-fsiomapbuffered-io-at-ifs_free/log
&gt;&gt; , happy to test any patches you might have.
&gt;
&gt;That&#x27;s actually much more helpful because it removes your incorrect
&gt;assumptions about what&#x27;s going on.
&gt;
&gt; WARNING: fs/iomap/buffered-io.c:254 at ifs_free+0x130/0x148, CPU#0: msync04/406
&gt;
&gt;That&#x27;s this one:
&gt;
&gt;        WARN_ON_ONCE(ifs_is_fully_uptodate(folio, ifs) !=
&gt;                        folio_test_uptodate(folio));
&gt;
&gt;which would be fully explained by fuse calling folio_clear_uptodate()
&gt;in fuse_send_write_pages().  I have come to believe that allowing
&gt;filesystems to call folio_clear_uptodate() is just dangerous.  It
&gt;causes assertions to fire all over the place (eg if the page is mapped
&gt;into memory, the MM contains assertions that it must be uptodate).
&gt;
&gt;So I think the first step is simply to delete the folio_clear_uptodate()
&gt;calls in fuse:

[snip]

Here&#x27;s the log of a run with the change you&#x27;ve provided applied: https://qa-reports.linaro.org/lkft/sashal-linus-next/build/v6.18-rc7-13807-g26a15474eb13/testrun/30620754/suite/log-parser-test/test/exception-warning-fsiomapbuffered-io-at-ifs_free/log

-- 
Thanks,
Sasha


---

On Tue, Feb 10, 2026 at 02:18:06PM -0800, Joanne Koong wrote:
&gt;On Mon, Feb 9, 2026 at 4:40\u202fPM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt;&gt;
&gt;&gt; On Mon, Feb 09, 2026 at 04:20:01PM -0800, Joanne Koong wrote:
&gt;&gt; &gt; On Mon, Feb 9, 2026 at 4:12\u202fPM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt;&gt; &gt; &gt;
&gt;&gt; &gt; &gt; On Mon, Feb 09, 2026 at 11:08:50AM -0800, Joanne Koong wrote:
&gt;&gt; &gt; &gt; &gt; On Fri, Feb 6, 2026 at 11:16\u202fPM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt;&gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 08:31:57PM -0500, Sasha Levin wrote:
&gt;&gt; &gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 2:30\u202fPM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Sasha,
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; Thanks for your patch and for the detailed writeup.
&gt;&gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; Thanks for looking into this!
&gt;&gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; set the uptodate bit and clear the locked bit:
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;   Thread A (read completion):          Thread B (concurrent write):
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;   --------------------------------     --------------------------------
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;   iomap_finish_folio_read()
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     spin_lock(state_lock)
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     ifs_set_range_uptodate() -&gt; true
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     spin_unlock(state_lock)
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                        iomap_set_range_uptodate()
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          spin_lock(state_lock)
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          ifs_set_range_uptodate() -&gt; true
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          spin_unlock(state_lock)
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          folio_mark_uptodate(folio)
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;     folio_end_read(folio, true)
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; The part I&#x27;m confused about here is how this can happen between a
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; concurrent read and write. My understanding is that the folio is
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; locked when the read occurs and locked when the write occurs and both
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; locks get dropped only when the read or write finishes. Looking at
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; iomap code, I see iomap_set_range_uptodate() getting called in
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; __iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; both those places the folio lock is held while this is called. I&#x27;m not
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; seeing how the read and write race in the diagram can happen, but
&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; maybe I&#x27;m missing something here?
&gt;&gt; &gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; &gt; Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
&gt;&gt; &gt; &gt; &gt; &gt; &gt; access. Looking at this again, I suspect that FUSE was calling
&gt;&gt; &gt; &gt; &gt; &gt; &gt; folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
&gt;&gt; &gt; &gt; &gt; &gt; &gt; ifs bits. For example, in fuse_send_write_pages() on write error, it calls
&gt;&gt; &gt; &gt; &gt; &gt; &gt; folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
&gt;&gt; &gt; &gt; &gt; &gt; &gt; showing all blocks uptodate?
&gt;&gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; Hi Sasha
&gt;&gt; &gt; &gt; &gt; &gt; On PowerPC with 64KB page size, msync04 fails with SIGBUS on NTFS-FUSE. The issue stems from a state inconsistency between
&gt;&gt; &gt; &gt; &gt; &gt; the iomap_folio_state (ifs) bitmap and the folio&#x27;s Uptodate flag.
&gt;&gt; &gt; &gt; &gt; &gt; tst_test.c:1985: TINFO: === Testing on ntfs ===
&gt;&gt; &gt; &gt; &gt; &gt; tst_test.c:1290: TINFO: Formatting /dev/loop0 with ntfs opts=&#x27;&#x27; extra opts=&#x27;&#x27;
&gt;&gt; &gt; &gt; &gt; &gt; Failed to set locale, using default &#x27;C&#x27;.
&gt;&gt; &gt; &gt; &gt; &gt; The partition start sector was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt;&gt; &gt; &gt; &gt; &gt; The number of sectors per track was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt;&gt; &gt; &gt; &gt; &gt; The number of heads was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt;&gt; &gt; &gt; &gt; &gt; To boot from a device, Windows needs the &#x27;partition start sector&#x27;, the &#x27;sectors per track&#x27; and the &#x27;number of heads&#x27; to be set.
&gt;&gt; &gt; &gt; &gt; &gt; Windows will not be able to boot from this device.
&gt;&gt; &gt; &gt; &gt; &gt; tst_test.c:1302: TINFO: Mounting /dev/loop0 to /tmp/LTP_msy3ljVxi/msync04 fstyp=ntfs flags=0
&gt;&gt; &gt; &gt; &gt; &gt; tst_test.c:1302: TINFO: Trying FUSE...
&gt;&gt; &gt; &gt; &gt; &gt; tst_test.c:1953: TBROK: Test killed by SIGBUS!
&gt;&gt; &gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; &gt; Root Cause Analysis: When a page fault triggers fuse_read_folio, the iomap_read_folio_iter handles the request. For a 64KB page,
&gt;&gt; &gt; &gt; &gt; &gt; after fetching 4KB via fuse_iomap_read_folio_range_async, the remaining 60KB (61440 bytes) is zero-filled via iomap_block_needs_zeroing,
&gt;&gt; &gt; &gt; &gt; &gt; then iomap_set_range_uptodate marks the folio as Uptodate globally, after folio_xor_flags folio&#x27;s uptodate become 0 again, finally trigger
&gt;&gt; &gt; &gt; &gt; &gt; an SIGBUS issue in filemap_fault.
&gt;&gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; Hi Wei,
&gt;&gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; Thanks for your report. afaict, this scenario occurs only if the
&gt;&gt; &gt; &gt; &gt; server is a fuseblk server with a block size different from the memory
&gt;&gt; &gt; &gt; &gt; page size and if the file size is less than the size of the folio
&gt;&gt; &gt; &gt; &gt; being read in.
&gt;&gt; &gt; &gt; Thanks for checking this and give quick feedback :)
&gt;&gt; &gt; &gt; &gt;
&gt;&gt; &gt; &gt; &gt; Could you verify that this snippet from Sasha&#x27;s patch fixes the issue?:
&gt;&gt; &gt; &gt; Yes, Sasha&#x27;s patch can fixes the issue.
&gt;&gt; &gt;
&gt;&gt; &gt; I think just those lines I pasted from Sasha&#x27;s patch is the relevant
&gt;&gt; &gt; fix. Could you verify that just those lines (without the changes
&gt;&gt; &gt; from the rest of his patch) fixes the issue?
&gt;&gt; Yes, i just add two lines change in iomap_set_range_uptodate can fixes
&gt;&gt; the issue.
&gt;
&gt;Great, thank you for confirming.
&gt;
&gt;Sasha, would you mind submitting this snippet of your patch as the fix
&gt;for the EOF zeroing issue? I think it could be restructured to
&gt;
&gt;diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt;index 1fe19b4ee2f4..412e661871f8 100644
&gt;--- a/fs/iomap/buffered-io.c
&gt;+++ b/fs/iomap/buffered-io.c
&gt;@@ -87,7 +87,16 @@ static void iomap_set_range_uptodate(struct folio
&gt;*folio, size_t off,
&gt;
&gt;        if (ifs) {
&gt;                spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt;-               uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt;+               /*
&gt;+                * If a read is in progress, we must NOT call
&gt;folio_mark_uptodate.
&gt;+                * The read completion path (iomap_finish_folio_read or
&gt;+                * iomap_read_end) will call folio_end_read() which uses XOR
&gt;+                * semantics to set the uptodate bit. If we set it here, the XOR
&gt;+                * in folio_end_read() will clear it, leaving the folio not
&gt;+                * uptodate.
&gt;+                */
&gt;+               uptodate = ifs_set_range_uptodate(folio, ifs, off, len) &amp;&amp;
&gt;+                       !ifs-&gt;read_bytes_pending;
&gt;                spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;        }
&gt;
&gt;to be a bit more concise.
&gt;
&gt;If you&#x27;re busy and don&#x27;t have the bandwidth, I&#x27;m happy to forward the
&gt;patch on your behalf with your Signed-off-by / authorship.

Thanks for the offer Joanna!

Since you&#x27;ve done all the triaging work here, please go ahead and submit it -
something like a Suggested-by would be more than enought for me :)

-- 
Thanks,
Sasha
</pre>
</details>
<div class="review-comment-signals">Signals: race condition, potential bug</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Wei Gao</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Wei Gao reported a race condition between iomap_set_range_uptodate and folio_end_read on PowerPC with 64KB page size, causing an SIGBUS issue in filemap_fault. He found that Sasha&#x27;s patch can fix the issue by blocking mark folio&#x27;s uptodate to 1.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, Dec 23, 2025 at 08:31:57PM -0500, Sasha Levin wrote:
&gt; On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt; &gt; On Tue, Dec 23, 2025 at 2:30\u202fPM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; Hi Sasha,
&gt; &gt; 
&gt; &gt; Thanks for your patch and for the detailed writeup.
&gt; 
&gt; Thanks for looking into this!
&gt; 
&gt; &gt; &gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt; &gt; &gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt; &gt; &gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt; &gt; &gt; 
&gt; &gt; &gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt; &gt; &gt; set the uptodate bit and clear the locked bit:
&gt; &gt; &gt; 
&gt; &gt; &gt;   Thread A (read completion):          Thread B (concurrent write):
&gt; &gt; &gt;   --------------------------------     --------------------------------
&gt; &gt; &gt;   iomap_finish_folio_read()
&gt; &gt; &gt;     spin_lock(state_lock)
&gt; &gt; &gt;     ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt;     spin_unlock(state_lock)
&gt; &gt; &gt;                                        iomap_set_range_uptodate()
&gt; &gt; &gt;                                          spin_lock(state_lock)
&gt; &gt; &gt;                                          ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt;                                          spin_unlock(state_lock)
&gt; &gt; &gt;                                          folio_mark_uptodate(folio)
&gt; &gt; &gt;     folio_end_read(folio, true)
&gt; &gt; &gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt; &gt; 
&gt; &gt; The part I&#x27;m confused about here is how this can happen between a
&gt; &gt; concurrent read and write. My understanding is that the folio is
&gt; &gt; locked when the read occurs and locked when the write occurs and both
&gt; &gt; locks get dropped only when the read or write finishes. Looking at
&gt; &gt; iomap code, I see iomap_set_range_uptodate() getting called in
&gt; &gt; __iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt; &gt; both those places the folio lock is held while this is called. I&#x27;m not
&gt; &gt; seeing how the read and write race in the diagram can happen, but
&gt; &gt; maybe I&#x27;m missing something here?
&gt; 
&gt; Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
&gt; access. Looking at this again, I suspect that FUSE was calling
&gt; folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
&gt; ifs bits. For example, in fuse_send_write_pages() on write error, it calls
&gt; folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
&gt; showing all blocks uptodate?

Hi Sasha
On PowerPC with 64KB page size, msync04 fails with SIGBUS on NTFS-FUSE. The issue stems from a state inconsistency between
the iomap_folio_state (ifs) bitmap and the folio&#x27;s Uptodate flag.
tst_test.c:1985: TINFO: === Testing on ntfs ===
tst_test.c:1290: TINFO: Formatting /dev/loop0 with ntfs opts=&#x27;&#x27; extra opts=&#x27;&#x27;
Failed to set locale, using default &#x27;C&#x27;.
The partition start sector was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
The number of sectors per track was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
The number of heads was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
To boot from a device, Windows needs the &#x27;partition start sector&#x27;, the &#x27;sectors per track&#x27; and the &#x27;number of heads&#x27; to be set.
Windows will not be able to boot from this device.
tst_test.c:1302: TINFO: Mounting /dev/loop0 to /tmp/LTP_msy3ljVxi/msync04 fstyp=ntfs flags=0
tst_test.c:1302: TINFO: Trying FUSE...
tst_test.c:1953: TBROK: Test killed by SIGBUS!

Root Cause Analysis: When a page fault triggers fuse_read_folio, the iomap_read_folio_iter handles the request. For a 64KB page, 
after fetching 4KB via fuse_iomap_read_folio_range_async, the remaining 60KB (61440 bytes) is zero-filled via iomap_block_needs_zeroing, 
then iomap_set_range_uptodate marks the folio as Uptodate globally, after folio_xor_flags folio&#x27;s uptodate become 0 again, finally trigger 
an SIGBUS issue in filemap_fault.

So your iomap_set_range_uptodate patch can fix above failed case since it block mark folio&#x27;s uptodate to 1.
Hope my findings are helpful.

&gt; 
&gt; -- 
&gt; Thanks,
&gt; Sasha
&gt; 


---

On Mon, Feb 09, 2026 at 11:08:50AM -0800, Joanne Koong wrote:
&gt; On Fri, Feb 6, 2026 at 11:16\u202fPM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt; &gt;
&gt; &gt; On Tue, Dec 23, 2025 at 08:31:57PM -0500, Sasha Levin wrote:
&gt; &gt; &gt; On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 2:30\u202fPM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Hi Sasha,
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Thanks for your patch and for the detailed writeup.
&gt; &gt; &gt;
&gt; &gt; &gt; Thanks for looking into this!
&gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt; &gt; &gt; &gt; &gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt; &gt; &gt; &gt; &gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt; &gt; &gt; &gt; &gt; set the uptodate bit and clear the locked bit:
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt;   Thread A (read completion):          Thread B (concurrent write):
&gt; &gt; &gt; &gt; &gt;   --------------------------------     --------------------------------
&gt; &gt; &gt; &gt; &gt;   iomap_finish_folio_read()
&gt; &gt; &gt; &gt; &gt;     spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt;     ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt;     spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt;                                        iomap_set_range_uptodate()
&gt; &gt; &gt; &gt; &gt;                                          spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt;                                          ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt;                                          spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt;                                          folio_mark_uptodate(folio)
&gt; &gt; &gt; &gt; &gt;     folio_end_read(folio, true)
&gt; &gt; &gt; &gt; &gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; The part I&#x27;m confused about here is how this can happen between a
&gt; &gt; &gt; &gt; concurrent read and write. My understanding is that the folio is
&gt; &gt; &gt; &gt; locked when the read occurs and locked when the write occurs and both
&gt; &gt; &gt; &gt; locks get dropped only when the read or write finishes. Looking at
&gt; &gt; &gt; &gt; iomap code, I see iomap_set_range_uptodate() getting called in
&gt; &gt; &gt; &gt; __iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt; &gt; &gt; &gt; both those places the folio lock is held while this is called. I&#x27;m not
&gt; &gt; &gt; &gt; seeing how the read and write race in the diagram can happen, but
&gt; &gt; &gt; &gt; maybe I&#x27;m missing something here?
&gt; &gt; &gt;
&gt; &gt; &gt; Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
&gt; &gt; &gt; access. Looking at this again, I suspect that FUSE was calling
&gt; &gt; &gt; folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
&gt; &gt; &gt; ifs bits. For example, in fuse_send_write_pages() on write error, it calls
&gt; &gt; &gt; folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
&gt; &gt; &gt; showing all blocks uptodate?
&gt; &gt;
&gt; &gt; Hi Sasha
&gt; &gt; On PowerPC with 64KB page size, msync04 fails with SIGBUS on NTFS-FUSE. The issue stems from a state inconsistency between
&gt; &gt; the iomap_folio_state (ifs) bitmap and the folio&#x27;s Uptodate flag.
&gt; &gt; tst_test.c:1985: TINFO: === Testing on ntfs ===
&gt; &gt; tst_test.c:1290: TINFO: Formatting /dev/loop0 with ntfs opts=&#x27;&#x27; extra opts=&#x27;&#x27;
&gt; &gt; Failed to set locale, using default &#x27;C&#x27;.
&gt; &gt; The partition start sector was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; The number of sectors per track was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; The number of heads was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; To boot from a device, Windows needs the &#x27;partition start sector&#x27;, the &#x27;sectors per track&#x27; and the &#x27;number of heads&#x27; to be set.
&gt; &gt; Windows will not be able to boot from this device.
&gt; &gt; tst_test.c:1302: TINFO: Mounting /dev/loop0 to /tmp/LTP_msy3ljVxi/msync04 fstyp=ntfs flags=0
&gt; &gt; tst_test.c:1302: TINFO: Trying FUSE...
&gt; &gt; tst_test.c:1953: TBROK: Test killed by SIGBUS!
&gt; &gt;
&gt; &gt; Root Cause Analysis: When a page fault triggers fuse_read_folio, the iomap_read_folio_iter handles the request. For a 64KB page,
&gt; &gt; after fetching 4KB via fuse_iomap_read_folio_range_async, the remaining 60KB (61440 bytes) is zero-filled via iomap_block_needs_zeroing,
&gt; &gt; then iomap_set_range_uptodate marks the folio as Uptodate globally, after folio_xor_flags folio&#x27;s uptodate become 0 again, finally trigger
&gt; &gt; an SIGBUS issue in filemap_fault.
&gt; 
&gt; Hi Wei,
&gt; 
&gt; Thanks for your report. afaict, this scenario occurs only if the
&gt; server is a fuseblk server with a block size different from the memory
&gt; page size and if the file size is less than the size of the folio
&gt; being read in.
Thanks for checking this and give quick feedback :)
&gt; 
&gt; Could you verify that this snippet from Sasha&#x27;s patch fixes the issue?:
Yes, Sasha&#x27;s patch can fixes the issue.
&gt; 
&gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; index e5c1ca440d93..7ceda24cf6a7 100644
&gt; --- a/fs/iomap/buffered-io.c
&gt; +++ b/fs/iomap/buffered-io.c
&gt; @@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio
&gt; *folio, size_t off,
&gt;   if (ifs) {
&gt;           spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt;           uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt;           + /*
&gt;           + * If a read is in progress, we must NOT call folio_mark_uptodate
&gt;           + * here. The read completion path (iomap_finish_folio_read or
&gt;           + * iomap_read_end) will call folio_end_read() which uses XOR
&gt;           + * semantics to set the uptodate bit. If we set it here, the XOR
&gt;           + * in folio_end_read() will clear it, leaving the folio not
&gt;           + * uptodate while the ifs says all blocks are uptodate.
&gt;           + */
&gt;          + if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
&gt;                    + uptodate = false;
&gt;         spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt;   }
&gt; 
&gt; Thanks,
&gt; Joanne
&gt; 
&gt; &gt;
&gt; &gt; So your iomap_set_range_uptodate patch can fix above failed case since it block mark folio&#x27;s uptodate to 1.
&gt; &gt; Hope my findings are helpful.
&gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; --
&gt; &gt; &gt; Thanks,
&gt; &gt; &gt; Sasha
&gt; &gt; &gt;


---

On Mon, Feb 09, 2026 at 04:20:01PM -0800, Joanne Koong wrote:
&gt; On Mon, Feb 9, 2026 at 4:12\u202fPM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt; &gt;
&gt; &gt; On Mon, Feb 09, 2026 at 11:08:50AM -0800, Joanne Koong wrote:
&gt; &gt; &gt; On Fri, Feb 6, 2026 at 11:16\u202fPM Wei Gao &lt;wegao@suse.com&gt; wrote:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 08:31:57PM -0500, Sasha Levin wrote:
&gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 05:12:09PM -0800, Joanne Koong wrote:
&gt; &gt; &gt; &gt; &gt; &gt; On Tue, Dec 23, 2025 at 2:30\u202fPM Sasha Levin &lt;sashal@kernel.org&gt; wrote:
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Hi Sasha,
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; Thanks for your patch and for the detailed writeup.
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Thanks for looking into this!
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; When iomap uses large folios, per-block uptodate tracking is managed via
&gt; &gt; &gt; &gt; &gt; &gt; &gt; iomap_folio_state (ifs). A race condition can cause the ifs uptodate bits
&gt; &gt; &gt; &gt; &gt; &gt; &gt; to become inconsistent with the folio&#x27;s uptodate flag.
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt; The race occurs because folio_end_read() uses XOR semantics to atomically
&gt; &gt; &gt; &gt; &gt; &gt; &gt; set the uptodate bit and clear the locked bit:
&gt; &gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; &gt;   Thread A (read completion):          Thread B (concurrent write):
&gt; &gt; &gt; &gt; &gt; &gt; &gt;   --------------------------------     --------------------------------
&gt; &gt; &gt; &gt; &gt; &gt; &gt;   iomap_finish_folio_read()
&gt; &gt; &gt; &gt; &gt; &gt; &gt;     spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;     ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt; &gt; &gt;     spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                                        iomap_set_range_uptodate()
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          spin_lock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          ifs_set_range_uptodate() -&gt; true
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          spin_unlock(state_lock)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;                                          folio_mark_uptodate(folio)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;     folio_end_read(folio, true)
&gt; &gt; &gt; &gt; &gt; &gt; &gt;       folio_xor_flags()  // XOR CLEARS uptodate!
&gt; &gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; &gt; The part I&#x27;m confused about here is how this can happen between a
&gt; &gt; &gt; &gt; &gt; &gt; concurrent read and write. My understanding is that the folio is
&gt; &gt; &gt; &gt; &gt; &gt; locked when the read occurs and locked when the write occurs and both
&gt; &gt; &gt; &gt; &gt; &gt; locks get dropped only when the read or write finishes. Looking at
&gt; &gt; &gt; &gt; &gt; &gt; iomap code, I see iomap_set_range_uptodate() getting called in
&gt; &gt; &gt; &gt; &gt; &gt; __iomap_write_begin() and __iomap_write_end() for the writes, but in
&gt; &gt; &gt; &gt; &gt; &gt; both those places the folio lock is held while this is called. I&#x27;m not
&gt; &gt; &gt; &gt; &gt; &gt; seeing how the read and write race in the diagram can happen, but
&gt; &gt; &gt; &gt; &gt; &gt; maybe I&#x27;m missing something here?
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Hmm, you&#x27;re right... The folio lock should prevent concurrent read/write
&gt; &gt; &gt; &gt; &gt; access. Looking at this again, I suspect that FUSE was calling
&gt; &gt; &gt; &gt; &gt; folio_clear_uptodate() and folio_mark_uptodate() directly without updating the
&gt; &gt; &gt; &gt; &gt; ifs bits. For example, in fuse_send_write_pages() on write error, it calls
&gt; &gt; &gt; &gt; &gt; folio_clear_uptodate(folio) which clears the folio flag but leaves ifs still
&gt; &gt; &gt; &gt; &gt; showing all blocks uptodate?
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Hi Sasha
&gt; &gt; &gt; &gt; On PowerPC with 64KB page size, msync04 fails with SIGBUS on NTFS-FUSE. The issue stems from a state inconsistency between
&gt; &gt; &gt; &gt; the iomap_folio_state (ifs) bitmap and the folio&#x27;s Uptodate flag.
&gt; &gt; &gt; &gt; tst_test.c:1985: TINFO: === Testing on ntfs ===
&gt; &gt; &gt; &gt; tst_test.c:1290: TINFO: Formatting /dev/loop0 with ntfs opts=&#x27;&#x27; extra opts=&#x27;&#x27;
&gt; &gt; &gt; &gt; Failed to set locale, using default &#x27;C&#x27;.
&gt; &gt; &gt; &gt; The partition start sector was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; &gt; The number of sectors per track was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; &gt; The number of heads was not specified for /dev/loop0 and it could not be obtained automatically.  It has been set to 0.
&gt; &gt; &gt; &gt; To boot from a device, Windows needs the &#x27;partition start sector&#x27;, the &#x27;sectors per track&#x27; and the &#x27;number of heads&#x27; to be set.
&gt; &gt; &gt; &gt; Windows will not be able to boot from this device.
&gt; &gt; &gt; &gt; tst_test.c:1302: TINFO: Mounting /dev/loop0 to /tmp/LTP_msy3ljVxi/msync04 fstyp=ntfs flags=0
&gt; &gt; &gt; &gt; tst_test.c:1302: TINFO: Trying FUSE...
&gt; &gt; &gt; &gt; tst_test.c:1953: TBROK: Test killed by SIGBUS!
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Root Cause Analysis: When a page fault triggers fuse_read_folio, the iomap_read_folio_iter handles the request. For a 64KB page,
&gt; &gt; &gt; &gt; after fetching 4KB via fuse_iomap_read_folio_range_async, the remaining 60KB (61440 bytes) is zero-filled via iomap_block_needs_zeroing,
&gt; &gt; &gt; &gt; then iomap_set_range_uptodate marks the folio as Uptodate globally, after folio_xor_flags folio&#x27;s uptodate become 0 again, finally trigger
&gt; &gt; &gt; &gt; an SIGBUS issue in filemap_fault.
&gt; &gt; &gt;
&gt; &gt; &gt; Hi Wei,
&gt; &gt; &gt;
&gt; &gt; &gt; Thanks for your report. afaict, this scenario occurs only if the
&gt; &gt; &gt; server is a fuseblk server with a block size different from the memory
&gt; &gt; &gt; page size and if the file size is less than the size of the folio
&gt; &gt; &gt; being read in.
&gt; &gt; Thanks for checking this and give quick feedback :)
&gt; &gt; &gt;
&gt; &gt; &gt; Could you verify that this snippet from Sasha&#x27;s patch fixes the issue?:
&gt; &gt; Yes, Sasha&#x27;s patch can fixes the issue.
&gt; 
&gt; I think just those lines I pasted from Sasha&#x27;s patch is the relevant
&gt; fix. Could you verify that just those lines (without the changes
&gt; from the rest of his patch) fixes the issue?
Yes, i just add two lines change in iomap_set_range_uptodate can fixes
the issue.
+		if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
+			uptodate = false;
&gt; 
&gt; Thanks,
&gt; Joanne
&gt; 
&gt; 
&gt; &gt; &gt;
&gt; &gt; &gt; diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
&gt; &gt; &gt; index e5c1ca440d93..7ceda24cf6a7 100644
&gt; &gt; &gt; --- a/fs/iomap/buffered-io.c
&gt; &gt; &gt; +++ b/fs/iomap/buffered-io.c
&gt; &gt; &gt; @@ -87,12 +86,50 @@ static void iomap_set_range_uptodate(struct folio
&gt; &gt; &gt; *folio, size_t off,
&gt; &gt; &gt;   if (ifs) {
&gt; &gt; &gt;           spin_lock_irqsave(&amp;ifs-&gt;state_lock, flags);
&gt; &gt; &gt;           uptodate = ifs_set_range_uptodate(folio, ifs, off, len);
&gt; &gt; &gt;           + /*
&gt; &gt; &gt;           + * If a read is in progress, we must NOT call folio_mark_uptodate
&gt; &gt; &gt;           + * here. The read completion path (iomap_finish_folio_read or
&gt; &gt; &gt;           + * iomap_read_end) will call folio_end_read() which uses XOR
&gt; &gt; &gt;           + * semantics to set the uptodate bit. If we set it here, the XOR
&gt; &gt; &gt;           + * in folio_end_read() will clear it, leaving the folio not
&gt; &gt; &gt;           + * uptodate while the ifs says all blocks are uptodate.
&gt; &gt; &gt;           + */
&gt; &gt; &gt;          + if (uptodate &amp;&amp; ifs-&gt;read_bytes_pending)
&gt; &gt; &gt;                    + uptodate = false;
&gt; &gt; &gt;         spin_unlock_irqrestore(&amp;ifs-&gt;state_lock, flags);
&gt; &gt; &gt;   }
&gt; &gt; &gt;
&gt; &gt; &gt; Thanks,
&gt; &gt; &gt; Joanne
&gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; So your iomap_set_range_uptodate patch can fix above failed case since it block mark folio&#x27;s uptodate to 1.
&gt; &gt; &gt; &gt; Hope my findings are helpful.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; --
&gt; &gt; &gt; &gt; &gt; Thanks,
&gt; &gt; &gt; &gt; &gt; Sasha
&gt; &gt; &gt; &gt; &gt;
</pre>
</details>
<div class="review-comment-signals">Signals: race condition, SIGBUS issue</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>