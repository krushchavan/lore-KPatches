{
  "thread_id": "20260226155334.3373953-1-usama.arif@linux.dev",
  "subject": "[PATCH mm-unstable v15 12/13] mm/khugepaged: run khugepaged for all orders",
  "url": "https://lore.kernel.org/all/20260226155334.3373953-1-usama.arif@linux.dev/",
  "dates": {
    "2026-02-26": {
      "report_file": "2026-02-26_ollama_llama3.1-8b.html",
      "developer": "Usama Arif",
      "reviews": [
        {
          "author": "Usama Arif",
          "summary": "Raised concern that SCAN_CGROUP_CHARGE_FAIL might not be a reliable indicator of resource constraint, and suggested considering other error codes.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "NEEDS_WORK"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Acked-by"
          ],
          "analysis_source": "llm",
          "raw_body": "",
          "reply_to": "",
          "message_date": "",
          "message_id": ""
        },
        {
          "author": "Nico Pache",
          "summary": "Provided additional context and insight into the decisions made in the patch, highlighting potential scenarios where collapsing or charging large order pages might be unproductive.",
          "sentiment": "positive",
          "sentiment_signals": [
            "POSITIVE"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On Thu, Feb 26, 2026 at 9:27â€¯AM Usama Arif <usama.arif@linux.dev> wrote:\n>\n> On Wed, 25 Feb 2026 20:26:31 -0700 Nico Pache <npache@redhat.com> wrote:\n>\n> > There are cases where, if an attempted collapse fails, all subsequent\n> > orders are guaranteed to also fail. Avoid these collapse attempts by\n> > bailing out early.\n> >\n> > Signed-off-by: Nico Pache <npache@redhat.com>\n> > ---\n> >  mm/khugepaged.c | 35 ++++++++++++++++++++++++++++++++++-\n> >  1 file changed, 34 insertions(+), 1 deletion(-)\n> >\n> > diff --git a/mm/khugepaged.c b/mm/khugepaged.c\n> > index 1c3711ed4513..388d3f2537e2 100644\n> > --- a/mm/khugepaged.c\n> > +++ b/mm/khugepaged.c\n> > @@ -1492,9 +1492,42 @@ static int mthp_collapse(struct mm_struct *mm, unsigned long address,\n> >                       ret = collapse_huge_page(mm, collapse_address, referenced,\n> >                                                unmapped, cc, mmap_locked,\n> >                                                order);\n> > -                     if (ret == SCAN_SUCCEED) {\n> > +\n> > +                     switch (ret) {\n> > +                     /* Cases were we continue to next collapse candidate */\n> > +                     case SCAN_SUCCEED:\n> >                               collapsed += nr_pte_entries;\n> > +                             fallthrough;\n> > +                     case SCAN_PTE_MAPPED_HUGEPAGE:\n> >                               continue;\n> > +                     /* Cases were lower orders might still succeed */\n> > +                     case SCAN_LACK_REFERENCED_PAGE:\n> > +                     case SCAN_EXCEED_NONE_PTE:\n> > +                     case SCAN_EXCEED_SWAP_PTE:\n> > +                     case SCAN_EXCEED_SHARED_PTE:\n> > +                     case SCAN_PAGE_LOCK:\n> > +                     case SCAN_PAGE_COUNT:\n> > +                     case SCAN_PAGE_LRU:\n> > +                     case SCAN_PAGE_NULL:\n> > +                     case SCAN_DEL_PAGE_LRU:\n> > +                     case SCAN_PTE_NON_PRESENT:\n> > +                     case SCAN_PTE_UFFD_WP:\n> > +                     case SCAN_ALLOC_HUGE_PAGE_FAIL:\n> > +                             goto next_order;\n> > +                     /* Cases were no further collapse is possible */\n> > +                     case SCAN_CGROUP_CHARGE_FAIL:\n>\n> The only one that stands out to me is SCAN_CGROUP_CHARGE_FAIL. memcg charging\n> of higher order folio might fail, but a lower order folio might pass?\n> That said, if the cgroup is that tight, continuing collapse work may not\n> be productive.\n>\n> Acked-by: Usama Arif <usama.arif@linux.dev>\n\nThanks! IIRC, David and I discussed all of these off chain to confirm\ntheir placement. I had this in the 'next_order' case at some point and\nDavid recommended it to \"fail\" for the same reason you state here:\ncollapsing or charging large order pages in such a tight cgroup is\nlikely unproductive and not worth the effort.\n\nIn contrast, SCAN_ALLOC_HUGE_PAGE_FAIL does not necessarily indicate a\nresource constraint, but it could. We might fail to allocate an N-page\nsize due to fragmentation, but we could easily find an (N-1) size. We\ncould also have a scenario where a lack of memory causes the failure,\niterating all the way down, which would be unproductive. However, at\nthat point the OOM reaper should be active and the system will already\nbe cornered in multiple ways, so it should be ok.\n\nHopefully that gives some insight into the decisions made here :)\n\nCheers,\n-- Nico\n\n>\n> > +                     case SCAN_COPY_MC:\n> > +                     case SCAN_ADDRESS_RANGE:\n> > +                     case SCAN_NO_PTE_TABLE:\n> > +                     case SCAN_ANY_PROCESS:\n> > +                     case SCAN_VMA_NULL:\n> > +                     case SCAN_VMA_CHECK:\n> > +                     case SCAN_SCAN_ABORT:\n> > +                     case SCAN_PAGE_ANON:\n> > +                     case SCAN_PMD_MAPPED:\n> > +                     case SCAN_FAIL:\n> > +                     default:\n> > +                             return collapsed;\n> >                       }\n> >               }\n> >\n> > --\n> > 2.53.0\n> >\n> >\n>\n\n\n",
          "reply_to": "Usama Arif",
          "message_date": "2026-02-26",
          "message_id": ""
        }
      ],
      "analysis_source": "llm",
      "patch_summary": "Patch aims to avoid unnecessary mTHP collapse attempts by considering specific error codes."
    }
  }
}