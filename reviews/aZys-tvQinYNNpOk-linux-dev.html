<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH v7 3/3] mm: vmscan: add PIDs to vmscan tracepoints</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH v7 3/3] mm: vmscan: add PIDs to vmscan tracepoints</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/aZys_tvQinYNNpOk@linux.dev/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-24">2026-02-24</a> &bull; <a href="#2026-02-23">2026-02-23</a> &bull; <a href="#2026-02-16">2026-02-16</a> &bull; <a href="#2026-02-13">2026-02-13</a> &bull; <a href="#2026-01-27">2026-01-27</a> &bull; <a href="#2026-01-22">2026-01-22</a> &bull; <a href="#2026-01-15">2026-01-15</a> &bull; <a href="#2026-01-07">2026-01-07</a> &bull; <a href="#2026-01-05">2026-01-05</a> &bull; <a href="#2025-12-29">2025-12-29</a> &bull; <a href="#2025-12-17">2025-12-17</a> &bull; <a href="#2025-12-16">2025-12-16</a> &bull; <a href="#2025-12-09">2025-12-09</a> &bull; <a href="#2025-12-08">2025-12-08</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2025-12-08">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-08">2025-12-08</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the difficulty of attributing memory reclaim events to specific cgroups, explaining that adding memory cgroup ID (memcg_id) to key vmscan tracepoints will enable better correlation and analysis for debugging memory pressure issues. The field is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 65 +++++++++++++++++++++--------------
 mm/vmscan.c                   | 17 ++++-----
 2 files changed, 48 insertions(+), 34 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index d2123dd960d59..afc9f80d03f34 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(order, gfp_flags, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -209,6 +216,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
@@ -221,6 +229,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
@@ -229,10 +238,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -242,15 +252,16 @@ TRACE_EVENT(mm_shrink_slab_start,
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
-	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
+	TP_PROTO(struct shrinker *shr, struct shrink_control *sc, int shrinker_retval,
 		long unused_scan_cnt, long new_scan_cnt, long total_scan),
 
-	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
+	TP_ARGS(shr, sc, shrinker_retval, unused_scan_cnt, new_scan_cnt,
 		total_scan),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
@@ -260,7 +271,8 @@ TRACE_EVENT(mm_shrink_slab_end,
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
@@ -268,10 +280,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -463,9 +476,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 258f5472f1e90..0e65ec3a087a5 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -931,7 +931,7 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl, freed, nr, new_nr, total_scan);
 	return freed;
 }
 
@@ -7092,11 +7092,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7126,7 +7126,8 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
 	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+						      sc.gfp_mask,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -7137,7 +7138,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -7171,13 +7172,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -8072,7 +8073,7 @@ static int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned in
 	fs_reclaim_release(sc.gfp_mask);
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed, 0);
 
 	return sc.nr_reclaimed &gt;= nr_pages;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
<div class="thread-children">
<div class="thread-node depth-1" id="2025-12-09">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-09">2025-12-09</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the patch does not handle the case where a task is being migrated, and requested that the PID be checked before adding it to the tracepoint

reviewer noted that adding a PID field to vmscan tracepoints on 64-bit machines would cause a hole in the ring buffer due to the &#x27;int&#x27; type, and requested moving the PID next to the order field, which is also an &#x27;int&#x27;, without inserting an intermediate &#x27;unsigned long&#x27;</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon,  8 Dec 2025 10:14:13 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

This puts a hole in the ring buffer on 64 bit machines. Please keep pid
next to order as they are both &#x27;int&#x27; and not have an &quot;unsigned long&quot;
between the two.</pre>
</details>
<div class="review-comment-signals">Signals: migrating tasks, PID check, requested change</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2" id="2025-12-29">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-29">2025-12-29</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author acknowledged Steven Rostedt&#x27;s feedback about displaying erroneous debugging values in IRQ context, agreed that adding a check to mark them as invalid is beneficial and would only remove it if instructed to do so.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">(re-sending the reply as I believe I missed the reply all)

It indeed shows whether or not we&#x27;re in an IRQ, but I believe the
kernel shouldn&#x27;t show erronous debugging values. Even though it can be
obvious that we&#x27;re in an interrupt, some people might look directly at
the garbage PID value without having second thoughts and taking it for
granted. On the other hand, it takes just a small check to mark the
debugging information as clearly invalid, which complements the IRQ
context flag.

If we shouldn&#x27;t put that check there, I&#x27;d happily remove it, but I&#x27;d
tend to think it&#x27;s a trivial addition that can only be for the best.

Thomas</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged feedback, agreed with approach</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the patch does not handle the case where a task is being migrated to another node, and suggested adding a check for this condition in the vmscan tracepoint

The reviewer questioned the necessity of adding PIDs to vmscan tracepoints, pointing out that existing trace events already indicate interrupt context and provide the current PID.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, 16 Dec 2025 06:02:52 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

Is this really needed? The trace events already show if you are in
interrupt context or not.

# tracer: nop
#
# entries-in-buffer/entries-written: 25817/25817   #P:8
#
#                                _-----=&gt; irqs-off/BH-disabled
#                               / _----=&gt; need-resched
#                              | / _---=&gt; hardirq/softirq   &lt;&lt;&lt;&lt;------ Shows irq context
#                              || / _--=&gt; preempt-depth
#                              ||| / _-=&gt; migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
          &lt;idle&gt;-0       [002] d..1. 11429.293552: rcu_watching: Startirq 0 1 0x74c
          &lt;idle&gt;-0       [000] d.H1. 11429.293564: rcu_utilization: Start scheduler-tick
          &lt;idle&gt;-0       [000] d.H1. 11429.293566: rcu_utilization: End scheduler-tick
          &lt;idle&gt;-0       [002] dN.1. 11429.293567: rcu_watching: Endirq 1 0 0x74c
          &lt;idle&gt;-0       [002] dN.1. 11429.293568: rcu_watching: Start 0 1 0x754
          &lt;idle&gt;-0       [000] d.s1. 11429.293577: rcu_watching: --= 3 1 0xdf4
          &lt;idle&gt;-0       [002] dN.1. 11429.293579: rcu_utilization: Start context switch
          &lt;idle&gt;-0       [002] dN.1. 11429.293580: rcu_utilization: End context switch
       rcu_sched-15      [002] d..1. 11429.293589: rcu_grace_period: rcu_sched 132685 start
          &lt;idle&gt;-0       [000] dN.1. 11429.293592: rcu_watching: Endirq 1 0 0xdf4
       rcu_sched-15      [002] d..1. 11429.293592: rcu_grace_period: rcu_sched 132685 cpustart
       rcu_sched-15      [002] d..1. 11429.293592: rcu_grace_period_init: rcu_sched 132685 0 0 7 ff
          &lt;idle&gt;-0       [000] dN.1. 11429.293593: rcu_watching: Start 0 1 0xdfc

Thus, you can already tell if you are in interrupt context or not, and you
always get the current pid. The &#x27;H&#x27;, &#x27;h&#x27; or &#x27;s&#x27; means you are in a
interrupt type context. (&#x27;H&#x27; for hard interrupt interrupting a softirq, &#x27;h&#x27;
for just a hard interrupt, and &#x27;s&#x27; for a softirq).

What&#x27;s the point of adding another field to cover the same information
that&#x27;s already available?

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shakeel Butt noted that using mem_cgroup_id() in the patch would introduce an internal ID, and suggested replacing it with cgroup_id(memcg-&gt;css.cgroup) which is an inode number exposed to userspace</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Please don&#x27;t use mem_cgroup_id() here as it is an ID internal to memcg.
Use cgroup_id(memcg-&gt;css.cgroup) instead which is inode number and is
exposed to the userspace.</pre>
</details>
<div class="review-comment-signals">Signals: requested change</div>
</div>
</div>
<div class="thread-node depth-1" id="2025-12-17">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-17">2025-12-17</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer expressed concern that the patch does not handle the case where a task is being migrated, and suggested adding a check for TASK_MIGRATION flag in the vmscan tracepoint

reviewer noted that adding PID and cgroup ID fields to vmscan tracepoints would result in inefficient memory alignment, suggesting moving the memcg_id field between order and gfp_flags for better alignment</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, 16 Dec 2025 06:02:51 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

Hmm, the above adds some holes. Note, events are at a minimum, 4 bytes
aligend. On 64bit, they can be 8 byte aligned. Still, above is the same as:

	struct {
		int		order;
		unsigned long	gfp_flags;
		unsigned short	memcg_id;
	};

See the issue? Perhaps it may be better to add the memcg_id in between the
order and gfp_flags?

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: concern about migration, suggested additional check, alignment issue</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-29">2025-12-29</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the patch does not handle the case where a task is being migrated to another node, and requested that the PID be cleared when this happens

Reviewer Steven Rostedt suggested an alternative approach to add PID and cgroup ID information to vmscan tracepoints without modifying the ring buffer, instead using a format string that includes context about interrupt execution.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 29 Dec 2025 02:54:27 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

I just don&#x27;t like wasting valuable ring buffer space for something that can
be easily determined without it.

How about this. I just wrote up this patch, and it could be something you
use. I tested it against the sched waking events, by adding:

 		__entry-&gt;target_cpu	= task_cpu(p);
 	),
 
-	TP_printk(&quot;comm=%s pid=%d prio=%d target_cpu=%03d&quot;,
+	TP_printk(&quot;comm=%s pid=%d prio=%d target_cpu=%03d %s&quot;,
 		  __entry-&gt;comm, __entry-&gt;pid, __entry-&gt;prio,
-		  __entry-&gt;target_cpu)
+		  __entry-&gt;target_cpu,
+		  __event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
Which produces:

          &lt;idle&gt;-0     [003] d.h4.    44.832126: sched_waking:         comm=in:imklog pid=619 prio=120 target_cpu=006 (in-irq)
          &lt;idle&gt;-0     [003] d.s3.    44.832180: sched_waking:         comm=rcu_preempt pid=15 prio=120 target_cpu=001 (in-irq)
       in:imklog-619   [006] d..2.    44.832393: sched_waking:         comm=rs:main Q:Reg pid=620 prio=120 target_cpu=003 

You can see it adds &quot;(in-irq)&quot; when the even is executed from IRQ context
(soft or hard irq). But I also added __event_in_hardirq() and
__event_in_softirq() if you wanted to distinguish them.

Now you don&#x27;t need to update what goes into the ring buffer (and waste its
space), but only update the output format that makes it obvious that the
task was in interrupt context or not.

I also used trace-cmd to record the events, and it still parses properly
with no updates to libtraceevent needed.

Would this work for you?

Below is the patch that allows for this:

-- Steve


diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f5..53a23988a3b8 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f4..47008897a795 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.</pre>
</details>
<div class="review-comment-signals">Signals: requested change, alternative approach, no modification needed</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer noted that memcg_id is a u64 but was being used as an unsigned short, and suggested passing the memcg pointer to the tracepoint instead of using cgroup_id() directly.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Couple of comments:

1. memcg_id is u64 but the patch is using &#x27;unsigned short&#x27;.
2. I would prefer memcg pointer be passed in tracepoint and then in
trace header file cgroup_id() be used similar to other users in
include/trace/events/ folder.

Orthogonally I am cleaning up memcg id usage and after that cleanup,
mem_cgroup_id() would be preferred way to get the ID. No need to do
anything now as I will cleanup this usage later as well.</pre>
</details>
<div class="review-comment-signals">Signals: type mismatch, preference for alternative approach</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Andrew Morton</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Andrew Morton, reported a compilation error due to an implicit function declaration of &#x27;__event_in_irq&#x27; in the &#x27;trace_raw_output_mm_vmscan_direct_reclaim_begin_template&#x27; function. The issue arises from the macro &#x27;TP_printk&#x27; expanding to include the function call without declaring it first.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">x86_64 allmodconfig;


In file included from ./include/trace/define_trace.h:132,
                 from ./include/trace/events/vmscan.h:569,
                 from mm/vmscan.c:73:
./include/trace/events/vmscan.h: In function &#x27;trace_raw_output_mm_vmscan_direct_reclaim_begin_template&#x27;:
./include/trace/events/vmscan.h:140:17: error: implicit declaration of function &#x27;__event_in_irq&#x27; [-Wimplicit-function-declaration]
  140 | +               __event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
      |                 ^~~~~~~~~~~~~~
./include/trace/trace_events.h:219:34: note: in definition of macro &#x27;DECLARE_EVENT_CLASS&#x27;
  219 |         trace_event_printf(iter, print);                                \
      |                                  ^~~~~
./include/trace/events/vmscan.h:135:9: note: in expansion of macro &#x27;TP_printk&#x27;
  135 |         TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u %s&quot;,
      |         ^~~~~~~~~
make[3]: *** [scripts/Makefile.build:287: mm/vmscan.o] Error 1
make[2]: *** [scripts/Makefile.build:556: mm] Error 2
make[1]: *** [/usr/src/25/Makefile:2054: .] Error 2
make: *** [Makefile:248: __sub-make] Error 2</pre>
</details>
<div class="review-comment-signals">Signals: compilation error, implicit function declaration</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the patch does not handle the case where a task is being migrated, and requested that the PID be added to the tracepoint only after the migration has completed

reviewer expressed confusion about why his previous patch was not included in the series and requested clarification</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 5 Jan 2026 18:06:40 -0800
Andrew Morton &lt;akpm@linux-foundation.org&gt; wrote:

---

This is dependent on my patch:

  https://lore.kernel.org/all/20251229163515.3d1b0bba@gandalf.local.home/

Where I said you can take this patch. But I don&#x27;t see it as part of the
series.

  https://lore.kernel.org/all/20251229163634.5aad205d@gandalf.local.home/

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: migration, task, confusion</div>
</div>
</div>
<div class="thread-node depth-2">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-07">2026-01-07</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer pointed out that the patch can directly use mem_cgroup_id() after their own series landed in mm-new, eliminating the need for a CONFIG option</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Oh sorry, I meant my series [1] landed in mm-new and with that Thomas
can directly use mem_cgroup_id() without worrying about CONFIG_MEMCG=n.

[1] https://lkml.kernel.org/r/20251225232116.294540-1-shakeel.butt@linux.dev</pre>
</details>
<div class="review-comment-signals">Signals: no specific technical concern or suggestion</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-01-07">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Harry Yoo</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-07">2026-01-07</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Harry Yoo, pointed out that the patch breaks CONFIG_MEMCG=n builds due to an invalid use of undefined type &#x27;struct mem_cgroup&#x27; in various functions within include/trace/events/vmscan.h.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Hi Thomas, this is breaking CONFIG_MEMCG=n builds.

In file included from ./include/trace/define_trace.h:132,
                 from ./include/trace/events/vmscan.h:569,
                 from mm/vmscan.c:73:
./include/trace/events/vmscan.h: In function \u2018do_trace_event_raw_event_mm_shrink_slab_start\u2019:
./include/trace/events/vmscan.h:248:68: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  248 |                 __entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
      |                                                                    ^~
./include/trace/trace_events.h:427:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
  427 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/trace_events.h:435:23: note: in expansion of macro \u2018PARAMS\u2019
  435 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:214:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  214 | TRACE_EVENT(mm_shrink_slab_start,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:237:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  237 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
./include/trace/events/vmscan.h: In function \u2018do_trace_event_raw_event_mm_shrink_slab_end\u2019:
./include/trace/events/vmscan.h:293:56: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  293 |                 __entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
      |                                                        ^~
./include/trace/trace_events.h:427:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
  427 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/trace_events.h:435:23: note: in expansion of macro \u2018PARAMS\u2019
  435 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:266:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  266 | TRACE_EVENT(mm_shrink_slab_end,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:285:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  285 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
In file included from ./include/trace/define_trace.h:133:
./include/trace/events/vmscan.h: In function \u2018do_perf_trace_mm_shrink_slab_start\u2019:
./include/trace/events/vmscan.h:248:68: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  248 |                 __entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
      |                                                                    ^~
./include/trace/perf.h:51:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
   51 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/perf.h:67:23: note: in expansion of macro \u2018PARAMS\u2019
   67 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:214:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  214 | TRACE_EVENT(mm_shrink_slab_start,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:237:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  237 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
./include/trace/events/vmscan.h: In function \u2018do_perf_trace_mm_shrink_slab_end\u2019:
./include/trace/events/vmscan.h:293:56: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  293 |                 __entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
      |                                                        ^~
./include/trace/perf.h:51:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
   51 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/perf.h:67:23: note: in expansion of macro \u2018PARAMS\u2019
   67 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:266:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  266 | TRACE_EVENT(mm_shrink_slab_end,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:285:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  285 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
  CC      arch/x86/mm/extable.o
make[3]: *** [scripts/Makefile.build:287: mm/vmscan.o] Error 1
make[2]: *** [scripts/Makefile.build:556: mm] Error 2
make[2]: *** Waiting for unfinished jobs....

-- 
Cheers,
Harry / Hyeonggon</pre>
</details>
<div class="review-comment-signals">Signals: build failure, undefined type</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Andrew Morton</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Andrew Morton requested that Thomas Ballasi cc relevant maintainers on vmscan changes, specifically mentioning the output of scripts/get_maintainer.pl, and noted that the first patch was missing a Signed-off-by: from the original author.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Pleae cc the relevant maintainers on vmscan changes.  We have a
veritable army of them:

hp2:/usr/src/mm&gt; scripts/get_maintainer.pl --no-rolestats --nogit -f mm/vmscan.c
Andrew Morton &lt;akpm@linux-foundation.org&gt;
Axel Rasmussen &lt;axelrasmussen@google.com&gt;
Yuanchu Xie &lt;yuanchu@google.com&gt;
Wei Xu &lt;weixugc@google.com&gt;
Johannes Weiner &lt;hannes@cmpxchg.org&gt;
David Hildenbrand &lt;david@kernel.org&gt;
Michal Hocko &lt;mhocko@kernel.org&gt;
Qi Zheng &lt;zhengqi.arch@bytedance.com&gt;
Shakeel Butt &lt;shakeel.butt@linux.dev&gt;
Lorenzo Stoakes &lt;lorenzo.stoakes@oracle.com&gt;

The first patch should have your Signed-off-by:, as you were on the
delivery path.

The patchset looks sensible to me - I&#x27;ll await reviewer input before
proceeding.  Thanks.</pre>
</details>
<div class="review-comment-signals">Signals: cc-relevant-maintainers, missing-signed-off-by</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-01-27">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-27">2026-01-27</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shakeel Butt requested that the patch be modified to pass the memcg pointer to the tracepoints, allowing for the use of the mem_cgroup_id() function to obtain the cgroup ID.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Please pass memcg pointer to tracepoints and call mem_cgroup_id(memcg)
here.</pre>
</details>
<div class="review-comment-signals">Signals: requested change</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-02-16">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Usama Arif</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-16">2026-02-16</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer questioned the removal of __entry-&gt;shrink in the patch, wondering if it was an unintended change.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">__entry-&gt;shrink is removed here, but still printed below. Was this an intended
change of this commit?</pre>
</details>
<div class="review-comment-signals">Signals: unclear intention, potential mistake</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-16">2026-02-16</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the patch does not handle the case where a task is being migrated, and requested that the PID be updated to reflect the new location of the task

reviewer made a lighthearted comment about the patch, not raising any technical concerns or suggestions</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 16 Feb 2026 08:13:21 -0800
Usama Arif &lt;usama.arif@linux.dev&gt; wrote:

---

Yeah. That&#x27;s when you should have done &quot;cut-and-paste&quot; but instead just
typed it in by memory :-p

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: migrating tasks, PID update</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Reviewed-by</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Acked-by</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shakeel Butt questioned the necessity of the in_task() check and pointed out that memory reclaim only occurs in process context, making the __event_in_irq() check unnecessary.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Where is this in_task() check happening? Also this patch is changing
tracepoints for memory reclaim which never happens in any context other than
process context, so we don&#x27;t need __event_in_irq() checks for these tracepoints.</pre>
</details>
<div class="review-comment-signals">Signals: requested change, technical clarification</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-02-24">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Masami (Google)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-24">2026-02-24</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the patch does not handle the case where a task is being migrated to another node, and suggested adding a check for this condition

Reviewer Masami suggested using the existing common_pid field in the tracepoint format to store current-&gt;pid, instead of duplicating it.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Hi,

On Mon, 23 Feb 2026 09:15:44 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

All entries saves current-&gt;pid in common_pid field. Can you use
this common field?

# cat events/vmscan/mm_vmscan_reclaim_pages/format 
name: mm_vmscan_reclaim_pages
ID: 590
format:
	field:unsigned short common_type;	offset:0;	size:2;	signed:0;
	field:unsigned char common_flags;	offset:2;	size:1;	signed:0;
	field:unsigned char common_preempt_count;	offset:3;	size:1;	signed:0;
	field:int common_pid;	offset:4;	size:4;	signed:1;    ## &lt;------------here

	field:int nid;	offset:8;	size:4;	signed:1;
	field:unsigned long nr_scanned;	offset:16;	size:8;	signed:0;
	field:unsigned long nr_reclaimed;	offset:24;	size:8;	signed:0;
	field:unsigned long nr_dirty;	offset:32;	size:8;	signed:0;
	field:unsigned long nr_writeback;	offset:40;	size:8;	signed:0;
	field:unsigned long nr_congested;	offset:48;	size:8;	signed:0;
	field:unsigned long nr_immediate;	offset:56;	size:8;	signed:0;
	field:unsigned int nr_activate0;	offset:64;	size:4;	signed:0;
	field:unsigned int nr_activate1;	offset:68;	size:4;	signed:0;
	field:unsigned long nr_ref_keep;	offset:72;	size:8;	signed:0;
	field:unsigned long nr_unmap_fail;	offset:80;	size:8;	signed:0;

Thank you,

-- 
Masami Hiramatsu (Google) &lt;mhiramat@kernel.org&gt;</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, requested change</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-08">2025-12-08</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the reliability of PID detection in interrupt or RCU contexts, explained that they use in_task() to safely access current-&gt;pid when in process context, and confirmed that the PID field is set to -1 as a sentinel value when not in process context.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index afc9f80d03f34..eddb4e75e2e23 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -121,18 +121,21 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 	TP_STRUCT__entry(
 		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -167,16 +170,19 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%u&quot;,
 		__entry-&gt;nr_reclaimed,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -216,6 +222,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
@@ -229,6 +236,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
@@ -238,10 +246,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
@@ -261,6 +270,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
@@ -272,6 +282,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
@@ -280,10 +291,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged concern, provided explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2025-12-16">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about the swapped field entries in v1 causing a hole in the ring buffer, and responded that they had already fixed this issue by swapping the field entries in v2.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v2:
- Swapped field entries to prevent a hole in the ring buffer

Link to v1:
https://lore.kernel.org/linux-trace-kernel/20251208181413.4722-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h | 77 +++++++++++++++++++++++------------
 mm/vmscan.c                   | 17 ++++----
 2 files changed, 60 insertions(+), 34 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix, already implemented</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2, but did not explicitly state whether a fix is planned.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 65 +++++++++++++++++++++--------------
 mm/vmscan.c                   | 17 ++++-----
 2 files changed, 48 insertions(+), 34 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index d2123dd960d59..afc9f80d03f34 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(order, gfp_flags, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -209,6 +216,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
@@ -221,6 +229,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
@@ -229,10 +238,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -242,15 +252,16 @@ TRACE_EVENT(mm_shrink_slab_start,
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
-	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
+	TP_PROTO(struct shrinker *shr, struct shrink_control *sc, int shrinker_retval,
 		long unused_scan_cnt, long new_scan_cnt, long total_scan),
 
-	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
+	TP_ARGS(shr, sc, shrinker_retval, unused_scan_cnt, new_scan_cnt,
 		total_scan),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
@@ -260,7 +271,8 @@ TRACE_EVENT(mm_shrink_slab_end,
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
@@ -268,10 +280,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -463,9 +476,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 258f5472f1e90..0e65ec3a087a5 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -931,7 +931,7 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl, freed, nr, new_nr, total_scan);
 	return freed;
 }
 
@@ -7092,11 +7092,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7126,7 +7126,8 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
 	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+						      sc.gfp_mask,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -7137,7 +7138,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -7171,13 +7172,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -8072,7 +8073,7 @@ static int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned in
 	fs_reclaim_release(sc.gfp_mask);
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed, 0);
 
 	return sc.nr_reclaimed &gt;= nr_pages;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged a technical issue, agreed to restructure</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that they use in_task() to safely access current-&gt;pid when in process context and set the field to -1 as a sentinel value otherwise. The author&#x27;s response suggests no immediate fix is planned.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index afc9f80d03f34..315725f30b504 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -120,19 +120,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
 	TP_STRUCT__entry(
 		__field(	int,	order		)
+		__field(	int,	pid		)
 		__field(	unsigned long,	gfp_flags	)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -167,16 +170,19 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%u&quot;,
 		__entry-&gt;nr_reclaimed,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -216,6 +222,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
@@ -229,6 +236,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
@@ -238,10 +246,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
@@ -261,6 +270,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
@@ -272,6 +282,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
@@ -280,10 +291,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: no clear resolution signal, clarification</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-29">2025-12-29</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer pointed out that the patch does not handle the case where a task is being migrated to another cgroup, and suggested adding a check for this condition

reviewer suggested using a previously posted patch instead of the current one, providing a link to it</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 29 Dec 2025 13:29:42 -0500
Steven Rostedt &lt;rostedt@goodmis.org&gt; wrote:

---

If this would work for you. Feel free to take the patch I posted and use that:

   https://lore.kernel.org/all/20251229163515.3d1b0bba@gandalf.local.home/

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: task migration, cgroup change, no clear technical issue raised</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-05">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about the swapoff path needing to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in v2.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v3:
- Swapped multiple field entries to prevent a hole in the ring buffer
- Replaced in_task() with __event_in_irq
- Replaced mem_cgroup_id(memcg) with cgroup_id(memcg-&gt;css.cgroup)
- Rebased the tree to latest 6.18

Link to v2:
https://lore.kernel.org/linux-trace-kernel/20251216140252.11864-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h | 100 ++++++++++++++++++++++------------
 mm/shrinker.c                 |   2 +-
 mm/vmscan.c                   |  17 +++---
 3 files changed, 74 insertions(+), 45 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix needed, agreed to restructure</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the default value of the memory cgroup ID (memcg_id) being set to 0 for operations not associated with a specific cgroup, explaining that this is intentional and allows for better correlation and analysis. The author did not indicate any plans to change this behavior.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 79 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  2 +-
 mm/vmscan.c                   | 17 ++++----
 3 files changed, 56 insertions(+), 42 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..93a9a9ba9405d 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg_id),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	int,	order		)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -208,31 +215,34 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(unsigned short, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -242,36 +252,39 @@ TRACE_EVENT(mm_shrink_slab_start,
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
-	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
+	TP_PROTO(struct shrinker *shr, struct shrink_control *sc, int shrinker_retval,
 		long unused_scan_cnt, long new_scan_cnt, long total_scan),
 
-	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
+	TP_ARGS(shr, sc, shrinker_retval, unused_scan_cnt, new_scan_cnt,
 		total_scan),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(unsigned short, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..e3b894c20bec8 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -461,7 +461,7 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl, freed, nr, new_nr, total_scan);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index b2fc8b626d3df..3ac9f45461795 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6642,11 +6642,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6675,8 +6675,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      cgroup_id(memcg-&gt;css.cgroup));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6687,7 +6688,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, cgroup_id(memcg-&gt;css.cgroup));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6723,13 +6724,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, cgroup_id(memcg-&gt;css.cgroup));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, cgroup_id(memcg-&gt;css.cgroup));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7675,7 +7676,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: no clear resolution signal, author provided explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the reliability of PID detection in interrupt and RCU contexts, explaining that the PID field is set to -1 as a sentinel value when not in process context, and using in_task() to safely access current-&gt;pid when in process context. The author confirmed that this approach is correct.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 33 ++++++++++++++++++++++++---------
 1 file changed, 24 insertions(+), 9 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 93a9a9ba9405d..d438abfa03ebb 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -121,19 +121,23 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	gfp_flags	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -167,17 +171,21 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%u %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -222,6 +230,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, total_scan)
 		__field(int, priority)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 	),
 
@@ -235,20 +244,23 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged concern, explained reasoning</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-07">2026-01-07</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer pointed out that the patch does not handle the case where a task is being migrated to another node, and suggested adding a check for this scenario

Reviewer Shakeel Butt requested that the patch use mem_cgroup_id() instead of cgroup_id(memcg-&gt;css.cgroup) to improve accuracy and consistency in tracing cgroup IDs.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, Jan 05, 2026 at 02:46:39PM -0800, Shakeel Butt wrote:
[...]

---

The series has been landed in mm-new. Please use mem_cgroup_id() instead
of cgroup_id(memcg-&gt;css.cgroup).</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, requested change</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-15">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about the type of memcg_id instances in vmscan tracepoints by changing them from unsigned short to u64, and updated struct entries accordingly.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v4:
- added Steven&#x27;s patch for __even_in_*irq() calls
- moved back to mem_cgroup_id() following Shakeel&#x27;s changes
- passed cgroup ID through trace calls for slab_* tracepoints
  instead of in vmscan.h directly
- changed memcg_id instances types from unsigned short to u64 and
  updated struct entries accordingly

Link to v3:
https://lore.kernel.org/linux-trace-kernel/20260105160423.23708-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 104 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 48 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged feedback, made changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about tracepoint flags and how they are used to indicate interrupt or softirq context. The author agrees that the information should be stored in the event structure itself, not just in the flags portion of the event header, but notes that this would require changes to existing code and suggests using helper macros instead.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __entry_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the default value of the memory cgroup ID (memcg_id) in tracepoints, explaining that it is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..20160e79eb0d7 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg_id),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, u64 memcg_id),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, u64 memcg_id),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ccfbe3fb3b378 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   mem_cgroup_id(shrinkctl-&gt;memcg));
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 mem_cgroup_id(shrinkctl-&gt;memcg));
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index b2fc8b626d3df..9a3cd975a9f30 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6642,11 +6642,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6675,8 +6675,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6687,7 +6688,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6723,13 +6724,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7675,7 +7676,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that they use in_task() to safely access current-&gt;pid when in process context and set it to -1 as a sentinel value otherwise.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 35 +++++++++++++++++++++++++----------
 1 file changed, 25 insertions(+), 10 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 20160e79eb0d7..288589e3364b0 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= memcg_id;
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = memcg_id;
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-22">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author acknowledged a concern about extra &#x27;+&#x27; characters at (in-irq) warnings and confirmed that the issue was fixed in v5.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v5:
- Fixed a small quirk that added extra +&#x27;s at (in-irq) warnings

Link to v4:
https://lore.kernel.org/linux-trace-kernel/20260115123809.2257-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 104 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 48 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged, confirmed</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about tracepoint flags, explained that instead of recording this information directly in the event structure, helper macros can be used to print the context (interrupt or softirq) using the flags portion of the event header.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __entry_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the difficulty of attributing memory reclaim events to specific cgroups, explaining that adding memory cgroup ID (memcg_id) to key vmscan tracepoints will enable better correlation and analysis. The field is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..20160e79eb0d7 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg_id),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, u64 memcg_id),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, u64 memcg_id),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ccfbe3fb3b378 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   mem_cgroup_id(shrinkctl-&gt;memcg));
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 mem_cgroup_id(shrinkctl-&gt;memcg));
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index b2fc8b626d3df..9a3cd975a9f30 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6642,11 +6642,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6675,8 +6675,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6687,7 +6688,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6723,13 +6724,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7675,7 +7676,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the PID field being set to -1 in non-process contexts, explaining that it uses in_task() to reliably detect when in process context and safely access current-&gt;pid.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 35 +++++++++++++++++++++++++----------
 1 file changed, 25 insertions(+), 10 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 20160e79eb0d7..c7f7621e48af5 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= memcg_id;
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = memcg_id;
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-13">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author acknowledged Steven&#x27;s patch was used as a reference and explained that passing memcg pointers instead of IDs is the correct approach, confirming this change in v6.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v6:
- Updated Steven&#x27;s patch with sign-off
- Passed memcg pointers as arguments in tracepoints instead of memcg_id

Link to v5:
https://lore.kernel.org/linux-trace-kernel/20260122182510.2126-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 104 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 48 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged prior work, explained technical decision</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about trace events wanting to expose if they were triggered in interrupt or softirq context, and explained that helper macros can be used in the print format to achieve this.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __entry_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the patch adding memory cgroup ID (memcg_id) to key vmscan tracepoints, which was previously missing in some scenarios. The author explains that for operations not associated with a specific cgroup, the field is defaulted to 0.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..1212f6a7c223e 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ddf784f996a59 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   shrinkctl-&gt;memcg);
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 shrinkctl-&gt;memcg);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 614ccf39fe3fa..9d512fb354fcd 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6603,11 +6603,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6636,8 +6636,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      memcg);
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6648,7 +6649,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, memcg);
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6684,13 +6685,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, memcg);
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, memcg);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7642,7 +7643,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that they use in_task() to safely access current-&gt;pid when in process context and set it to -1 as a sentinel value otherwise.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 35 +++++++++++++++++++++++++----------
 1 file changed, 25 insertions(+), 10 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 1212f6a7c223e..a68b712ef757a 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-23">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about the __entry_in_irq() macro being renamed to __event_in_irq(), confirming that the change was made in v6 and providing a link to the updated patch.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v6:
- Edited __entry_in_irq() to __event_in_irq() in corresponding commit
  message
- Restore an entry that was removed inadvertently

Link to v6:
https://lore.kernel.org/linux-trace-kernel/20260213181537.54350-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 103 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 47 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix, provided clarification</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about tracepoint flags and interrupt context, explaining that instead of recording this information in the event structure itself, helper macros can be used to print the relevant information in the format string.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing concerns about the patch&#x27;s ability to attribute memory reclaim events to specific cgroups, making debugging challenging. The author explains that the field is defaulted to 0 for operations not associated with a specific cgroup and provides context on why this is necessary.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..1212f6a7c223e 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ddf784f996a59 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   shrinkctl-&gt;memcg);
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 shrinkctl-&gt;memcg);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 614ccf39fe3fa..9d512fb354fcd 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6603,11 +6603,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6636,8 +6636,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      memcg);
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6648,7 +6649,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, memcg);
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6684,13 +6685,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, memcg);
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, memcg);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7642,7 +7643,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that the PID field is set to -1 as a sentinel value when not in process context and using in_task() to safely access current-&gt;pid when in process context.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 34 +++++++++++++++++++++++++---------
 1 file changed, 25 insertions(+), 9 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 1212f6a7c223e..15b31281f0955 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,6 +278,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
@@ -277,18 +290,21 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>