<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: [PATCH v3 0/3] pull region-specific logic into new files</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }
        .reply-to-label {
            font-size: 0.8em;
            color: #999;
            font-style: italic;
            margin-top: 3px;
        }
        .lore-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 0.82em;
            color: #0366d6;
            text-decoration: none;
            font-weight: 500;
            white-space: nowrap;
        }
        .lore-link:hover { text-decoration: underline; color: #0056b3; }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../index.html">&larr; Back to reports</a></div>
    <h1>[PATCH v3 0/3] pull region-specific logic into new files</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/20260211204206.2171525-1-gourry@gourry.net/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-20">2026-02-20</a> &bull; <a href="#2026-02-17">2026-02-17</a> &bull; <a href="#2026-02-11">2026-02-11</a></div>
    <div class="patch-summary-block"><div class="patch-summary-label">Patch summary</div><div class="patch-summary-text">This patch refactors the cxl_region management code in region.c to separate logic for pmem and dax regions into new files, region_pmem.c and region_dax.c respectively. This improves code organization, reduces development conflicts, and clarifies where changes occur. Additionally, a cleanup.h fixup is included to tidy up existing functions.</div></div>
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-11">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-20_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-11">2026-02-11</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the region-specific logic in core/region.c being overloaded, and responded by moving pmem region logic from region.c into region_pmem.c to make it clear that this code only applies to pmem regions. The author confirmed that no functional changes were made.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">core/region.c is overloaded with per-region control logic (pmem, dax).
Move pmem region logic from region.c into region_pmem.c to make it
clear that this code only applies to pmem regions.

No functional changes.

Reviewed-by: Dave Jiang &lt;dave.jiang@intel.com&gt;
Reviewed-by: Fabio M. De Francesco &lt;fabio.m.de.francesco@linux.intel.com&gt;
Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;
---
 drivers/cxl/core/Makefile      |   1 +
 drivers/cxl/core/core.h        |   1 +
 drivers/cxl/core/region.c      | 184 --------------------------------
 drivers/cxl/core/region_pmem.c | 189 +++++++++++++++++++++++++++++++++
 4 files changed, 191 insertions(+), 184 deletions(-)
 create mode 100644 drivers/cxl/core/region_pmem.c

diff --git a/drivers/cxl/core/Makefile b/drivers/cxl/core/Makefile
index a639a9499972..d1484a0e5eb4 100644
--- a/drivers/cxl/core/Makefile
+++ b/drivers/cxl/core/Makefile
@@ -16,6 +16,7 @@ cxl_core-y += pmu.o
 cxl_core-y += cdat.o
 cxl_core-$(CONFIG_TRACING) += trace.o
 cxl_core-$(CONFIG_CXL_REGION) += region.o
+cxl_core-$(CONFIG_CXL_REGION) += region_pmem.o
 cxl_core-$(CONFIG_CXL_MCE) += mce.o
 cxl_core-$(CONFIG_CXL_FEATURES) += features.o
 cxl_core-$(CONFIG_CXL_EDAC_MEM_FEATURES) += edac.o
diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index 007b8aff0238..ced65a779a09 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -50,6 +50,7 @@ int cxl_get_poison_by_endpoint(struct cxl_port *port);
 struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa);
 u64 cxl_dpa_to_hpa(struct cxl_region *cxlr, const struct cxl_memdev *cxlmd,
 		   u64 dpa);
+int devm_cxl_add_pmem_region(struct cxl_region *cxlr);
 
 #else
 static inline u64 cxl_dpa_to_hpa(struct cxl_region *cxlr,
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index bd4c4a4a27da..1c322318d70e 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -2757,46 +2757,6 @@ static ssize_t delete_region_store(struct device *dev,
 }
 DEVICE_ATTR_WO(delete_region);
 
-static void cxl_pmem_region_release(struct device *dev)
-{
-	struct cxl_pmem_region *cxlr_pmem = to_cxl_pmem_region(dev);
-	int i;
-
-	for (i = 0; i &lt; cxlr_pmem-&gt;nr_mappings; i++) {
-		struct cxl_memdev *cxlmd = cxlr_pmem-&gt;mapping[i].cxlmd;
-
-		put_device(&amp;cxlmd-&gt;dev);
-	}
-
-	kfree(cxlr_pmem);
-}
-
-static const struct attribute_group *cxl_pmem_region_attribute_groups[] = {
-	&amp;cxl_base_attribute_group,
-	NULL,
-};
-
-const struct device_type cxl_pmem_region_type = {
-	.name = &quot;cxl_pmem_region&quot;,
-	.release = cxl_pmem_region_release,
-	.groups = cxl_pmem_region_attribute_groups,
-};
-
-bool is_cxl_pmem_region(struct device *dev)
-{
-	return dev-&gt;type == &amp;cxl_pmem_region_type;
-}
-EXPORT_SYMBOL_NS_GPL(is_cxl_pmem_region, &quot;CXL&quot;);
-
-struct cxl_pmem_region *to_cxl_pmem_region(struct device *dev)
-{
-	if (dev_WARN_ONCE(dev, !is_cxl_pmem_region(dev),
-			  &quot;not a cxl_pmem_region device\n&quot;))
-		return NULL;
-	return container_of(dev, struct cxl_pmem_region, dev);
-}
-EXPORT_SYMBOL_NS_GPL(to_cxl_pmem_region, &quot;CXL&quot;);
-
 struct cxl_poison_context {
 	struct cxl_port *port;
 	int part;
@@ -3432,64 +3392,6 @@ static int region_offset_to_dpa_result(struct cxl_region *cxlr, u64 offset,
 	return -ENXIO;
 }
 
-static struct lock_class_key cxl_pmem_region_key;
-
-static int cxl_pmem_region_alloc(struct cxl_region *cxlr)
-{
-	struct cxl_region_params *p = &amp;cxlr-&gt;params;
-	struct cxl_nvdimm_bridge *cxl_nvb;
-	struct device *dev;
-	int i;
-
-	guard(rwsem_read)(&amp;cxl_rwsem.region);
-	if (p-&gt;state != CXL_CONFIG_COMMIT)
-		return -ENXIO;
-
-	struct cxl_pmem_region *cxlr_pmem __free(kfree) =
-		kzalloc(struct_size(cxlr_pmem, mapping, p-&gt;nr_targets), GFP_KERNEL);
-	if (!cxlr_pmem)
-		return -ENOMEM;
-
-	cxlr_pmem-&gt;hpa_range.start = p-&gt;res-&gt;start;
-	cxlr_pmem-&gt;hpa_range.end = p-&gt;res-&gt;end;
-
-	/* Snapshot the region configuration underneath the cxl_rwsem.region */
-	cxlr_pmem-&gt;nr_mappings = p-&gt;nr_targets;
-	for (i = 0; i &lt; p-&gt;nr_targets; i++) {
-		struct cxl_endpoint_decoder *cxled = p-&gt;targets[i];
-		struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
-		struct cxl_pmem_region_mapping *m = &amp;cxlr_pmem-&gt;mapping[i];
-
-		/*
-		 * Regions never span CXL root devices, so by definition the
-		 * bridge for one device is the same for all.
-		 */
-		if (i == 0) {
-			cxl_nvb = cxl_find_nvdimm_bridge(cxlmd-&gt;endpoint);
-			if (!cxl_nvb)
-				return -ENODEV;
-			cxlr-&gt;cxl_nvb = cxl_nvb;
-		}
-		m-&gt;cxlmd = cxlmd;
-		get_device(&amp;cxlmd-&gt;dev);
-		m-&gt;start = cxled-&gt;dpa_res-&gt;start;
-		m-&gt;size = resource_size(cxled-&gt;dpa_res);
-		m-&gt;position = i;
-	}
-
-	dev = &amp;cxlr_pmem-&gt;dev;
-	device_initialize(dev);
-	lockdep_set_class(&amp;dev-&gt;mutex, &amp;cxl_pmem_region_key);
-	device_set_pm_not_required(dev);
-	dev-&gt;parent = &amp;cxlr-&gt;dev;
-	dev-&gt;bus = &amp;cxl_bus_type;
-	dev-&gt;type = &amp;cxl_pmem_region_type;
-	cxlr_pmem-&gt;cxlr = cxlr;
-	cxlr-&gt;cxlr_pmem = no_free_ptr(cxlr_pmem);
-
-	return 0;
-}
-
 static void cxl_dax_region_release(struct device *dev)
 {
 	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
@@ -3553,92 +3455,6 @@ static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)
 	return cxlr_dax;
 }
 
-static void cxlr_pmem_unregister(void *_cxlr_pmem)
-{
-	struct cxl_pmem_region *cxlr_pmem = _cxlr_pmem;
-	struct cxl_region *cxlr = cxlr_pmem-&gt;cxlr;
-	struct cxl_nvdimm_bridge *cxl_nvb = cxlr-&gt;cxl_nvb;
-
-	/*
-	 * Either the bridge is in -&gt;remove() context under the device_lock(),
-	 * or cxlr_release_nvdimm() is cancelling the bridge&#x27;s release action
-	 * for @cxlr_pmem and doing it itself (while manually holding the bridge
-	 * lock).
-	 */
-	device_lock_assert(&amp;cxl_nvb-&gt;dev);
-	cxlr-&gt;cxlr_pmem = NULL;
-	cxlr_pmem-&gt;cxlr = NULL;
-	device_unregister(&amp;cxlr_pmem-&gt;dev);
-}
-
-static void cxlr_release_nvdimm(void *_cxlr)
-{
-	struct cxl_region *cxlr = _cxlr;
-	struct cxl_nvdimm_bridge *cxl_nvb = cxlr-&gt;cxl_nvb;
-
-	scoped_guard(device, &amp;cxl_nvb-&gt;dev) {
-		if (cxlr-&gt;cxlr_pmem)
-			devm_release_action(&amp;cxl_nvb-&gt;dev, cxlr_pmem_unregister,
-					    cxlr-&gt;cxlr_pmem);
-	}
-	cxlr-&gt;cxl_nvb = NULL;
-	put_device(&amp;cxl_nvb-&gt;dev);
-}
-
-/**
- * devm_cxl_add_pmem_region() - add a cxl_region-to-nd_region bridge
- * @cxlr: parent CXL region for this pmem region bridge device
- *
- * Return: 0 on success negative error code on failure.
- */
-static int devm_cxl_add_pmem_region(struct cxl_region *cxlr)
-{
-	struct cxl_pmem_region *cxlr_pmem;
-	struct cxl_nvdimm_bridge *cxl_nvb;
-	struct device *dev;
-	int rc;
-
-	rc = cxl_pmem_region_alloc(cxlr);
-	if (rc)
-		return rc;
-	cxlr_pmem = cxlr-&gt;cxlr_pmem;
-	cxl_nvb = cxlr-&gt;cxl_nvb;
-
-	dev = &amp;cxlr_pmem-&gt;dev;
-	rc = dev_set_name(dev, &quot;pmem_region%d&quot;, cxlr-&gt;id);
-	if (rc)
-		goto err;
-
-	rc = device_add(dev);
-	if (rc)
-		goto err;
-
-	dev_dbg(&amp;cxlr-&gt;dev, &quot;%s: register %s\n&quot;, dev_name(dev-&gt;parent),
-		dev_name(dev));
-
-	scoped_guard(device, &amp;cxl_nvb-&gt;dev) {
-		if (cxl_nvb-&gt;dev.driver)
-			rc = devm_add_action_or_reset(&amp;cxl_nvb-&gt;dev,
-						      cxlr_pmem_unregister,
-						      cxlr_pmem);
-		else
-			rc = -ENXIO;
-	}
-
-	if (rc)
-		goto err_bridge;
-
-	/* @cxlr carries a reference on @cxl_nvb until cxlr_release_nvdimm */
-	return devm_add_action_or_reset(&amp;cxlr-&gt;dev, cxlr_release_nvdimm, cxlr);
-
-err:
-	put_device(dev);
-err_bridge:
-	put_device(&amp;cxl_nvb-&gt;dev);
-	cxlr-&gt;cxl_nvb = NULL;
-	return rc;
-}
-
 static void cxlr_dax_unregister(void *_cxlr_dax)
 {
 	struct cxl_dax_region *cxlr_dax = _cxlr_dax;
diff --git a/drivers/cxl/core/region_pmem.c b/drivers/cxl/core/region_pmem.c
new file mode 100644
index 000000000000..f800407566d3
--- /dev/null
+++ b/drivers/cxl/core/region_pmem.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* Copyright(c) 2022 Intel Corporation. All rights reserved. */
+#include &lt;linux/device.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;cxlmem.h&gt;
+#include &lt;cxl.h&gt;
+#include &quot;core.h&quot;
+
+static void cxl_pmem_region_release(struct device *dev)
+{
+	struct cxl_pmem_region *cxlr_pmem = to_cxl_pmem_region(dev);
+	int i;
+
+	for (i = 0; i &lt; cxlr_pmem-&gt;nr_mappings; i++) {
+		struct cxl_memdev *cxlmd = cxlr_pmem-&gt;mapping[i].cxlmd;
+
+		put_device(&amp;cxlmd-&gt;dev);
+	}
+
+	kfree(cxlr_pmem);
+}
+
+static const struct attribute_group *cxl_pmem_region_attribute_groups[] = {
+	&amp;cxl_base_attribute_group,
+	NULL
+};
+
+const struct device_type cxl_pmem_region_type = {
+	.name = &quot;cxl_pmem_region&quot;,
+	.release = cxl_pmem_region_release,
+	.groups = cxl_pmem_region_attribute_groups,
+};
+bool is_cxl_pmem_region(struct device *dev)
+{
+	return dev-&gt;type == &amp;cxl_pmem_region_type;
+}
+EXPORT_SYMBOL_NS_GPL(is_cxl_pmem_region, &quot;CXL&quot;);
+
+struct cxl_pmem_region *to_cxl_pmem_region(struct device *dev)
+{
+	if (dev_WARN_ONCE(dev, !is_cxl_pmem_region(dev),
+				&quot;not a cxl_pmem_region device\n&quot;))
+		return NULL;
+	return container_of(dev, struct cxl_pmem_region, dev);
+}
+EXPORT_SYMBOL_NS_GPL(to_cxl_pmem_region, &quot;CXL&quot;);
+static struct lock_class_key cxl_pmem_region_key;
+
+static int cxl_pmem_region_alloc(struct cxl_region *cxlr)
+{
+	struct cxl_region_params *p = &amp;cxlr-&gt;params;
+	struct cxl_nvdimm_bridge *cxl_nvb;
+	struct device *dev;
+	int i;
+
+	guard(rwsem_read)(&amp;cxl_rwsem.region);
+	if (p-&gt;state != CXL_CONFIG_COMMIT)
+		return -ENXIO;
+
+	struct cxl_pmem_region *cxlr_pmem __free(kfree) =
+		kzalloc(struct_size(cxlr_pmem, mapping, p-&gt;nr_targets), GFP_KERNEL);
+	if (!cxlr_pmem)
+		return -ENOMEM;
+
+	cxlr_pmem-&gt;hpa_range.start = p-&gt;res-&gt;start;
+	cxlr_pmem-&gt;hpa_range.end = p-&gt;res-&gt;end;
+
+	/* Snapshot the region configuration underneath the cxl_rwsem.region */
+	cxlr_pmem-&gt;nr_mappings = p-&gt;nr_targets;
+	for (i = 0; i &lt; p-&gt;nr_targets; i++) {
+		struct cxl_endpoint_decoder *cxled = p-&gt;targets[i];
+		struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
+		struct cxl_pmem_region_mapping *m = &amp;cxlr_pmem-&gt;mapping[i];
+
+		/*
+		 * Regions never span CXL root devices, so by definition the
+		 * bridge for one device is the same for all.
+		 */
+		if (i == 0) {
+			cxl_nvb = cxl_find_nvdimm_bridge(cxlmd-&gt;endpoint);
+			if (!cxl_nvb)
+				return -ENODEV;
+			cxlr-&gt;cxl_nvb = cxl_nvb;
+		}
+		m-&gt;cxlmd = cxlmd;
+		get_device(&amp;cxlmd-&gt;dev);
+		m-&gt;start = cxled-&gt;dpa_res-&gt;start;
+		m-&gt;size = resource_size(cxled-&gt;dpa_res);
+		m-&gt;position = i;
+	}
+
+	dev = &amp;cxlr_pmem-&gt;dev;
+	device_initialize(dev);
+	lockdep_set_class(&amp;dev-&gt;mutex, &amp;cxl_pmem_region_key);
+	device_set_pm_not_required(dev);
+	dev-&gt;parent = &amp;cxlr-&gt;dev;
+	dev-&gt;bus = &amp;cxl_bus_type;
+	dev-&gt;type = &amp;cxl_pmem_region_type;
+	cxlr_pmem-&gt;cxlr = cxlr;
+	cxlr-&gt;cxlr_pmem = no_free_ptr(cxlr_pmem);
+
+	return 0;
+}
+
+static void cxlr_pmem_unregister(void *_cxlr_pmem)
+{
+	struct cxl_pmem_region *cxlr_pmem = _cxlr_pmem;
+	struct cxl_region *cxlr = cxlr_pmem-&gt;cxlr;
+	struct cxl_nvdimm_bridge *cxl_nvb = cxlr-&gt;cxl_nvb;
+
+	/*
+	 * Either the bridge is in -&gt;remove() context under the device_lock(),
+	 * or cxlr_release_nvdimm() is cancelling the bridge&#x27;s release action
+	 * for @cxlr_pmem and doing it itself (while manually holding the bridge
+	 * lock).
+	 */
+	device_lock_assert(&amp;cxl_nvb-&gt;dev);
+	cxlr-&gt;cxlr_pmem = NULL;
+	cxlr_pmem-&gt;cxlr = NULL;
+	device_unregister(&amp;cxlr_pmem-&gt;dev);
+}
+
+static void cxlr_release_nvdimm(void *_cxlr)
+{
+	struct cxl_region *cxlr = _cxlr;
+	struct cxl_nvdimm_bridge *cxl_nvb = cxlr-&gt;cxl_nvb;
+
+	scoped_guard(device, &amp;cxl_nvb-&gt;dev) {
+		if (cxlr-&gt;cxlr_pmem)
+			devm_release_action(&amp;cxl_nvb-&gt;dev, cxlr_pmem_unregister,
+					cxlr-&gt;cxlr_pmem);
+	}
+	cxlr-&gt;cxl_nvb = NULL;
+	put_device(&amp;cxl_nvb-&gt;dev);
+}
+
+/**
+ * devm_cxl_add_pmem_region() - add a cxl_region-to-nd_region bridge
+ * @cxlr: parent CXL region for this pmem region bridge device
+ *
+ * Return: 0 on success negative error code on failure.
+ */
+int devm_cxl_add_pmem_region(struct cxl_region *cxlr)
+{
+	struct cxl_pmem_region *cxlr_pmem;
+	struct cxl_nvdimm_bridge *cxl_nvb;
+	struct device *dev;
+	int rc;
+
+	rc = cxl_pmem_region_alloc(cxlr);
+	if (rc)
+		return rc;
+	cxlr_pmem = cxlr-&gt;cxlr_pmem;
+	cxl_nvb = cxlr-&gt;cxl_nvb;
+
+	dev = &amp;cxlr_pmem-&gt;dev;
+	rc = dev_set_name(dev, &quot;pmem_region%d&quot;, cxlr-&gt;id);
+	if (rc)
+		goto err;
+
+	rc = device_add(dev);
+	if (rc)
+		goto err;
+
+	dev_dbg(&amp;cxlr-&gt;dev, &quot;%s: register %s\n&quot;, dev_name(dev-&gt;parent),
+			dev_name(dev));
+
+	scoped_guard(device, &amp;cxl_nvb-&gt;dev) {
+		if (cxl_nvb-&gt;dev.driver)
+			rc = devm_add_action_or_reset(&amp;cxl_nvb-&gt;dev,
+					cxlr_pmem_unregister,
+					cxlr_pmem);
+		else
+			rc = -ENXIO;
+	}
+
+	if (rc)
+		goto err_bridge;
+
+	/* @cxlr carries a reference on @cxl_nvb until cxlr_release_nvdimm */
+	return devm_add_action_or_reset(&amp;cxlr-&gt;dev, cxlr_release_nvdimm, cxlr);
+
+err:
+	put_device(dev);
+err_bridge:
+	put_device(&amp;cxl_nvb-&gt;dev);
+	cxlr-&gt;cxl_nvb = NULL;
+	return rc;
+}
-- 
2.47.3</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged a concern, confirmed no functional changes</div>
</div>
<div class="thread-children">
<div class="thread-node depth-1" id="2026-02-17">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Dave Jiang</span>
<a class="date-chip" href="../2026-02-20_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Dave Jiang suggested keeping a local variable that is currently being removed and reused in the patch, citing its repeated use as a reason for retention.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Given that this local var is used multiple times, maybe we should keep it?

DJ</pre>
</details>
<div class="reply-to-label">&#8627; replying to Gregory Price</div>
<div class="review-comment-signals">Signals: requested change</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2" id="2026-02-20">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-20_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-20">2026-02-20</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author acknowledged the need to re-spin the patch after reviewer feedback and agreed to do so</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Fair, will re-spin claned up

~Gregory</pre>
</details>
<div class="reply-to-label">&#8627; replying to Dave Jiang</div>
<div class="review-comment-signals">Signals: acknowledged, re-spin</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-20_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-11">2026-02-11</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the overloading of region control logic in core/region.c by moving CXL DAX region device logic into region_dax.c, confirming that no functional changes were made.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">core/region.c is overloaded with per-region control logic (pmem, dax).
Move CXL DAX region device logic from region.c into region_dax.c.

No functional changes.

Reviewed-by: Dave Jiang &lt;dave.jiang@intel.com&gt;
Reviewed-by: Fabio M. De Francesco &lt;fabio.m.de.francesco@linux.intel.com&gt;
Acked-by: Davidlohr Bueso &lt;dave@stgolabs.net&gt;
Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;
---
 drivers/cxl/core/Makefile     |   1 +
 drivers/cxl/core/core.h       |   1 +
 drivers/cxl/core/region.c     |  99 ------------------------------
 drivers/cxl/core/region_dax.c | 109 ++++++++++++++++++++++++++++++++++
 4 files changed, 111 insertions(+), 99 deletions(-)
 create mode 100644 drivers/cxl/core/region_dax.c

diff --git a/drivers/cxl/core/Makefile b/drivers/cxl/core/Makefile
index d1484a0e5eb4..d3ec8aea64c5 100644
--- a/drivers/cxl/core/Makefile
+++ b/drivers/cxl/core/Makefile
@@ -16,6 +16,7 @@ cxl_core-y += pmu.o
 cxl_core-y += cdat.o
 cxl_core-$(CONFIG_TRACING) += trace.o
 cxl_core-$(CONFIG_CXL_REGION) += region.o
+cxl_core-$(CONFIG_CXL_REGION) += region_dax.o
 cxl_core-$(CONFIG_CXL_REGION) += region_pmem.o
 cxl_core-$(CONFIG_CXL_MCE) += mce.o
 cxl_core-$(CONFIG_CXL_FEATURES) += features.o
diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index ced65a779a09..a89e0d6d9e7b 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -50,6 +50,7 @@ int cxl_get_poison_by_endpoint(struct cxl_port *port);
 struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa);
 u64 cxl_dpa_to_hpa(struct cxl_region *cxlr, const struct cxl_memdev *cxlmd,
 		   u64 dpa);
+int devm_cxl_add_dax_region(struct cxl_region *cxlr);
 int devm_cxl_add_pmem_region(struct cxl_region *cxlr);
 
 #else
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 1c322318d70e..0c37caa60f2a 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -3392,105 +3392,6 @@ static int region_offset_to_dpa_result(struct cxl_region *cxlr, u64 offset,
 	return -ENXIO;
 }
 
-static void cxl_dax_region_release(struct device *dev)
-{
-	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
-
-	kfree(cxlr_dax);
-}
-
-static const struct attribute_group *cxl_dax_region_attribute_groups[] = {
-	&amp;cxl_base_attribute_group,
-	NULL,
-};
-
-const struct device_type cxl_dax_region_type = {
-	.name = &quot;cxl_dax_region&quot;,
-	.release = cxl_dax_region_release,
-	.groups = cxl_dax_region_attribute_groups,
-};
-
-static bool is_cxl_dax_region(struct device *dev)
-{
-	return dev-&gt;type == &amp;cxl_dax_region_type;
-}
-
-struct cxl_dax_region *to_cxl_dax_region(struct device *dev)
-{
-	if (dev_WARN_ONCE(dev, !is_cxl_dax_region(dev),
-			  &quot;not a cxl_dax_region device\n&quot;))
-		return NULL;
-	return container_of(dev, struct cxl_dax_region, dev);
-}
-EXPORT_SYMBOL_NS_GPL(to_cxl_dax_region, &quot;CXL&quot;);
-
-static struct lock_class_key cxl_dax_region_key;
-
-static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)
-{
-	struct cxl_region_params *p = &amp;cxlr-&gt;params;
-	struct cxl_dax_region *cxlr_dax;
-	struct device *dev;
-
-	guard(rwsem_read)(&amp;cxl_rwsem.region);
-	if (p-&gt;state != CXL_CONFIG_COMMIT)
-		return ERR_PTR(-ENXIO);
-
-	cxlr_dax = kzalloc(sizeof(*cxlr_dax), GFP_KERNEL);
-	if (!cxlr_dax)
-		return ERR_PTR(-ENOMEM);
-
-	cxlr_dax-&gt;hpa_range.start = p-&gt;res-&gt;start;
-	cxlr_dax-&gt;hpa_range.end = p-&gt;res-&gt;end;
-
-	dev = &amp;cxlr_dax-&gt;dev;
-	cxlr_dax-&gt;cxlr = cxlr;
-	device_initialize(dev);
-	lockdep_set_class(&amp;dev-&gt;mutex, &amp;cxl_dax_region_key);
-	device_set_pm_not_required(dev);
-	dev-&gt;parent = &amp;cxlr-&gt;dev;
-	dev-&gt;bus = &amp;cxl_bus_type;
-	dev-&gt;type = &amp;cxl_dax_region_type;
-
-	return cxlr_dax;
-}
-
-static void cxlr_dax_unregister(void *_cxlr_dax)
-{
-	struct cxl_dax_region *cxlr_dax = _cxlr_dax;
-
-	device_unregister(&amp;cxlr_dax-&gt;dev);
-}
-
-static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
-{
-	struct cxl_dax_region *cxlr_dax;
-	struct device *dev;
-	int rc;
-
-	cxlr_dax = cxl_dax_region_alloc(cxlr);
-	if (IS_ERR(cxlr_dax))
-		return PTR_ERR(cxlr_dax);
-
-	dev = &amp;cxlr_dax-&gt;dev;
-	rc = dev_set_name(dev, &quot;dax_region%d&quot;, cxlr-&gt;id);
-	if (rc)
-		goto err;
-
-	rc = device_add(dev);
-	if (rc)
-		goto err;
-
-	dev_dbg(&amp;cxlr-&gt;dev, &quot;%s: register %s\n&quot;, dev_name(dev-&gt;parent),
-		dev_name(dev));
-
-	return devm_add_action_or_reset(&amp;cxlr-&gt;dev, cxlr_dax_unregister,
-					cxlr_dax);
-err:
-	put_device(dev);
-	return rc;
-}
-
 static int match_root_decoder(struct device *dev, const void *data)
 {
 	const struct range *r1, *r2 = data;
diff --git a/drivers/cxl/core/region_dax.c b/drivers/cxl/core/region_dax.c
new file mode 100644
index 000000000000..c8dd2bd1d9b9
--- /dev/null
+++ b/drivers/cxl/core/region_dax.c
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright(c) 2022 Intel Corporation. All rights reserved.
+ * Copyright(c) 2026 Meta Technologies Inc. All rights reserved.
+ */
+#include &lt;linux/device.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;cxlmem.h&gt;
+#include &lt;cxl.h&gt;
+#include &quot;core.h&quot;
+
+static void cxl_dax_region_release(struct device *dev)
+{
+	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
+
+	kfree(cxlr_dax);
+}
+
+static const struct attribute_group *cxl_dax_region_attribute_groups[] = {
+	&amp;cxl_base_attribute_group,
+	NULL
+};
+
+const struct device_type cxl_dax_region_type = {
+	.name = &quot;cxl_dax_region&quot;,
+	.release = cxl_dax_region_release,
+	.groups = cxl_dax_region_attribute_groups,
+};
+
+static bool is_cxl_dax_region(struct device *dev)
+{
+	return dev-&gt;type == &amp;cxl_dax_region_type;
+}
+
+struct cxl_dax_region *to_cxl_dax_region(struct device *dev)
+{
+	if (dev_WARN_ONCE(dev, !is_cxl_dax_region(dev),
+			  &quot;not a cxl_dax_region device\n&quot;))
+		return NULL;
+	return container_of(dev, struct cxl_dax_region, dev);
+}
+EXPORT_SYMBOL_NS_GPL(to_cxl_dax_region, &quot;CXL&quot;);
+
+static struct lock_class_key cxl_dax_region_key;
+
+static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)
+{
+	struct cxl_region_params *p = &amp;cxlr-&gt;params;
+	struct cxl_dax_region *cxlr_dax;
+	struct device *dev;
+
+	guard(rwsem_read)(&amp;cxl_rwsem.region);
+	if (p-&gt;state != CXL_CONFIG_COMMIT)
+		return ERR_PTR(-ENXIO);
+
+	cxlr_dax = kzalloc(sizeof(*cxlr_dax), GFP_KERNEL);
+	if (!cxlr_dax)
+		return ERR_PTR(-ENOMEM);
+
+	cxlr_dax-&gt;hpa_range.start = p-&gt;res-&gt;start;
+	cxlr_dax-&gt;hpa_range.end = p-&gt;res-&gt;end;
+
+	dev = &amp;cxlr_dax-&gt;dev;
+	cxlr_dax-&gt;cxlr = cxlr;
+	device_initialize(dev);
+	lockdep_set_class(&amp;dev-&gt;mutex, &amp;cxl_dax_region_key);
+	device_set_pm_not_required(dev);
+	dev-&gt;parent = &amp;cxlr-&gt;dev;
+	dev-&gt;bus = &amp;cxl_bus_type;
+	dev-&gt;type = &amp;cxl_dax_region_type;
+
+	return cxlr_dax;
+}
+
+static void cxlr_dax_unregister(void *_cxlr_dax)
+{
+	struct cxl_dax_region *cxlr_dax = _cxlr_dax;
+
+	device_unregister(&amp;cxlr_dax-&gt;dev);
+}
+
+int devm_cxl_add_dax_region(struct cxl_region *cxlr)
+{
+	struct cxl_dax_region *cxlr_dax;
+	struct device *dev;
+	int rc;
+
+	cxlr_dax = cxl_dax_region_alloc(cxlr);
+	if (IS_ERR(cxlr_dax))
+		return PTR_ERR(cxlr_dax);
+
+	dev = &amp;cxlr_dax-&gt;dev;
+	rc = dev_set_name(dev, &quot;dax_region%d&quot;, cxlr-&gt;id);
+	if (rc)
+		goto err;
+
+	rc = device_add(dev);
+	if (rc)
+		goto err;
+
+	dev_dbg(&amp;cxlr-&gt;dev, &quot;%s: register %s\n&quot;, dev_name(dev-&gt;parent),
+		dev_name(dev));
+
+	return devm_add_action_or_reset(&amp;cxlr-&gt;dev, cxlr_dax_unregister,
+					cxlr_dax);
+err:
+	put_device(dev);
+	return rc;
+}
-- 
2.47.3</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix, no functional changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Gregory Price (author)</span>
<a class="date-chip" href="../2026-02-20_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-11">2026-02-11</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the use of gotos in the function, acknowledging that it&#x27;s not a functional change but rather a cleanup effort. They&#x27;ve made changes to remove the gotos and added a comment indicating no functional change intended.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Cleanup the gotos in the function.

No functional change intended.

Signed-off-by: Gregory Price &lt;gourry@gourry.net&gt;
---
 drivers/cxl/core/region_dax.c | 21 ++++++++-------------
 drivers/cxl/cxl.h             |  1 +
 2 files changed, 9 insertions(+), 13 deletions(-)

diff --git a/drivers/cxl/core/region_dax.c b/drivers/cxl/core/region_dax.c
index c8dd2bd1d9b9..49907c6c7620 100644
--- a/drivers/cxl/core/region_dax.c
+++ b/drivers/cxl/core/region_dax.c
@@ -81,29 +81,24 @@ static void cxlr_dax_unregister(void *_cxlr_dax)
 
 int devm_cxl_add_dax_region(struct cxl_region *cxlr)
 {
-	struct cxl_dax_region *cxlr_dax;
-	struct device *dev;
+	struct cxl_dax_region *cxlr_dax __free(put_cxl_dax_region) = NULL;
 	int rc;
 
 	cxlr_dax = cxl_dax_region_alloc(cxlr);
 	if (IS_ERR(cxlr_dax))
 		return PTR_ERR(cxlr_dax);
 
-	dev = &amp;cxlr_dax-&gt;dev;
-	rc = dev_set_name(dev, &quot;dax_region%d&quot;, cxlr-&gt;id);
+	rc = dev_set_name(&amp;cxlr_dax-&gt;dev, &quot;dax_region%d&quot;, cxlr-&gt;id);
 	if (rc)
-		goto err;
+		return rc;
 
-	rc = device_add(dev);
+	rc = device_add(&amp;cxlr_dax-&gt;dev);
 	if (rc)
-		goto err;
+		return rc;
 
-	dev_dbg(&amp;cxlr-&gt;dev, &quot;%s: register %s\n&quot;, dev_name(dev-&gt;parent),
-		dev_name(dev));
+	dev_dbg(&amp;cxlr-&gt;dev, &quot;%s: register %s\n&quot;, dev_name(cxlr_dax-&gt;dev.parent),
+		dev_name(&amp;cxlr_dax-&gt;dev));
 
 	return devm_add_action_or_reset(&amp;cxlr-&gt;dev, cxlr_dax_unregister,
-					cxlr_dax);
-err:
-	put_device(dev);
-	return rc;
+					no_free_ptr(cxlr_dax));
 }
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index 04c673e7cdb0..0b59008ea45a 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -803,6 +803,7 @@ DEFINE_FREE(put_cxl_root, struct cxl_root *, if (_T) put_device(&amp;_T-&gt;port.dev))
 DEFINE_FREE(put_cxl_port, struct cxl_port *, if (!IS_ERR_OR_NULL(_T)) put_device(&amp;_T-&gt;dev))
 DEFINE_FREE(put_cxl_root_decoder, struct cxl_root_decoder *, if (!IS_ERR_OR_NULL(_T)) put_device(&amp;_T-&gt;cxlsd.cxld.dev))
 DEFINE_FREE(put_cxl_region, struct cxl_region *, if (!IS_ERR_OR_NULL(_T)) put_device(&amp;_T-&gt;dev))
+DEFINE_FREE(put_cxl_dax_region, struct cxl_dax_region *, if (!IS_ERR_OR_NULL(_T)) put_device(&amp;_T-&gt;dev))
 
 int devm_cxl_enumerate_ports(struct cxl_memdev *cxlmd);
 void cxl_bus_rescan(void);
-- 
2.47.3</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged feedback, made changes</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>