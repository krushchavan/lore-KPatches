{
  "thread_id": "ae5f1ee0c43eda94f86bc60b1b223c86e0f24805.camel@kernel.org",
  "subject": "Re: [PATCH v1 1/2] NFSD: Defer sub-object cleanup in export put callbacks",
  "url": "https://lore.kernel.org/all/ae5f1ee0c43eda94f86bc60b1b223c86e0f24805.camel@kernel.org/",
  "dates": {
    "2026-02-20": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Jeff Layton",
          "summary": "Reviewer noted that the patch does not address the original crashes reported on PowerPC systems, as it only contains compile and regression tests.",
          "sentiment": "neutral",
          "sentiment_signals": [
            "test coverage",
            "regression testing"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "Looks good.\n\nReviwed-by: Jeff Layton <jlayton@kernel.org>",
          "reply_to": "Chuck Lever",
          "message_date": "2026-02-20"
        },
        {
          "author": "Jeff Layton",
          "summary": "Gave Reviewed-by",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "heuristic",
          "raw_body": "",
          "reply_to": "Chuck Lever",
          "message_date": "2026-02-20"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-19": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "Chuck Lever (author)",
          "summary": "The author addressed the concern that svc_export_put() and expkey_put() call path_put() and auth_domain_put() before the RCU grace period, which can lead to a NULL pointer dereference in d_path(). The author agreed to restructure the code to use queue_rcu_work(), which defers the callback until after the RCU grace period and executes it in process context where sleeping is permitted. A dedicated workqueue is used for the shutdown drain to only NFSD export release work items.",
          "sentiment": "positive",
          "sentiment_signals": [
            "agreed",
            "restructured"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "From: Chuck Lever <chuck.lever@oracle.com>\n\nsvc_export_put() calls path_put() and auth_domain_put() immediately\nwhen the last reference drops, before the RCU grace period. RCU\nreaders in e_show() and c_show() access both ex_path (via\nseq_path/d_path) and ex_client->name (via seq_escape) without\nholding a reference. If cache_clean removes the entry and drops the\nlast reference concurrently, the sub-objects are freed while still\nin use, producing a NULL pointer dereference in d_path.\n\nCommit 2530766492ec (\"nfsd: fix UAF when access ex_uuid or\nex_stats\") moved kfree of ex_uuid and ex_stats into the\ncall_rcu callback, but left path_put() and auth_domain_put() running\nbefore the grace period because both may sleep and call_rcu\ncallbacks execute in softirq context.\n\nReplace call_rcu/kfree_rcu with queue_rcu_work(), which defers the\ncallback until after the RCU grace period and executes it in process\ncontext where sleeping is permitted. This allows path_put() and\nauth_domain_put() to be moved into the deferred callback alongside\nthe other resource releases. Apply the same fix to expkey_put(),\nwhich has the identical pattern with ek_path and ek_client.\n\nA dedicated workqueue scopes the shutdown drain to only NFSD\nexport release work items; flushing the shared\nsystem_unbound_wq would stall on unrelated work from other\nsubsystems. nfsd_export_shutdown() uses rcu_barrier() followed\nby flush_workqueue() to ensure all deferred release callbacks\ncomplete before the export caches are destroyed.\n\nReported-by: Misbah Anjum N <misanjum@linux.ibm.com>\nCloses: https://lore.kernel.org/linux-nfs/dcd371d3a95815a84ba7de52cef447b8@linux.ibm.com/\nFixes: c224edca7af0 (\"nfsd: no need get cache ref when protected by rcu\")\nFixes: 1b10f0b603c0 (\"SUNRPC: no need get cache ref when protected by rcu\")\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\n---\n fs/nfsd/export.c | 63 +++++++++++++++++++++++++++++++++++++++++-------\n fs/nfsd/export.h |  7 ++++--\n fs/nfsd/nfsctl.c |  8 +++++-\n 3 files changed, 66 insertions(+), 12 deletions(-)\n\ndiff --git a/fs/nfsd/export.c b/fs/nfsd/export.c\nindex 04b18f0f402f..53fe66784ed2 100644\n--- a/fs/nfsd/export.c\n+++ b/fs/nfsd/export.c\n@@ -36,19 +36,30 @@\n  * second map contains a reference to the entry in the first map.\n  */\n \n+static struct workqueue_struct *nfsd_export_wq;\n+\n #define\tEXPKEY_HASHBITS\t\t8\n #define\tEXPKEY_HASHMAX\t\t(1 << EXPKEY_HASHBITS)\n #define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n \n-static void expkey_put(struct kref *ref)\n+static void expkey_release(struct work_struct *work)\n {\n-\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n+\tstruct svc_expkey *key = container_of(to_rcu_work(work),\n+\t\t\t\t\t      struct svc_expkey, ek_rwork);\n \n \tif (test_bit(CACHE_VALID, &key->h.flags) &&\n \t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n \t\tpath_put(&key->ek_path);\n \tauth_domain_put(key->ek_client);\n-\tkfree_rcu(key, ek_rcu);\n+\tkfree(key);\n+}\n+\n+static void expkey_put(struct kref *ref)\n+{\n+\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n+\n+\tINIT_RCU_WORK(&key->ek_rwork, expkey_release);\n+\tqueue_rcu_work(nfsd_export_wq, &key->ek_rwork);\n }\n \n static int expkey_upcall(struct cache_detail *cd, struct cache_head *h)\n@@ -353,11 +364,13 @@ static void export_stats_destroy(struct export_stats *stats)\n \t\t\t\t\t    EXP_STATS_COUNTERS_NUM);\n }\n \n-static void svc_export_release(struct rcu_head *rcu_head)\n+static void svc_export_release(struct work_struct *work)\n {\n-\tstruct svc_export *exp = container_of(rcu_head, struct svc_export,\n-\t\t\tex_rcu);\n+\tstruct svc_export *exp = container_of(to_rcu_work(work),\n+\t\t\t\t\t      struct svc_export, ex_rwork);\n \n+\tpath_put(&exp->ex_path);\n+\tauth_domain_put(exp->ex_client);\n \tnfsd4_fslocs_free(&exp->ex_fslocs);\n \texport_stats_destroy(exp->ex_stats);\n \tkfree(exp->ex_stats);\n@@ -369,9 +382,8 @@ static void svc_export_put(struct kref *ref)\n {\n \tstruct svc_export *exp = container_of(ref, struct svc_export, h.ref);\n \n-\tpath_put(&exp->ex_path);\n-\tauth_domain_put(exp->ex_client);\n-\tcall_rcu(&exp->ex_rcu, svc_export_release);\n+\tINIT_RCU_WORK(&exp->ex_rwork, svc_export_release);\n+\tqueue_rcu_work(nfsd_export_wq, &exp->ex_rwork);\n }\n \n static int svc_export_upcall(struct cache_detail *cd, struct cache_head *h)\n@@ -1481,6 +1493,36 @@ const struct seq_operations nfs_exports_op = {\n \t.show\t= e_show,\n };\n \n+/**\n+ * nfsd_export_wq_init - allocate the export release workqueue\n+ *\n+ * Called once at module load. The workqueue runs deferred svc_export and\n+ * svc_expkey release work scheduled by queue_rcu_work() in the cache put\n+ * callbacks.\n+ *\n+ * Return values:\n+ *   %0: workqueue allocated\n+ *   %-ENOMEM: allocation failed\n+ */\n+int nfsd_export_wq_init(void)\n+{\n+\tnfsd_export_wq = alloc_workqueue(\"nfsd_export\", WQ_UNBOUND, 0);\n+\tif (!nfsd_export_wq)\n+\t\treturn -ENOMEM;\n+\treturn 0;\n+}\n+\n+/**\n+ * nfsd_export_wq_shutdown - drain and free the export release workqueue\n+ *\n+ * Called once at module unload. Per-namespace teardown in\n+ * nfsd_export_shutdown() has already drained all deferred work.\n+ */\n+void nfsd_export_wq_shutdown(void)\n+{\n+\tdestroy_workqueue(nfsd_export_wq);\n+}\n+\n /*\n  * Initialize the exports module.\n  */\n@@ -1542,6 +1584,9 @@ nfsd_export_shutdown(struct net *net)\n \n \tcache_unregister_net(nn->svc_expkey_cache, net);\n \tcache_unregister_net(nn->svc_export_cache, net);\n+\t/* Drain deferred export and expkey release work. */\n+\trcu_barrier();\n+\tflush_workqueue(nfsd_export_wq);\n \tcache_destroy_net(nn->svc_expkey_cache, net);\n \tcache_destroy_net(nn->svc_export_cache, net);\n \tsvcauth_unix_purge(net);\ndiff --git a/fs/nfsd/export.h b/fs/nfsd/export.h\nindex d2b09cd76145..b05399374574 100644\n--- a/fs/nfsd/export.h\n+++ b/fs/nfsd/export.h\n@@ -7,6 +7,7 @@\n \n #include <linux/sunrpc/cache.h>\n #include <linux/percpu_counter.h>\n+#include <linux/workqueue.h>\n #include <uapi/linux/nfsd/export.h>\n #include <linux/nfs4.h>\n \n@@ -75,7 +76,7 @@ struct svc_export {\n \tu32\t\t\tex_layout_types;\n \tstruct nfsd4_deviceid_map *ex_devid_map;\n \tstruct cache_detail\t*cd;\n-\tstruct rcu_head\t\tex_rcu;\n+\tstruct rcu_work\t\tex_rwork;\n \tunsigned long\t\tex_xprtsec_modes;\n \tstruct export_stats\t*ex_stats;\n };\n@@ -92,7 +93,7 @@ struct svc_expkey {\n \tu32\t\t\tek_fsid[6];\n \n \tstruct path\t\tek_path;\n-\tstruct rcu_head\t\tek_rcu;\n+\tstruct rcu_work\t\tek_rwork;\n };\n \n #define EX_ISSYNC(exp)\t\t(!((exp)->ex_flags & NFSEXP_ASYNC))\n@@ -110,6 +111,8 @@ __be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp,\n /*\n  * Function declarations\n  */\n+int\t\t\tnfsd_export_wq_init(void);\n+void\t\t\tnfsd_export_wq_shutdown(void);\n int\t\t\tnfsd_export_init(struct net *);\n void\t\t\tnfsd_export_shutdown(struct net *);\n void\t\t\tnfsd_export_flush(struct net *);\ndiff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c\nindex 664a3275c511..4166f59908f4 100644\n--- a/fs/nfsd/nfsctl.c\n+++ b/fs/nfsd/nfsctl.c\n@@ -2308,9 +2308,12 @@ static int __init init_nfsd(void)\n \tif (retval)\n \t\tgoto out_free_pnfs;\n \tnfsd_lockd_init();\t/* lockd->nfsd callbacks */\n+\tretval = nfsd_export_wq_init();\n+\tif (retval)\n+\t\tgoto out_free_lockd;\n \tretval = register_pernet_subsys(&nfsd_net_ops);\n \tif (retval < 0)\n-\t\tgoto out_free_lockd;\n+\t\tgoto out_free_export_wq;\n \tretval = register_cld_notifier();\n \tif (retval)\n \t\tgoto out_free_subsys;\n@@ -2339,6 +2342,8 @@ static int __init init_nfsd(void)\n \tunregister_cld_notifier();\n out_free_subsys:\n \tunregister_pernet_subsys(&nfsd_net_ops);\n+out_free_export_wq:\n+\tnfsd_export_wq_shutdown();\n out_free_lockd:\n \tnfsd_lockd_shutdown();\n \tnfsd_drc_slab_free();\n@@ -2359,6 +2364,7 @@ static void __exit exit_nfsd(void)\n \tnfsd4_destroy_laundry_wq();\n \tunregister_cld_notifier();\n \tunregister_pernet_subsys(&nfsd_net_ops);\n+\tnfsd_export_wq_shutdown();\n \tnfsd_drc_slab_free();\n \tnfsd_lockd_shutdown();\n \tnfsd4_free_slabs();\n-- \n2.53.0",
          "reply_to": "",
          "message_date": "2026-02-19"
        },
        {
          "author": "Chuck Lever (author)",
          "summary": "The author addressed a concern about the /proc/fs/nfs/exports proc entry being freed while still-open file descriptors exist, explaining that holding a reference on the struct net for the lifetime of the open file descriptor prevents nfsd_net_exit() from running and thus prevents nfsd_export_shutdown() from freeing the cache. The author confirmed this fix is sufficient to address the issue.",
          "sentiment": "positive",
          "sentiment_signals": [
            "acknowledged a specific technical concern",
            "confirmed the proposed solution"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "From: Chuck Lever <chuck.lever@oracle.com>\n\nThe /proc/fs/nfs/exports proc entry is created at module init\nand persists for the module's lifetime. exports_proc_open()\ncaptures the caller's current network namespace and stores\nits svc_export_cache in seq->private, but takes no reference\non the namespace. If the namespace is subsequently torn down\n(e.g. container destruction after the opener does setns() to a\ndifferent namespace), nfsd_net_exit() calls nfsd_export_shutdown()\nwhich frees the cache. Subsequent reads on the still-open fd\ndereference the freed cache_detail, walking a freed hash table.\n\nHold a reference on the struct net for the lifetime of the open\nfile descriptor. This prevents nfsd_net_exit() from running --\nand thus prevents nfsd_export_shutdown() from freeing the cache\n-- while any exports fd is open. cache_detail already stores\nits net pointer (cd->net, set by cache_create_net()), so\nexports_release() can retrieve it without additional per-file\nstorage.\n\nReported-by: Misbah Anjum N <misanjum@linux.ibm.com>\nCloses: https://lore.kernel.org/linux-nfs/dcd371d3a95815a84ba7de52cef447b8@linux.ibm.com/\nFixes: 96d851c4d28d (\"nfsd: use proper net while reading \"exports\" file\")\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\n---\n fs/nfsd/nfsctl.c | 14 ++++++++++++--\n 1 file changed, 12 insertions(+), 2 deletions(-)\n\ndiff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c\nindex 4166f59908f4..3d5a676e1d14 100644\n--- a/fs/nfsd/nfsctl.c\n+++ b/fs/nfsd/nfsctl.c\n@@ -149,9 +149,19 @@ static int exports_net_open(struct net *net, struct file *file)\n \n \tseq = file->private_data;\n \tseq->private = nn->svc_export_cache;\n+\tget_net(net);\n \treturn 0;\n }\n \n+static int exports_release(struct inode *inode, struct file *file)\n+{\n+\tstruct seq_file *seq = file->private_data;\n+\tstruct cache_detail *cd = seq->private;\n+\n+\tput_net(cd->net);\n+\treturn seq_release(inode, file);\n+}\n+\n static int exports_nfsd_open(struct inode *inode, struct file *file)\n {\n \treturn exports_net_open(inode->i_sb->s_fs_info, file);\n@@ -161,7 +171,7 @@ static const struct file_operations exports_nfsd_operations = {\n \t.open\t\t= exports_nfsd_open,\n \t.read\t\t= seq_read,\n \t.llseek\t\t= seq_lseek,\n-\t.release\t= seq_release,\n+\t.release\t= exports_release,\n };\n \n static int export_features_show(struct seq_file *m, void *v)\n@@ -1376,7 +1386,7 @@ static const struct proc_ops exports_proc_ops = {\n \t.proc_open\t= exports_proc_open,\n \t.proc_read\t= seq_read,\n \t.proc_lseek\t= seq_lseek,\n-\t.proc_release\t= seq_release,\n+\t.proc_release\t= exports_release,\n };\n \n static int create_proc_exports_entry(void)\n-- \n2.53.0",
          "reply_to": "",
          "message_date": "2026-02-19"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    },
    "2026-02-22": {
      "report_file": "2026-02-20_ollama_llama3.1-8b.html",
      "developer": "Jeff Layton",
      "reviews": [
        {
          "author": "NeilBrown",
          "summary": "Gave Reviewed-by",
          "sentiment": "positive",
          "sentiment_signals": [],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "heuristic",
          "raw_body": "",
          "reply_to": "Chuck Lever",
          "message_date": "2026-02-22"
        }
      ],
      "analysis_source": "llm-per-reviewer"
    }
  }
}