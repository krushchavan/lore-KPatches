{
  "thread_id": "e49fc187-0ef8-4557-abac-0082653fa645@gmail.com",
  "subject": "Re: [PATCH bpf-next 1/3] selftests/bpf: Check bpf_mem_cgroup_page_state return value",
  "url": "https://lore.kernel.org/all/e49fc187-0ef8-4557-abac-0082653fa645@gmail.com/",
  "dates": {
    "2026-02-13": {
      "report_file": "2026-02-13_ollama_llama3.1-8b.html",
      "developer": "JP Kobryn",
      "reviews": [
        {
          "author": "Hui Zhu (author)",
          "summary": "Reviewer Hui Zhu approved the patch, mentioning a good catch and agreeing to fix it in the next version.",
          "sentiment": "positive",
          "sentiment_signals": [
            "agreement",
            "approval"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "From: Hui Zhu <zhuhui@kylinos.cn>\n\nWhile back-porting \"mm: bpf kfuncs to access memcg data\", I\nencountered issues with test_cgroup_iter_memcg, specifically\nin test_kmem.\n\nThe test_cgroup_iter_memcg test would falsely pass when\nbpf_mem_cgroup_page_state() failed due to incompatible enum\nvalues across kernel versions. Additionally, test_kmem would\nfail on systems with cgroup.memory=nokmem enabled.\n\nThis series addresses these issues:\n1. Add return value checks for bpf_mem_cgroup_page_state()\n2. Return error when accessing kmem with nokmem enabled\n3. Skip test_kmem when cgroup.memory=nokmem is set\n\nHui Zhu (3):\n  selftests/bpf: Check bpf_mem_cgroup_page_state return value\n  mm/memcontrol: Return error when accessing kmem with nokmem\n  selftests/bpf: Skip test_kmem when cgroup.memory=nokmem\n\n mm/memcontrol.c                               |  3 +-\n .../bpf/prog_tests/cgroup_iter_memcg.c        | 40 +++++++++++++++++++\n 2 files changed, 42 insertions(+), 1 deletion(-)\n\n-- \n2.43.0\n\n\n\n---\n\nFrom: Hui Zhu <zhuhui@kylinos.cn>\n\nWhen running tests on hosts with cgroup.memory=nokmem enabled for\nperformance reasons, test_kmem always gets a value of 0 for kmem\nstatistics.\n\nSince BPF programs cannot easily determine whether kmem is enabled,\nadd a check in memcg_stat_item_valid() to return an error when\nattempting to access MEMCG_KMEM statistics while kmem accounting\nis disabled via cgroup_memory_nokmem.\n\nThis prevents BPF programs from silently receiving zero values and\nallows them to properly handle the case where kmem accounting is\nunavailable.\n\nSigned-off-by: Hui Zhu <zhuhui@kylinos.cn>\n---\n mm/memcontrol.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\ndiff --git a/mm/memcontrol.c b/mm/memcontrol.c\nindex 129eed3ff5bb..4d8419623d1c 100644\n--- a/mm/memcontrol.c\n+++ b/mm/memcontrol.c\n@@ -667,7 +667,8 @@ unsigned long memcg_page_state(struct mem_cgroup *memcg, int idx)\n \n bool memcg_stat_item_valid(int idx)\n {\n-\tif ((u32)idx >= MEMCG_NR_STAT)\n+\tif ((u32)idx >= MEMCG_NR_STAT ||\n+\t    (cgroup_memory_nokmem && (u32)idx == MEMCG_KMEM))\n \t\treturn false;\n \n \treturn !BAD_STAT_IDX(memcg_stats_index(idx));\n-- \n2.43.0\n\n\n\n---\n\nFrom: Hui Zhu <zhuhui@kylinos.cn>\n\nWhen cgroup.memory=nokmem is set in kernel command line, kmem\naccounting is disabled and the test_kmem subtest will fail.\n\nAdd a check to skip this test when the parameter is present.\n\nSigned-off-by: Hui Zhu <zhuhui@kylinos.cn>\n---\n .../bpf/prog_tests/cgroup_iter_memcg.c        | 28 +++++++++++++++++++\n 1 file changed, 28 insertions(+)\n\ndiff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\nindex 13b299512429..203e6b091a21 100644\n--- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n+++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n@@ -134,11 +134,39 @@ static void test_shmem(struct bpf_link *link, struct memcg_query *memcg_query)\n \tshm_unlink(\"/tmp_shmem\");\n }\n \n+static bool cmdline_has(const char *arg)\n+{\n+\tchar cmdline[4096];\n+\tint fd;\n+\tssize_t len;\n+\tbool ret = false;\n+\n+\tfd = open(\"/proc/cmdline\", O_RDONLY);\n+\tif (fd < 0)\n+\t\treturn false;\n+\n+\tlen = read(fd, cmdline, sizeof(cmdline) - 1);\n+\tclose(fd);\n+\tif (len < 0)\n+\t\treturn false;\n+\n+\tcmdline[len] = '\\0';\n+\tif (strstr(cmdline, arg))\n+\t\tret = true;\n+\n+\treturn ret;\n+}\n+\n #define NR_PIPES 64\n static void test_kmem(struct bpf_link *link, struct memcg_query *memcg_query)\n {\n \tint fds[NR_PIPES][2], i;\n \n+\tif (cmdline_has(\"cgroup.memory=nokmem\")) {\n+\t\ttest__skip();\n+\t\treturn;\n+\t}\n+\n \t/*\n \t * Increase kmem value by creating pipes which will allocate some\n \t * kernel buffers.\n-- \n2.43.0\n\n\n\n---\n\n2026年2月12日 16:50, bot+bpf-ci@kernel.org mailto:bot+bpf-ci@kernel.org  写到:\n\n\n> \n> > \n> > diff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> >  --- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> >  +++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> > \n> [ ... ]\n> \n> > \n> > @@ -170,6 +180,8 @@ static void test_pgfault(struct bpf_link *link, struct memcg_query *memcg_query)\n> >  if (!ASSERT_OK(read_stats(link), \"read stats\"))\n> >  goto cleanup;\n> > \n> >  + ASSERT_NEQ(memcg_query->pgfault, (unsigned long)-1,\n> >  + \"bpf_mem_cgroup_page_state PGFAULT\");\n> > \n>  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> \n> The assertion message references bpf_mem_cgroup_page_state(), but the BPF\n> program actually uses bpf_mem_cgroup_vm_events() to retrieve the pgfault\n> value:\n> \n> tools/testing/selftests/bpf/progs/cgroup_iter_memcg.c:\n>  memcg_query.pgfault = bpf_mem_cgroup_vm_events(memcg, PGFAULT);\n> \n> Should the message be \"bpf_mem_cgroup_vm_events PGFAULT\" instead?\n\nGood catch!  I will fix it in the next version.\n\nBest,\nHui\n\n> \n> ---\n> AI reviewed your patch. Please fix the bug or email reply why it's not a bug.\n> See: https://github.com/kernel-patches/vmtest/blob/master/ci/claude/README.md\n> \n> CI run summary: https://github.com/kernel-patches/bpf/actions/runs/21939182103\n> \n> AI-authorship-score: low\n> AI-authorship-explanation: The commit message uses first-person narrative describing a real back-porting scenario, and the code changes are simple repetitive assertions typical of human-written test improvements.\n> issues-found: 1\n> issue-severity-score: low\n> issue-severity-explanation: Minor documentation issue where an assertion message references the wrong BPF function name; does not affect test correctness or system behavior.\n>\n\n\n---\n\n2026年2月13日 08:14, \"JP Kobryn\" <inwardvessel@gmail.com mailto:inwardvessel@gmail.com?to=%22JP%20Kobryn%22%20%3Cinwardvessel%40gmail.com%3E > 写到:\n\n\n> \n> On 2/12/26 12:23 AM, Hui Zhu wrote:\n> \n> > \n> > From: Hui Zhu <zhuhui@kylinos.cn>\n> >  When back-porting test_progs to different kernel versions, I encountered\n> >  an issue where the test_cgroup_iter_memcg test would falsely pass even\n> >  when bpf_mem_cgroup_page_state() failed.\n> >  The problem occurs when test_progs compiled on one kernel version is\n> >  executed on another kernel with different enum values for memory\n> >  statistics (e.g., NR_ANON_MAPPED, NR_FILE_PAGES). [...]\n> > \n> This patch looks good but I think to fully solve this cross-kernel issue\n> we should use co-re in the bpf program. In your second revision, can you\n> add an additional patch to make use of bpf_core_enum_value()? This way\n> instead of relying on enum values in vmlinux.h at compile-time, we use\n> the btf info at load-time instead to get the proper value for the given\n> kernel.\n>\n\nI post v2 according to your comments.\nThanks for your review.\n\nBest,\nHui\n\n",
          "reply_to": ""
        },
        {
          "author": "bot+bpf-ci",
          "summary": "The reviewer pointed out a minor documentation issue in the patch, where an assertion message references the wrong BPF function name.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "minor documentation issue"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "> diff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> --- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> +++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n\n[ ... ]\n\n> @@ -170,6 +180,8 @@ static void test_pgfault(struct bpf_link *link, struct memcg_query *memcg_query)\n>  \tif (!ASSERT_OK(read_stats(link), \"read stats\"))\n>  \t\tgoto cleanup;\n>\n> +\tASSERT_NEQ(memcg_query->pgfault, (unsigned long)-1,\n> +\t\t  \"bpf_mem_cgroup_page_state PGFAULT\");\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe assertion message references bpf_mem_cgroup_page_state(), but the BPF\nprogram actually uses bpf_mem_cgroup_vm_events() to retrieve the pgfault\nvalue:\n\ntools/testing/selftests/bpf/progs/cgroup_iter_memcg.c:\n    memcg_query.pgfault = bpf_mem_cgroup_vm_events(memcg, PGFAULT);\n\nShould the message be \"bpf_mem_cgroup_vm_events PGFAULT\" instead?\n\n\n---\nAI reviewed your patch. Please fix the bug or email reply why it's not a bug.\nSee: https://github.com/kernel-patches/vmtest/blob/master/ci/claude/README.md\n\nCI run summary: https://github.com/kernel-patches/bpf/actions/runs/21939182103\n\nAI-authorship-score: low\nAI-authorship-explanation: The commit message uses first-person narrative describing a real back-porting scenario, and the code changes are simple repetitive assertions typical of human-written test improvements.\nissues-found: 1\nissue-severity-score: low\nissue-severity-explanation: Minor documentation issue where an assertion message references the wrong BPF function name; does not affect test correctness or system behavior.\n",
          "reply_to": ""
        },
        {
          "author": "JP Kobryn",
          "summary": "Reviewer JP Kobryn suggested additional patches to fully solve cross-kernel issues by using bpf_core_enum_value() in the BPF program, and questioned the necessity of checking kmem value when it's disabled.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "additional work"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On 2/12/26 12:23 AM, Hui Zhu wrote:\n> From: Hui Zhu <zhuhui@kylinos.cn>\n> \n> When back-porting test_progs to different kernel versions, I encountered\n> an issue where the test_cgroup_iter_memcg test would falsely pass even\n> when bpf_mem_cgroup_page_state() failed.\n> \n> The problem occurs when test_progs compiled on one kernel version is\n> executed on another kernel with different enum values for memory\n> statistics (e.g., NR_ANON_MAPPED, NR_FILE_PAGES). [...]\n\nThis patch looks good but I think to fully solve this cross-kernel issue\nwe should use co-re in the bpf program. In your second revision, can you\nadd an additional patch to make use of bpf_core_enum_value()? This way\ninstead of relying on enum values in vmlinux.h at compile-time, we use\nthe btf info at load-time instead to get the proper value for the given\nkernel.\n\n\n---\n\nOn 2/12/26 12:23 AM, Hui Zhu wrote:\n> From: Hui Zhu <zhuhui@kylinos.cn>\n> \n> When running tests on hosts with cgroup.memory=nokmem enabled for\n> performance reasons, test_kmem always gets a value of 0 for kmem\n> statistics.\n> \n> Since BPF programs cannot easily determine whether kmem is enabled,\n> add a check in memcg_stat_item_valid() to return an error when\n> attempting to access MEMCG_KMEM statistics while kmem accounting\n> is disabled via cgroup_memory_nokmem.\n> \n> This prevents BPF programs from silently receiving zero values and\n> allows them to properly handle the case where kmem accounting is\n> unavailable.\n> \n> Signed-off-by: Hui Zhu <zhuhui@kylinos.cn>\n> ---\n>   mm/memcontrol.c | 3 ++-\n>   1 file changed, 2 insertions(+), 1 deletion(-)\n> \n> diff --git a/mm/memcontrol.c b/mm/memcontrol.c\n> index 129eed3ff5bb..4d8419623d1c 100644\n> --- a/mm/memcontrol.c\n> +++ b/mm/memcontrol.c\n> @@ -667,7 +667,8 @@ unsigned long memcg_page_state(struct mem_cgroup *memcg, int idx)\n>   \n>   bool memcg_stat_item_valid(int idx)\n>   {\n> -\tif ((u32)idx >= MEMCG_NR_STAT)\n> +\tif ((u32)idx >= MEMCG_NR_STAT ||\n> +\t    (cgroup_memory_nokmem && (u32)idx == MEMCG_KMEM))\n>   \t\treturn false;\n\nIt's still a valid stat though, right? When it's disabled the value will\njust remain zero. I don't think this is necessary.\n\n\n---\n\nOn 2/12/26 12:23 AM, Hui Zhu wrote:\n> From: Hui Zhu <zhuhui@kylinos.cn>\n> \n> When cgroup.memory=nokmem is set in kernel command line, kmem\n> accounting is disabled and the test_kmem subtest will fail.\n> \n> Add a check to skip this test when the parameter is present.\n> \n> Signed-off-by: Hui Zhu <zhuhui@kylinos.cn>\n> ---\n>   .../bpf/prog_tests/cgroup_iter_memcg.c        | 28 +++++++++++++++++++\n>   1 file changed, 28 insertions(+)\n> \n> diff --git a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> index 13b299512429..203e6b091a21 100644\n> --- a/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> +++ b/tools/testing/selftests/bpf/prog_tests/cgroup_iter_memcg.c\n> @@ -134,11 +134,39 @@ static void test_shmem(struct bpf_link *link, struct memcg_query *memcg_query)\n>   \tshm_unlink(\"/tmp_shmem\");\n>   }\n>   \n> +static bool cmdline_has(const char *arg)\n> +{\n> +\tchar cmdline[4096];\n> +\tint fd;\n> +\tssize_t len;\n> +\tbool ret = false;\n> +\n> +\tfd = open(\"/proc/cmdline\", O_RDONLY);\n> +\tif (fd < 0)\n> +\t\treturn false;\n> +\n> +\tlen = read(fd, cmdline, sizeof(cmdline) - 1);\n> +\tclose(fd);\n> +\tif (len < 0)\n> +\t\treturn false;\n> +\n> +\tcmdline[len] = '\\0';\n> +\tif (strstr(cmdline, arg))\n> +\t\tret = true;\n> +\n> +\treturn ret;\n> +}\n> +\n>   #define NR_PIPES 64\n>   static void test_kmem(struct bpf_link *link, struct memcg_query *memcg_query)\n>   {\n>   \tint fds[NR_PIPES][2], i;\n>   \n> +\tif (cmdline_has(\"cgroup.memory=nokmem\")) {\n> +\t\ttest__skip();\n> +\t\treturn;\n> +\t}\n\nInstead of just skipping what if we proceed and then confirm we get a\nzero value after the allocations?\n",
          "reply_to": ""
        }
      ],
      "analysis_source": "llm"
    }
  }
}