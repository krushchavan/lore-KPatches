<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: [PATCH v5] mm: move pgscan, pgsteal, pgrefill to node stats</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }
        .reply-to-label {
            font-size: 0.8em;
            color: #999;
            font-style: italic;
            margin-top: 3px;
        }
        .lore-link {
            display: inline-block;
            margin-top: 4px;
            font-size: 0.82em;
            color: #0366d6;
            text-decoration: none;
            font-weight: 500;
            white-space: nowrap;
        }
        .lore-link:hover { text-decoration: underline; color: #0056b3; }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../index.html">&larr; Back to reports</a></div>
    <h1>[PATCH v5] mm: move pgscan, pgsteal, pgrefill to node stats</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/20260219235846.161910-1-jp.kobryn@linux.dev/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-23">2026-02-23</a> &bull; <a href="#2026-02-20">2026-02-20</a> &bull; <a href="#2026-02-19">2026-02-19</a></div>
    <div class="patch-summary-block"><div class="patch-summary-label">Patch summary</div><div class="patch-summary-text">There are situations where reclaim kicks in on a system with free memory. One possible cause is a NUMA imbalance scenario where one or more nodes are under pressure. It would help if we could easily identify such nodes.

Move the pgscan, pgsteal, and pgrefill counters from vm_event_item to node_stat_item to provide per-node reclaim visibility. With these counters as node stats, the values are now displayed in the per-node section of /proc/zoneinfo, which allows for quick identification of the affected nodes.

/proc/vmstat continues to report the same counters, aggregated across all nodes. But the ordering of these items within the readout changes as they move from the vm events section to the node stats section.

Memcg accounting of these counters is preserved. The relocated counters remain visible in memory.stat alongside the existing aggregate pgscan and pgsteal counters.</div></div>
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-19">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Zi Yan</span>
<a class="date-chip" href="../2026-02-19_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-19">2026-02-19</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Acked-by</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 19 Feb 2026, at 18:58, JP Kobryn (Meta) wrote:

&gt; There are situations where reclaim kicks in on a system with free memory.
&gt; One possible cause is a NUMA imbalance scenario where one or more nodes are
&gt; under pressure. It would help if we could easily identify such nodes.
&gt;
&gt; Move the pgscan, pgsteal, and pgrefill counters from vm_event_item to
&gt; node_stat_item to provide per-node reclaim visibility. With these counters
&gt; as node stats, the values are now displayed in the per-node section of
&gt; /proc/zoneinfo, which allows for quick identification of the affected
&gt; nodes.
&gt;
&gt; /proc/vmstat continues to report the same counters, aggregated across all
&gt; nodes. But the ordering of these items within the readout changes as they
&gt; move from the vm events section to the node stats section.
&gt;
&gt; Memcg accounting of these counters is preserved. The relocated counters
&gt; remain visible in memory.stat alongside the existing aggregate pgscan and
&gt; pgsteal counters.
&gt;
&gt; However, this change affects how the global counters are accumulated.
&gt; Previously, the global event count update was gated on !cgroup_reclaim(),
&gt; excluding memcg-based reclaim from /proc/vmstat. Now that
&gt; mod_lruvec_state() is being used to update the counters, the global
&gt; counters will include all reclaim. This is consistent with how pgdemote
&gt; counters are already tracked.
&gt;
&gt; Finally, the virtio_balloon driver is updated to use
&gt; global_node_page_state() to fetch the counters, as they are no longer
&gt; accessible through the vm_events array.
&gt;
&gt; Signed-off-by: JP Kobryn &lt;jp.kobryn@linux.dev&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; Acked-by: Michael S. Tsirkin &lt;mst@redhat.com&gt;
&gt; Reviewed-by: Vlastimil Babka (SUSE) &lt;vbabka@kernel.org&gt;
&gt; ---
&gt; v5:
&gt; 	- rebase onto mm/mm-new
&gt;
&gt; v4: https://lore.kernel.org/linux-mm/20260219171124.19053-1-jp.kobryn@linux.dev/
&gt; 	- remove unused memcg var from scan_folios()
&gt;
&gt; v3: https://lore.kernel.org/linux-mm/20260218222652.108411-1-jp.kobryn@linux.dev/
&gt; 	- additionally move PGREFILL to node stats
&gt;
&gt; v2: https://lore.kernel.org/linux-mm/20260218032941.225439-1-jp.kobryn@linux.dev/
&gt; 	- update commit message
&gt; 	- add entries to memory_stats array
&gt; 	- add switch cases in memcg_page_state_output_unit()
&gt;
&gt; v1: https://lore.kernel.org/linux-mm/20260212045109.255391-3-inwardvessel@gmail.com/
&gt;
&gt;  drivers/virtio/virtio_balloon.c |  8 ++---
&gt;  include/linux/mmzone.h          | 13 ++++++++
&gt;  include/linux/vm_event_item.h   | 13 --------
&gt;  mm/memcontrol.c                 | 56 +++++++++++++++++++++++----------
&gt;  mm/vmscan.c                     | 39 ++++++++---------------
&gt;  mm/vmstat.c                     | 26 +++++++--------
&gt;  6 files changed, 82 insertions(+), 73 deletions(-)
&gt;

Acked-by: Zi Yan &lt;ziy@nvidia.com&gt;

Best Regards,
Yan, Zi
</pre>
</details>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-20">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Johannes Weiner</span>
<a class="date-chip" href="../2026-02-20.html" title="First appeared in report for 2026-02-20">2026-02-20</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Acked-by</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Thu, Feb 19, 2026 at 03:58:46PM -0800, JP Kobryn (Meta) wrote:
&gt; There are situations where reclaim kicks in on a system with free memory.
&gt; One possible cause is a NUMA imbalance scenario where one or more nodes are
&gt; under pressure. It would help if we could easily identify such nodes.
&gt; 
&gt; Move the pgscan, pgsteal, and pgrefill counters from vm_event_item to
&gt; node_stat_item to provide per-node reclaim visibility. With these counters
&gt; as node stats, the values are now displayed in the per-node section of
&gt; /proc/zoneinfo, which allows for quick identification of the affected
&gt; nodes.
&gt; 
&gt; /proc/vmstat continues to report the same counters, aggregated across all
&gt; nodes. But the ordering of these items within the readout changes as they
&gt; move from the vm events section to the node stats section.
&gt; 
&gt; Memcg accounting of these counters is preserved. The relocated counters
&gt; remain visible in memory.stat alongside the existing aggregate pgscan and
&gt; pgsteal counters.
&gt; 
&gt; However, this change affects how the global counters are accumulated.
&gt; Previously, the global event count update was gated on !cgroup_reclaim(),
&gt; excluding memcg-based reclaim from /proc/vmstat. Now that
&gt; mod_lruvec_state() is being used to update the counters, the global
&gt; counters will include all reclaim. This is consistent with how pgdemote
&gt; counters are already tracked.
&gt; 
&gt; Finally, the virtio_balloon driver is updated to use
&gt; global_node_page_state() to fetch the counters, as they are no longer
&gt; accessible through the vm_events array.
&gt; 
&gt; Signed-off-by: JP Kobryn &lt;jp.kobryn@linux.dev&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; Acked-by: Michael S. Tsirkin &lt;mst@redhat.com&gt;
&gt; Reviewed-by: Vlastimil Babka (SUSE) &lt;vbabka@kernel.org&gt;

Acked-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
</pre>
</details>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-20.html" title="First appeared in report for 2026-02-20">2026-02-20</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Yeah this difference always confused me.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Thu, Feb 19, 2026 at 03:58:46PM -0800, JP Kobryn (Meta) wrote:
&gt; There are situations where reclaim kicks in on a system with free memory.
&gt; One possible cause is a NUMA imbalance scenario where one or more nodes are
&gt; under pressure. It would help if we could easily identify such nodes.
&gt; 
&gt; Move the pgscan, pgsteal, and pgrefill counters from vm_event_item to
&gt; node_stat_item to provide per-node reclaim visibility. With these counters
&gt; as node stats, the values are now displayed in the per-node section of
&gt; /proc/zoneinfo, which allows for quick identification of the affected
&gt; nodes.
&gt; 
&gt; /proc/vmstat continues to report the same counters, aggregated across all
&gt; nodes. But the ordering of these items within the readout changes as they
&gt; move from the vm events section to the node stats section.
&gt; 
&gt; Memcg accounting of these counters is preserved. The relocated counters
&gt; remain visible in memory.stat alongside the existing aggregate pgscan and
&gt; pgsteal counters.
&gt; 
&gt; However, this change affects how the global counters are accumulated.
&gt; Previously, the global event count update was gated on !cgroup_reclaim(),
&gt; excluding memcg-based reclaim from /proc/vmstat. Now that
&gt; mod_lruvec_state() is being used to update the counters, the global
&gt; counters will include all reclaim. This is consistent with how pgdemote
&gt; counters are already tracked.

Yeah this difference always confused me.

&gt; 
&gt; Finally, the virtio_balloon driver is updated to use
&gt; global_node_page_state() to fetch the counters, as they are no longer
&gt; accessible through the vm_events array.
&gt; 
&gt; Signed-off-by: JP Kobryn &lt;jp.kobryn@linux.dev&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; Acked-by: Michael S. Tsirkin &lt;mst@redhat.com&gt;
&gt; Reviewed-by: Vlastimil Babka (SUSE) &lt;vbabka@kernel.org&gt;

Acked-by: Shakeel Butt &lt;shakeel.butt@linux.dev&gt;
</pre>
</details>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-23">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Michal Hocko</span>
<a class="date-chip" href="../2026-02-23.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Acked-by</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Thu 19-02-26 15:58:46, JP Kobryn (Meta) wrote:
&gt; There are situations where reclaim kicks in on a system with free memory.
&gt; One possible cause is a NUMA imbalance scenario where one or more nodes are
&gt; under pressure. It would help if we could easily identify such nodes.
&gt; 
&gt; Move the pgscan, pgsteal, and pgrefill counters from vm_event_item to
&gt; node_stat_item to provide per-node reclaim visibility. With these counters
&gt; as node stats, the values are now displayed in the per-node section of
&gt; /proc/zoneinfo, which allows for quick identification of the affected
&gt; nodes.
&gt; 
&gt; /proc/vmstat continues to report the same counters, aggregated across all
&gt; nodes. But the ordering of these items within the readout changes as they
&gt; move from the vm events section to the node stats section.
&gt; 
&gt; Memcg accounting of these counters is preserved. The relocated counters
&gt; remain visible in memory.stat alongside the existing aggregate pgscan and
&gt; pgsteal counters.
&gt; 
&gt; However, this change affects how the global counters are accumulated.
&gt; Previously, the global event count update was gated on !cgroup_reclaim(),
&gt; excluding memcg-based reclaim from /proc/vmstat. Now that
&gt; mod_lruvec_state() is being used to update the counters, the global
&gt; counters will include all reclaim. This is consistent with how pgdemote
&gt; counters are already tracked.
&gt; 
&gt; Finally, the virtio_balloon driver is updated to use
&gt; global_node_page_state() to fetch the counters, as they are no longer
&gt; accessible through the vm_events array.
&gt; 
&gt; Signed-off-by: JP Kobryn &lt;jp.kobryn@linux.dev&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; Acked-by: Michael S. Tsirkin &lt;mst@redhat.com&gt;
&gt; Reviewed-by: Vlastimil Babka (SUSE) &lt;vbabka@kernel.org&gt;

Acked-by: Michal Hocko &lt;mhocko@suse.com&gt;
Thanks

&gt; ---
&gt; v5:
&gt; 	- rebase onto mm/mm-new
&gt; 
&gt; v4: https://lore.kernel.org/linux-mm/20260219171124.19053-1-jp.kobryn@linux.dev/
&gt; 	- remove unused memcg var from scan_folios()
&gt; 
&gt; v3: https://lore.kernel.org/linux-mm/20260218222652.108411-1-jp.kobryn@linux.dev/
&gt; 	- additionally move PGREFILL to node stats
&gt; 
&gt; v2: https://lore.kernel.org/linux-mm/20260218032941.225439-1-jp.kobryn@linux.dev/
&gt; 	- update commit message
&gt; 	- add entries to memory_stats array
&gt; 	- add switch cases in memcg_page_state_output_unit()
&gt; 
&gt; v1: https://lore.kernel.org/linux-mm/20260212045109.255391-3-inwardvessel@gmail.com/
&gt; 
&gt;  drivers/virtio/virtio_balloon.c |  8 ++---
&gt;  include/linux/mmzone.h          | 13 ++++++++
&gt;  include/linux/vm_event_item.h   | 13 --------
&gt;  mm/memcontrol.c                 | 56 +++++++++++++++++++++++----------
&gt;  mm/vmscan.c                     | 39 ++++++++---------------
&gt;  mm/vmstat.c                     | 26 +++++++--------
&gt;  6 files changed, 82 insertions(+), 73 deletions(-)
&gt; 
&gt; diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
&gt; index 4e549abe59ff..ab945532ceef 100644
&gt; --- a/drivers/virtio/virtio_balloon.c
&gt; +++ b/drivers/virtio/virtio_balloon.c
&gt; @@ -369,13 +369,13 @@ static inline unsigned int update_balloon_vm_stats(struct virtio_balloon *vb)
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ALLOC_STALL, stall);
&gt;  
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_SCAN,
&gt; -		    pages_to_bytes(events[PGSCAN_KSWAPD]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSCAN_KSWAPD)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_SCAN,
&gt; -		    pages_to_bytes(events[PGSCAN_DIRECT]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSCAN_DIRECT)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_RECLAIM,
&gt; -		    pages_to_bytes(events[PGSTEAL_KSWAPD]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSTEAL_KSWAPD)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_RECLAIM,
&gt; -		    pages_to_bytes(events[PGSTEAL_DIRECT]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSTEAL_DIRECT)));
&gt;  
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_HTLB_PGALLOC,
&gt; diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
&gt; index 3e51190a55e4..546bca95ca40 100644
&gt; --- a/include/linux/mmzone.h
&gt; +++ b/include/linux/mmzone.h
&gt; @@ -255,6 +255,19 @@ enum node_stat_item {
&gt;  	PGDEMOTE_DIRECT,
&gt;  	PGDEMOTE_KHUGEPAGED,
&gt;  	PGDEMOTE_PROACTIVE,
&gt; +	PGSTEAL_KSWAPD,
&gt; +	PGSTEAL_DIRECT,
&gt; +	PGSTEAL_KHUGEPAGED,
&gt; +	PGSTEAL_PROACTIVE,
&gt; +	PGSTEAL_ANON,
&gt; +	PGSTEAL_FILE,
&gt; +	PGSCAN_KSWAPD,
&gt; +	PGSCAN_DIRECT,
&gt; +	PGSCAN_KHUGEPAGED,
&gt; +	PGSCAN_PROACTIVE,
&gt; +	PGSCAN_ANON,
&gt; +	PGSCAN_FILE,
&gt; +	PGREFILL,
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	NR_HUGETLB,
&gt;  #endif
&gt; diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h
&gt; index 22a139f82d75..03fe95f5a020 100644
&gt; --- a/include/linux/vm_event_item.h
&gt; +++ b/include/linux/vm_event_item.h
&gt; @@ -38,21 +38,8 @@ enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
&gt;  		PGFREE, PGACTIVATE, PGDEACTIVATE, PGLAZYFREE,
&gt;  		PGFAULT, PGMAJFAULT,
&gt;  		PGLAZYFREED,
&gt; -		PGREFILL,
&gt;  		PGREUSE,
&gt; -		PGSTEAL_KSWAPD,
&gt; -		PGSTEAL_DIRECT,
&gt; -		PGSTEAL_KHUGEPAGED,
&gt; -		PGSTEAL_PROACTIVE,
&gt; -		PGSCAN_KSWAPD,
&gt; -		PGSCAN_DIRECT,
&gt; -		PGSCAN_KHUGEPAGED,
&gt; -		PGSCAN_PROACTIVE,
&gt;  		PGSCAN_DIRECT_THROTTLE,
&gt; -		PGSCAN_ANON,
&gt; -		PGSCAN_FILE,
&gt; -		PGSTEAL_ANON,
&gt; -		PGSTEAL_FILE,
&gt;  #ifdef CONFIG_NUMA
&gt;  		PGSCAN_ZONE_RECLAIM_SUCCESS,
&gt;  		PGSCAN_ZONE_RECLAIM_FAILED,
&gt; diff --git a/mm/memcontrol.c b/mm/memcontrol.c
&gt; index 6fb9c999347b..0d834c47706f 100644
&gt; --- a/mm/memcontrol.c
&gt; +++ b/mm/memcontrol.c
&gt; @@ -331,6 +331,19 @@ static const unsigned int memcg_node_stat_items[] = {
&gt;  	PGDEMOTE_DIRECT,
&gt;  	PGDEMOTE_KHUGEPAGED,
&gt;  	PGDEMOTE_PROACTIVE,
&gt; +	PGSTEAL_KSWAPD,
&gt; +	PGSTEAL_DIRECT,
&gt; +	PGSTEAL_KHUGEPAGED,
&gt; +	PGSTEAL_PROACTIVE,
&gt; +	PGSTEAL_ANON,
&gt; +	PGSTEAL_FILE,
&gt; +	PGSCAN_KSWAPD,
&gt; +	PGSCAN_DIRECT,
&gt; +	PGSCAN_KHUGEPAGED,
&gt; +	PGSCAN_PROACTIVE,
&gt; +	PGSCAN_ANON,
&gt; +	PGSCAN_FILE,
&gt; +	PGREFILL,
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	NR_HUGETLB,
&gt;  #endif
&gt; @@ -444,17 +457,8 @@ static const unsigned int memcg_vm_event_stat[] = {
&gt;  #endif
&gt;  	PSWPIN,
&gt;  	PSWPOUT,
&gt; -	PGSCAN_KSWAPD,
&gt; -	PGSCAN_DIRECT,
&gt; -	PGSCAN_KHUGEPAGED,
&gt; -	PGSCAN_PROACTIVE,
&gt; -	PGSTEAL_KSWAPD,
&gt; -	PGSTEAL_DIRECT,
&gt; -	PGSTEAL_KHUGEPAGED,
&gt; -	PGSTEAL_PROACTIVE,
&gt;  	PGFAULT,
&gt;  	PGMAJFAULT,
&gt; -	PGREFILL,
&gt;  	PGACTIVATE,
&gt;  	PGDEACTIVATE,
&gt;  	PGLAZYFREE,
&gt; @@ -1401,6 +1405,15 @@ static const struct memory_stat memory_stats[] = {
&gt;  	{ &quot;pgdemote_direct&quot;,		PGDEMOTE_DIRECT		},
&gt;  	{ &quot;pgdemote_khugepaged&quot;,	PGDEMOTE_KHUGEPAGED	},
&gt;  	{ &quot;pgdemote_proactive&quot;,		PGDEMOTE_PROACTIVE	},
&gt; +	{ &quot;pgsteal_kswapd&quot;,		PGSTEAL_KSWAPD		},
&gt; +	{ &quot;pgsteal_direct&quot;,		PGSTEAL_DIRECT		},
&gt; +	{ &quot;pgsteal_khugepaged&quot;,		PGSTEAL_KHUGEPAGED	},
&gt; +	{ &quot;pgsteal_proactive&quot;,		PGSTEAL_PROACTIVE	},
&gt; +	{ &quot;pgscan_kswapd&quot;,		PGSCAN_KSWAPD		},
&gt; +	{ &quot;pgscan_direct&quot;,		PGSCAN_DIRECT		},
&gt; +	{ &quot;pgscan_khugepaged&quot;,		PGSCAN_KHUGEPAGED	},
&gt; +	{ &quot;pgscan_proactive&quot;,		PGSCAN_PROACTIVE	},
&gt; +	{ &quot;pgrefill&quot;,			PGREFILL		},
&gt;  #ifdef CONFIG_NUMA_BALANCING
&gt;  	{ &quot;pgpromote_success&quot;,		PGPROMOTE_SUCCESS	},
&gt;  #endif
&gt; @@ -1444,6 +1457,15 @@ static int memcg_page_state_output_unit(int item)
&gt;  	case PGDEMOTE_DIRECT:
&gt;  	case PGDEMOTE_KHUGEPAGED:
&gt;  	case PGDEMOTE_PROACTIVE:
&gt; +	case PGSTEAL_KSWAPD:
&gt; +	case PGSTEAL_DIRECT:
&gt; +	case PGSTEAL_KHUGEPAGED:
&gt; +	case PGSTEAL_PROACTIVE:
&gt; +	case PGSCAN_KSWAPD:
&gt; +	case PGSCAN_DIRECT:
&gt; +	case PGSCAN_KHUGEPAGED:
&gt; +	case PGSCAN_PROACTIVE:
&gt; +	case PGREFILL:
&gt;  #ifdef CONFIG_NUMA_BALANCING
&gt;  	case PGPROMOTE_SUCCESS:
&gt;  #endif
&gt; @@ -1562,15 +1584,15 @@ static void memcg_stat_format(struct mem_cgroup *memcg, struct seq_buf *s)
&gt;  
&gt;  	/* Accumulated memory events */
&gt;  	memcg_seq_buf_print_stat(s, NULL, &quot;pgscan&quot;, &#x27; &#x27;,
&gt; -				 memcg_events(memcg, PGSCAN_KSWAPD) +
&gt; -				 memcg_events(memcg, PGSCAN_DIRECT) +
&gt; -				 memcg_events(memcg, PGSCAN_PROACTIVE) +
&gt; -				 memcg_events(memcg, PGSCAN_KHUGEPAGED));
&gt; +				 memcg_page_state(memcg, PGSCAN_KSWAPD) +
&gt; +				 memcg_page_state(memcg, PGSCAN_DIRECT) +
&gt; +				 memcg_page_state(memcg, PGSCAN_PROACTIVE) +
&gt; +				 memcg_page_state(memcg, PGSCAN_KHUGEPAGED));
&gt;  	memcg_seq_buf_print_stat(s, NULL, &quot;pgsteal&quot;, &#x27; &#x27;,
&gt; -				 memcg_events(memcg, PGSTEAL_KSWAPD) +
&gt; -				 memcg_events(memcg, PGSTEAL_DIRECT) +
&gt; -				 memcg_events(memcg, PGSTEAL_PROACTIVE) +
&gt; -				 memcg_events(memcg, PGSTEAL_KHUGEPAGED));
&gt; +				 memcg_page_state(memcg, PGSTEAL_KSWAPD) +
&gt; +				 memcg_page_state(memcg, PGSTEAL_DIRECT) +
&gt; +				 memcg_page_state(memcg, PGSTEAL_PROACTIVE) +
&gt; +				 memcg_page_state(memcg, PGSTEAL_KHUGEPAGED));
&gt;  
&gt;  	for (i = 0; i &lt; ARRAY_SIZE(memcg_vm_event_stat); i++) {
&gt;  #ifdef CONFIG_MEMCG_V1
&gt; diff --git a/mm/vmscan.c b/mm/vmscan.c
&gt; index 5fa6e6bd6540..c3dc7c7befac 100644
&gt; --- a/mm/vmscan.c
&gt; +++ b/mm/vmscan.c
&gt; @@ -1984,7 +1984,7 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  	unsigned long nr_taken;
&gt;  	struct reclaim_stat stat;
&gt;  	bool file = is_file_lru(lru);
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	struct pglist_data *pgdat = lruvec_pgdat(lruvec);
&gt;  	bool stalled = false;
&gt;  
&gt; @@ -2010,10 +2010,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  
&gt;  	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);
&gt;  	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, nr_scanned);
&gt; -	count_memcg_events(lruvec_memcg(lruvec), item, nr_scanned);
&gt; -	__count_vm_events(PGSCAN_ANON + file, nr_scanned);
&gt; +	mod_lruvec_state(lruvec, item, nr_scanned);
&gt; +	mod_lruvec_state(lruvec, PGSCAN_ANON + file, nr_scanned);
&gt;  
&gt;  	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
&gt;  
&gt; @@ -2030,10 +2028,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  					stat.nr_demoted);
&gt;  	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);
&gt;  	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, nr_reclaimed);
&gt; -	count_memcg_events(lruvec_memcg(lruvec), item, nr_reclaimed);
&gt; -	__count_vm_events(PGSTEAL_ANON + file, nr_reclaimed);
&gt; +	mod_lruvec_state(lruvec, item, nr_reclaimed);
&gt; +	mod_lruvec_state(lruvec, PGSTEAL_ANON + file, nr_reclaimed);
&gt;  
&gt;  	lru_note_cost_unlock_irq(lruvec, file, stat.nr_pageout,
&gt;  					nr_scanned - nr_reclaimed);
&gt; @@ -2120,9 +2116,7 @@ static void shrink_active_list(unsigned long nr_to_scan,
&gt;  
&gt;  	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);
&gt;  
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(PGREFILL, nr_scanned);
&gt; -	count_memcg_events(lruvec_memcg(lruvec), PGREFILL, nr_scanned);
&gt; +	mod_lruvec_state(lruvec, PGREFILL, nr_scanned);
&gt;  
&gt;  	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
&gt;  
&gt; @@ -4537,7 +4531,7 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  {
&gt;  	int i;
&gt;  	int gen;
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	int sorted = 0;
&gt;  	int scanned = 0;
&gt;  	int isolated = 0;
&gt; @@ -4545,7 +4539,6 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  	int scan_batch = min(nr_to_scan, MAX_LRU_BATCH);
&gt;  	int remaining = scan_batch;
&gt;  	struct lru_gen_folio *lrugen = &amp;lruvec-&gt;lrugen;
&gt; -	struct mem_cgroup *memcg = lruvec_memcg(lruvec);
&gt;  
&gt;  	VM_WARN_ON_ONCE(!list_empty(list));
&gt;  
&gt; @@ -4596,13 +4589,9 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  	}
&gt;  
&gt;  	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc)) {
&gt; -		__count_vm_events(item, isolated);
&gt; -		__count_vm_events(PGREFILL, sorted);
&gt; -	}
&gt; -	count_memcg_events(memcg, item, isolated);
&gt; -	count_memcg_events(memcg, PGREFILL, sorted);
&gt; -	__count_vm_events(PGSCAN_ANON + type, isolated);
&gt; +	mod_lruvec_state(lruvec, item, isolated);
&gt; +	mod_lruvec_state(lruvec, PGREFILL, sorted);
&gt; +	mod_lruvec_state(lruvec, PGSCAN_ANON + type, isolated);
&gt;  	trace_mm_vmscan_lru_isolate(sc-&gt;reclaim_idx, sc-&gt;order, scan_batch,
&gt;  				scanned, skipped, isolated,
&gt;  				type ? LRU_INACTIVE_FILE : LRU_INACTIVE_ANON);
&gt; @@ -4705,7 +4694,7 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  	LIST_HEAD(clean);
&gt;  	struct folio *folio;
&gt;  	struct folio *next;
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	struct reclaim_stat stat;
&gt;  	struct lru_gen_mm_walk *walk;
&gt;  	bool skip_retry = false;
&gt; @@ -4769,10 +4758,8 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  					stat.nr_demoted);
&gt;  
&gt;  	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, reclaimed);
&gt; -	count_memcg_events(memcg, item, reclaimed);
&gt; -	__count_vm_events(PGSTEAL_ANON + type, reclaimed);
&gt; +	mod_lruvec_state(lruvec, item, reclaimed);
&gt; +	mod_lruvec_state(lruvec, PGSTEAL_ANON + type, reclaimed);
&gt;  
&gt;  	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
&gt;  
&gt; diff --git a/mm/vmstat.c b/mm/vmstat.c
&gt; index 86b14b0f77b5..44bbb7752f11 100644
&gt; --- a/mm/vmstat.c
&gt; +++ b/mm/vmstat.c
&gt; @@ -1276,6 +1276,19 @@ const char * const vmstat_text[] = {
&gt;  	[I(PGDEMOTE_DIRECT)]			= &quot;pgdemote_direct&quot;,
&gt;  	[I(PGDEMOTE_KHUGEPAGED)]		= &quot;pgdemote_khugepaged&quot;,
&gt;  	[I(PGDEMOTE_PROACTIVE)]			= &quot;pgdemote_proactive&quot;,
&gt; +	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
&gt; +	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
&gt; +	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
&gt; +	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
&gt; +	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
&gt; +	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
&gt; +	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
&gt; +	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
&gt; +	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
&gt; +	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
&gt; +	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
&gt; +	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
&gt; +	[I(PGREFILL)]				= &quot;pgrefill&quot;,
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	[I(NR_HUGETLB)]				= &quot;nr_hugetlb&quot;,
&gt;  #endif
&gt; @@ -1318,21 +1331,8 @@ const char * const vmstat_text[] = {
&gt;  	[I(PGMAJFAULT)]				= &quot;pgmajfault&quot;,
&gt;  	[I(PGLAZYFREED)]			= &quot;pglazyfreed&quot;,
&gt;  
&gt; -	[I(PGREFILL)]				= &quot;pgrefill&quot;,
&gt;  	[I(PGREUSE)]				= &quot;pgreuse&quot;,
&gt; -	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
&gt; -	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
&gt; -	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
&gt; -	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
&gt; -	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
&gt; -	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
&gt; -	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
&gt; -	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
&gt;  	[I(PGSCAN_DIRECT_THROTTLE)]		= &quot;pgscan_direct_throttle&quot;,
&gt; -	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
&gt; -	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
&gt; -	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
&gt; -	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
&gt;  
&gt;  #ifdef CONFIG_NUMA
&gt;  	[I(PGSCAN_ZONE_RECLAIM_SUCCESS)]	= &quot;zone_reclaim_success&quot;,
&gt; -- 
&gt; 2.47.3

-- 
Michal Hocko
SUSE Labs

</pre>
</details>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>