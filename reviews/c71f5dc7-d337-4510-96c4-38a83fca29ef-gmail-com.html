<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH 1/2] mm/mempolicy: track page allocations per mempolicy</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH 1/2] mm/mempolicy: track page allocations per mempolicy</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/c71f5dc7-d337-4510-96c4-38a83fca29ef@gmail.com/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-17">2026-02-17</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-17">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">JP Kobryn (author)</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer JP Kobryn suggested adding per-policy page allocation counters to help diagnose memory pressure issues by correlating mempolicy with node pressure.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">It would be useful to see a breakdown of allocations to understand which
NUMA policies are driving them. For example, when investigating memory
pressure, having policy-specific counts could show that allocations were
bound to the affected node (via MPOL_BIND).

Add per-policy page allocation counters as new node stat items. These
counters can provide correlation between a mempolicy and pressure on a
given node.

Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
---
 include/linux/mmzone.h |  9 +++++++++
 mm/mempolicy.c         | 30 ++++++++++++++++++++++++++++--
 mm/vmstat.c            |  9 +++++++++
 3 files changed, 46 insertions(+), 2 deletions(-)

diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index fc5d6c88d2f0..762609d5f0af 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -255,6 +255,15 @@ enum node_stat_item {
 	PGDEMOTE_DIRECT,
 	PGDEMOTE_KHUGEPAGED,
 	PGDEMOTE_PROACTIVE,
+#ifdef CONFIG_NUMA
+	PGALLOC_MPOL_DEFAULT,
+	PGALLOC_MPOL_PREFERRED,
+	PGALLOC_MPOL_BIND,
+	PGALLOC_MPOL_INTERLEAVE,
+	PGALLOC_MPOL_LOCAL,
+	PGALLOC_MPOL_PREFERRED_MANY,
+	PGALLOC_MPOL_WEIGHTED_INTERLEAVE,
+#endif
 #ifdef CONFIG_HUGETLB_PAGE
 	NR_HUGETLB,
 #endif
diff --git a/mm/mempolicy.c b/mm/mempolicy.c
index 68a98ba57882..3c64784af761 100644
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@ -217,6 +217,21 @@ static void reduce_interleave_weights(unsigned int *bw, u8 *new_iw)
 		new_iw[nid] /= iw_gcd;
 }
 
+#define CHECK_MPOL_NODE_STAT_OFFSET(mpol) \
+	BUILD_BUG_ON(PGALLOC_##mpol - mpol != PGALLOC_MPOL_DEFAULT)
+
+static enum node_stat_item mpol_node_stat(unsigned short mode)
+{
+	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_PREFERRED);
+	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_BIND);
+	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_INTERLEAVE);
+	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_LOCAL);
+	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_PREFERRED_MANY);
+	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_WEIGHTED_INTERLEAVE);
+
+	return PGALLOC_MPOL_DEFAULT + mode;
+}
+
 int mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)
 {
 	struct weighted_interleave_state *new_wi_state, *old_wi_state = NULL;
@@ -2446,8 +2461,14 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
 
 	nodemask = policy_nodemask(gfp, pol, ilx, &amp;nid);
 
-	if (pol-&gt;mode == MPOL_PREFERRED_MANY)
-		return alloc_pages_preferred_many(gfp, order, nid, nodemask);
+	if (pol-&gt;mode == MPOL_PREFERRED_MANY) {
+		page = alloc_pages_preferred_many(gfp, order, nid, nodemask);
+		if (page)
+			__mod_node_page_state(page_pgdat(page),
+					mpol_node_stat(MPOL_PREFERRED_MANY), 1 &lt;&lt; order);
+
+		return page;
+	}
 
 	if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp;
 	    /* filter &quot;hugepage&quot; allocation, unless from alloc_pages() */
@@ -2472,6 +2493,9 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
 			page = __alloc_frozen_pages_noprof(
 				gfp | __GFP_THISNODE | __GFP_NORETRY, order,
 				nid, NULL);
+			if (page)
+				__mod_node_page_state(page_pgdat(page),
+						mpol_node_stat(pol-&gt;mode), 1 &lt;&lt; order);
 			if (page || !(gfp &amp; __GFP_DIRECT_RECLAIM))
 				return page;
 			/*
@@ -2484,6 +2508,8 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
 	}
 
 	page = __alloc_frozen_pages_noprof(gfp, order, nid, nodemask);
+	if (page)
+		__mod_node_page_state(page_pgdat(page), mpol_node_stat(pol-&gt;mode), 1 &lt;&lt; order);
 
 	if (unlikely(pol-&gt;mode == MPOL_INTERLEAVE ||
 		     pol-&gt;mode == MPOL_WEIGHTED_INTERLEAVE) &amp;&amp; page) {
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 65de88cdf40e..74e0ddde1e93 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -1291,6 +1291,15 @@ const char * const vmstat_text[] = {
 	[I(PGDEMOTE_DIRECT)]			= &quot;pgdemote_direct&quot;,
 	[I(PGDEMOTE_KHUGEPAGED)]		= &quot;pgdemote_khugepaged&quot;,
 	[I(PGDEMOTE_PROACTIVE)]			= &quot;pgdemote_proactive&quot;,
+#ifdef CONFIG_NUMA
+	[I(PGALLOC_MPOL_DEFAULT)]		= &quot;pgalloc_mpol_default&quot;,
+	[I(PGALLOC_MPOL_PREFERRED)]		= &quot;pgalloc_mpol_preferred&quot;,
+	[I(PGALLOC_MPOL_BIND)]			= &quot;pgalloc_mpol_bind&quot;,
+	[I(PGALLOC_MPOL_INTERLEAVE)]		= &quot;pgalloc_mpol_interleave&quot;,
+	[I(PGALLOC_MPOL_LOCAL)]			= &quot;pgalloc_mpol_local&quot;,
+	[I(PGALLOC_MPOL_PREFERRED_MANY)]	= &quot;pgalloc_mpol_preferred_many&quot;,
+	[I(PGALLOC_MPOL_WEIGHTED_INTERLEAVE)]	= &quot;pgalloc_mpol_weighted_interleave&quot;,
+#endif
 #ifdef CONFIG_HUGETLB_PAGE
 	[I(NR_HUGETLB)]				= &quot;nr_hugetlb&quot;,
 #endif
-- 
2.47.3



---

It would be useful to narrow down reclaim to specific nodes.

Provide per-node reclaim visibility by changing the pgscan and pgsteal
stats from global vm_event_item&#x27;s to node_stat_item&#x27;s. Note this change has
the side effect of now tracking these stats on a per-memcg basis.

Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
---
 drivers/virtio/virtio_balloon.c |  8 ++++----
 include/linux/mmzone.h          | 12 +++++++++++
 include/linux/vm_event_item.h   | 12 -----------
 mm/memcontrol.c                 | 36 ++++++++++++++++++---------------
 mm/vmscan.c                     | 32 +++++++++++------------------
 mm/vmstat.c                     | 24 +++++++++++-----------
 6 files changed, 60 insertions(+), 64 deletions(-)

diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
index 74fe59f5a78c..1341d9d1a2a1 100644
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@ -374,13 +374,13 @@ static inline unsigned int update_balloon_vm_stats(struct virtio_balloon *vb)
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_ALLOC_STALL, stall);
 
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_SCAN,
-		    pages_to_bytes(events[PGSCAN_KSWAPD]));
+		    pages_to_bytes(global_node_page_state(PGSCAN_KSWAPD)));
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_SCAN,
-		    pages_to_bytes(events[PGSCAN_DIRECT]));
+		    pages_to_bytes(global_node_page_state(PGSCAN_DIRECT)));
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_RECLAIM,
-		    pages_to_bytes(events[PGSTEAL_KSWAPD]));
+		    pages_to_bytes(global_node_page_state(PGSTEAL_KSWAPD)));
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_RECLAIM,
-		    pages_to_bytes(events[PGSTEAL_DIRECT]));
+		    pages_to_bytes(global_node_page_state(PGSTEAL_DIRECT)));
 
 #ifdef CONFIG_HUGETLB_PAGE
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_HTLB_PGALLOC,
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 762609d5f0af..fc39c107a4b5 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -255,6 +255,18 @@ enum node_stat_item {
 	PGDEMOTE_DIRECT,
 	PGDEMOTE_KHUGEPAGED,
 	PGDEMOTE_PROACTIVE,
+	PGSTEAL_KSWAPD,
+	PGSTEAL_DIRECT,
+	PGSTEAL_KHUGEPAGED,
+	PGSTEAL_PROACTIVE,
+	PGSTEAL_ANON,
+	PGSTEAL_FILE,
+	PGSCAN_KSWAPD,
+	PGSCAN_DIRECT,
+	PGSCAN_KHUGEPAGED,
+	PGSCAN_PROACTIVE,
+	PGSCAN_ANON,
+	PGSCAN_FILE,
 #ifdef CONFIG_NUMA
 	PGALLOC_MPOL_DEFAULT,
 	PGALLOC_MPOL_PREFERRED,
diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h
index 92f80b4d69a6..6f1787680658 100644
--- a/include/linux/vm_event_item.h
+++ b/include/linux/vm_event_item.h
@@ -40,19 +40,7 @@ enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
 		PGLAZYFREED,
 		PGREFILL,
 		PGREUSE,
-		PGSTEAL_KSWAPD,
-		PGSTEAL_DIRECT,
-		PGSTEAL_KHUGEPAGED,
-		PGSTEAL_PROACTIVE,
-		PGSCAN_KSWAPD,
-		PGSCAN_DIRECT,
-		PGSCAN_KHUGEPAGED,
-		PGSCAN_PROACTIVE,
 		PGSCAN_DIRECT_THROTTLE,
-		PGSCAN_ANON,
-		PGSCAN_FILE,
-		PGSTEAL_ANON,
-		PGSTEAL_FILE,
 #ifdef CONFIG_NUMA
 		PGSCAN_ZONE_RECLAIM_SUCCESS,
 		PGSCAN_ZONE_RECLAIM_FAILED,
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 86f43b7e5f71..bde0b6536be6 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -328,6 +328,18 @@ static const unsigned int memcg_node_stat_items[] = {
 	PGDEMOTE_DIRECT,
 	PGDEMOTE_KHUGEPAGED,
 	PGDEMOTE_PROACTIVE,
+	PGSTEAL_KSWAPD,
+	PGSTEAL_DIRECT,
+	PGSTEAL_KHUGEPAGED,
+	PGSTEAL_PROACTIVE,
+	PGSTEAL_ANON,
+	PGSTEAL_FILE,
+	PGSCAN_KSWAPD,
+	PGSCAN_DIRECT,
+	PGSCAN_KHUGEPAGED,
+	PGSCAN_PROACTIVE,
+	PGSCAN_ANON,
+	PGSCAN_FILE,
 #ifdef CONFIG_HUGETLB_PAGE
 	NR_HUGETLB,
 #endif
@@ -441,14 +453,6 @@ static const unsigned int memcg_vm_event_stat[] = {
 #endif
 	PSWPIN,
 	PSWPOUT,
-	PGSCAN_KSWAPD,
-	PGSCAN_DIRECT,
-	PGSCAN_KHUGEPAGED,
-	PGSCAN_PROACTIVE,
-	PGSTEAL_KSWAPD,
-	PGSTEAL_DIRECT,
-	PGSTEAL_KHUGEPAGED,
-	PGSTEAL_PROACTIVE,
 	PGFAULT,
 	PGMAJFAULT,
 	PGREFILL,
@@ -1496,15 +1500,15 @@ static void memcg_stat_format(struct mem_cgroup *memcg, struct seq_buf *s)
 
 	/* Accumulated memory events */
 	seq_buf_printf(s, &quot;pgscan %lu\n&quot;,
-		       memcg_events(memcg, PGSCAN_KSWAPD) +
-		       memcg_events(memcg, PGSCAN_DIRECT) +
-		       memcg_events(memcg, PGSCAN_PROACTIVE) +
-		       memcg_events(memcg, PGSCAN_KHUGEPAGED));
+		       memcg_page_state(memcg, PGSCAN_KSWAPD) +
+		       memcg_page_state(memcg, PGSCAN_DIRECT) +
+		       memcg_page_state(memcg, PGSCAN_PROACTIVE) +
+		       memcg_page_state(memcg, PGSCAN_KHUGEPAGED));
 	seq_buf_printf(s, &quot;pgsteal %lu\n&quot;,
-		       memcg_events(memcg, PGSTEAL_KSWAPD) +
-		       memcg_events(memcg, PGSTEAL_DIRECT) +
-		       memcg_events(memcg, PGSTEAL_PROACTIVE) +
-		       memcg_events(memcg, PGSTEAL_KHUGEPAGED));
+		       memcg_page_state(memcg, PGSTEAL_KSWAPD) +
+		       memcg_page_state(memcg, PGSTEAL_DIRECT) +
+		       memcg_page_state(memcg, PGSTEAL_PROACTIVE) +
+		       memcg_page_state(memcg, PGSTEAL_KHUGEPAGED));
 
 	for (i = 0; i &lt; ARRAY_SIZE(memcg_vm_event_stat); i++) {
 #ifdef CONFIG_MEMCG_V1
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 614ccf39fe3f..16a0f21e3ea1 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -1977,7 +1977,7 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
 	unsigned long nr_taken;
 	struct reclaim_stat stat;
 	bool file = is_file_lru(lru);
-	enum vm_event_item item;
+	enum node_stat_item item;
 	struct pglist_data *pgdat = lruvec_pgdat(lruvec);
 	bool stalled = false;
 
@@ -2003,10 +2003,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
 
 	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);
 	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
-	if (!cgroup_reclaim(sc))
-		__count_vm_events(item, nr_scanned);
-	count_memcg_events(lruvec_memcg(lruvec), item, nr_scanned);
-	__count_vm_events(PGSCAN_ANON + file, nr_scanned);
+	mod_lruvec_state(lruvec, item, nr_scanned);
+	mod_lruvec_state(lruvec, PGSCAN_ANON + file, nr_scanned);
 
 	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
 
@@ -2023,10 +2021,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
 					stat.nr_demoted);
 	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);
 	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
-	if (!cgroup_reclaim(sc))
-		__count_vm_events(item, nr_reclaimed);
-	count_memcg_events(lruvec_memcg(lruvec), item, nr_reclaimed);
-	__count_vm_events(PGSTEAL_ANON + file, nr_reclaimed);
+	mod_lruvec_state(lruvec, item, nr_reclaimed);
+	mod_lruvec_state(lruvec, PGSTEAL_ANON + file, nr_reclaimed);
 
 	lru_note_cost_unlock_irq(lruvec, file, stat.nr_pageout,
 					nr_scanned - nr_reclaimed);
@@ -4536,7 +4532,7 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
 {
 	int i;
 	int gen;
-	enum vm_event_item item;
+	enum node_stat_item item;
 	int sorted = 0;
 	int scanned = 0;
 	int isolated = 0;
@@ -4595,13 +4591,11 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
 	}
 
 	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
-	if (!cgroup_reclaim(sc)) {
-		__count_vm_events(item, isolated);
+	if (!cgroup_reclaim(sc))
 		__count_vm_events(PGREFILL, sorted);
-	}
-	count_memcg_events(memcg, item, isolated);
+	mod_lruvec_state(lruvec, item, isolated);
 	count_memcg_events(memcg, PGREFILL, sorted);
-	__count_vm_events(PGSCAN_ANON + type, isolated);
+	mod_lruvec_state(lruvec, PGSCAN_ANON + type, isolated);
 	trace_mm_vmscan_lru_isolate(sc-&gt;reclaim_idx, sc-&gt;order, scan_batch,
 				scanned, skipped, isolated,
 				type ? LRU_INACTIVE_FILE : LRU_INACTIVE_ANON);
@@ -4686,7 +4680,7 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
 	LIST_HEAD(clean);
 	struct folio *folio;
 	struct folio *next;
-	enum vm_event_item item;
+	enum node_stat_item item;
 	struct reclaim_stat stat;
 	struct lru_gen_mm_walk *walk;
 	bool skip_retry = false;
@@ -4750,10 +4744,8 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
 					stat.nr_demoted);
 
 	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
-	if (!cgroup_reclaim(sc))
-		__count_vm_events(item, reclaimed);
-	count_memcg_events(memcg, item, reclaimed);
-	__count_vm_events(PGSTEAL_ANON + type, reclaimed);
+	mod_lruvec_state(lruvec, item, reclaimed);
+	mod_lruvec_state(lruvec, PGSTEAL_ANON + type, reclaimed);
 
 	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
 
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 74e0ddde1e93..e4b259989d58 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -1291,6 +1291,18 @@ const char * const vmstat_text[] = {
 	[I(PGDEMOTE_DIRECT)]			= &quot;pgdemote_direct&quot;,
 	[I(PGDEMOTE_KHUGEPAGED)]		= &quot;pgdemote_khugepaged&quot;,
 	[I(PGDEMOTE_PROACTIVE)]			= &quot;pgdemote_proactive&quot;,
+	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
+	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
+	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
+	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
+	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
+	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
+	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
+	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
+	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
+	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
+	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
+	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
 #ifdef CONFIG_NUMA
 	[I(PGALLOC_MPOL_DEFAULT)]		= &quot;pgalloc_mpol_default&quot;,
 	[I(PGALLOC_MPOL_PREFERRED)]		= &quot;pgalloc_mpol_preferred&quot;,
@@ -1344,19 +1356,7 @@ const char * const vmstat_text[] = {
 
 	[I(PGREFILL)]				= &quot;pgrefill&quot;,
 	[I(PGREUSE)]				= &quot;pgreuse&quot;,
-	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
-	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
-	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
-	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
-	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
-	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
-	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
-	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
 	[I(PGSCAN_DIRECT_THROTTLE)]		= &quot;pgscan_direct_throttle&quot;,
-	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
-	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
-	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
-	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
 
 #ifdef CONFIG_NUMA
 	[I(PGSCAN_ZONE_RECLAIM_SUCCESS)]	= &quot;zone_reclaim_success&quot;,
-- 
2.47.3



---

On 2/11/26 11:29 PM, Michal Hocko wrote:
&gt; On Wed 11-02-26 20:51:09, JP Kobryn wrote:
&gt;&gt; It would be useful to narrow down reclaim to specific nodes.
&gt;&gt;
&gt;&gt; Provide per-node reclaim visibility by changing the pgscan and pgsteal
&gt;&gt; stats from global vm_event_item&#x27;s to node_stat_item&#x27;s. Note this change has
&gt;&gt; the side effect of now tracking these stats on a per-memcg basis.
&gt; 
&gt; The changelog could have been more clear about the actual changes as
&gt; this is not overly clear for untrained eyes. The most important parts
&gt; are that /proc/vmstat will preserve reclaim stats with slightly
&gt; different counters ordering (shouldn&#x27;t break userspace much^W), per-node
&gt; stats will be now newly displayed in /proc/zoneinfo - this is presumably
&gt; the primary motivation to have a better insight of per-node reclaim
&gt; activity, and memcg stats will now show their share of the global memory
&gt; reclaim.
&gt; 
&gt; Have I missed anything?

That&#x27;s accurate. Plus aside from reading /proc/zoneinfo they will also
be in /sys/devices/system/node/nodeN/vmstat. I see I could have been
more explicit about this. Let me make additions to the changelog in v2.
Thanks for taking a look.


---

On 2/11/26 8:57 PM, Matthew Wilcox wrote:
&gt; On Wed, Feb 11, 2026 at 08:51:07PM -0800, JP Kobryn wrote:
&gt;&gt; We sometimes find ourselves in situations where reclaim kicks in, yet there
&gt; 
&gt; who is we?  you haven&#x27;t indicated any affiliation in your tags.

Meta. Is there a preferred way of indicating this?


---

On 2/11/26 11:29 PM, Michal Hocko wrote:
&gt; On Wed 11-02-26 20:51:08, JP Kobryn wrote:
&gt;&gt; It would be useful to see a breakdown of allocations to understand which
&gt;&gt; NUMA policies are driving them. For example, when investigating memory
&gt;&gt; pressure, having policy-specific counts could show that allocations were
&gt;&gt; bound to the affected node (via MPOL_BIND).
&gt;&gt;
&gt;&gt; Add per-policy page allocation counters as new node stat items. These
&gt;&gt; counters can provide correlation between a mempolicy and pressure on a
&gt;&gt; given node.
&gt; 
&gt; Could you be more specific how exactly do you plan to use those
&gt; counters?

Yes. Patch 2 allows us to find which nodes are undergoing reclaim. Once
we identify the affected node(s), the new mpol counters (this patch)
allow us correlate the pressure to the mempolicy driving it.


---

On 2/12/26 7:07 AM, Shakeel Butt wrote:
&gt; On Wed, Feb 11, 2026 at 08:51:08PM -0800, JP Kobryn wrote:
&gt;&gt; It would be useful to see a breakdown of allocations to understand which
&gt;&gt; NUMA policies are driving them. For example, when investigating memory
&gt;&gt; pressure, having policy-specific counts could show that allocations were
&gt;&gt; bound to the affected node (via MPOL_BIND).
&gt;&gt;
&gt;&gt; Add per-policy page allocation counters as new node stat items. These
&gt;&gt; counters can provide correlation between a mempolicy and pressure on a
&gt;&gt; given node.
&gt;&gt;
&gt;&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt;&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; 
&gt; [...]
&gt; 
&gt;&gt;   int mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)
&gt;&gt;   {
&gt;&gt;   	struct weighted_interleave_state *new_wi_state, *old_wi_state = NULL;
&gt;&gt; @@ -2446,8 +2461,14 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
&gt;&gt;   
&gt;&gt;   	nodemask = policy_nodemask(gfp, pol, ilx, &amp;nid);
&gt;&gt;   
&gt;&gt; -	if (pol-&gt;mode == MPOL_PREFERRED_MANY)
&gt;&gt; -		return alloc_pages_preferred_many(gfp, order, nid, nodemask);
&gt;&gt; +	if (pol-&gt;mode == MPOL_PREFERRED_MANY) {
&gt;&gt; +		page = alloc_pages_preferred_many(gfp, order, nid, nodemask);
&gt;&gt; +		if (page)
&gt;&gt; +			__mod_node_page_state(page_pgdat(page),
&gt;&gt; +					mpol_node_stat(MPOL_PREFERRED_MANY), 1 &lt;&lt; order);
&gt; 
&gt; Here and two places below, please use mod_node_page_state() instead of
&gt; __mod_node_page_state() as __foo() requires preempt disable or if the
&gt; given stat can be updated in IRQ, then IRQ disable. This code path does
&gt; not do either of that.

Thanks, I also see syzbot flagged this as well. I can make this change
in v2.


---

On 2/11/26 11:08 PM, Michael S. Tsirkin wrote:
&gt; On Wed, Feb 11, 2026 at 08:51:09PM -0800, JP Kobryn wrote:
&gt;&gt; It would be useful to narrow down reclaim to specific nodes.
&gt;&gt;
&gt;&gt; Provide per-node reclaim visibility by changing the pgscan and pgsteal
&gt;&gt; stats from global vm_event_item&#x27;s to node_stat_item&#x27;s. Note this change has
&gt;&gt; the side effect of now tracking these stats on a per-memcg basis.
&gt;&gt;
&gt;&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt;&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; 
&gt; virtio_balloon changes

Thanks. I&#x27;ll make sure to spell this out in the v2 changelog.


---

On 2/12/26 7:24 AM, Vlastimil Babka wrote:
&gt; On 2/12/26 05:51, JP Kobryn wrote:
&gt;&gt; It would be useful to see a breakdown of allocations to understand which
&gt;&gt; NUMA policies are driving them. For example, when investigating memory
&gt;&gt; pressure, having policy-specific counts could show that allocations were
&gt;&gt; bound to the affected node (via MPOL_BIND).
&gt;&gt;
&gt;&gt; Add per-policy page allocation counters as new node stat items. These
&gt;&gt; counters can provide correlation between a mempolicy and pressure on a
&gt;&gt; given node.
&gt;&gt;
&gt;&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt;&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; 
&gt; Are the numa_{hit,miss,etc.} counters insufficient? Could they be extended
&gt; in a way that would capture any missing important details? A counter per
&gt; policy type seems exhaustive, but then on one hand it might be not important
&gt; to distinguish beetween some of them, and on the other hand it doesn&#x27;t track
&gt; the nodemask anyway.

The two patches of the series should complement each other. When
investigating memory pressure, we could identify the affected nodes
(patch 2). Then we can cross-reference the policy-specific stats to find
any correlation (this patch).

I think extending numa_* counters would call for more permutations to
account for the numa stat per policy. I think distinguishing between
MPOL_DEFAULT and MPOL_BIND is meaningful, for example. Am I
understanding your question?


---

On 2/13/26 12:54 AM, Vlastimil Babka wrote:
&gt; On 2/12/26 22:25, JP Kobryn wrote:
&gt;&gt; On 2/12/26 7:24 AM, Vlastimil Babka wrote:
&gt;&gt;&gt; On 2/12/26 05:51, JP Kobryn wrote:
&gt;&gt;&gt;&gt; It would be useful to see a breakdown of allocations to understand which
&gt;&gt;&gt;&gt; NUMA policies are driving them. For example, when investigating memory
&gt;&gt;&gt;&gt; pressure, having policy-specific counts could show that allocations were
&gt;&gt;&gt;&gt; bound to the affected node (via MPOL_BIND).
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Add per-policy page allocation counters as new node stat items. These
&gt;&gt;&gt;&gt; counters can provide correlation between a mempolicy and pressure on a
&gt;&gt;&gt;&gt; given node.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt;&gt;&gt;&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Are the numa_{hit,miss,etc.} counters insufficient? Could they be extended
&gt;&gt;&gt; in a way that would capture any missing important details? A counter per
&gt;&gt;&gt; policy type seems exhaustive, but then on one hand it might be not important
&gt;&gt;&gt; to distinguish beetween some of them, and on the other hand it doesn&#x27;t track
&gt;&gt;&gt; the nodemask anyway.
&gt;&gt;
&gt;&gt; The two patches of the series should complement each other. When
&gt;&gt; investigating memory pressure, we could identify the affected nodes
&gt;&gt; (patch 2). Then we can cross-reference the policy-specific stats to find
&gt;&gt; any correlation (this patch).
&gt;&gt;
&gt;&gt; I think extending numa_* counters would call for more permutations to
&gt;&gt; account for the numa stat per policy. I think distinguishing between
&gt;&gt; MPOL_DEFAULT and MPOL_BIND is meaningful, for example. Am I
&gt; 
&gt; Are there other useful examples or would it be enough to add e.g. a
&gt; numa_bind counter to the numa_hit/miss/etc?

Aside from bind, it&#x27;s worth emphasizing that with default policy
tracking we could see if the local node is the source of pressure. In
the interleave case, we would be able to see if the loads are being
balanced or, in the weighted case, being distributed properly.

On extending the numa stats instead, I looked into this some more. I&#x27;m
not sure if they&#x27;re a good fit. They seem more about whether the
allocator succeeded at placement rather than which policy drove the
allocation. Thoughts?

&gt; What I&#x27;m trying to say the level of detail you are trying to add to the
&gt; always-on counters seems like more suitable for tracepoints. The counters
&gt; should be limited to what&#x27;s known to be useful and not &quot;everything we are
&gt; able to track and possibly could need one day&quot;.
In a triage scenario, having the stats collected up to the time of the
reported issue would be better. We make use of the tool called below[0].
It periodically samples the system and allows us to view the
historical state prior to the issue. If we started at the time of the
incident and attached tracepoints it would be too late.

The triage workflow would look like this:
1) Pressure/OOMs reported while system-wide memory is free.
2) Check per-node pgscan/pgsteal stats (provided by patch 2) to narrow
down node(s) under pressure.
3) Check per-policy allocation counters (this patch) on that node to
find what policy was driving it.

[0] https://github.com/facebookincubator/below


---

On 2/16/26 12:26 AM, Michal Hocko wrote:
&gt; On Thu 12-02-26 13:22:56, JP Kobryn wrote:
&gt;&gt; On 2/11/26 11:29 PM, Michal Hocko wrote:
&gt;&gt;&gt; On Wed 11-02-26 20:51:08, JP Kobryn wrote:
&gt;&gt;&gt;&gt; It would be useful to see a breakdown of allocations to understand which
&gt;&gt;&gt;&gt; NUMA policies are driving them. For example, when investigating memory
&gt;&gt;&gt;&gt; pressure, having policy-specific counts could show that allocations were
&gt;&gt;&gt;&gt; bound to the affected node (via MPOL_BIND).
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Add per-policy page allocation counters as new node stat items. These
&gt;&gt;&gt;&gt; counters can provide correlation between a mempolicy and pressure on a
&gt;&gt;&gt;&gt; given node.
&gt;&gt;&gt;
&gt;&gt;&gt; Could you be more specific how exactly do you plan to use those
&gt;&gt;&gt; counters?
&gt;&gt;
&gt;&gt; Yes. Patch 2 allows us to find which nodes are undergoing reclaim. Once
&gt;&gt; we identify the affected node(s), the new mpol counters (this patch)
&gt;&gt; allow us correlate the pressure to the mempolicy driving it.
&gt; 
&gt; I would appreciate somehow more specificity. You are adding counters
&gt; that are not really easy to drop once they are in. Sure we have
&gt; precedence of dropping some counters in the past so this is not as hard
&gt; as usual userspace APIs but still...
&gt; 
&gt; How exactly do you tolerate mempolicy allocations to specific nodes?
&gt; While MPOL_MBIND is quite straightforward others are less so.

The design does account for this regardless of the policy. In the call
to __mod_node_page_state(), I&#x27;m using page_pgdat(page) so the stat is
attributed to the node where the page actually landed.


---

On 2/16/26 1:07 PM, Michal Hocko wrote:
&gt; On Mon 16-02-26 09:50:26, JP Kobryn (Meta) wrote:
&gt;&gt; On 2/16/26 12:26 AM, Michal Hocko wrote:
&gt;&gt;&gt; On Thu 12-02-26 13:22:56, JP Kobryn wrote:
&gt;&gt;&gt;&gt; On 2/11/26 11:29 PM, Michal Hocko wrote:
&gt;&gt;&gt;&gt;&gt; On Wed 11-02-26 20:51:08, JP Kobryn wrote:
&gt;&gt;&gt;&gt;&gt;&gt; It would be useful to see a breakdown of allocations to understand which
&gt;&gt;&gt;&gt;&gt;&gt; NUMA policies are driving them. For example, when investigating memory
&gt;&gt;&gt;&gt;&gt;&gt; pressure, having policy-specific counts could show that allocations were
&gt;&gt;&gt;&gt;&gt;&gt; bound to the affected node (via MPOL_BIND).
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; Add per-policy page allocation counters as new node stat items. These
&gt;&gt;&gt;&gt;&gt;&gt; counters can provide correlation between a mempolicy and pressure on a
&gt;&gt;&gt;&gt;&gt;&gt; given node.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Could you be more specific how exactly do you plan to use those
&gt;&gt;&gt;&gt;&gt; counters?
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Yes. Patch 2 allows us to find which nodes are undergoing reclaim. Once
&gt;&gt;&gt;&gt; we identify the affected node(s), the new mpol counters (this patch)
&gt;&gt;&gt;&gt; allow us correlate the pressure to the mempolicy driving it.
&gt;&gt;&gt;
&gt;&gt;&gt; I would appreciate somehow more specificity. You are adding counters
&gt;&gt;&gt; that are not really easy to drop once they are in. Sure we have
&gt;&gt;&gt; precedence of dropping some counters in the past so this is not as hard
&gt;&gt;&gt; as usual userspace APIs but still...
&gt;&gt;&gt;
&gt;&gt;&gt; How exactly do you tolerate mempolicy allocations to specific nodes?
&gt;&gt;&gt; While MPOL_MBIND is quite straightforward others are less so.
&gt;&gt;
&gt;&gt; The design does account for this regardless of the policy. In the call
&gt;&gt; to __mod_node_page_state(), I&#x27;m using page_pgdat(page) so the stat is
&gt;&gt; attributed to the node where the page actually landed.
&gt; 
&gt; That much is clear[*]. The consumer side of things is not really clear to
&gt; me. How do you know which policy or part of the nodemask of that policy
&gt; is the source of the memory pressure on a particular node? In other
&gt; words how much is the data actually useful except for a single node
&gt; mempolicy (i.e. MBIND).

Other than the bind policy, having the interleave (and weighted) stats
would allow us to see the effective distribution of the policy. Pressure
could be linked to a user configured weight scheme. I would think it
could also help with confirming expected distributions.

You brought up the node mask so with the preferred policy, I think this
is a good one for using the counters as well. Once we&#x27;re at the point
where we know the node(s) under pressure and then see significant
preferred allocs accounted for, we could search the numa_maps that have
&quot;prefer:&lt;node&gt;&quot; to find the tasks targeting the affected nodes.

I mentioned this on another thread in this series but I&#x27;ll include here
as well and expand some more. For any given policy, the workflow would
be:
1) Pressure/OOMs reported while system-wide memory is free.
2) Check per-node pgscan/pgsteal stats (provided by patch 2) to narrow
down node(s) under pressure. They become available in
/sys/devices/system/node/nodeN/vmstat.
3) Check per-policy allocation counters (this patch) on that node to
find what policy was driving it. Same readout at nodeN/vmstat.
4) Now use /proc/*/numa_maps to identify tasks using the policy.

&gt; 
&gt; [*] btw. I believe you misaccount MPOL_LOCAL because you attribute the
&gt; target node even when the allocation is from a remote node from the
&gt; &quot;local&quot; POV.

It&#x27;s a good point. The accounting as a result of fallback cases
shouldn&#x27;t detract from an investigation though. We&#x27;re interested in the
node(s) under pressure so the relatively few fallback allocations would
land on nodes that are not under pressure and could be viewed as
acceptable noise.


---

On 2/17/26 4:37 AM, Michal Hocko wrote:
&gt; On Mon 16-02-26 23:48:42, JP Kobryn (Meta) wrote:
&gt;&gt; On 2/16/26 1:07 PM, Michal Hocko wrote:
&gt; [...]
&gt;&gt;&gt; [*] btw. I believe you misaccount MPOL_LOCAL because you attribute the
&gt;&gt;&gt; target node even when the allocation is from a remote node from the
&gt;&gt;&gt; &quot;local&quot; POV.
&gt;&gt;
&gt;&gt; It&#x27;s a good point. The accounting as a result of fallback cases
&gt;&gt; shouldn&#x27;t detract from an investigation though. We&#x27;re interested in the
&gt;&gt; node(s) under pressure so the relatively few fallback allocations would
&gt;&gt; land on nodes that are not under pressure and could be viewed as
&gt;&gt; acceptable noise.
&gt; 
&gt; This is really confusing. You simply have no means to tell the
&gt; difference between the requested node and the real node used so you
&gt; cannot really say whether the memory pressure is because of fallbacks or
&gt; your mempolicy configurations. That means that you cannot tell the
&gt; difference between the source of the pressure and victim of that
&gt; pressure.

What if I excluded the fallback cases? I could get the actual node from
the allocated page and compare against the requested node or node mask.
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Matthew Wilcox</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Matthew Wilcox, raised concerns about missing affiliation in the patch tags and incorrect formatting of the &#x27;From&#x27; line in the patch submission.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Wed, Feb 11, 2026 at 08:51:07PM -0800, JP Kobryn wrote:
&gt; We sometimes find ourselves in situations where reclaim kicks in, yet there

who is we?  you haven&#x27;t indicated any affiliation in your tags.


---

On Thu, Feb 12, 2026 at 01:22:09PM -0800, JP Kobryn wrote:
&gt; On 2/11/26 8:57 PM, Matthew Wilcox wrote:
&gt; &gt; On Wed, Feb 11, 2026 at 08:51:07PM -0800, JP Kobryn wrote:
&gt; &gt; &gt; We sometimes find ourselves in situations where reclaim kicks in, yet there
&gt; &gt; 
&gt; &gt; who is we?  you haven&#x27;t indicated any affiliation in your tags.
&gt; 
&gt; Meta. Is there a preferred way of indicating this?

Documentation/process/submitting-patches.rst:

&gt;From Line
^^^^^^^^^

The ``from`` line must be the very first line in the message body,
and has the form:

        From: Patch Author &lt;author@example.com&gt;

The ``from`` line specifies who will be credited as the author of the
patch in the permanent changelog.  If the ``from`` line is missing,
then the ``From:`` line from the email header will be used to determine
the patch author in the changelog.

The author may indicate their affiliation or the sponsor of the work
by adding the name of an organization to the ``from`` and ``SoB`` lines,
e.g.:

        From: Patch Author (Company) &lt;author@example.com&gt;


I do this with ~/.gitconfig

[user]
        name = Matthew Wilcox (Oracle)
        email = willy@infradead.org

and it goes into the From and Signed-off-by lines correctly when
generating patches.
</pre>
</details>
<div class="review-comment-signals">Signals: missing affiliation, incorrect formatting</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Michael Tsirkin</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Michael Tsirkin raised concerns about the virtio_balloon changes in the patch</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Wed, Feb 11, 2026 at 08:51:09PM -0800, JP Kobryn wrote:
&gt; It would be useful to narrow down reclaim to specific nodes.
&gt; 
&gt; Provide per-node reclaim visibility by changing the pgscan and pgsteal
&gt; stats from global vm_event_item&#x27;s to node_stat_item&#x27;s. Note this change has
&gt; the side effect of now tracking these stats on a per-memcg basis.
&gt; 
&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;

virtio_balloon changes

&gt; ---
&gt;  drivers/virtio/virtio_balloon.c |  8 ++++----
&gt;  include/linux/mmzone.h          | 12 +++++++++++
&gt;  include/linux/vm_event_item.h   | 12 -----------
&gt;  mm/memcontrol.c                 | 36 ++++++++++++++++++---------------
&gt;  mm/vmscan.c                     | 32 +++++++++++------------------
&gt;  mm/vmstat.c                     | 24 +++++++++++-----------
&gt;  6 files changed, 60 insertions(+), 64 deletions(-)
&gt; 
&gt; diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
&gt; index 74fe59f5a78c..1341d9d1a2a1 100644
&gt; --- a/drivers/virtio/virtio_balloon.c
&gt; +++ b/drivers/virtio/virtio_balloon.c
&gt; @@ -374,13 +374,13 @@ static inline unsigned int update_balloon_vm_stats(struct virtio_balloon *vb)
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ALLOC_STALL, stall);
&gt;  
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_SCAN,
&gt; -		    pages_to_bytes(events[PGSCAN_KSWAPD]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSCAN_KSWAPD)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_SCAN,
&gt; -		    pages_to_bytes(events[PGSCAN_DIRECT]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSCAN_DIRECT)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_RECLAIM,
&gt; -		    pages_to_bytes(events[PGSTEAL_KSWAPD]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSTEAL_KSWAPD)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_RECLAIM,
&gt; -		    pages_to_bytes(events[PGSTEAL_DIRECT]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSTEAL_DIRECT)));
&gt;  
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_HTLB_PGALLOC,
&gt; diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
&gt; index 762609d5f0af..fc39c107a4b5 100644
&gt; --- a/include/linux/mmzone.h
&gt; +++ b/include/linux/mmzone.h
&gt; @@ -255,6 +255,18 @@ enum node_stat_item {
&gt;  	PGDEMOTE_DIRECT,
&gt;  	PGDEMOTE_KHUGEPAGED,
&gt;  	PGDEMOTE_PROACTIVE,
&gt; +	PGSTEAL_KSWAPD,
&gt; +	PGSTEAL_DIRECT,
&gt; +	PGSTEAL_KHUGEPAGED,
&gt; +	PGSTEAL_PROACTIVE,
&gt; +	PGSTEAL_ANON,
&gt; +	PGSTEAL_FILE,
&gt; +	PGSCAN_KSWAPD,
&gt; +	PGSCAN_DIRECT,
&gt; +	PGSCAN_KHUGEPAGED,
&gt; +	PGSCAN_PROACTIVE,
&gt; +	PGSCAN_ANON,
&gt; +	PGSCAN_FILE,
&gt;  #ifdef CONFIG_NUMA
&gt;  	PGALLOC_MPOL_DEFAULT,
&gt;  	PGALLOC_MPOL_PREFERRED,
&gt; diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h
&gt; index 92f80b4d69a6..6f1787680658 100644
&gt; --- a/include/linux/vm_event_item.h
&gt; +++ b/include/linux/vm_event_item.h
&gt; @@ -40,19 +40,7 @@ enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
&gt;  		PGLAZYFREED,
&gt;  		PGREFILL,
&gt;  		PGREUSE,
&gt; -		PGSTEAL_KSWAPD,
&gt; -		PGSTEAL_DIRECT,
&gt; -		PGSTEAL_KHUGEPAGED,
&gt; -		PGSTEAL_PROACTIVE,
&gt; -		PGSCAN_KSWAPD,
&gt; -		PGSCAN_DIRECT,
&gt; -		PGSCAN_KHUGEPAGED,
&gt; -		PGSCAN_PROACTIVE,
&gt;  		PGSCAN_DIRECT_THROTTLE,
&gt; -		PGSCAN_ANON,
&gt; -		PGSCAN_FILE,
&gt; -		PGSTEAL_ANON,
&gt; -		PGSTEAL_FILE,
&gt;  #ifdef CONFIG_NUMA
&gt;  		PGSCAN_ZONE_RECLAIM_SUCCESS,
&gt;  		PGSCAN_ZONE_RECLAIM_FAILED,
&gt; diff --git a/mm/memcontrol.c b/mm/memcontrol.c
&gt; index 86f43b7e5f71..bde0b6536be6 100644
&gt; --- a/mm/memcontrol.c
&gt; +++ b/mm/memcontrol.c
&gt; @@ -328,6 +328,18 @@ static const unsigned int memcg_node_stat_items[] = {
&gt;  	PGDEMOTE_DIRECT,
&gt;  	PGDEMOTE_KHUGEPAGED,
&gt;  	PGDEMOTE_PROACTIVE,
&gt; +	PGSTEAL_KSWAPD,
&gt; +	PGSTEAL_DIRECT,
&gt; +	PGSTEAL_KHUGEPAGED,
&gt; +	PGSTEAL_PROACTIVE,
&gt; +	PGSTEAL_ANON,
&gt; +	PGSTEAL_FILE,
&gt; +	PGSCAN_KSWAPD,
&gt; +	PGSCAN_DIRECT,
&gt; +	PGSCAN_KHUGEPAGED,
&gt; +	PGSCAN_PROACTIVE,
&gt; +	PGSCAN_ANON,
&gt; +	PGSCAN_FILE,
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	NR_HUGETLB,
&gt;  #endif
&gt; @@ -441,14 +453,6 @@ static const unsigned int memcg_vm_event_stat[] = {
&gt;  #endif
&gt;  	PSWPIN,
&gt;  	PSWPOUT,
&gt; -	PGSCAN_KSWAPD,
&gt; -	PGSCAN_DIRECT,
&gt; -	PGSCAN_KHUGEPAGED,
&gt; -	PGSCAN_PROACTIVE,
&gt; -	PGSTEAL_KSWAPD,
&gt; -	PGSTEAL_DIRECT,
&gt; -	PGSTEAL_KHUGEPAGED,
&gt; -	PGSTEAL_PROACTIVE,
&gt;  	PGFAULT,
&gt;  	PGMAJFAULT,
&gt;  	PGREFILL,
&gt; @@ -1496,15 +1500,15 @@ static void memcg_stat_format(struct mem_cgroup *memcg, struct seq_buf *s)
&gt;  
&gt;  	/* Accumulated memory events */
&gt;  	seq_buf_printf(s, &quot;pgscan %lu\n&quot;,
&gt; -		       memcg_events(memcg, PGSCAN_KSWAPD) +
&gt; -		       memcg_events(memcg, PGSCAN_DIRECT) +
&gt; -		       memcg_events(memcg, PGSCAN_PROACTIVE) +
&gt; -		       memcg_events(memcg, PGSCAN_KHUGEPAGED));
&gt; +		       memcg_page_state(memcg, PGSCAN_KSWAPD) +
&gt; +		       memcg_page_state(memcg, PGSCAN_DIRECT) +
&gt; +		       memcg_page_state(memcg, PGSCAN_PROACTIVE) +
&gt; +		       memcg_page_state(memcg, PGSCAN_KHUGEPAGED));
&gt;  	seq_buf_printf(s, &quot;pgsteal %lu\n&quot;,
&gt; -		       memcg_events(memcg, PGSTEAL_KSWAPD) +
&gt; -		       memcg_events(memcg, PGSTEAL_DIRECT) +
&gt; -		       memcg_events(memcg, PGSTEAL_PROACTIVE) +
&gt; -		       memcg_events(memcg, PGSTEAL_KHUGEPAGED));
&gt; +		       memcg_page_state(memcg, PGSTEAL_KSWAPD) +
&gt; +		       memcg_page_state(memcg, PGSTEAL_DIRECT) +
&gt; +		       memcg_page_state(memcg, PGSTEAL_PROACTIVE) +
&gt; +		       memcg_page_state(memcg, PGSTEAL_KHUGEPAGED));
&gt;  
&gt;  	for (i = 0; i &lt; ARRAY_SIZE(memcg_vm_event_stat); i++) {
&gt;  #ifdef CONFIG_MEMCG_V1
&gt; diff --git a/mm/vmscan.c b/mm/vmscan.c
&gt; index 614ccf39fe3f..16a0f21e3ea1 100644
&gt; --- a/mm/vmscan.c
&gt; +++ b/mm/vmscan.c
&gt; @@ -1977,7 +1977,7 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  	unsigned long nr_taken;
&gt;  	struct reclaim_stat stat;
&gt;  	bool file = is_file_lru(lru);
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	struct pglist_data *pgdat = lruvec_pgdat(lruvec);
&gt;  	bool stalled = false;
&gt;  
&gt; @@ -2003,10 +2003,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  
&gt;  	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);
&gt;  	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, nr_scanned);
&gt; -	count_memcg_events(lruvec_memcg(lruvec), item, nr_scanned);
&gt; -	__count_vm_events(PGSCAN_ANON + file, nr_scanned);
&gt; +	mod_lruvec_state(lruvec, item, nr_scanned);
&gt; +	mod_lruvec_state(lruvec, PGSCAN_ANON + file, nr_scanned);
&gt;  
&gt;  	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
&gt;  
&gt; @@ -2023,10 +2021,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  					stat.nr_demoted);
&gt;  	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);
&gt;  	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, nr_reclaimed);
&gt; -	count_memcg_events(lruvec_memcg(lruvec), item, nr_reclaimed);
&gt; -	__count_vm_events(PGSTEAL_ANON + file, nr_reclaimed);
&gt; +	mod_lruvec_state(lruvec, item, nr_reclaimed);
&gt; +	mod_lruvec_state(lruvec, PGSTEAL_ANON + file, nr_reclaimed);
&gt;  
&gt;  	lru_note_cost_unlock_irq(lruvec, file, stat.nr_pageout,
&gt;  					nr_scanned - nr_reclaimed);
&gt; @@ -4536,7 +4532,7 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  {
&gt;  	int i;
&gt;  	int gen;
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	int sorted = 0;
&gt;  	int scanned = 0;
&gt;  	int isolated = 0;
&gt; @@ -4595,13 +4591,11 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  	}
&gt;  
&gt;  	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc)) {
&gt; -		__count_vm_events(item, isolated);
&gt; +	if (!cgroup_reclaim(sc))
&gt;  		__count_vm_events(PGREFILL, sorted);
&gt; -	}
&gt; -	count_memcg_events(memcg, item, isolated);
&gt; +	mod_lruvec_state(lruvec, item, isolated);
&gt;  	count_memcg_events(memcg, PGREFILL, sorted);
&gt; -	__count_vm_events(PGSCAN_ANON + type, isolated);
&gt; +	mod_lruvec_state(lruvec, PGSCAN_ANON + type, isolated);
&gt;  	trace_mm_vmscan_lru_isolate(sc-&gt;reclaim_idx, sc-&gt;order, scan_batch,
&gt;  				scanned, skipped, isolated,
&gt;  				type ? LRU_INACTIVE_FILE : LRU_INACTIVE_ANON);
&gt; @@ -4686,7 +4680,7 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  	LIST_HEAD(clean);
&gt;  	struct folio *folio;
&gt;  	struct folio *next;
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	struct reclaim_stat stat;
&gt;  	struct lru_gen_mm_walk *walk;
&gt;  	bool skip_retry = false;
&gt; @@ -4750,10 +4744,8 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  					stat.nr_demoted);
&gt;  
&gt;  	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, reclaimed);
&gt; -	count_memcg_events(memcg, item, reclaimed);
&gt; -	__count_vm_events(PGSTEAL_ANON + type, reclaimed);
&gt; +	mod_lruvec_state(lruvec, item, reclaimed);
&gt; +	mod_lruvec_state(lruvec, PGSTEAL_ANON + type, reclaimed);
&gt;  
&gt;  	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
&gt;  
&gt; diff --git a/mm/vmstat.c b/mm/vmstat.c
&gt; index 74e0ddde1e93..e4b259989d58 100644
&gt; --- a/mm/vmstat.c
&gt; +++ b/mm/vmstat.c
&gt; @@ -1291,6 +1291,18 @@ const char * const vmstat_text[] = {
&gt;  	[I(PGDEMOTE_DIRECT)]			= &quot;pgdemote_direct&quot;,
&gt;  	[I(PGDEMOTE_KHUGEPAGED)]		= &quot;pgdemote_khugepaged&quot;,
&gt;  	[I(PGDEMOTE_PROACTIVE)]			= &quot;pgdemote_proactive&quot;,
&gt; +	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
&gt; +	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
&gt; +	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
&gt; +	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
&gt; +	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
&gt; +	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
&gt; +	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
&gt; +	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
&gt; +	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
&gt; +	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
&gt; +	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
&gt; +	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
&gt;  #ifdef CONFIG_NUMA
&gt;  	[I(PGALLOC_MPOL_DEFAULT)]		= &quot;pgalloc_mpol_default&quot;,
&gt;  	[I(PGALLOC_MPOL_PREFERRED)]		= &quot;pgalloc_mpol_preferred&quot;,
&gt; @@ -1344,19 +1356,7 @@ const char * const vmstat_text[] = {
&gt;  
&gt;  	[I(PGREFILL)]				= &quot;pgrefill&quot;,
&gt;  	[I(PGREUSE)]				= &quot;pgreuse&quot;,
&gt; -	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
&gt; -	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
&gt; -	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
&gt; -	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
&gt; -	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
&gt; -	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
&gt; -	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
&gt; -	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
&gt;  	[I(PGSCAN_DIRECT_THROTTLE)]		= &quot;pgscan_direct_throttle&quot;,
&gt; -	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
&gt; -	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
&gt; -	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
&gt; -	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
&gt;  
&gt;  #ifdef CONFIG_NUMA
&gt;  	[I(PGSCAN_ZONE_RECLAIM_SUCCESS)]	= &quot;zone_reclaim_success&quot;,
&gt; -- 
&gt; 2.47.3

</pre>
</details>
<div class="review-comment-signals">Signals: virtio_balloon changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Michal Hocko</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Michal Hocko raised concerns about the clarity and usefulness of the patch, specifically questioning how the counters will be used and whether they can provide accurate information about memory pressure. He also expressed doubts about the long-term maintainability of the scheme.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Wed 11-02-26 20:51:09, JP Kobryn wrote:
&gt; It would be useful to narrow down reclaim to specific nodes.
&gt; 
&gt; Provide per-node reclaim visibility by changing the pgscan and pgsteal
&gt; stats from global vm_event_item&#x27;s to node_stat_item&#x27;s. Note this change has
&gt; the side effect of now tracking these stats on a per-memcg basis.

The changelog could have been more clear about the actual changes as
this is not overly clear for untrained eyes. The most important parts
are that /proc/vmstat will preserve reclaim stats with slightly
different counters ordering (shouldn&#x27;t break userspace much^W), per-node
stats will be now newly displayed in /proc/zoneinfo - this is presumably
the primary motivation to have a better insight of per-node reclaim
activity, and memcg stats will now show their share of the global memory
reclaim.

Have I missed anything?

&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt; ---
&gt;  drivers/virtio/virtio_balloon.c |  8 ++++----
&gt;  include/linux/mmzone.h          | 12 +++++++++++
&gt;  include/linux/vm_event_item.h   | 12 -----------
&gt;  mm/memcontrol.c                 | 36 ++++++++++++++++++---------------
&gt;  mm/vmscan.c                     | 32 +++++++++++------------------
&gt;  mm/vmstat.c                     | 24 +++++++++++-----------
&gt;  6 files changed, 60 insertions(+), 64 deletions(-)
&gt; 
&gt; diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
&gt; index 74fe59f5a78c..1341d9d1a2a1 100644
&gt; --- a/drivers/virtio/virtio_balloon.c
&gt; +++ b/drivers/virtio/virtio_balloon.c
&gt; @@ -374,13 +374,13 @@ static inline unsigned int update_balloon_vm_stats(struct virtio_balloon *vb)
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ALLOC_STALL, stall);
&gt;  
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_SCAN,
&gt; -		    pages_to_bytes(events[PGSCAN_KSWAPD]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSCAN_KSWAPD)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_SCAN,
&gt; -		    pages_to_bytes(events[PGSCAN_DIRECT]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSCAN_DIRECT)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_ASYNC_RECLAIM,
&gt; -		    pages_to_bytes(events[PGSTEAL_KSWAPD]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSTEAL_KSWAPD)));
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_DIRECT_RECLAIM,
&gt; -		    pages_to_bytes(events[PGSTEAL_DIRECT]));
&gt; +		    pages_to_bytes(global_node_page_state(PGSTEAL_DIRECT)));
&gt;  
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	update_stat(vb, idx++, VIRTIO_BALLOON_S_HTLB_PGALLOC,
&gt; diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
&gt; index 762609d5f0af..fc39c107a4b5 100644
&gt; --- a/include/linux/mmzone.h
&gt; +++ b/include/linux/mmzone.h
&gt; @@ -255,6 +255,18 @@ enum node_stat_item {
&gt;  	PGDEMOTE_DIRECT,
&gt;  	PGDEMOTE_KHUGEPAGED,
&gt;  	PGDEMOTE_PROACTIVE,
&gt; +	PGSTEAL_KSWAPD,
&gt; +	PGSTEAL_DIRECT,
&gt; +	PGSTEAL_KHUGEPAGED,
&gt; +	PGSTEAL_PROACTIVE,
&gt; +	PGSTEAL_ANON,
&gt; +	PGSTEAL_FILE,
&gt; +	PGSCAN_KSWAPD,
&gt; +	PGSCAN_DIRECT,
&gt; +	PGSCAN_KHUGEPAGED,
&gt; +	PGSCAN_PROACTIVE,
&gt; +	PGSCAN_ANON,
&gt; +	PGSCAN_FILE,
&gt;  #ifdef CONFIG_NUMA
&gt;  	PGALLOC_MPOL_DEFAULT,
&gt;  	PGALLOC_MPOL_PREFERRED,
&gt; diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h
&gt; index 92f80b4d69a6..6f1787680658 100644
&gt; --- a/include/linux/vm_event_item.h
&gt; +++ b/include/linux/vm_event_item.h
&gt; @@ -40,19 +40,7 @@ enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
&gt;  		PGLAZYFREED,
&gt;  		PGREFILL,
&gt;  		PGREUSE,
&gt; -		PGSTEAL_KSWAPD,
&gt; -		PGSTEAL_DIRECT,
&gt; -		PGSTEAL_KHUGEPAGED,
&gt; -		PGSTEAL_PROACTIVE,
&gt; -		PGSCAN_KSWAPD,
&gt; -		PGSCAN_DIRECT,
&gt; -		PGSCAN_KHUGEPAGED,
&gt; -		PGSCAN_PROACTIVE,
&gt;  		PGSCAN_DIRECT_THROTTLE,
&gt; -		PGSCAN_ANON,
&gt; -		PGSCAN_FILE,
&gt; -		PGSTEAL_ANON,
&gt; -		PGSTEAL_FILE,
&gt;  #ifdef CONFIG_NUMA
&gt;  		PGSCAN_ZONE_RECLAIM_SUCCESS,
&gt;  		PGSCAN_ZONE_RECLAIM_FAILED,
&gt; diff --git a/mm/memcontrol.c b/mm/memcontrol.c
&gt; index 86f43b7e5f71..bde0b6536be6 100644
&gt; --- a/mm/memcontrol.c
&gt; +++ b/mm/memcontrol.c
&gt; @@ -328,6 +328,18 @@ static const unsigned int memcg_node_stat_items[] = {
&gt;  	PGDEMOTE_DIRECT,
&gt;  	PGDEMOTE_KHUGEPAGED,
&gt;  	PGDEMOTE_PROACTIVE,
&gt; +	PGSTEAL_KSWAPD,
&gt; +	PGSTEAL_DIRECT,
&gt; +	PGSTEAL_KHUGEPAGED,
&gt; +	PGSTEAL_PROACTIVE,
&gt; +	PGSTEAL_ANON,
&gt; +	PGSTEAL_FILE,
&gt; +	PGSCAN_KSWAPD,
&gt; +	PGSCAN_DIRECT,
&gt; +	PGSCAN_KHUGEPAGED,
&gt; +	PGSCAN_PROACTIVE,
&gt; +	PGSCAN_ANON,
&gt; +	PGSCAN_FILE,
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	NR_HUGETLB,
&gt;  #endif
&gt; @@ -441,14 +453,6 @@ static const unsigned int memcg_vm_event_stat[] = {
&gt;  #endif
&gt;  	PSWPIN,
&gt;  	PSWPOUT,
&gt; -	PGSCAN_KSWAPD,
&gt; -	PGSCAN_DIRECT,
&gt; -	PGSCAN_KHUGEPAGED,
&gt; -	PGSCAN_PROACTIVE,
&gt; -	PGSTEAL_KSWAPD,
&gt; -	PGSTEAL_DIRECT,
&gt; -	PGSTEAL_KHUGEPAGED,
&gt; -	PGSTEAL_PROACTIVE,
&gt;  	PGFAULT,
&gt;  	PGMAJFAULT,
&gt;  	PGREFILL,
&gt; @@ -1496,15 +1500,15 @@ static void memcg_stat_format(struct mem_cgroup *memcg, struct seq_buf *s)
&gt;  
&gt;  	/* Accumulated memory events */
&gt;  	seq_buf_printf(s, &quot;pgscan %lu\n&quot;,
&gt; -		       memcg_events(memcg, PGSCAN_KSWAPD) +
&gt; -		       memcg_events(memcg, PGSCAN_DIRECT) +
&gt; -		       memcg_events(memcg, PGSCAN_PROACTIVE) +
&gt; -		       memcg_events(memcg, PGSCAN_KHUGEPAGED));
&gt; +		       memcg_page_state(memcg, PGSCAN_KSWAPD) +
&gt; +		       memcg_page_state(memcg, PGSCAN_DIRECT) +
&gt; +		       memcg_page_state(memcg, PGSCAN_PROACTIVE) +
&gt; +		       memcg_page_state(memcg, PGSCAN_KHUGEPAGED));
&gt;  	seq_buf_printf(s, &quot;pgsteal %lu\n&quot;,
&gt; -		       memcg_events(memcg, PGSTEAL_KSWAPD) +
&gt; -		       memcg_events(memcg, PGSTEAL_DIRECT) +
&gt; -		       memcg_events(memcg, PGSTEAL_PROACTIVE) +
&gt; -		       memcg_events(memcg, PGSTEAL_KHUGEPAGED));
&gt; +		       memcg_page_state(memcg, PGSTEAL_KSWAPD) +
&gt; +		       memcg_page_state(memcg, PGSTEAL_DIRECT) +
&gt; +		       memcg_page_state(memcg, PGSTEAL_PROACTIVE) +
&gt; +		       memcg_page_state(memcg, PGSTEAL_KHUGEPAGED));
&gt;  
&gt;  	for (i = 0; i &lt; ARRAY_SIZE(memcg_vm_event_stat); i++) {
&gt;  #ifdef CONFIG_MEMCG_V1
&gt; diff --git a/mm/vmscan.c b/mm/vmscan.c
&gt; index 614ccf39fe3f..16a0f21e3ea1 100644
&gt; --- a/mm/vmscan.c
&gt; +++ b/mm/vmscan.c
&gt; @@ -1977,7 +1977,7 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  	unsigned long nr_taken;
&gt;  	struct reclaim_stat stat;
&gt;  	bool file = is_file_lru(lru);
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	struct pglist_data *pgdat = lruvec_pgdat(lruvec);
&gt;  	bool stalled = false;
&gt;  
&gt; @@ -2003,10 +2003,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  
&gt;  	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, nr_taken);
&gt;  	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, nr_scanned);
&gt; -	count_memcg_events(lruvec_memcg(lruvec), item, nr_scanned);
&gt; -	__count_vm_events(PGSCAN_ANON + file, nr_scanned);
&gt; +	mod_lruvec_state(lruvec, item, nr_scanned);
&gt; +	mod_lruvec_state(lruvec, PGSCAN_ANON + file, nr_scanned);
&gt;  
&gt;  	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
&gt;  
&gt; @@ -2023,10 +2021,8 @@ static unsigned long shrink_inactive_list(unsigned long nr_to_scan,
&gt;  					stat.nr_demoted);
&gt;  	__mod_node_page_state(pgdat, NR_ISOLATED_ANON + file, -nr_taken);
&gt;  	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, nr_reclaimed);
&gt; -	count_memcg_events(lruvec_memcg(lruvec), item, nr_reclaimed);
&gt; -	__count_vm_events(PGSTEAL_ANON + file, nr_reclaimed);
&gt; +	mod_lruvec_state(lruvec, item, nr_reclaimed);
&gt; +	mod_lruvec_state(lruvec, PGSTEAL_ANON + file, nr_reclaimed);
&gt;  
&gt;  	lru_note_cost_unlock_irq(lruvec, file, stat.nr_pageout,
&gt;  					nr_scanned - nr_reclaimed);
&gt; @@ -4536,7 +4532,7 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  {
&gt;  	int i;
&gt;  	int gen;
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	int sorted = 0;
&gt;  	int scanned = 0;
&gt;  	int isolated = 0;
&gt; @@ -4595,13 +4591,11 @@ static int scan_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  	}
&gt;  
&gt;  	item = PGSCAN_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc)) {
&gt; -		__count_vm_events(item, isolated);
&gt; +	if (!cgroup_reclaim(sc))
&gt;  		__count_vm_events(PGREFILL, sorted);
&gt; -	}
&gt; -	count_memcg_events(memcg, item, isolated);
&gt; +	mod_lruvec_state(lruvec, item, isolated);
&gt;  	count_memcg_events(memcg, PGREFILL, sorted);
&gt; -	__count_vm_events(PGSCAN_ANON + type, isolated);
&gt; +	mod_lruvec_state(lruvec, PGSCAN_ANON + type, isolated);
&gt;  	trace_mm_vmscan_lru_isolate(sc-&gt;reclaim_idx, sc-&gt;order, scan_batch,
&gt;  				scanned, skipped, isolated,
&gt;  				type ? LRU_INACTIVE_FILE : LRU_INACTIVE_ANON);
&gt; @@ -4686,7 +4680,7 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  	LIST_HEAD(clean);
&gt;  	struct folio *folio;
&gt;  	struct folio *next;
&gt; -	enum vm_event_item item;
&gt; +	enum node_stat_item item;
&gt;  	struct reclaim_stat stat;
&gt;  	struct lru_gen_mm_walk *walk;
&gt;  	bool skip_retry = false;
&gt; @@ -4750,10 +4744,8 @@ static int evict_folios(unsigned long nr_to_scan, struct lruvec *lruvec,
&gt;  					stat.nr_demoted);
&gt;  
&gt;  	item = PGSTEAL_KSWAPD + reclaimer_offset(sc);
&gt; -	if (!cgroup_reclaim(sc))
&gt; -		__count_vm_events(item, reclaimed);
&gt; -	count_memcg_events(memcg, item, reclaimed);
&gt; -	__count_vm_events(PGSTEAL_ANON + type, reclaimed);
&gt; +	mod_lruvec_state(lruvec, item, reclaimed);
&gt; +	mod_lruvec_state(lruvec, PGSTEAL_ANON + type, reclaimed);
&gt;  
&gt;  	spin_unlock_irq(&amp;lruvec-&gt;lru_lock);
&gt;  
&gt; diff --git a/mm/vmstat.c b/mm/vmstat.c
&gt; index 74e0ddde1e93..e4b259989d58 100644
&gt; --- a/mm/vmstat.c
&gt; +++ b/mm/vmstat.c
&gt; @@ -1291,6 +1291,18 @@ const char * const vmstat_text[] = {
&gt;  	[I(PGDEMOTE_DIRECT)]			= &quot;pgdemote_direct&quot;,
&gt;  	[I(PGDEMOTE_KHUGEPAGED)]		= &quot;pgdemote_khugepaged&quot;,
&gt;  	[I(PGDEMOTE_PROACTIVE)]			= &quot;pgdemote_proactive&quot;,
&gt; +	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
&gt; +	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
&gt; +	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
&gt; +	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
&gt; +	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
&gt; +	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
&gt; +	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
&gt; +	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
&gt; +	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
&gt; +	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
&gt; +	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
&gt; +	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
&gt;  #ifdef CONFIG_NUMA
&gt;  	[I(PGALLOC_MPOL_DEFAULT)]		= &quot;pgalloc_mpol_default&quot;,
&gt;  	[I(PGALLOC_MPOL_PREFERRED)]		= &quot;pgalloc_mpol_preferred&quot;,
&gt; @@ -1344,19 +1356,7 @@ const char * const vmstat_text[] = {
&gt;  
&gt;  	[I(PGREFILL)]				= &quot;pgrefill&quot;,
&gt;  	[I(PGREUSE)]				= &quot;pgreuse&quot;,
&gt; -	[I(PGSTEAL_KSWAPD)]			= &quot;pgsteal_kswapd&quot;,
&gt; -	[I(PGSTEAL_DIRECT)]			= &quot;pgsteal_direct&quot;,
&gt; -	[I(PGSTEAL_KHUGEPAGED)]			= &quot;pgsteal_khugepaged&quot;,
&gt; -	[I(PGSTEAL_PROACTIVE)]			= &quot;pgsteal_proactive&quot;,
&gt; -	[I(PGSCAN_KSWAPD)]			= &quot;pgscan_kswapd&quot;,
&gt; -	[I(PGSCAN_DIRECT)]			= &quot;pgscan_direct&quot;,
&gt; -	[I(PGSCAN_KHUGEPAGED)]			= &quot;pgscan_khugepaged&quot;,
&gt; -	[I(PGSCAN_PROACTIVE)]			= &quot;pgscan_proactive&quot;,
&gt;  	[I(PGSCAN_DIRECT_THROTTLE)]		= &quot;pgscan_direct_throttle&quot;,
&gt; -	[I(PGSCAN_ANON)]			= &quot;pgscan_anon&quot;,
&gt; -	[I(PGSCAN_FILE)]			= &quot;pgscan_file&quot;,
&gt; -	[I(PGSTEAL_ANON)]			= &quot;pgsteal_anon&quot;,
&gt; -	[I(PGSTEAL_FILE)]			= &quot;pgsteal_file&quot;,
&gt;  
&gt;  #ifdef CONFIG_NUMA
&gt;  	[I(PGSCAN_ZONE_RECLAIM_SUCCESS)]	= &quot;zone_reclaim_success&quot;,
&gt; -- 
&gt; 2.47.3
&gt; 

-- 
Michal Hocko
SUSE Labs


---

On Wed 11-02-26 20:51:08, JP Kobryn wrote:
&gt; It would be useful to see a breakdown of allocations to understand which
&gt; NUMA policies are driving them. For example, when investigating memory
&gt; pressure, having policy-specific counts could show that allocations were
&gt; bound to the affected node (via MPOL_BIND).
&gt; 
&gt; Add per-policy page allocation counters as new node stat items. These
&gt; counters can provide correlation between a mempolicy and pressure on a
&gt; given node.

Could you be more specific how exactly do you plan to use those
counters?

-- 
Michal Hocko
SUSE Labs


---

On Thu 12-02-26 13:22:56, JP Kobryn wrote:
&gt; On 2/11/26 11:29 PM, Michal Hocko wrote:
&gt; &gt; On Wed 11-02-26 20:51:08, JP Kobryn wrote:
&gt; &gt; &gt; It would be useful to see a breakdown of allocations to understand which
&gt; &gt; &gt; NUMA policies are driving them. For example, when investigating memory
&gt; &gt; &gt; pressure, having policy-specific counts could show that allocations were
&gt; &gt; &gt; bound to the affected node (via MPOL_BIND).
&gt; &gt; &gt; 
&gt; &gt; &gt; Add per-policy page allocation counters as new node stat items. These
&gt; &gt; &gt; counters can provide correlation between a mempolicy and pressure on a
&gt; &gt; &gt; given node.
&gt; &gt; 
&gt; &gt; Could you be more specific how exactly do you plan to use those
&gt; &gt; counters?
&gt; 
&gt; Yes. Patch 2 allows us to find which nodes are undergoing reclaim. Once
&gt; we identify the affected node(s), the new mpol counters (this patch)
&gt; allow us correlate the pressure to the mempolicy driving it.

I would appreciate somehow more specificity. You are adding counters
that are not really easy to drop once they are in. Sure we have
precedence of dropping some counters in the past so this is not as hard
as usual userspace APIs but still...

How exactly do you tolerate mempolicy allocations to specific nodes?
While MPOL_MBIND is quite straightforward others are less so.
-- 
Michal Hocko
SUSE Labs


---

On Mon 16-02-26 09:50:26, JP Kobryn (Meta) wrote:
&gt; On 2/16/26 12:26 AM, Michal Hocko wrote:
&gt; &gt; On Thu 12-02-26 13:22:56, JP Kobryn wrote:
&gt; &gt; &gt; On 2/11/26 11:29 PM, Michal Hocko wrote:
&gt; &gt; &gt; &gt; On Wed 11-02-26 20:51:08, JP Kobryn wrote:
&gt; &gt; &gt; &gt; &gt; It would be useful to see a breakdown of allocations to understand which
&gt; &gt; &gt; &gt; &gt; NUMA policies are driving them. For example, when investigating memory
&gt; &gt; &gt; &gt; &gt; pressure, having policy-specific counts could show that allocations were
&gt; &gt; &gt; &gt; &gt; bound to the affected node (via MPOL_BIND).
&gt; &gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; &gt; Add per-policy page allocation counters as new node stat items. These
&gt; &gt; &gt; &gt; &gt; counters can provide correlation between a mempolicy and pressure on a
&gt; &gt; &gt; &gt; &gt; given node.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; Could you be more specific how exactly do you plan to use those
&gt; &gt; &gt; &gt; counters?
&gt; &gt; &gt; 
&gt; &gt; &gt; Yes. Patch 2 allows us to find which nodes are undergoing reclaim. Once
&gt; &gt; &gt; we identify the affected node(s), the new mpol counters (this patch)
&gt; &gt; &gt; allow us correlate the pressure to the mempolicy driving it.
&gt; &gt; 
&gt; &gt; I would appreciate somehow more specificity. You are adding counters
&gt; &gt; that are not really easy to drop once they are in. Sure we have
&gt; &gt; precedence of dropping some counters in the past so this is not as hard
&gt; &gt; as usual userspace APIs but still...
&gt; &gt; 
&gt; &gt; How exactly do you tolerate mempolicy allocations to specific nodes?
&gt; &gt; While MPOL_MBIND is quite straightforward others are less so.
&gt; 
&gt; The design does account for this regardless of the policy. In the call
&gt; to __mod_node_page_state(), I&#x27;m using page_pgdat(page) so the stat is
&gt; attributed to the node where the page actually landed.

That much is clear[*]. The consumer side of things is not really clear to
me. How do you know which policy or part of the nodemask of that policy
is the source of the memory pressure on a particular node? In other
words how much is the data actually useful except for a single node
mempolicy (i.e. MBIND).

[*] btw. I believe you misaccount MPOL_LOCAL because you attribute the
target node even when the allocation is from a remote node from the
&quot;local&quot; POV.
-- 
Michal Hocko
SUSE Labs


---

On Mon 16-02-26 23:48:42, JP Kobryn (Meta) wrote:
&gt; On 2/16/26 1:07 PM, Michal Hocko wrote:
[...]
&gt; &gt; [*] btw. I believe you misaccount MPOL_LOCAL because you attribute the
&gt; &gt; target node even when the allocation is from a remote node from the
&gt; &gt; &quot;local&quot; POV.
&gt; 
&gt; It&#x27;s a good point. The accounting as a result of fallback cases
&gt; shouldn&#x27;t detract from an investigation though. We&#x27;re interested in the
&gt; node(s) under pressure so the relatively few fallback allocations would
&gt; land on nodes that are not under pressure and could be viewed as
&gt; acceptable noise.

This is really confusing. You simply have no means to tell the
difference between the requested node and the real node used so you
cannot really say whether the memory pressure is because of fallbacks or
your mempolicy configurations. That means that you cannot tell the
difference between the source of the pressure and victim of that
pressure. 

I am not saying these scheme doesn&#x27;t work in your particular setup but I
do not see this is long term maintainable thing. It is just too easy to
get misleading numbers. If we want/need to track mempolicy allocations
better than what existing numa_* counters offer then this needs to be
thought through I believe.

I do not think we should add these counters in this form. 
-- 
Michal Hocko
SUSE Labs


---

On Tue 17-02-26 10:19:08, JP Kobryn (Meta) wrote:
&gt; On 2/17/26 4:37 AM, Michal Hocko wrote:
&gt; &gt; On Mon 16-02-26 23:48:42, JP Kobryn (Meta) wrote:
&gt; &gt; &gt; On 2/16/26 1:07 PM, Michal Hocko wrote:
&gt; &gt; [...]
&gt; &gt; &gt; &gt; [*] btw. I believe you misaccount MPOL_LOCAL because you attribute the
&gt; &gt; &gt; &gt; target node even when the allocation is from a remote node from the
&gt; &gt; &gt; &gt; &quot;local&quot; POV.
&gt; &gt; &gt; 
&gt; &gt; &gt; It&#x27;s a good point. The accounting as a result of fallback cases
&gt; &gt; &gt; shouldn&#x27;t detract from an investigation though. We&#x27;re interested in the
&gt; &gt; &gt; node(s) under pressure so the relatively few fallback allocations would
&gt; &gt; &gt; land on nodes that are not under pressure and could be viewed as
&gt; &gt; &gt; acceptable noise.
&gt; &gt; 
&gt; &gt; This is really confusing. You simply have no means to tell the
&gt; &gt; difference between the requested node and the real node used so you
&gt; &gt; cannot really say whether the memory pressure is because of fallbacks or
&gt; &gt; your mempolicy configurations. That means that you cannot tell the
&gt; &gt; difference between the source of the pressure and victim of that
&gt; &gt; pressure.
&gt; 
&gt; What if I excluded the fallback cases? I could get the actual node from
&gt; the allocated page and compare against the requested node or node mask.

I think it would make sense to send the per-node reclaim stats
separately as there doesn&#x27;t seem to be any dispute about that.

For mempolicy stats try to define semantic for each mempolicy first.
What exactly do you miss from existing numa_*?
Do you want to count number of requests/successes. Do you want to track
failures? In what kind of granularity (track fallback nodes)?

-- 
Michal Hocko
SUSE Labs
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, doubts about maintainability</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shakeel Butt requested changes to use mod_node_page_state() instead of __mod_node_page_state(), citing preempt disable or IRQ disable requirements.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Wed, Feb 11, 2026 at 08:51:08PM -0800, JP Kobryn wrote:
&gt; It would be useful to see a breakdown of allocations to understand which
&gt; NUMA policies are driving them. For example, when investigating memory
&gt; pressure, having policy-specific counts could show that allocations were
&gt; bound to the affected node (via MPOL_BIND).
&gt; 
&gt; Add per-policy page allocation counters as new node stat items. These
&gt; counters can provide correlation between a mempolicy and pressure on a
&gt; given node.
&gt; 
&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;

[...]

&gt;  int mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)
&gt;  {
&gt;  	struct weighted_interleave_state *new_wi_state, *old_wi_state = NULL;
&gt; @@ -2446,8 +2461,14 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
&gt;  
&gt;  	nodemask = policy_nodemask(gfp, pol, ilx, &amp;nid);
&gt;  
&gt; -	if (pol-&gt;mode == MPOL_PREFERRED_MANY)
&gt; -		return alloc_pages_preferred_many(gfp, order, nid, nodemask);
&gt; +	if (pol-&gt;mode == MPOL_PREFERRED_MANY) {
&gt; +		page = alloc_pages_preferred_many(gfp, order, nid, nodemask);
&gt; +		if (page)
&gt; +			__mod_node_page_state(page_pgdat(page),
&gt; +					mpol_node_stat(MPOL_PREFERRED_MANY), 1 &lt;&lt; order);

Here and two places below, please use mod_node_page_state() instead of
__mod_node_page_state() as __foo() requires preempt disable or if the
given stat can be updated in IRQ, then IRQ disable. This code path does
not do either of that.

&gt; +
&gt; +		return page;
&gt; +	}
&gt;  
&gt;  	if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp;
&gt;  	    /* filter &quot;hugepage&quot; allocation, unless from alloc_pages() */
&gt; @@ -2472,6 +2493,9 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
&gt;  			page = __alloc_frozen_pages_noprof(
&gt;  				gfp | __GFP_THISNODE | __GFP_NORETRY, order,
&gt;  				nid, NULL);
&gt; +			if (page)
&gt; +				__mod_node_page_state(page_pgdat(page),
&gt; +						mpol_node_stat(pol-&gt;mode), 1 &lt;&lt; order);
&gt;  			if (page || !(gfp &amp; __GFP_DIRECT_RECLAIM))
&gt;  				return page;
&gt;  			/*
&gt; @@ -2484,6 +2508,8 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
&gt;  	}
&gt;  
&gt;  	page = __alloc_frozen_pages_noprof(gfp, order, nid, nodemask);
&gt; +	if (page)
&gt; +		__mod_node_page_state(page_pgdat(page), mpol_node_stat(pol-&gt;mode), 1 &lt;&lt; order);
&gt;  
</pre>
</details>
<div class="review-comment-signals">Signals: requested_changes</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Vlastimil Babka</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Vlastimil Babka raised concerns about the level of detail in the numa counters, suggesting they might be too exhaustive and proposing to limit them to only what is known to be useful.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 2/12/26 05:51, JP Kobryn wrote:
&gt; It would be useful to see a breakdown of allocations to understand which
&gt; NUMA policies are driving them. For example, when investigating memory
&gt; pressure, having policy-specific counts could show that allocations were
&gt; bound to the affected node (via MPOL_BIND).
&gt; 
&gt; Add per-policy page allocation counters as new node stat items. These
&gt; counters can provide correlation between a mempolicy and pressure on a
&gt; given node.
&gt; 
&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;

Are the numa_{hit,miss,etc.} counters insufficient? Could they be extended
in a way that would capture any missing important details? A counter per
policy type seems exhaustive, but then on one hand it might be not important
to distinguish beetween some of them, and on the other hand it doesn&#x27;t track
the nodemask anyway.

&gt; ---
&gt;  include/linux/mmzone.h |  9 +++++++++
&gt;  mm/mempolicy.c         | 30 ++++++++++++++++++++++++++++--
&gt;  mm/vmstat.c            |  9 +++++++++
&gt;  3 files changed, 46 insertions(+), 2 deletions(-)
&gt; 
&gt; diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
&gt; index fc5d6c88d2f0..762609d5f0af 100644
&gt; --- a/include/linux/mmzone.h
&gt; +++ b/include/linux/mmzone.h
&gt; @@ -255,6 +255,15 @@ enum node_stat_item {
&gt;  	PGDEMOTE_DIRECT,
&gt;  	PGDEMOTE_KHUGEPAGED,
&gt;  	PGDEMOTE_PROACTIVE,
&gt; +#ifdef CONFIG_NUMA
&gt; +	PGALLOC_MPOL_DEFAULT,
&gt; +	PGALLOC_MPOL_PREFERRED,
&gt; +	PGALLOC_MPOL_BIND,
&gt; +	PGALLOC_MPOL_INTERLEAVE,
&gt; +	PGALLOC_MPOL_LOCAL,
&gt; +	PGALLOC_MPOL_PREFERRED_MANY,
&gt; +	PGALLOC_MPOL_WEIGHTED_INTERLEAVE,
&gt; +#endif
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	NR_HUGETLB,
&gt;  #endif
&gt; diff --git a/mm/mempolicy.c b/mm/mempolicy.c
&gt; index 68a98ba57882..3c64784af761 100644
&gt; --- a/mm/mempolicy.c
&gt; +++ b/mm/mempolicy.c
&gt; @@ -217,6 +217,21 @@ static void reduce_interleave_weights(unsigned int *bw, u8 *new_iw)
&gt;  		new_iw[nid] /= iw_gcd;
&gt;  }
&gt;  
&gt; +#define CHECK_MPOL_NODE_STAT_OFFSET(mpol) \
&gt; +	BUILD_BUG_ON(PGALLOC_##mpol - mpol != PGALLOC_MPOL_DEFAULT)
&gt; +
&gt; +static enum node_stat_item mpol_node_stat(unsigned short mode)
&gt; +{
&gt; +	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_PREFERRED);
&gt; +	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_BIND);
&gt; +	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_INTERLEAVE);
&gt; +	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_LOCAL);
&gt; +	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_PREFERRED_MANY);
&gt; +	CHECK_MPOL_NODE_STAT_OFFSET(MPOL_WEIGHTED_INTERLEAVE);
&gt; +
&gt; +	return PGALLOC_MPOL_DEFAULT + mode;
&gt; +}
&gt; +
&gt;  int mempolicy_set_node_perf(unsigned int node, struct access_coordinate *coords)
&gt;  {
&gt;  	struct weighted_interleave_state *new_wi_state, *old_wi_state = NULL;
&gt; @@ -2446,8 +2461,14 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
&gt;  
&gt;  	nodemask = policy_nodemask(gfp, pol, ilx, &amp;nid);
&gt;  
&gt; -	if (pol-&gt;mode == MPOL_PREFERRED_MANY)
&gt; -		return alloc_pages_preferred_many(gfp, order, nid, nodemask);
&gt; +	if (pol-&gt;mode == MPOL_PREFERRED_MANY) {
&gt; +		page = alloc_pages_preferred_many(gfp, order, nid, nodemask);
&gt; +		if (page)
&gt; +			__mod_node_page_state(page_pgdat(page),
&gt; +					mpol_node_stat(MPOL_PREFERRED_MANY), 1 &lt;&lt; order);
&gt; +
&gt; +		return page;
&gt; +	}
&gt;  
&gt;  	if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp;
&gt;  	    /* filter &quot;hugepage&quot; allocation, unless from alloc_pages() */
&gt; @@ -2472,6 +2493,9 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
&gt;  			page = __alloc_frozen_pages_noprof(
&gt;  				gfp | __GFP_THISNODE | __GFP_NORETRY, order,
&gt;  				nid, NULL);
&gt; +			if (page)
&gt; +				__mod_node_page_state(page_pgdat(page),
&gt; +						mpol_node_stat(pol-&gt;mode), 1 &lt;&lt; order);
&gt;  			if (page || !(gfp &amp; __GFP_DIRECT_RECLAIM))
&gt;  				return page;
&gt;  			/*
&gt; @@ -2484,6 +2508,8 @@ static struct page *alloc_pages_mpol(gfp_t gfp, unsigned int order,
&gt;  	}
&gt;  
&gt;  	page = __alloc_frozen_pages_noprof(gfp, order, nid, nodemask);
&gt; +	if (page)
&gt; +		__mod_node_page_state(page_pgdat(page), mpol_node_stat(pol-&gt;mode), 1 &lt;&lt; order);
&gt;  
&gt;  	if (unlikely(pol-&gt;mode == MPOL_INTERLEAVE ||
&gt;  		     pol-&gt;mode == MPOL_WEIGHTED_INTERLEAVE) &amp;&amp; page) {
&gt; diff --git a/mm/vmstat.c b/mm/vmstat.c
&gt; index 65de88cdf40e..74e0ddde1e93 100644
&gt; --- a/mm/vmstat.c
&gt; +++ b/mm/vmstat.c
&gt; @@ -1291,6 +1291,15 @@ const char * const vmstat_text[] = {
&gt;  	[I(PGDEMOTE_DIRECT)]			= &quot;pgdemote_direct&quot;,
&gt;  	[I(PGDEMOTE_KHUGEPAGED)]		= &quot;pgdemote_khugepaged&quot;,
&gt;  	[I(PGDEMOTE_PROACTIVE)]			= &quot;pgdemote_proactive&quot;,
&gt; +#ifdef CONFIG_NUMA
&gt; +	[I(PGALLOC_MPOL_DEFAULT)]		= &quot;pgalloc_mpol_default&quot;,
&gt; +	[I(PGALLOC_MPOL_PREFERRED)]		= &quot;pgalloc_mpol_preferred&quot;,
&gt; +	[I(PGALLOC_MPOL_BIND)]			= &quot;pgalloc_mpol_bind&quot;,
&gt; +	[I(PGALLOC_MPOL_INTERLEAVE)]		= &quot;pgalloc_mpol_interleave&quot;,
&gt; +	[I(PGALLOC_MPOL_LOCAL)]			= &quot;pgalloc_mpol_local&quot;,
&gt; +	[I(PGALLOC_MPOL_PREFERRED_MANY)]	= &quot;pgalloc_mpol_preferred_many&quot;,
&gt; +	[I(PGALLOC_MPOL_WEIGHTED_INTERLEAVE)]	= &quot;pgalloc_mpol_weighted_interleave&quot;,
&gt; +#endif
&gt;  #ifdef CONFIG_HUGETLB_PAGE
&gt;  	[I(NR_HUGETLB)]				= &quot;nr_hugetlb&quot;,
&gt;  #endif



---

On 2/12/26 22:25, JP Kobryn wrote:
&gt; On 2/12/26 7:24 AM, Vlastimil Babka wrote:
&gt;&gt; On 2/12/26 05:51, JP Kobryn wrote:
&gt;&gt;&gt; It would be useful to see a breakdown of allocations to understand which
&gt;&gt;&gt; NUMA policies are driving them. For example, when investigating memory
&gt;&gt;&gt; pressure, having policy-specific counts could show that allocations were
&gt;&gt;&gt; bound to the affected node (via MPOL_BIND).
&gt;&gt;&gt;
&gt;&gt;&gt; Add per-policy page allocation counters as new node stat items. These
&gt;&gt;&gt; counters can provide correlation between a mempolicy and pressure on a
&gt;&gt;&gt; given node.
&gt;&gt;&gt;
&gt;&gt;&gt; Signed-off-by: JP Kobryn &lt;inwardvessel@gmail.com&gt;
&gt;&gt;&gt; Suggested-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
&gt;&gt; 
&gt;&gt; Are the numa_{hit,miss,etc.} counters insufficient? Could they be extended
&gt;&gt; in a way that would capture any missing important details? A counter per
&gt;&gt; policy type seems exhaustive, but then on one hand it might be not important
&gt;&gt; to distinguish beetween some of them, and on the other hand it doesn&#x27;t track
&gt;&gt; the nodemask anyway.
&gt; 
&gt; The two patches of the series should complement each other. When
&gt; investigating memory pressure, we could identify the affected nodes
&gt; (patch 2). Then we can cross-reference the policy-specific stats to find
&gt; any correlation (this patch).
&gt; 
&gt; I think extending numa_* counters would call for more permutations to
&gt; account for the numa stat per policy. I think distinguishing between
&gt; MPOL_DEFAULT and MPOL_BIND is meaningful, for example. Am I

Are there other useful examples or would it be enough to add e.g. a
numa_bind counter to the numa_hit/miss/etc?
What I&#x27;m trying to say the level of detail you are trying to add to the
always-on counters seems like more suitable for tracepoints. The counters
should be limited to what&#x27;s known to be useful and not &quot;everything we are
able to track and possibly could need one day&quot;.

&gt; understanding your question?

</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, suggested alternative approach</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">syzbot ci</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="review-tag-badge">Tested-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, syzbot ci, reported a WARNING in the kernel due to an issue in __mod_node_page_state() when testing the patch series. The warning was triggered by a test case and is not a direct objection to the code changes.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">syzbot ci has tested the following series

[v1] improve per-node allocation and reclaim visibility
https://lore.kernel.org/all/20260212045109.255391-1-inwardvessel@gmail.com
* [PATCH 1/2] mm/mempolicy: track page allocations per mempolicy
* [PATCH 2/2] mm: move pgscan and pgsteal to node stats

and found the following issue:
WARNING in __mod_node_page_state

Full report is available here:
https://ci.syzbot.org/series/4ec12ede-3298-43a3-ab6b-79d47759672e

***

WARNING in __mod_node_page_state

tree:      mm-new
URL:       https://kernel.googlesource.com/pub/scm/linux/kernel/git/akpm/mm.git
base:      72a46cdd4ef13690beb8c5a2f6a2023fd7ef2eb4
arch:      amd64
compiler:  Debian clang version 21.1.8 (++20251221033036+2078da43e25a-1~exp1~20251221153213.50), Debian LLD 21.1.8
config:    https://ci.syzbot.org/builds/0f678e4c-a4ba-4f17-8ed7-8ae99e56a463/config

------------[ cut here ]------------
IS_ENABLED(CONFIG_PREEMPT_COUNT) &amp;&amp; __lockdep_enabled &amp;&amp; (preempt_count() == 0 &amp;&amp; this_cpu_read(hardirqs_enabled))
WARNING: mm/vmstat.c:396 at __mod_node_page_state+0x126/0x170, CPU#0: kthreadd/2
Modules linked in:
CPU: 0 UID: 0 PID: 2 Comm: kthreadd Not tainted syzkaller #0 PREEMPT(full) 
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
RIP: 0010:__mod_node_page_state+0x126/0x170
Code: 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc cc 48 89 df 4c 89 e6 44 89 fa e8 68 00 00 00 31 db eb cc 90 0f 0b 90 e9 3e ff ff ff 90 &lt;0f&gt; 0b 90 eb 80 48 c7 c7 e0 c6 64 8e 4c 89 f6 e8 66 3c d3 02 e9 28
RSP: 0000:ffffc900000773d0 EFLAGS: 00010202
RAX: 0000000000000001 RBX: 0000000000000001 RCX: 0000000000000000
RDX: 0000000000000001 RSI: 000000000000003d RDI: ffff88815fffb380
RBP: dffffc0000000000 R08: ffffffff8fef2977 R09: 1ffffffff1fde52e
R10: dffffc0000000000 R11: fffffbfff1fde52f R12: ffff88815fffb380
R13: ffffffff92f50f00 R14: 000000000000003d R15: 000000000000003d
FS:  0000000000000000(0000) GS:ffff88818e0f0000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: ffff88823ffff000 CR3: 000000000e346000 CR4: 00000000000006f0
Call Trace:
 &lt;TASK&gt;
 alloc_pages_mpol+0x407/0x740
 alloc_pages_noprof+0xa8/0x190
 get_free_pages_noprof+0xf/0x80
 __kasan_populate_vmalloc+0x38/0x1d0
 alloc_vmap_area+0xd21/0x1460
 __get_vm_area_node+0x1f8/0x300
 __vmalloc_node_range_noprof+0x372/0x1730
 __vmalloc_node_noprof+0xc2/0x100
 dup_task_struct+0x228/0x9a0
 copy_process+0x508/0x3980
 kernel_clone+0x248/0x870
 kernel_thread+0x13f/0x1b0
 kthreadd+0x4f9/0x6f0
 ret_from_fork+0x51b/0xa40
 ret_from_fork_asm+0x1a/0x30
 &lt;/TASK&gt;


***

If these findings have caused you to resend the series or submit a
separate fix, please add the following tag to your commit message:
  Tested-by: syzbot@syzkaller.appspotmail.com

---
This report is generated by a bot. It may contain errors.
syzbot ci engineers can be reached at syzkaller@googlegroups.com.
</pre>
</details>
<div class="review-comment-signals">Signals: WARNING, NEEDS_WORK</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">kernel robot</span>
<a class="date-chip" href="../2026-02-17_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-17">2026-02-17</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, kernel robot, pointed out a potential issue with the patch, citing a high number of failures in a boot test, specifically mentioning that RIP:__mod_node_page_state was hit 244 times.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">

Hello,

kernel test robot noticed &quot;RIP:__mod_node_page_state&quot; on:

commit: 4b5f69459c0988d3b292aceb74633e04eea84c7f (&quot;[PATCH 1/2] mm/mempolicy: track page allocations per mempolicy&quot;)
url: https://github.com/intel-lab-lkp/linux/commits/JP-Kobryn/mm-mempolicy-track-page-allocations-per-mempolicy/20260212-142941
base: https://git.kernel.org/cgit/linux/kernel/git/akpm/mm.git mm-everything
patch link: https://lore.kernel.org/all/20260212045109.255391-2-inwardvessel@gmail.com/
patch subject: [PATCH 1/2] mm/mempolicy: track page allocations per mempolicy

in testcase: boot

config: x86_64-randconfig-007-20250327
compiler: gcc-14
test machine: qemu-system-x86_64 -enable-kvm -cpu SandyBridge -smp 2 -m 32G

(please refer to attached dmesg/kmsg for entire log/backtrace)


+------------------------------------------------------------------+------------+------------+
|                                                                  | 5cbf93e36f | 4b5f69459c |
+------------------------------------------------------------------+------------+------------+
| boot_successes                                                   | 244        | 0          |
| boot_failures                                                    | 0          | 244        |
| RIP:__mod_node_page_state                                        | 0          | 244        |
| BUG:using__this_cpu_read()in_preemptible                         | 0          | 244        |
| BUG:using__this_cpu_write()in_preemptible[#]code:kthreadd        | 0          | 244        |
| BUG:using__this_cpu_write()in_preemptible[#]code:swapper         | 0          | 187        |
| BUG:using__this_cpu_write()in_preemptible[#]code:kdevtmpfs       | 0          | 79         |
| BUG:using__this_cpu_write()in_preemptible[#]code:kworker/u8      | 0          | 229        |
| BUG:using__this_cpu_write()in_preemptible[#]code:udevd           | 0          | 62         |
| BUG:using__this_cpu_write()in_preemptible[#]code:tail            | 0          | 21         |
| BUG:using__this_cpu_write()in_preemptible[#]code:syslogd         | 0          | 54         |
| BUG:using__this_cpu_write()in_preemptible[#]code:klogd           | 0          | 113        |
| BUG:using__this_cpu_write()in_preemptible[#]code:sleep           | 0          | 98         |
| BUG:using__this_cpu_write()in_preemptible[#]code:post-run        | 0          | 39         |
| BUG:using__this_cpu_write()in_preemptible[#]code:rsync           | 0          | 9          |
| BUG:using__this_cpu_write()in_preemptible[#]code:modprobe        | 0          | 6          |
| BUG:using__this_cpu_write()in_preemptible[#]code                 | 0          | 32         |
| BUG:using__this_cpu_write()in_preemptible[#]code:udevadm         | 0          | 78         |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd         | 0          | 39         |
| BUG:using__this_cpu_write()in_preemptible[#]code:(udev-worker)   | 0          | 53         |
| RIP:rep_movs_alternative                                         | 0          | 5          |
| BUG:using__this_cpu_write()in_preemptible[#]code:cat             | 0          | 7          |
| BUG:using__this_cpu_write()in_preemptible[#]code:sed             | 0          | 98         |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-udevd   | 0          | 19         |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-journal | 0          | 54         |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-random  | 0          | 4          |
| BUG:using__this_cpu_write()in_preemptible[#]code:journalctl      | 0          | 8          |
| BUG:using__this_cpu_write()in_preemptible[#]code:start_getty     | 0          | 4          |
| RIP:__put_user_4                                                 | 0          | 24         |
| BUG:using__this_cpu_write()in_preemptible[#]code:wget            | 0          | 82         |
| BUG:using__this_cpu_write()in_preemptible[#]code:run-lkp         | 0          | 32         |
| BUG:using__this_cpu_write()in_preemptible[#]code:boot-#-yocto-i3 | 0          | 24         |
| BUG:using__this_cpu_write()in_preemptible[#]code:one-shot-monito | 0          | 4          |
| BUG:using__this_cpu_write()in_preemptible[#]code:vmstat          | 0          | 29         |
| BUG:using__this_cpu_write()in_preemptible[#]code:rs:main_Q:Reg   | 0          | 9          |
| RIP:rep_stos_alternative                                         | 0          | 11         |
| BUG:using__this_cpu_write()in_preemptible[#]code:lkp-setup-rootf | 0          | 21         |
| BUG:using__this_cpu_write()in_preemptible[#]code:stty            | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:tee             | 0          | 7          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-rc-loca | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:(exec-inner)    | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:groupadd        | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:(sd-exec-strv)  | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:rc              | 0          | 14         |
| BUG:using__this_cpu_write()in_preemptible[#]code:getty           | 0          | 18         |
| BUG:using__this_cpu_write()in_preemptible[#]code:boot-#-debian   | 0          | 4          |
| BUG:using__this_cpu_write()in_preemptible[#]code:monitor         | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-tmpfile | 0          | 6          |
| BUG:using__this_cpu_write()in_preemptible[#]code:lscpu           | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:dirname         | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-sysuser | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:(d-sysctl)      | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:mount           | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:ls              | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:pgrep           | 0          | 4          |
| BUG:using__this_cpu_write()in_preemptible[#]code:grep            | 0          | 8          |
| BUG:using__this_cpu_write()in_preemptible[#]code:S77lkp-bootstra | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:date            | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-sysctl  | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:find            | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:sshd            | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-system  | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-sysv-ge | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-hiberna | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:journal-offline | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:sysctl          | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:init            | 0          | 7          |
| BUG:using__this_cpu_write()in_preemptible[#]code:mkdir           | 0          | 6          |
| BUG:using__this_cpu_write()in_preemptible[#]code:mountpoint      | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-logind  | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:dmesg           | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-ssh-gen | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:cp              | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:wakeup          | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:dpkg-deb        | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:dpkg            | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:(modprobe)      | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:sync            | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-update  | 0          | 4          |
| BUG:using__this_cpu_write()in_preemptible[#]code:kmod            | 0          | 1          |
| RIP:strncpy_from_user                                            | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:sm-notify       | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-remount | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:blkmapd         | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:mkfifo          | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:ln              | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:sh              | 0          | 5          |
| BUG:using__this_cpu_write()in_preemptible[#]code:bootlogd        | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:run-test        | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:S07bootlogd     | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:hwclock.sh      | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:(sd-mkdcreds)   | 0          | 1          |
| RIP:filldir64                                                    | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:chmod           | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:ps              | 0          | 3          |
| BUG:using__this_cpu_write()in_preemptible[#]code:which           | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:ip              | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:start-stop-daem | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:S20syslog       | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-gpt-aut | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-debug-g | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:(rpcbind)       | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:seq             | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-run-gen | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:wait            | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:addgroup        | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:rm              | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:in:imklog       | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:basename        | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:touch           | 0          | 1          |
| RIP:ia32_setup_frame                                             | 0          | 2          |
| BUG:using__this_cpu_write()in_preemptible[#]code:no-stdout-monit | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:systemd-tpm#-ge | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:(mount)         | 0          | 1          |
| BUG:using__this_cpu_write()in_preemptible[#]code:ldconfig        | 0          | 1          |
+------------------------------------------------------------------+------------+------------+

If you fix the issue in a separate patch/commit (i.e. not just a new version of
the same patch/commit), kindly add following tags
| Reported-by: kernel test robot &lt;oliver.sang@intel.com&gt;
| Closes: https://lore.kernel.org/oe-lkp/202602181136.f66ba888-lkp@intel.com



[    0.624787][    T2] ------------[ cut here ]------------
[    0.625191][    T2] WARNING: mm/vmstat.c:396 at __mod_node_page_state+0x88/0x1c0, CPU#0: kthreadd/2
[    0.625887][    T2] Modules linked in:
[    0.626070][    T2] CPU: 0 UID: 0 PID: 2 Comm: kthreadd Tainted: G                T   6.19.0-rc6-00596-g4b5f69459c09 #1 PREEMPT(lazy)  a55f7fce8adbfb8e52612c1f0ea71f4db1a1df23
[    0.626084][    T2] Tainted: [T]=RANDSTRUCT
[    0.626402][    T2] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
[    0.627150][    T2] RIP: 0010:__mod_node_page_state (mm/vmstat.c:396 (discriminator 34))
[    0.627592][    T2] Code: 8b 05 88 b9 73 02 48 c7 c7 d8 b0 b4 83 85 c0 89 45 d0 40 0f 95 c6 31 c9 31 d2 40 0f b6 f6 e8 3f 96 e4 ff 8b 45 d0 85 c0 74 1b &lt;0f&gt; 0b be 01 00 00 00 eb 14 31 c9 31 d2 31 f6 48 c7 c7 d8 b0 b4 83
All code
========
   0:	8b 05 88 b9 73 02    	mov    0x273b988(%rip),%eax        # 0x273b98e
   6:	48 c7 c7 d8 b0 b4 83 	mov    $0xffffffff83b4b0d8,%rdi
   d:	85 c0                	test   %eax,%eax
   f:	89 45 d0             	mov    %eax,-0x30(%rbp)
  12:	40 0f 95 c6          	setne  %sil
  16:	31 c9                	xor    %ecx,%ecx
  18:	31 d2                	xor    %edx,%edx
  1a:	40 0f b6 f6          	movzbl %sil,%esi
  1e:	e8 3f 96 e4 ff       	call   0xffffffffffe49662
  23:	8b 45 d0             	mov    -0x30(%rbp),%eax
  26:	85 c0                	test   %eax,%eax
  28:	74 1b                	je     0x45
  2a:*	0f 0b                	ud2		&lt;-- trapping instruction
  2c:	be 01 00 00 00       	mov    $0x1,%esi
  31:	eb 14                	jmp    0x47
  33:	31 c9                	xor    %ecx,%ecx
  35:	31 d2                	xor    %edx,%edx
  37:	31 f6                	xor    %esi,%esi
  39:	48 c7 c7 d8 b0 b4 83 	mov    $0xffffffff83b4b0d8,%rdi

Code starting with the faulting instruction
===========================================
   0:	0f 0b                	ud2
   2:	be 01 00 00 00       	mov    $0x1,%esi
   7:	eb 14                	jmp    0x1d
   9:	31 c9                	xor    %ecx,%ecx
   b:	31 d2                	xor    %edx,%edx
   d:	31 f6                	xor    %esi,%esi
   f:	48 c7 c7 d8 b0 b4 83 	mov    $0xffffffff83b4b0d8,%rdi
[    0.629418][    T2] RSP: 0000:ffff88810039fa20 EFLAGS: 00010202
[    0.629869][    T2] RAX: 0000000000000001 RBX: 0000000000000002 RCX: 0000000000000000
[    0.630445][    T2] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
[    0.631089][    T2] RBP: ffff88810039fa50 R08: 0000000000000000 R09: 0000000000000000
[    0.631671][    T2] R10: 0000000000000000 R11: 0000000000000000 R12: ffff88883ffe02c0
[    0.632247][    T2] R13: ffffffff83f18971 R14: ffffffff83f18940 R15: 0000000000000030
[    0.632746][    T2] FS:  0000000000000000(0000) GS:ffff88889bd1c000(0000) knlGS:0000000000000000
[    0.633394][    T2] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    0.633875][    T2] CR2: ffff88883ffff000 CR3: 000000000343d000 CR4: 00000000000406b0
[    0.634478][    T2] Call Trace:
[    0.634723][    T2]  &lt;TASK&gt;
[    0.634951][    T2]  alloc_pages_mpol (mm/mempolicy.c:2513 (discriminator 1))
[    0.635326][    T2]  alloc_frozen_pages_noprof (mm/mempolicy.c:2584)
[    0.635746][    T2]  allocate_slab (mm/slub.c:3075 (discriminator 2) mm/slub.c:3248 (discriminator 2))
[    0.636086][    T2]  new_slab (mm/slub.c:3304)
[    0.636394][    T2]  ___slab_alloc (mm/slub.c:4657)
[    0.636749][    T2]  ? dup_task_struct (kernel/fork.c:184 (discriminator 2) kernel/fork.c:915 (discriminator 2))
[    0.637114][    T2]  __slab_alloc+0x8a/0x180
[    0.637519][    T2]  slab_alloc_node+0x189/0x340
[    0.637919][    T2]  ? dup_task_struct (kernel/fork.c:184 (discriminator 2) kernel/fork.c:915 (discriminator 2))
[    0.638285][    T2]  kmem_cache_alloc_node_noprof (mm/slub.c:5317 (discriminator 1))
[    0.638710][    T2]  dup_task_struct (kernel/fork.c:184 (discriminator 2) kernel/fork.c:915 (discriminator 2))
[    0.639058][    T2]  ? ftrace_likely_update (arch/x86/include/asm/smap.h:90 kernel/trace/trace_branch.c:223)
[    0.639416][    T2]  copy_process (kernel/fork.c:2052 (discriminator 1))
[    0.639773][    T2]  kernel_clone (include/linux/random.h:26 kernel/fork.c:2652)
[    0.640115][    T2]  ? kthread_fetch_affinity (kernel/kthread.c:412)
[    0.640552][    T2]  kernel_thread (kernel/fork.c:2713)
[    0.640892][    T2]  ? kthread_fetch_affinity (kernel/kthread.c:412)
[    0.641310][    T2]  kthreadd (kernel/kthread.c:486 kernel/kthread.c:844)
[    0.641621][    T2]  ? kthreadd (kernel/kthread.c:830 (discriminator 5))
[    0.641938][    T2]  ? kthread_is_per_cpu (kernel/kthread.c:816)
[    0.642316][    T2]  ret_from_fork (arch/x86/kernel/process.c:164)
[    0.642657][    T2]  ? kthread_is_per_cpu (kernel/kthread.c:816)
[    0.642744][    T2]  ? kthread_is_per_cpu (kernel/kthread.c:816)
[    0.643127][    T2]  ret_from_fork_asm (arch/x86/entry/entry_64.S:256)
[    0.643502][    T2]  &lt;/TASK&gt;
[    0.643755][    T2] irq event stamp: 393
[    0.644054][    T2] hardirqs last  enabled at (401): __up_console_sem (arch/x86/include/asm/irqflags.h:42 arch/x86/include/asm/irqflags.h:119 arch/x86/include/asm/irqflags.h:159 kernel/printk/printk.c:345)
[    0.644730][    T2] hardirqs last disabled at (408): __up_console_sem (kernel/printk/printk.c:343 (discriminator 3))
[    0.645406][    T2] softirqs last  enabled at (54): handle_softirqs (kernel/softirq.c:469 (discriminator 1) kernel/softirq.c:650 (discriminator 1))
[    0.646077][    T2] softirqs last disabled at (49): __irq_exit_rcu (kernel/softirq.c:657 kernel/softirq.c:496 kernel/softirq.c:723)
[    0.646741][    T2] ---[ end trace 0000000000000000 ]---


The kernel config and materials to reproduce are available at:
https://download.01.org/0day-ci/archive/20260218/202602181136.f66ba888-lkp@intel.com



-- 
0-DAY CI Kernel Test Service
https://github.com/intel/lkp-tests/wiki


</pre>
</details>
<div class="review-comment-signals">Signals: potential bug, high failure rate</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>