<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH 1/2] efi: Fix reservation of unaccepted memory table</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH 1/2] efi: Fix reservation of unaccepted memory table</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/aY9Mf8oZODGiDoXp@thinkstation/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-13">2026-02-13</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2026-02-13">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Kiryl (Meta) (author)</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer pointed out a potential issue in the patch where the reservation of unaccepted memory table might not cover the entire range if its start address is not page-aligned, which could lead to kernel panics.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The reserve_unaccepted() function incorrectly calculates the size of the
memblock reservation for the unaccepted memory table. It aligns the
size of the table, but fails to account for cases where the table&#x27;s
starting physical address (efi.unaccepted) is not page-aligned.

If the table starts at an offset within a page and its end crosses into
a subsequent page that the aligned size does not cover, the end of the
table will not be reserved. This can lead to the table being overwritten
or inaccessible, causing a kernel panic in accept_memory().

This issue was observed when starting Intel TDX VMs with specific memory
sizes (e.g., &gt; 64GB).

Fix this by calculating the end address first (including the unaligned
start) and then aligning it up, ensuring the entire range is covered
by the reservation.

Fixes: 8dbe33956d96 (&quot;efi/unaccepted: Make sure unaccepted table is mapped&quot;)
Reported-by: Moritz Sanft &lt;ms@edgeless.systems&gt;
Signed-off-by: Kiryl Shutsemau (Meta) &lt;kas@kernel.org&gt;
---
 drivers/firmware/efi/efi.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 111e87a618e5..56e9d73412fa 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,
 
 static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)
 {
-	phys_addr_t start, size;
+	phys_addr_t start, end;
 
 	start = PAGE_ALIGN_DOWN(efi.unaccepted);
-	size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted-&gt;size);
+	end = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted-&gt;size);
 
-	memblock_add(start, size);
-	memblock_reserve(start, size);
+	memblock_add(start, end - start);
+	memblock_reserve(start, end - start);
 }
 
 int __init efi_config_parse_tables(const efi_config_table_t *config_tables,
-- 
2.51.2



---

The accept_memory() and range_contains_unaccepted_memory() functions
employ a &quot;guard page&quot; logic to prevent crashes with load_unaligned_zeropad().
This logic extends the range to be accepted (or checked) by one unit_size
if the end of the range is aligned to a unit_size boundary.

However, if the caller passes a range that is not page-aligned, the
&#x27;end&#x27; of the range might not be numerically aligned to unit_size, even
if it covers the last page of a unit. This causes the &quot;if (!(end % unit_size))&quot;
check to fail, skipping the necessary extension and leaving the next
unit unaccepted, which can lead to a kernel panic when accessed by
load_unaligned_zeropad().

Align the start address down and the size up to the nearest page
boundary before performing the unit_size alignment check. This ensures
that the guard unit is correctly added when the range effectively ends
on a unit boundary.

Signed-off-by: Kiryl Shutsemau (Meta) &lt;kas@kernel.org&gt;
---
 drivers/firmware/efi/unaccepted_memory.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c
index c2c067eff634..9ddf3dedd514 100644
--- a/drivers/firmware/efi/unaccepted_memory.c
+++ b/drivers/firmware/efi/unaccepted_memory.c
@@ -35,14 +35,18 @@ void accept_memory(phys_addr_t start, unsigned long size)
 	struct efi_unaccepted_memory *unaccepted;
 	unsigned long range_start, range_end;
 	struct accept_range range, *entry;
-	phys_addr_t end = start + size;
 	unsigned long flags;
+	phys_addr_t end;
 	u64 unit_size;
 
 	unaccepted = efi_get_unaccepted_table();
 	if (!unaccepted)
 		return;
 
+	start = PAGE_ALIGN_DOWN(start);
+	size = PAGE_ALIGN(size);
+	end = start + size;
+
 	unit_size = unaccepted-&gt;unit_size;
 
 	/*
@@ -160,15 +164,19 @@ void accept_memory(phys_addr_t start, unsigned long size)
 bool range_contains_unaccepted_memory(phys_addr_t start, unsigned long size)
 {
 	struct efi_unaccepted_memory *unaccepted;
-	phys_addr_t end = start + size;
 	unsigned long flags;
 	bool ret = false;
+	phys_addr_t end;
 	u64 unit_size;
 
 	unaccepted = efi_get_unaccepted_table();
 	if (!unaccepted)
 		return false;
 
+	start = PAGE_ALIGN_DOWN(start);
+	size = PAGE_ALIGN(size);
+	end = start + size;
+
 	unit_size = unaccepted-&gt;unit_size;
 
 	/*
-- 
2.51.2



---

On Fri, Feb 13, 2026 at 08:01:55AM -0800, Dave Hansen wrote:
&gt; On 2/13/26 07:48, Kiryl Shutsemau (Meta) wrote:
&gt; &gt;  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)
&gt; &gt;  {
&gt; &gt; -	phys_addr_t start, size;
&gt; &gt; +	phys_addr_t start, end;
&gt; &gt;  
&gt; &gt;  	start = PAGE_ALIGN_DOWN(efi.unaccepted);
&gt; 
&gt; Why are we even aligning the start? Isn&#x27;t *that* the bug?

How so? It is up to EFI how the table is allocated. We need to be sure
that this memory is mapped and not overwritten.

&gt; The memblock code seems to be able to handle arbitrary alignment just fine.

Memblock will track it, but, as the comment says, anything smaller than
page size will not be mapped, but we need the table to be accessible by
kernel.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov


---

On Fri, Feb 13, 2026 at 08:46:55AM -0800, Dave Hansen wrote:
&gt; On 2/13/26 08:14, Kiryl Shutsemau wrote:
&gt; &gt;&gt; The memblock code seems to be able to handle arbitrary alignment just fine.
&gt; &gt; Memblock will track it, but, as the comment says, anything smaller than
&gt; &gt; page size will not be mapped, but we need the table to be accessible by
&gt; &gt; kernel.
&gt; 
&gt; That seems really, really fragile.
&gt; 
&gt; We should first make sure this is intentional memblock behavior and not
&gt; a bug before we go add more hacks on top of it.
&gt; 
&gt; Why would you even present a byte-level reservation interface if it is
&gt; free to just silently ignore some of the ranges by rounding them off later?

+Mike.

My guess that multiple memblock_add() calls might add up to the full
page size.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov


---

On Sat, Feb 14, 2026 at 05:51:47PM +0200, Mike Rapoport wrote:
&gt; &gt; My guess that multiple memblock_add() calls might add up to the full
&gt; &gt; page size.
&gt; 
&gt; I&#x27;m not following here. Can you explain what do you mean?
&gt; 
&gt; Multiple memblock_add() calls to adjacent ranges will coalesce into one
&gt; larger range. But I don&#x27;t see how is that related.

I tried to find justification for the byte-level tracking by memblock.
Not in relation to this case, but in general.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov


---

On Mon, Feb 16, 2026 at 08:51:17AM -0600, Tom Lendacky wrote:
&gt; On 2/13/26 09:48, Kiryl Shutsemau (Meta) wrote:
&gt; &gt; The accept_memory() and range_contains_unaccepted_memory() functions
&gt; &gt; employ a &quot;guard page&quot; logic to prevent crashes with load_unaligned_zeropad().
&gt; &gt; This logic extends the range to be accepted (or checked) by one unit_size
&gt; &gt; if the end of the range is aligned to a unit_size boundary.
&gt; &gt; 
&gt; &gt; However, if the caller passes a range that is not page-aligned, the
&gt; &gt; &#x27;end&#x27; of the range might not be numerically aligned to unit_size, even
&gt; &gt; if it covers the last page of a unit. This causes the &quot;if (!(end % unit_size))&quot;
&gt; &gt; check to fail, skipping the necessary extension and leaving the next
&gt; &gt; unit unaccepted, which can lead to a kernel panic when accessed by
&gt; &gt; load_unaligned_zeropad().
&gt; &gt; 
&gt; &gt; Align the start address down and the size up to the nearest page
&gt; &gt; boundary before performing the unit_size alignment check. This ensures
&gt; &gt; that the guard unit is correctly added when the range effectively ends
&gt; &gt; on a unit boundary.
&gt; &gt; 
&gt; &gt; Signed-off-by: Kiryl Shutsemau (Meta) &lt;kas@kernel.org&gt;
&gt; &gt; ---
&gt; &gt;  drivers/firmware/efi/unaccepted_memory.c | 12 ++++++++++--
&gt; &gt;  1 file changed, 10 insertions(+), 2 deletions(-)
&gt; &gt; 
&gt; &gt; diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c
&gt; &gt; index c2c067eff634..9ddf3dedd514 100644
&gt; &gt; --- a/drivers/firmware/efi/unaccepted_memory.c
&gt; &gt; +++ b/drivers/firmware/efi/unaccepted_memory.c
&gt; &gt; @@ -35,14 +35,18 @@ void accept_memory(phys_addr_t start, unsigned long size)
&gt; &gt;  	struct efi_unaccepted_memory *unaccepted;
&gt; &gt;  	unsigned long range_start, range_end;
&gt; &gt;  	struct accept_range range, *entry;
&gt; &gt; -	phys_addr_t end = start + size;
&gt; &gt;  	unsigned long flags;
&gt; &gt; +	phys_addr_t end;
&gt; &gt;  	u64 unit_size;
&gt; &gt;  
&gt; &gt;  	unaccepted = efi_get_unaccepted_table();
&gt; &gt;  	if (!unaccepted)
&gt; &gt;  		return;
&gt; &gt;  
&gt; &gt; +	start = PAGE_ALIGN_DOWN(start);
&gt; &gt; +	size = PAGE_ALIGN(size);
&gt; &gt; +	end = start + size;
&gt; 
&gt; Should this really be:
&gt; 
&gt; 	end = PAGE_ALIGN(start + size);
&gt; 	start = PAGE_ALIGN_DOWN(start);
&gt; 
&gt; ?

Doh! Yes, you are right.

-- 
  Kiryl Shutsemau / Kirill A. Shutemov
</pre>
</details>
<div class="review-comment-signals">Signals: potential sources of kernel panics, fixes: 8dbe33956d96</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Dave Hansen</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Dave Hansen questioned the patch&#x27;s approach to aligning the start of unaccepted memory table reservation, suggesting that this might be the actual bug rather than a fix.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 2/13/26 07:48, Kiryl Shutsemau (Meta) wrote:
&gt;  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)
&gt;  {
&gt; -	phys_addr_t start, size;
&gt; +	phys_addr_t start, end;
&gt;  
&gt;  	start = PAGE_ALIGN_DOWN(efi.unaccepted);

Why are we even aligning the start? Isn&#x27;t *that* the bug?

The memblock code seems to be able to handle arbitrary alignment just fine.


---

On 2/13/26 08:14, Kiryl Shutsemau wrote:
&gt;&gt; The memblock code seems to be able to handle arbitrary alignment just fine.
&gt; Memblock will track it, but, as the comment says, anything smaller than
&gt; page size will not be mapped, but we need the table to be accessible by
&gt; kernel.

That seems really, really fragile.

We should first make sure this is intentional memblock behavior and not
a bug before we go add more hacks on top of it.

Why would you even present a byte-level reservation interface if it is
free to just silently ignore some of the ranges by rounding them off later?


---

On 2/14/26 07:51, Mike Rapoport wrote:
&gt; Heh, it&#x27;s x86&#x27;s choice of memblock iterator that&#x27;s rounding the ranges \U0001f609

Ahh, good point. I was just assuming that the memblock iteration _had_
to be over PFNs. Silly me.

&gt; Maybe I miss some context, but my understanding is that for crash kernels
&gt; the unaccepted table is E820_TYPE_RESERVED and those are never added to
&gt; memblock.memory by e820 code, hence the call to memblock_add() in
&gt; reserve_unaccepted().
&gt; 
&gt; When x86 creates page tables, init_range_memory_mapping() walks
&gt; memblock.memory with for_each_mem_pfn_range() that rounds ranges that are
&gt; not page-aligned, which is normally fine, because it would mean that we
&gt; miss some partial pages that are divided between E820_RAM and
&gt; E820_SOMETHING_ELSE.
&gt; 
&gt; And Kiryl&#x27;s intention to round up unaccepted to page boundary seems correct
&gt; to me.

It fixes the bug for sure.

I&#x27;m more worried about the next feature, or the existing features that
also only working because memory is page-aligned somewhere (even though
it isn&#x27;t guaranteed to remain that way).

There are two choices for fixing this: One, we do Kiryl&#x27;s fix plus
checks to ensure that all the memblocks that generate direct mappings
(is it _just_ the &quot;memory&quot; type?) are padded out to page-aligned boundaries.

The other alternative is to do for_each_mem_range() and do the padding
universally when creating the mappings. Maybe _also_ with warnings or
maybe a pr_debug().

I do still think it&#x27;s a little wonky for memblock_add()&#x27;s management of
the &quot;memory&quot; type to allow unaligned arguments when that type is also
used to create page-aligned mapping structures. Memblocks themselves
obviously need to be byte-level, but I&#x27;m not sure it&#x27;s the right thing
for the &quot;memory&quot; type API.
</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, technical concerns</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Mike Rapoport</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Mike Rapoport questioned the patch&#x27;s intention to round up unaccepted memory table to page boundary, suggesting it might not be necessary due to memblock iterator rounding ranges.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Fri, Feb 13, 2026 at 05:20:14PM +0000, Kiryl Shutsemau wrote:
&gt; On Fri, Feb 13, 2026 at 08:46:55AM -0800, Dave Hansen wrote:
&gt; &gt; On 2/13/26 08:14, Kiryl Shutsemau wrote:
&gt; &gt; &gt;&gt; The memblock code seems to be able to handle arbitrary alignment just fine.
&gt; &gt; &gt; Memblock will track it, but, as the comment says, anything smaller than
&gt; &gt; &gt; page size will not be mapped, but we need the table to be accessible by
&gt; &gt; &gt; kernel.
&gt; &gt; 
&gt; &gt; That seems really, really fragile.
&gt; &gt; 
&gt; &gt; We should first make sure this is intentional memblock behavior and not
&gt; &gt; a bug before we go add more hacks on top of it.
&gt; &gt; 
&gt; &gt; Why would you even present a byte-level reservation interface if it is
&gt; &gt; free to just silently ignore some of the ranges by rounding them off later?

Heh, it&#x27;s x86&#x27;s choice of memblock iterator that&#x27;s rounding the ranges ;)

Maybe I miss some context, but my understanding is that for crash kernels
the unaccepted table is E820_TYPE_RESERVED and those are never added to
memblock.memory by e820 code, hence the call to memblock_add() in
reserve_unaccepted().

When x86 creates page tables, init_range_memory_mapping() walks
memblock.memory with for_each_mem_pfn_range() that rounds ranges that are
not page-aligned, which is normally fine, because it would mean that we
miss some partial pages that are divided between E820_RAM and
E820_SOMETHING_ELSE.

And Kiryl&#x27;s intention to round up unaccepted to page boundary seems correct
to me.

&gt; My guess that multiple memblock_add() calls might add up to the full
&gt; page size.

I&#x27;m not following here. Can you explain what do you mean?

Multiple memblock_add() calls to adjacent ranges will coalesce into one
larger range. But I don&#x27;t see how is that related.

&gt; 
&gt; -- 
&gt;   Kiryl Shutsemau / Kirill A. Shutemov

-- 
Sincerely yours,
Mike.


---

On Mon, Feb 16, 2026 at 02:22:49PM +0000, Kiryl Shutsemau wrote:
&gt; On Sat, Feb 14, 2026 at 05:51:47PM +0200, Mike Rapoport wrote:
&gt; &gt; &gt; My guess that multiple memblock_add() calls might add up to the full
&gt; &gt; &gt; page size.
&gt; &gt; 
&gt; &gt; I&#x27;m not following here. Can you explain what do you mean?
&gt; &gt; 
&gt; &gt; Multiple memblock_add() calls to adjacent ranges will coalesce into one
&gt; &gt; larger range. But I don&#x27;t see how is that related.
&gt; 
&gt; I tried to find justification for the byte-level tracking by memblock.
&gt; Not in relation to this case, but in general.

Probably somewhere deep in git archaeology :)

I presume to not waste a page for every small allocation.
 
&gt; -- 
&gt;   Kiryl Shutsemau / Kirill A. Shutemov

-- 
Sincerely yours,
Mike.


---

On Mon, Feb 16, 2026 at 07:53:24AM -0800, Dave Hansen wrote:
&gt; On 2/14/26 07:51, Mike Rapoport wrote:
&gt; &gt; Heh, it&#x27;s x86&#x27;s choice of memblock iterator that&#x27;s rounding the ranges \U0001f609
&gt; 
&gt; Ahh, good point. I was just assuming that the memblock iteration _had_
&gt; to be over PFNs. Silly me.
&gt; 
&gt; &gt; Maybe I miss some context, but my understanding is that for crash kernels
&gt; &gt; the unaccepted table is E820_TYPE_RESERVED and those are never added to
&gt; &gt; memblock.memory by e820 code, hence the call to memblock_add() in
&gt; &gt; reserve_unaccepted().
&gt; &gt; 
&gt; &gt; When x86 creates page tables, init_range_memory_mapping() walks
&gt; &gt; memblock.memory with for_each_mem_pfn_range() that rounds ranges that are
&gt; &gt; not page-aligned, which is normally fine, because it would mean that we
&gt; &gt; miss some partial pages that are divided between E820_RAM and
&gt; &gt; E820_SOMETHING_ELSE.
&gt; &gt; 
&gt; &gt; And Kiryl&#x27;s intention to round up unaccepted to page boundary seems correct
&gt; &gt; to me.
&gt; 
&gt; It fixes the bug for sure.
&gt; 
&gt; I&#x27;m more worried about the next feature, or the existing features that
&gt; also only working because memory is page-aligned somewhere (even though
&gt; it isn&#x27;t guaranteed to remain that way).
&gt; 
&gt; There are two choices for fixing this: One, we do Kiryl&#x27;s fix plus
&gt; checks to ensure that all the memblocks that generate direct mappings
&gt; (is it _just_ the &quot;memory&quot; type?) are padded out to page-aligned boundaries.
&gt; 
&gt; The other alternative is to do for_each_mem_range() and do the padding
&gt; universally when creating the mappings. Maybe _also_ with warnings or
&gt; maybe a pr_debug().
&gt; 
&gt; I do still think it&#x27;s a little wonky for memblock_add()&#x27;s management of
&gt; the &quot;memory&quot; type to allow unaligned arguments when that type is also
&gt; used to create page-aligned mapping structures. Memblocks themselves
&gt; obviously need to be byte-level, but I&#x27;m not sure it&#x27;s the right thing
&gt; for the &quot;memory&quot; type API.

Well, we could make memblock_add() implicitly cut down the edges when it&#x27;s
adding to memblock.memory and make everything there page aligned, but I
truly have no idea what will break and I&#x27;m sure something will :)

Another thing that&#x27;s more on x86 side, is that translation from e820 to
memblock only adds E820_TYPE_RAM to memblock. And since in e820 these are
mutually exclusive with other e820 types, this could create non-aligned
chunks when firmware reservations are not page aligned. It also creates
unnecessary holes in memblock.memory that slow down memblock interation a
bit and more interestingly, everything that&#x27;s not in E820_TYPE_RAM is
treated as IO and requires ioremap/memremap for access, even it is in DRAM.

If these reserved regions were added to memblock.memory along with being
memblock_reserve()ed we wouldn&#x27;t hit the bug with unaccepted I believe some
others as well.

-- 
Sincerely yours,
Mike.

</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, clarification needed</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Tom Lendacky</span>
<a class="date-chip" href="../2026-02-13_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Tom Lendacky questioned the alignment calculation in the patch, suggesting a different approach.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On 2/13/26 09:48, Kiryl Shutsemau (Meta) wrote:
&gt; The accept_memory() and range_contains_unaccepted_memory() functions
&gt; employ a &quot;guard page&quot; logic to prevent crashes with load_unaligned_zeropad().
&gt; This logic extends the range to be accepted (or checked) by one unit_size
&gt; if the end of the range is aligned to a unit_size boundary.
&gt; 
&gt; However, if the caller passes a range that is not page-aligned, the
&gt; &#x27;end&#x27; of the range might not be numerically aligned to unit_size, even
&gt; if it covers the last page of a unit. This causes the &quot;if (!(end % unit_size))&quot;
&gt; check to fail, skipping the necessary extension and leaving the next
&gt; unit unaccepted, which can lead to a kernel panic when accessed by
&gt; load_unaligned_zeropad().
&gt; 
&gt; Align the start address down and the size up to the nearest page
&gt; boundary before performing the unit_size alignment check. This ensures
&gt; that the guard unit is correctly added when the range effectively ends
&gt; on a unit boundary.
&gt; 
&gt; Signed-off-by: Kiryl Shutsemau (Meta) &lt;kas@kernel.org&gt;
&gt; ---
&gt;  drivers/firmware/efi/unaccepted_memory.c | 12 ++++++++++--
&gt;  1 file changed, 10 insertions(+), 2 deletions(-)
&gt; 
&gt; diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c
&gt; index c2c067eff634..9ddf3dedd514 100644
&gt; --- a/drivers/firmware/efi/unaccepted_memory.c
&gt; +++ b/drivers/firmware/efi/unaccepted_memory.c
&gt; @@ -35,14 +35,18 @@ void accept_memory(phys_addr_t start, unsigned long size)
&gt;  	struct efi_unaccepted_memory *unaccepted;
&gt;  	unsigned long range_start, range_end;
&gt;  	struct accept_range range, *entry;
&gt; -	phys_addr_t end = start + size;
&gt;  	unsigned long flags;
&gt; +	phys_addr_t end;
&gt;  	u64 unit_size;
&gt;  
&gt;  	unaccepted = efi_get_unaccepted_table();
&gt;  	if (!unaccepted)
&gt;  		return;
&gt;  
&gt; +	start = PAGE_ALIGN_DOWN(start);
&gt; +	size = PAGE_ALIGN(size);
&gt; +	end = start + size;

Should this really be:

	end = PAGE_ALIGN(start + size);
	start = PAGE_ALIGN_DOWN(start);

?

Thanks,
Tom

&gt; +
&gt;  	unit_size = unaccepted-&gt;unit_size;
&gt;  
&gt;  	/*
&gt; @@ -160,15 +164,19 @@ void accept_memory(phys_addr_t start, unsigned long size)
&gt;  bool range_contains_unaccepted_memory(phys_addr_t start, unsigned long size)
&gt;  {
&gt;  	struct efi_unaccepted_memory *unaccepted;
&gt; -	phys_addr_t end = start + size;
&gt;  	unsigned long flags;
&gt;  	bool ret = false;
&gt; +	phys_addr_t end;
&gt;  	u64 unit_size;
&gt;  
&gt;  	unaccepted = efi_get_unaccepted_table();
&gt;  	if (!unaccepted)
&gt;  		return false;
&gt;  
&gt; +	start = PAGE_ALIGN_DOWN(start);
&gt; +	size = PAGE_ALIGN(size);
&gt; +	end = start + size;
&gt; +
&gt;  	unit_size = unaccepted-&gt;unit_size;
&gt;  
&gt;  	/*

</pre>
</details>
<div class="review-comment-signals">Signals: questioning code</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>