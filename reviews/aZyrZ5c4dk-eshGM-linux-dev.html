<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Review Comments: Re: [PATCH v7 1/3] tracing: Add __event_in_*irq() helpers</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                         "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        .home-link { margin-bottom: 12px; display: block; }
        .home-link a { color: #0366d6; text-decoration: none; font-size: 0.9em; }
        .home-link a:hover { text-decoration: underline; }

        h1 { font-size: 1.3em; margin-bottom: 2px; color: #1a1a1a; line-height: 1.3; }

        .lore-link { font-size: 0.85em; margin: 4px 0 6px; display: block; }
        .lore-link a { color: #0366d6; text-decoration: none; }
        .lore-link a:hover { text-decoration: underline; }

        .date-range {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 16px;
        }
        .date-range a { color: #0366d6; text-decoration: none; }
        .date-range a:hover { text-decoration: underline; }

        /* thread-node scroll margin so the card isn't clipped at the top */
        .thread-node { scroll-margin-top: 8px; }

        /* ── Patch summary ──────────────────────────────────────────── */
        .patch-summary-block {
            background: #fff;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 3px solid #4a90d9;
        }
        .patch-summary-label {
            font-size: 0.72em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: #4a90d9;
            margin-bottom: 4px;
        }
        .patch-summary-text {
            font-size: 0.88em;
            color: #444;
            line-height: 1.55;
        }

        /* ── Thread tree ────────────────────────────────────────────── */
        .thread-tree {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Depth indentation via left border */
        .thread-node { position: relative; }
        .thread-children {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 2px solid #e0e0e0;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* ── Review comment card ────────────────────────────────────── */
        .review-comment {
            background: #fff;
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.88em;
        }
        .review-comment-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .review-author {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 0.95em;
        }

        /* Date chip — links back to the daily report */
        .date-chip {
            font-size: 0.75em;
            color: #777;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 1px 7px;
            text-decoration: none;
            white-space: nowrap;
        }
        a.date-chip:hover { background: #e0e8f5; color: #0366d6; }

        .badge {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 600;
        }
        .inline-review-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1565c0;
        }
        .review-tag-badge {
            display: inline-block;
            padding: 0 6px;
            border-radius: 8px;
            font-size: 0.78em;
            font-weight: 500;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .analysis-source-badge {
            display: inline-block;
            padding: 1px 7px;
            border-radius: 10px;
            font-size: 0.72em;
            font-weight: 600;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .review-comment-text {
            color: #444;
            line-height: 1.55;
            margin-bottom: 4px;
        }
        .review-comment-signals {
            margin-top: 3px;
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
        }

        /* ── Collapsible raw body ───────────────────────────────────── */
        .raw-body-toggle {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .raw-body-toggle summary {
            cursor: pointer;
            color: #888;
            padding: 2px 0;
            font-weight: 500;
            font-size: 0.9em;
            list-style: none;
        }
        .raw-body-toggle summary::-webkit-details-marker { display: none; }
        .raw-body-toggle summary::before { content: "▶ "; font-size: 0.7em; }
        .raw-body-toggle[open] summary::before { content: "▼ "; }
        .raw-body-toggle summary:hover { color: #555; }
        .raw-body-text {
            white-space: pre-wrap;
            font-size: 0.95em;
            background: #f8f8f8;
            padding: 8px 10px;
            border-radius: 4px;
            max-height: 360px;
            overflow-y: auto;
            margin-top: 4px;
            line-height: 1.5;
            color: #444;
            border: 1px solid #e8e8e8;
        }

        .no-reviews {
            color: #aaa;
            font-size: 0.85em;
            font-style: italic;
            padding: 8px 0;
        }

        footer {
            text-align: center;
            color: #bbb;
            font-size: 0.78em;
            margin-top: 36px;
            padding: 16px;
        }
    </style>
</head>
<body>
    <div class="home-link"><a href="../">&larr; Back to reports</a></div>
    <h1>Re: [PATCH v7 1/3] tracing: Add __event_in_*irq() helpers</h1>
    <div class="lore-link"><a href="https://lore.kernel.org/all/aZyrZ5c4dk_eshGM@linux.dev/" target="_blank">View on lore.kernel.org &rarr;</a></div>
    <div class="date-range">Active on: <a href="#2026-02-24">2026-02-24</a> &bull; <a href="#2026-02-23">2026-02-23</a> &bull; <a href="#2026-02-16">2026-02-16</a> &bull; <a href="#2026-02-13">2026-02-13</a> &bull; <a href="#2026-01-27">2026-01-27</a> &bull; <a href="#2026-01-22">2026-01-22</a> &bull; <a href="#2026-01-15">2026-01-15</a> &bull; <a href="#2026-01-07">2026-01-07</a> &bull; <a href="#2026-01-05">2026-01-05</a> &bull; <a href="#2025-12-29">2025-12-29</a> &bull; <a href="#2025-12-17">2025-12-17</a> &bull; <a href="#2025-12-16">2025-12-16</a> &bull; <a href="#2025-12-09">2025-12-09</a> &bull; <a href="#2025-12-08">2025-12-08</a></div>
    
    <div class="thread-tree">
<div class="thread-node depth-0" id="2025-12-08">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-08">2025-12-08</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the difficulty of attributing memory reclaim events to specific cgroups, making debugging challenging. The author acknowledges that adding memory cgroup ID (memcg_id) to key vmscan tracepoints will enable better correlation and analysis, but does not explicitly state whether they plan to address this in a future version.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 65 +++++++++++++++++++++--------------
 mm/vmscan.c                   | 17 ++++-----
 2 files changed, 48 insertions(+), 34 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index d2123dd960d59..afc9f80d03f34 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(order, gfp_flags, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -209,6 +216,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
@@ -221,6 +229,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
@@ -229,10 +238,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -242,15 +252,16 @@ TRACE_EVENT(mm_shrink_slab_start,
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
-	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
+	TP_PROTO(struct shrinker *shr, struct shrink_control *sc, int shrinker_retval,
 		long unused_scan_cnt, long new_scan_cnt, long total_scan),
 
-	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
+	TP_ARGS(shr, sc, shrinker_retval, unused_scan_cnt, new_scan_cnt,
 		total_scan),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
@@ -260,7 +271,8 @@ TRACE_EVENT(mm_shrink_slab_end,
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
@@ -268,10 +280,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -463,9 +476,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 258f5472f1e90..0e65ec3a087a5 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -931,7 +931,7 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl, freed, nr, new_nr, total_scan);
 	return freed;
 }
 
@@ -7092,11 +7092,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7126,7 +7126,8 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
 	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+						      sc.gfp_mask,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -7137,7 +7138,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -7171,13 +7172,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -8072,7 +8073,7 @@ static int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned in
 	fs_reclaim_release(sc.gfp_mask);
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed, 0);
 
 	return sc.nr_reclaimed &gt;= nr_pages;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledgment of challenge, no explicit fix planned</div>
</div>
<div class="thread-children">
<div class="thread-node depth-1" id="2025-12-09">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-09">2025-12-09</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the __event_in_*irq() helpers do not handle the case where the event is triggered from a non-IRQ context, and requested that the patch be updated to include a check for this scenario

reviewer noted that adding a PID field next to the order field in the tracepoint would cause alignment issues on 64-bit machines, suggesting moving the &#x27;unsigned long&#x27; between them</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon,  8 Dec 2025 10:14:13 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

This puts a hole in the ring buffer on 64 bit machines. Please keep pid
next to order as they are both &#x27;int&#x27; and not have an &quot;unsigned long&quot;
between the two.</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, alignment issue, 64-bit machine</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2" id="2025-12-29">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-29">2025-12-29</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed Steven Rostedt&#x27;s concern about displaying erroneous debugging values in IRQ context, explaining that adding a small check to mark such information as invalid is a trivial addition and improves clarity.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">(re-sending the reply as I believe I missed the reply all)

It indeed shows whether or not we&#x27;re in an IRQ, but I believe the
kernel shouldn&#x27;t show erronous debugging values. Even though it can be
obvious that we&#x27;re in an interrupt, some people might look directly at
the garbage PID value without having second thoughts and taking it for
granted. On the other hand, it takes just a small check to mark the
debugging information as clearly invalid, which complements the IRQ
context flag.

If we shouldn&#x27;t put that check there, I&#x27;d happily remove it, but I&#x27;d
tend to think it&#x27;s a trivial addition that can only be for the best.

Thomas</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged feedback, explained reasoning</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the __event_in_*irq() helpers do not handle the case where the irq is disabled, and suggested adding a check to ensure the irq is enabled before calling the helper

The reviewer questioned the necessity of adding __event_in_*irq() helpers, pointing out that existing trace events already indicate whether a task is in interrupt context or not, and also provide the current PID.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, 16 Dec 2025 06:02:52 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

Is this really needed? The trace events already show if you are in
interrupt context or not.

# tracer: nop
#
# entries-in-buffer/entries-written: 25817/25817   #P:8
#
#                                _-----=&gt; irqs-off/BH-disabled
#                               / _----=&gt; need-resched
#                              | / _---=&gt; hardirq/softirq   &lt;&lt;&lt;&lt;------ Shows irq context
#                              || / _--=&gt; preempt-depth
#                              ||| / _-=&gt; migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
          &lt;idle&gt;-0       [002] d..1. 11429.293552: rcu_watching: Startirq 0 1 0x74c
          &lt;idle&gt;-0       [000] d.H1. 11429.293564: rcu_utilization: Start scheduler-tick
          &lt;idle&gt;-0       [000] d.H1. 11429.293566: rcu_utilization: End scheduler-tick
          &lt;idle&gt;-0       [002] dN.1. 11429.293567: rcu_watching: Endirq 1 0 0x74c
          &lt;idle&gt;-0       [002] dN.1. 11429.293568: rcu_watching: Start 0 1 0x754
          &lt;idle&gt;-0       [000] d.s1. 11429.293577: rcu_watching: --= 3 1 0xdf4
          &lt;idle&gt;-0       [002] dN.1. 11429.293579: rcu_utilization: Start context switch
          &lt;idle&gt;-0       [002] dN.1. 11429.293580: rcu_utilization: End context switch
       rcu_sched-15      [002] d..1. 11429.293589: rcu_grace_period: rcu_sched 132685 start
          &lt;idle&gt;-0       [000] dN.1. 11429.293592: rcu_watching: Endirq 1 0 0xdf4
       rcu_sched-15      [002] d..1. 11429.293592: rcu_grace_period: rcu_sched 132685 cpustart
       rcu_sched-15      [002] d..1. 11429.293592: rcu_grace_period_init: rcu_sched 132685 0 0 7 ff
          &lt;idle&gt;-0       [000] dN.1. 11429.293593: rcu_watching: Start 0 1 0xdfc

Thus, you can already tell if you are in interrupt context or not, and you
always get the current pid. The &#x27;H&#x27;, &#x27;h&#x27; or &#x27;s&#x27; means you are in a
interrupt type context. (&#x27;H&#x27; for hard interrupt interrupting a softirq, &#x27;h&#x27;
for just a hard interrupt, and &#x27;s&#x27; for a softirq).

What&#x27;s the point of adding another field to cover the same information
that&#x27;s already available?

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shakeel Butt suggested using cgroup_id() instead of mem_cgroup_id() in the vmscan tracepoints, citing that mem_cgroup_id() is an internal ID not exposed to userspace and recommending the use of inode number provided by cgroup_id()</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Please don&#x27;t use mem_cgroup_id() here as it is an ID internal to memcg.
Use cgroup_id(memcg-&gt;css.cgroup) instead which is inode number and is
exposed to the userspace.</pre>
</details>
<div class="review-comment-signals">Signals: requested change</div>
</div>
</div>
<div class="thread-node depth-1" id="2025-12-17">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-17">2025-12-17</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the __event_in_*irq() helpers are not properly handling the case where the event is being triggered from a non-IRQ context, and requested that the patch be updated to handle this scenario

reviewer noted that the current event structure is not aligned properly, specifically pointing out that the memcg_id field should be placed between order and gfp_flags to maintain alignment</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Tue, 16 Dec 2025 06:02:51 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

Hmm, the above adds some holes. Note, events are at a minimum, 4 bytes
aligend. On 64bit, they can be 8 byte aligned. Still, above is the same as:

	struct {
		int		order;
		unsigned long	gfp_flags;
		unsigned short	memcg_id;
	};

See the issue? Perhaps it may be better to add the memcg_id in between the
order and gfp_flags?

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, alignment issue, field placement suggestion</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-29">2025-12-29</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the __event_in_*irq() helpers do not check if the current CPU is in an NMI context, which could lead to incorrect tracing results when called from within an NMI handler

Reviewer Steven Rostedt suggested an alternative approach to determining if a task was in interrupt context, which would avoid wasting ring buffer space and only require updating the output format.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 29 Dec 2025 02:54:27 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

I just don&#x27;t like wasting valuable ring buffer space for something that can
be easily determined without it.

How about this. I just wrote up this patch, and it could be something you
use. I tested it against the sched waking events, by adding:

 		__entry-&gt;target_cpu	= task_cpu(p);
 	),
 
-	TP_printk(&quot;comm=%s pid=%d prio=%d target_cpu=%03d&quot;,
+	TP_printk(&quot;comm=%s pid=%d prio=%d target_cpu=%03d %s&quot;,
 		  __entry-&gt;comm, __entry-&gt;pid, __entry-&gt;prio,
-		  __entry-&gt;target_cpu)
+		  __entry-&gt;target_cpu,
+		  __event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
Which produces:

          &lt;idle&gt;-0     [003] d.h4.    44.832126: sched_waking:         comm=in:imklog pid=619 prio=120 target_cpu=006 (in-irq)
          &lt;idle&gt;-0     [003] d.s3.    44.832180: sched_waking:         comm=rcu_preempt pid=15 prio=120 target_cpu=001 (in-irq)
       in:imklog-619   [006] d..2.    44.832393: sched_waking:         comm=rs:main Q:Reg pid=620 prio=120 target_cpu=003 

You can see it adds &quot;(in-irq)&quot; when the even is executed from IRQ context
(soft or hard irq). But I also added __event_in_hardirq() and
__event_in_softirq() if you wanted to distinguish them.

Now you don&#x27;t need to update what goes into the ring buffer (and waste its
space), but only update the output format that makes it obvious that the
task was in interrupt context or not.

I also used trace-cmd to record the events, and it still parses properly
with no updates to libtraceevent needed.

Would this work for you?

Below is the patch that allows for this:

-- Steve


diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f5..53a23988a3b8 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f4..47008897a795 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.</pre>
</details>
<div class="review-comment-signals">Signals: potential bug, NMI context, alternative approach</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer noted that memcg_id is a u64 but was being used as an unsigned short, and suggested passing the memcg pointer to the tracepoint instead of using cgroup_id() directly.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Couple of comments:

1. memcg_id is u64 but the patch is using &#x27;unsigned short&#x27;.
2. I would prefer memcg pointer be passed in tracepoint and then in
trace header file cgroup_id() be used similar to other users in
include/trace/events/ folder.

Orthogonally I am cleaning up memcg id usage and after that cleanup,
mem_cgroup_id() would be preferred way to get the ID. No need to do
anything now as I will cleanup this usage later as well.</pre>
</details>
<div class="review-comment-signals">Signals: type mismatch, alternative solution</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Andrew Morton</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Andrew Morton, pointed out an implicit function declaration error in the `__event_in_irq()` macro usage within the `TP_printk` macro expansion in `include/trace/events/vmscan.h`. The error occurs when trying to use `__event_in_irq()` without a preceding declaration. To fix this issue, the reviewer suggested adding a forward declaration for `__event_in_irq()` or ensuring it is declared before its usage.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">x86_64 allmodconfig;


In file included from ./include/trace/define_trace.h:132,
                 from ./include/trace/events/vmscan.h:569,
                 from mm/vmscan.c:73:
./include/trace/events/vmscan.h: In function &#x27;trace_raw_output_mm_vmscan_direct_reclaim_begin_template&#x27;:
./include/trace/events/vmscan.h:140:17: error: implicit declaration of function &#x27;__event_in_irq&#x27; [-Wimplicit-function-declaration]
  140 | +               __event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
      |                 ^~~~~~~~~~~~~~
./include/trace/trace_events.h:219:34: note: in definition of macro &#x27;DECLARE_EVENT_CLASS&#x27;
  219 |         trace_event_printf(iter, print);                                \
      |                                  ^~~~~
./include/trace/events/vmscan.h:135:9: note: in expansion of macro &#x27;TP_printk&#x27;
  135 |         TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u %s&quot;,
      |         ^~~~~~~~~
make[3]: *** [scripts/Makefile.build:287: mm/vmscan.o] Error 1
make[2]: *** [scripts/Makefile.build:556: mm] Error 2
make[1]: *** [/usr/src/25/Makefile:2054: .] Error 2
make: *** [Makefile:248: __sub-make] Error 2</pre>
</details>
<div class="review-comment-signals">Signals: implicit function declaration error, missing declaration</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that the __event_in_*irq() helpers do not handle the case where the event is triggered from a softirq, and suggested adding a check for this scenario

Reviewer Steven Rostedt expressed confusion about why his patch is not included in the series, and requested that it be added</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 5 Jan 2026 18:06:40 -0800
Andrew Morton &lt;akpm@linux-foundation.org&gt; wrote:

---

This is dependent on my patch:

  https://lore.kernel.org/all/20251229163515.3d1b0bba@gandalf.local.home/

Where I said you can take this patch. But I don&#x27;t see it as part of the
series.

  https://lore.kernel.org/all/20251229163634.5aad205d@gandalf.local.home/

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, confusion, request</div>
</div>
</div>
<div class="thread-node depth-2">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-07">2026-01-07</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer pointed out that the patch can directly use mem_cgroup_id() since his own series has landed in mm-new, eliminating the need for the __event_in_*irq() helpers.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Oh sorry, I meant my series [1] landed in mm-new and with that Thomas
can directly use mem_cgroup_id() without worrying about CONFIG_MEMCG=n.

[1] https://lkml.kernel.org/r/20251225232116.294540-1-shakeel.butt@linux.dev</pre>
</details>
<div class="review-comment-signals">Signals: patch becomes unnecessary</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-01-07">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Harry Yoo</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-07">2026-01-07</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The reviewer, Harry Yoo, pointed out that the patch breaks CONFIG_MEMCG=n builds due to an invalid use of the undefined type &#x27;struct mem_cgroup&#x27; in several functions within include/trace/events/vmscan.h.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Hi Thomas, this is breaking CONFIG_MEMCG=n builds.

In file included from ./include/trace/define_trace.h:132,
                 from ./include/trace/events/vmscan.h:569,
                 from mm/vmscan.c:73:
./include/trace/events/vmscan.h: In function \u2018do_trace_event_raw_event_mm_shrink_slab_start\u2019:
./include/trace/events/vmscan.h:248:68: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  248 |                 __entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
      |                                                                    ^~
./include/trace/trace_events.h:427:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
  427 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/trace_events.h:435:23: note: in expansion of macro \u2018PARAMS\u2019
  435 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:214:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  214 | TRACE_EVENT(mm_shrink_slab_start,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:237:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  237 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
./include/trace/events/vmscan.h: In function \u2018do_trace_event_raw_event_mm_shrink_slab_end\u2019:
./include/trace/events/vmscan.h:293:56: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  293 |                 __entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
      |                                                        ^~
./include/trace/trace_events.h:427:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
  427 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/trace_events.h:435:23: note: in expansion of macro \u2018PARAMS\u2019
  435 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:266:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  266 | TRACE_EVENT(mm_shrink_slab_end,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:285:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  285 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
In file included from ./include/trace/define_trace.h:133:
./include/trace/events/vmscan.h: In function \u2018do_perf_trace_mm_shrink_slab_start\u2019:
./include/trace/events/vmscan.h:248:68: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  248 |                 __entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
      |                                                                    ^~
./include/trace/perf.h:51:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
   51 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/perf.h:67:23: note: in expansion of macro \u2018PARAMS\u2019
   67 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:214:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  214 | TRACE_EVENT(mm_shrink_slab_start,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:237:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  237 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
./include/trace/events/vmscan.h: In function \u2018do_perf_trace_mm_shrink_slab_end\u2019:
./include/trace/events/vmscan.h:293:56: error: invalid use of undefined type \u2018struct mem_cgroup\u2019
  293 |                 __entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
      |                                                        ^~
./include/trace/perf.h:51:11: note: in definition of macro \u2018__DECLARE_EVENT_CLASS\u2019
   51 |         { assign; }                                                     \
      |           ^~~~~~
./include/trace/perf.h:67:23: note: in expansion of macro \u2018PARAMS\u2019
   67 |                       PARAMS(assign), PARAMS(print))                    \
      |                       ^~~~~~
./include/trace/trace_events.h:40:9: note: in expansion of macro \u2018DECLARE_EVENT_CLASS\u2019
   40 |         DECLARE_EVENT_CLASS(name,                              \
      |         ^~~~~~~~~~~~~~~~~~~
./include/trace/trace_events.h:44:30: note: in expansion of macro \u2018PARAMS\u2019
   44 |                              PARAMS(assign),                   \
      |                              ^~~~~~
./include/trace/events/vmscan.h:266:1: note: in expansion of macro \u2018TRACE_EVENT\u2019
  266 | TRACE_EVENT(mm_shrink_slab_end,
      | ^~~~~~~~~~~
./include/trace/events/vmscan.h:285:9: note: in expansion of macro \u2018TP_fast_assign\u2019
  285 |         TP_fast_assign(
      |         ^~~~~~~~~~~~~~
  CC      arch/x86/mm/extable.o
make[3]: *** [scripts/Makefile.build:287: mm/vmscan.o] Error 1
make[2]: *** [scripts/Makefile.build:556: mm] Error 2
make[2]: *** Waiting for unfinished jobs....

-- 
Cheers,
Harry / Hyeonggon</pre>
</details>
<div class="review-comment-signals">Signals: build failure, undefined type</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Andrew Morton</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Andrew Morton requested that Thomas Ballasi cc relevant maintainers on vmscan changes, specifically mentioning the output of scripts/get_maintainer.pl to ensure all necessary parties are notified.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Pleae cc the relevant maintainers on vmscan changes.  We have a
veritable army of them:

hp2:/usr/src/mm&gt; scripts/get_maintainer.pl --no-rolestats --nogit -f mm/vmscan.c
Andrew Morton &lt;akpm@linux-foundation.org&gt;
Axel Rasmussen &lt;axelrasmussen@google.com&gt;
Yuanchu Xie &lt;yuanchu@google.com&gt;
Wei Xu &lt;weixugc@google.com&gt;
Johannes Weiner &lt;hannes@cmpxchg.org&gt;
David Hildenbrand &lt;david@kernel.org&gt;
Michal Hocko &lt;mhocko@kernel.org&gt;
Qi Zheng &lt;zhengqi.arch@bytedance.com&gt;
Shakeel Butt &lt;shakeel.butt@linux.dev&gt;
Lorenzo Stoakes &lt;lorenzo.stoakes@oracle.com&gt;

The first patch should have your Signed-off-by:, as you were on the
delivery path.

The patchset looks sensible to me - I&#x27;ll await reviewer input before
proceeding.  Thanks.</pre>
</details>
<div class="review-comment-signals">Signals: cc, maintainers</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-01-27">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-27">2026-01-27</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer Shakeel Butt requested that the patch be modified to pass the memcg pointer to the tracepoints, specifically calling mem_cgroup_id() on it.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Please pass memcg pointer to tracepoints and call mem_cgroup_id(memcg)
here.</pre>
</details>
<div class="review-comment-signals">Signals: requested modification</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-02-16">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Usama Arif</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-16">2026-02-16</a>
<span class="inline-review-badge">Inline Review</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer questioned the removal of __entry-&gt;shrink in this patch, wondering if it was an intentional change.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">__entry-&gt;shrink is removed here, but still printed below. Was this an intended
change of this commit?</pre>
</details>
<div class="review-comment-signals">Signals: uncertainty, request for clarification</div>
</div>
<div class="thread-children">
<div class="thread-node depth-2">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-16">2026-02-16</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer pointed out that the __event_in_*irq() helpers do not handle the case where the event is triggered from a softirq, which can lead to incorrect tracing results

reviewer made a lighthearted comment about the patch author typing in code manually, rather than copying and pasting</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 16 Feb 2026 08:13:21 -0800
Usama Arif &lt;usama.arif@linux.dev&gt; wrote:

---

Yeah. That&#x27;s when you should have done &quot;cut-and-paste&quot; but instead just
typed it in by memory :-p

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Reviewed-by</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="review-tag-badge">Acked-by</span>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#6c4b00;background:#ffeeba" title="Analysis source: Heuristic">Heuristic</span>
</div>
<div class="review-comment-text">Gave Acked-by</div>
</div>
</div>
<div class="thread-node depth-1">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer questioned the necessity of __event_in_irq() checks for vmscan tracepoints, pointing out that memory reclaim only occurs in process context and therefore such checks are unnecessary.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Where is this in_task() check happening? Also this patch is changing
tracepoints for memory reclaim which never happens in any context other than
process context, so we don&#x27;t need __event_in_irq() checks for these tracepoints.</pre>
</details>
<div class="review-comment-signals">Signals: requested changes</div>
</div>
</div>
<div class="thread-node depth-1" id="2026-02-24">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Masami (Google)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-24">2026-02-24</a>
<span class="inline-review-badge">Inline Review</span>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer pointed out that the __event_in_*irq() helpers do not handle the case where the event is triggered from a non-IRQ context, and suggested adding a check to ensure the current task is in an IRQ context before calling the helper

Reviewer Masami suggested reusing the common_pid field in the mm_vmscan_reclaim_pages tracepoint to save space, pointing out that all entries already store current-&gt;pid in this field.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Hi,

On Mon, 23 Feb 2026 09:15:44 -0800
Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt; wrote:

---

All entries saves current-&gt;pid in common_pid field. Can you use
this common field?

# cat events/vmscan/mm_vmscan_reclaim_pages/format 
name: mm_vmscan_reclaim_pages
ID: 590
format:
	field:unsigned short common_type;	offset:0;	size:2;	signed:0;
	field:unsigned char common_flags;	offset:2;	size:1;	signed:0;
	field:unsigned char common_preempt_count;	offset:3;	size:1;	signed:0;
	field:int common_pid;	offset:4;	size:4;	signed:1;    ## &lt;------------here

	field:int nid;	offset:8;	size:4;	signed:1;
	field:unsigned long nr_scanned;	offset:16;	size:8;	signed:0;
	field:unsigned long nr_reclaimed;	offset:24;	size:8;	signed:0;
	field:unsigned long nr_dirty;	offset:32;	size:8;	signed:0;
	field:unsigned long nr_writeback;	offset:40;	size:8;	signed:0;
	field:unsigned long nr_congested;	offset:48;	size:8;	signed:0;
	field:unsigned long nr_immediate;	offset:56;	size:8;	signed:0;
	field:unsigned int nr_activate0;	offset:64;	size:4;	signed:0;
	field:unsigned int nr_activate1;	offset:68;	size:4;	signed:0;
	field:unsigned long nr_ref_keep;	offset:72;	size:8;	signed:0;
	field:unsigned long nr_unmap_fail;	offset:80;	size:8;	signed:0;

Thank you,

-- 
Masami Hiramatsu (Google) &lt;mhiramat@kernel.org&gt;</pre>
</details>
<div class="review-comment-signals">Signals: requested changes, requested change</div>
</div>
</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-08">2025-12-08</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in tracing events, specifically when not in process context (e.g., interrupts or RCU contexts). The author explains that they use in_task() to safely access current-&gt;pid and set it to -1 as a sentinel value when not in process context. This response suggests that the patch is addressing the concern but does not indicate any plans for further revision.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index afc9f80d03f34..eddb4e75e2e23 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -121,18 +121,21 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 	TP_STRUCT__entry(
 		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -167,16 +170,19 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%u&quot;,
 		__entry-&gt;nr_reclaimed,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -216,6 +222,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
@@ -229,6 +236,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
@@ -238,10 +246,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
@@ -261,6 +270,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
@@ -272,6 +282,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
@@ -280,10 +291,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged concern, explained solution</div>
</div>
</div>
<div class="thread-node depth-0" id="2025-12-16">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author responded to a concern about the swapped field entries in v1 causing a hole in the ring buffer by explaining that they were swapped in v2 to prevent this issue.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v2:
- Swapped field entries to prevent a hole in the ring buffer

Link to v1:
https://lore.kernel.org/linux-trace-kernel/20251208181413.4722-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h | 77 +++++++++++++++++++++++------------
 mm/vmscan.c                   | 17 ++++----
 2 files changed, 60 insertions(+), 34 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix needed, explained solution</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author acknowledged that the swapoff path needs to drop the per-vswap spinlock before calling try_to_unmap(), agreed to restructure in a future version.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 65 +++++++++++++++++++++--------------
 mm/vmscan.c                   | 17 ++++-----
 2 files changed, 48 insertions(+), 34 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index d2123dd960d59..afc9f80d03f34 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(order, gfp_flags, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(int order, gfp_t gfp_flags, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(order, gfp_flags, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -209,6 +216,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
@@ -221,6 +229,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
@@ -229,10 +238,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -242,15 +252,16 @@ TRACE_EVENT(mm_shrink_slab_start,
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
-	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
+	TP_PROTO(struct shrinker *shr, struct shrink_control *sc, int shrinker_retval,
 		long unused_scan_cnt, long new_scan_cnt, long total_scan),
 
-	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
+	TP_ARGS(shr, sc, shrinker_retval, unused_scan_cnt, new_scan_cnt,
 		total_scan),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
@@ -260,7 +271,8 @@ TRACE_EVENT(mm_shrink_slab_end,
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
@@ -268,10 +280,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -463,9 +476,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 258f5472f1e90..0e65ec3a087a5 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -931,7 +931,7 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl, freed, nr, new_nr, total_scan);
 	return freed;
 }
 
@@ -7092,11 +7092,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7126,7 +7126,8 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
 	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+						      sc.gfp_mask,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -7137,7 +7138,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -7171,13 +7172,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -8072,7 +8073,7 @@ static int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned in
 	fs_reclaim_release(sc.gfp_mask);
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc.nr_reclaimed, 0);
 
 	return sc.nr_reclaimed &gt;= nr_pages;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix needed, agreed to restructure</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-16">2025-12-16</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the reliability of PID detection in tracing events, explaining that they use in_task() to safely access current-&gt;pid when in process context and set it to -1 as a sentinel value otherwise.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index afc9f80d03f34..315725f30b504 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -120,19 +120,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
 	TP_STRUCT__entry(
 		__field(	int,	order		)
+		__field(	int,	pid		)
 		__field(	unsigned long,	gfp_flags	)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -167,16 +170,19 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;pid		= in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%u&quot;,
 		__entry-&gt;nr_reclaimed,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id)
 );
 
@@ -216,6 +222,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
@@ -229,6 +236,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
@@ -238,10 +246,11 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
@@ -261,6 +270,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 		__field(void *, shrink)
 		__field(long, unused_scan)
@@ -272,6 +282,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = in_task() ? current-&gt;pid : -1;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? mem_cgroup_id(sc-&gt;memcg) : 0;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
@@ -280,10 +291,11 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Steven Rostedt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2025-12-29">2025-12-29</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">reviewer noted that __event_in_irq() is not properly handling the case where the event is being triggered from an interrupt handler, and suggested adding a check to ensure the current task is not in an interrupt context

reviewer suggested using a previously posted patch instead of the current one, providing a link to the alternative patch</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, 29 Dec 2025 13:29:42 -0500
Steven Rostedt &lt;rostedt@goodmis.org&gt; wrote:

---

If this would work for you. Feel free to take the patch I posted and use that:

   https://lore.kernel.org/all/20251229163515.3d1b0bba@gandalf.local.home/

-- Steve</pre>
</details>
<div class="review-comment-signals">Signals: interrupt handling, task state, suggestion</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-05">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the potential for a hole in the ring buffer due to reordered field entries, and responded by swapping multiple field entries to prevent this issue.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v3:
- Swapped multiple field entries to prevent a hole in the ring buffer
- Replaced in_task() with __event_in_irq
- Replaced mem_cgroup_id(memcg) with cgroup_id(memcg-&gt;css.cgroup)
- Rebased the tree to latest 6.18

Link to v2:
https://lore.kernel.org/linux-trace-kernel/20251216140252.11864-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h | 100 ++++++++++++++++++++++------------
 mm/shrinker.c                 |   2 +-
 mm/vmscan.c                   |  17 +++---
 3 files changed, 74 insertions(+), 45 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix needed, agreed to change</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the lack of cgroup IDs in vmscan tracepoints, explaining that they are being added to key tracepoints and defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 79 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  2 +-
 mm/vmscan.c                   | 17 ++++----
 3 files changed, 56 insertions(+), 42 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..93a9a9ba9405d 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg_id),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	int,	order		)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, unsigned short memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -208,31 +215,34 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(unsigned short, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -242,36 +252,39 @@ TRACE_EVENT(mm_shrink_slab_start,
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
-	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
+	TP_PROTO(struct shrinker *shr, struct shrink_control *sc, int shrinker_retval,
 		long unused_scan_cnt, long new_scan_cnt, long total_scan),
 
-	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
+	TP_ARGS(shr, sc, shrinker_retval, unused_scan_cnt, new_scan_cnt,
 		total_scan),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(unsigned short, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, unsigned short memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..e3b894c20bec8 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -461,7 +461,7 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl, freed, nr, new_nr, total_scan);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index b2fc8b626d3df..3ac9f45461795 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6642,11 +6642,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6675,8 +6675,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      cgroup_id(memcg-&gt;css.cgroup));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6687,7 +6688,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, cgroup_id(memcg-&gt;css.cgroup));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6723,13 +6724,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, cgroup_id(memcg-&gt;css.cgroup));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, cgroup_id(memcg-&gt;css.cgroup));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7675,7 +7676,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-05">2026-01-05</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that they use in_task() to safely access current-&gt;pid when in process context and set it to -1 as a sentinel value otherwise. They are not planning to restructure their approach based on this feedback.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 33 ++++++++++++++++++++++++---------
 1 file changed, 24 insertions(+), 9 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 93a9a9ba9405d..d438abfa03ebb 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -121,19 +121,23 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	gfp_flags	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%u&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%u %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -167,17 +171,21 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	int,	pid		)
 		__field(	unsigned short,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%u&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%u %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -222,6 +230,7 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, total_scan)
 		__field(int, priority)
 		__field(int, nid)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 	),
 
@@ -235,20 +244,23 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = sc-&gt;memcg ? cgroup_id(sc-&gt;memcg-&gt;css.cgroup) : 0;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(unsigned short, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = cgroup_id(sc-&gt;memcg-&gt;css.cgroup);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %u unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: neutral explanation, no clear resolution signal</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Shakeel Butt</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-07">2026-01-07</a>
<span class="review-tag-badge">Reviewed-by</span>
<span class="badge" style="color:#856404;background:#fff3cd">Needs Work</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Reviewer noted that the __event_in_*irq() helpers may not be sufficient for tracing events in all interrupt contexts, and requested additional information on how these helpers handle nested interrupts or interrupt nesting

Reviewer requested to replace the usage of cgroup_id() with mem_cgroup_id(), citing that the former has been deprecated in favor of the latter, and suggesting to use the more modern function for consistency</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">On Mon, Jan 05, 2026 at 02:46:39PM -0800, Shakeel Butt wrote:
[...]

---

The series has been landed in mm-new. Please use mem_cgroup_id() instead
of cgroup_id(memcg-&gt;css.cgroup).</pre>
</details>
<div class="review-comment-signals">Signals: requested additional information, requested change</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-15">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about the implementation of __event_in_*irq() helpers by adding Steven Rostedt&#x27;s patch in v4, which resolves the issue.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v4:
- added Steven&#x27;s patch for __even_in_*irq() calls
- moved back to mem_cgroup_id() following Shakeel&#x27;s changes
- passed cgroup ID through trace calls for slab_* tracepoints
  instead of in vmscan.h directly
- changed memcg_id instances types from unsigned short to u64 and
  updated struct entries accordingly

Link to v3:
https://lore.kernel.org/linux-trace-kernel/20260105160423.23708-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 104 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 48 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: resolved</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about exposing interrupt context information in trace events, explaining that instead of recording this in the event structure itself, helper macros can be used to check the flags portion of the event header.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __entry_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the difficulty of attributing memory reclaim events to specific cgroups, explaining that adding memory cgroup ID (memcg_id) to key vmscan tracepoints will enable better correlation and analysis. The field is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..20160e79eb0d7 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg_id),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, u64 memcg_id),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, u64 memcg_id),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ccfbe3fb3b378 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   mem_cgroup_id(shrinkctl-&gt;memcg));
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 mem_cgroup_id(shrinkctl-&gt;memcg));
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index b2fc8b626d3df..9a3cd975a9f30 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6642,11 +6642,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6675,8 +6675,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6687,7 +6688,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6723,13 +6724,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7675,7 +7676,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-15">2026-01-15</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that the __event_in_irq() macro is used to safely access current-&gt;pid when not in process context.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 35 +++++++++++++++++++++++++----------
 1 file changed, 25 insertions(+), 10 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 20160e79eb0d7..288589e3364b0 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= memcg_id;
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = memcg_id;
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
++		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-01-22">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about extra &#x27;+&#x27; characters at (in-irq) warnings in v4, confirmed that the issue was fixed in v5 by removing the quirk.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v5:
- Fixed a small quirk that added extra +&#x27;s at (in-irq) warnings

Link to v4:
https://lore.kernel.org/linux-trace-kernel/20260115123809.2257-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 104 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 48 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged fix, confirmed resolution</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the implementation of __event_in_irq() helpers, explaining that instead of recording this information in the event structure itself, it&#x27;s stored in the flags portion of the event header and can be accessed using helper macros.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __entry_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the difficulty of attributing memory reclaim events to specific cgroups, which makes debugging memory pressure issues challenging. The author explains that this patch adds memory cgroup ID (memcg_id) to key vmscan tracepoints to enable better correlation and analysis, with the field defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..20160e79eb0d7 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg_id),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, u64 memcg_id),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, u64 memcg_id),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, u64 memcg_id),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg_id),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, u64 memcg_id),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg_id)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ccfbe3fb3b378 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   mem_cgroup_id(shrinkctl-&gt;memcg));
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 mem_cgroup_id(shrinkctl-&gt;memcg));
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index b2fc8b626d3df..9a3cd975a9f30 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6642,11 +6642,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6675,8 +6675,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      mem_cgroup_id(memcg));
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6687,7 +6688,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, mem_cgroup_id(memcg));
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6723,13 +6724,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, mem_cgroup_id(memcg));
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, mem_cgroup_id(memcg));
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7675,7 +7676,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-01-22">2026-01-22</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that they use in_task() to safely access current-&gt;pid when in process context and set it to -1 as a sentinel value otherwise. The author&#x27;s response suggests no immediate fix is planned.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 35 +++++++++++++++++++++++++----------
 1 file changed, 25 insertions(+), 10 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 20160e79eb0d7..c7f7621e48af5 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= memcg_id;
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= memcg_id;
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = memcg_id;
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = memcg_id;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: no clear resolution signal, technical explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-13">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about the patch being unrelated to their original submission by explaining that they were updating Steven Rostedt&#x27;s patch and providing a link to v5, which included the tracing changes.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v6:
- Updated Steven&#x27;s patch with sign-off
- Passed memcg pointers as arguments in tracepoints instead of memcg_id

Link to v5:
https://lore.kernel.org/linux-trace-kernel/20260122182510.2126-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 104 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 48 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about how to expose interrupt context information in trace events, explaining that instead of recording this in the event structure itself, helper macros can be used to check the flags portion of the event header.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __entry_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the difficulty of attributing memory reclaim events to specific cgroups, which makes debugging challenging. The author explains that this patch adds memory cgroup ID (memcg_id) to key vmscan tracepoints to enable better correlation and analysis. The field is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..1212f6a7c223e 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ddf784f996a59 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   shrinkctl-&gt;memcg);
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 shrinkctl-&gt;memcg);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 614ccf39fe3fa..9d512fb354fcd 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6603,11 +6603,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6636,8 +6636,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      memcg);
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6648,7 +6649,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, memcg);
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6684,13 +6685,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, memcg);
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, memcg);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7642,7 +7643,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-13">2026-02-13</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author is addressing a concern about the reliability of PID detection in interrupt or RCU contexts, explaining that they use in_task() to safely access current-&gt;pid when in process context and set it to -1 as a sentinel value otherwise.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 35 +++++++++++++++++++++++++----------
 1 file changed, 25 insertions(+), 10 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 1212f6a7c223e..a68b712ef757a 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,29 +278,32 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0" id="2026-02-23">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#155724;background:#d4edda">Positive</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">Author addressed a concern about the naming convention of the new helpers by explaining that they were edited to match the existing __entry_in_irq() function and restoring an entry that was inadvertently removed.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Changes in v6:
- Edited __entry_in_irq() to __event_in_irq() in corresponding commit
  message
- Restore an entry that was removed inadvertently

Link to v6:
https://lore.kernel.org/linux-trace-kernel/20260213181537.54350-1-tballasi@linux.microsoft.com/

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;

Steven Rostedt (1):
  tracing: Add __event_in_*irq() helpers

Thomas Ballasi (2):
  mm: vmscan: add cgroup IDs to vmscan tracepoints
  mm: vmscan: add PIDs to vmscan tracepoints

 include/trace/events/vmscan.h              | 103 +++++++++++++--------
 include/trace/stages/stage3_trace_output.h |   8 ++
 include/trace/stages/stage7_class_define.h |  19 ++++
 mm/shrinker.c                              |   6 +-
 mm/vmscan.c                                |  17 ++--
 5 files changed, 106 insertions(+), 47 deletions(-)

-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: acknowledged feedback, provided explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about exposing interrupt context information in trace events, explaining that instead of recording this in the event structure itself, helper macros can be used to check the flags portion of the event header.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">From: Steven Rostedt &lt;rostedt@goodmis.org&gt;

Some trace events want to expose in their output if they were triggered in
an interrupt or softirq context. Instead of recording this in the event
structure itself, as this information is stored in the flags portion of
the event header, add helper macros that can be used in the print format:

  TP_printk(&quot;val=%d %s&quot;, __entry-&gt;val, __event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)

This will output &quot;(in-irq)&quot; for the event in the trace data if the event
was triggered in hard or soft interrupt context.

Link: https://lore.kernel.org/all/20251229132942.31a2b583@gandalf.local.home/

Signed-off-by: Steven Rostedt (Google) &lt;rostedt@goodmis.org&gt;
Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/stages/stage3_trace_output.h |  8 ++++++++
 include/trace/stages/stage7_class_define.h | 19 +++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/include/trace/stages/stage3_trace_output.h b/include/trace/stages/stage3_trace_output.h
index 1e7b0bef95f52..53a23988a3b8a 100644
--- a/include/trace/stages/stage3_trace_output.h
+++ b/include/trace/stages/stage3_trace_output.h
@@ -150,3 +150,11 @@
 
 #undef __get_buf
 #define __get_buf(len)		trace_seq_acquire(p, (len))
+
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+#define __event_in_hardirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_HARDIRQ)
+#define __event_in_softirq()	(__entry-&gt;ent.flags &amp; TRACE_FLAG_SOFTIRQ)
+#define __event_in_irq()	(__entry-&gt;ent.flags &amp; (TRACE_FLAG_HARDIRQ | TRACE_FLAG_SOFTIRQ))
diff --git a/include/trace/stages/stage7_class_define.h b/include/trace/stages/stage7_class_define.h
index fcd564a590f43..47008897a7956 100644
--- a/include/trace/stages/stage7_class_define.h
+++ b/include/trace/stages/stage7_class_define.h
@@ -26,6 +26,25 @@
 #undef __print_hex_dump
 #undef __get_buf
 
+#undef __event_in_hardirq
+#undef __event_in_softirq
+#undef __event_in_irq
+
+/*
+ * The TRACE_FLAG_* are enums. Instead of using TRACE_DEFINE_ENUM(),
+ * use their hardcoded values. These values are parsed by user space
+ * tooling elsewhere so they will never change.
+ *
+ * See &quot;enum trace_flag_type&quot; in linux/trace_events.h:
+ *   TRACE_FLAG_HARDIRQ
+ *   TRACE_FLAG_SOFTIRQ
+ */
+
+/* This is what is displayed in the format files */
+#define __event_in_hardirq()	(REC-&gt;common_flags &amp; 0x8)
+#define __event_in_softirq()	(REC-&gt;common_flags &amp; 0x10)
+#define __event_in_irq()	(REC-&gt;common_flags &amp; 0x18)
+
 /*
  * The below is not executed in the kernel. It is only what is
  * displayed in the print format for userspace to parse.
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the difficulty of attributing memory reclaim events to specific cgroups, explaining that adding memory cgroup ID (memcg_id) to key vmscan tracepoints will enable better correlation and analysis. The field is defaulted to 0 for operations not associated with a specific cgroup.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">Memory reclaim events are currently difficult to attribute to
specific cgroups, making debugging memory pressure issues
challenging.  This patch adds memory cgroup ID (memcg_id) to key
vmscan tracepoints to enable better correlation and analysis.

For operations not associated with a specific cgroup, the field
is defaulted to 0.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 83 ++++++++++++++++++++---------------
 mm/shrinker.c                 |  6 ++-
 mm/vmscan.c                   | 17 +++----
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 490958fa10dee..1212f6a7c223e 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -114,85 +114,92 @@ TRACE_EVENT(mm_vmscan_wakeup_kswapd,
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags),
+	TP_ARGS(gfp_flags, order, memcg),
 
 	TP_STRUCT__entry(
-		__field(	int,	order		)
 		__field(	unsigned long,	gfp_flags	)
+		__field(	u64,	memcg_id	)
+		__field(	int,	order		)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;order		= order;
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
+		__entry-&gt;order		= order;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
 		__entry-&gt;order,
-		show_gfp_flags(__entry-&gt;gfp_flags))
+		show_gfp_flags(__entry-&gt;gfp_flags),
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_memcg_softlimit_reclaim_begin,
 
-	TP_PROTO(int order, gfp_t gfp_flags),
+	TP_PROTO(gfp_t gfp_flags, int order, struct mem_cgroup *memcg),
 
-	TP_ARGS(order, gfp_flags)
+	TP_ARGS(gfp_flags, order, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
 DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed),
+	TP_ARGS(nr_reclaimed, memcg),
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
+		__field(	u64,	memcg_id	)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
+		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu&quot;, __entry-&gt;nr_reclaimed)
+	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+		__entry-&gt;nr_reclaimed,
+		__entry-&gt;memcg_id)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 #ifdef CONFIG_MEMCG
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 #endif /* CONFIG_MEMCG */
 
@@ -200,39 +207,42 @@ TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long cache_items,
 		unsigned long long delta, unsigned long total_scan,
-		int priority),
+		int priority, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, sc, nr_objects_to_shrink, cache_items, delta, total_scan,
-		priority),
+		priority, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
 		__field(void *, shrink)
-		__field(int, nid)
 		__field(long, nr_objects_to_shrink)
 		__field(unsigned long, gfp_flags)
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
 		__field(int, priority)
+		__field(int, nid)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
-		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;nr_objects_to_shrink = nr_objects_to_shrink;
 		__entry-&gt;gfp_flags = (__force unsigned long)sc-&gt;gfp_mask;
 		__entry-&gt;cache_items = cache_items;
 		__entry-&gt;delta = delta;
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;priority = priority;
+		__entry-&gt;nid = sc-&gt;nid;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
@@ -243,35 +253,38 @@ TRACE_EVENT(mm_shrink_slab_start,
 
 TRACE_EVENT(mm_shrink_slab_end,
 	TP_PROTO(struct shrinker *shr, int nid, int shrinker_retval,
-		long unused_scan_cnt, long new_scan_cnt, long total_scan),
+		long unused_scan_cnt, long new_scan_cnt, long total_scan, struct mem_cgroup *memcg),
 
 	TP_ARGS(shr, nid, shrinker_retval, unused_scan_cnt, new_scan_cnt,
-		total_scan),
+		total_scan, memcg),
 
 	TP_STRUCT__entry(
 		__field(struct shrinker *, shr)
-		__field(int, nid)
 		__field(void *, shrink)
 		__field(long, unused_scan)
 		__field(long, new_scan)
-		__field(int, retval)
 		__field(long, total_scan)
+		__field(int, nid)
+		__field(int, retval)
+		__field(u64, memcg_id)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;shr = shr;
-		__entry-&gt;nid = nid;
 		__entry-&gt;shrink = shr-&gt;scan_objects;
 		__entry-&gt;unused_scan = unused_scan_cnt;
 		__entry-&gt;new_scan = new_scan_cnt;
-		__entry-&gt;retval = shrinker_retval;
 		__entry-&gt;total_scan = total_scan;
+		__entry-&gt;nid = nid;
+		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
@@ -504,9 +517,9 @@ TRACE_EVENT(mm_vmscan_node_reclaim_begin,
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_node_reclaim_end,
 
-	TP_PROTO(unsigned long nr_reclaimed),
+	TP_PROTO(unsigned long nr_reclaimed, struct mem_cgroup *memcg),
 
-	TP_ARGS(nr_reclaimed)
+	TP_ARGS(nr_reclaimed, memcg)
 );
 
 TRACE_EVENT(mm_vmscan_throttled,
diff --git a/mm/shrinker.c b/mm/shrinker.c
index 4a93fd433689a..ddf784f996a59 100644
--- a/mm/shrinker.c
+++ b/mm/shrinker.c
@@ -410,7 +410,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	total_scan = min(total_scan, (2 * freeable));
 
 	trace_mm_shrink_slab_start(shrinker, shrinkctl, nr,
-				   freeable, delta, total_scan, priority);
+				   freeable, delta, total_scan, priority,
+				   shrinkctl-&gt;memcg);
 
 	/*
 	 * Normally, we should not scan less than batch_size objects in one
@@ -461,7 +462,8 @@ static unsigned long do_shrink_slab(struct shrink_control *shrinkctl,
 	 */
 	new_nr = add_nr_deferred(next_deferred, shrinker, shrinkctl);
 
-	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan);
+	trace_mm_shrink_slab_end(shrinker, shrinkctl-&gt;nid, freed, nr, new_nr, total_scan,
+				 shrinkctl-&gt;memcg);
 	return freed;
 }
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 614ccf39fe3fa..9d512fb354fcd 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -6603,11 +6603,11 @@ unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
 		return 1;
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_direct_reclaim_begin(order, sc.gfp_mask);
+	trace_mm_vmscan_direct_reclaim_begin(sc.gfp_mask, order, 0);
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
-	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_direct_reclaim_end(nr_reclaimed, 0);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -6636,8 +6636,9 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE &amp; ~GFP_RECLAIM_MASK);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.order,
-						      sc.gfp_mask);
+	trace_mm_vmscan_memcg_softlimit_reclaim_begin(sc.gfp_mask,
+						      sc.order,
+						      memcg);
 
 	/*
 	 * NOTE: Although we can get the priority field, using it
@@ -6648,7 +6649,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 	 */
 	shrink_lruvec(lruvec, &amp;sc);
 
-	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
+	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed, memcg);
 
 	*nr_scanned = sc.nr_scanned;
 
@@ -6684,13 +6685,13 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,
 	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
 
 	set_task_reclaim_state(current, &amp;sc.reclaim_state);
-	trace_mm_vmscan_memcg_reclaim_begin(0, sc.gfp_mask);
+	trace_mm_vmscan_memcg_reclaim_begin(sc.gfp_mask, 0, memcg);
 	noreclaim_flag = memalloc_noreclaim_save();
 
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
-	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
+	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed, memcg);
 	set_task_reclaim_state(current, NULL);
 
 	return nr_reclaimed;
@@ -7642,7 +7643,7 @@ static unsigned long __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask,
 	delayacct_freepages_end();
 	psi_memstall_leave(&amp;pflags);
 
-	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed);
+	trace_mm_vmscan_node_reclaim_end(sc-&gt;nr_reclaimed, 0);
 
 	return sc-&gt;nr_reclaimed;
 }
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
<div class="thread-node depth-0">
<div class="review-comment">
<div class="review-comment-header">
<span class="review-author">Thomas Ballasi (author)</span>
<a class="date-chip" href="../2026-02-23_ollama_llama3.1-8b.html" title="First appeared in report for 2026-02-23">2026-02-23</a>
<span class="badge" style="color:#383d41;background:#e2e3e5">Neutral</span>
<span class="analysis-source-badge" style="color:#004085;background:#cce5ff" title="Analysis source: LLM">LLM</span>
</div>
<div class="review-comment-text">The author addressed a concern about the reliability of PID detection in interrupt context, explaining that the PID field uses in_task() to safely access current-&gt;pid when not in process context and is set to -1 as a sentinel value.</div>
<details class="raw-body-toggle">
<summary>Show original comment</summary>
<pre class="raw-body-text">The changes aims at adding additionnal tracepoints variables to help
debuggers attribute them to specific processes.

The PID field uses in_task() to reliably detect when we&#x27;re in process
context and can safely access current-&gt;pid.  When not in process
context (such as in interrupt or in an asynchronous RCU context), the
field is set to -1 as a sentinel value.

Signed-off-by: Thomas Ballasi &lt;tballasi@linux.microsoft.com&gt;
---
 include/trace/events/vmscan.h | 34 +++++++++++++++++++++++++---------
 1 file changed, 25 insertions(+), 9 deletions(-)

diff --git a/include/trace/events/vmscan.h b/include/trace/events/vmscan.h
index 1212f6a7c223e..15b31281f0955 100644
--- a/include/trace/events/vmscan.h
+++ b/include/trace/events/vmscan.h
@@ -122,18 +122,22 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_begin_template,
 		__field(	unsigned long,	gfp_flags	)
 		__field(	u64,	memcg_id	)
 		__field(	int,	order		)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;gfp_flags	= (__force unsigned long)gfp_flags;
 		__entry-&gt;order		= order;
+		__entry-&gt;pid		= current-&gt;pid;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;order=%d gfp_flags=%s memcg_id=%llu&quot;,
+	TP_printk(&quot;order=%d gfp_flags=%s pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;order,
 		show_gfp_flags(__entry-&gt;gfp_flags),
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_begin_template, mm_vmscan_direct_reclaim_begin,
@@ -168,16 +172,20 @@ DECLARE_EVENT_CLASS(mm_vmscan_direct_reclaim_end_template,
 	TP_STRUCT__entry(
 		__field(	unsigned long,	nr_reclaimed	)
 		__field(	u64,	memcg_id	)
+		__field(	int,	pid		)
 	),
 
 	TP_fast_assign(
 		__entry-&gt;nr_reclaimed	= nr_reclaimed;
 		__entry-&gt;memcg_id	= mem_cgroup_id(memcg);
+		__entry-&gt;pid		= current-&gt;pid;
 	),
 
-	TP_printk(&quot;nr_reclaimed=%lu memcg_id=%llu&quot;,
+	TP_printk(&quot;nr_reclaimed=%lu pid=%d memcg_id=%llu %s&quot;,
 		__entry-&gt;nr_reclaimed,
-		__entry-&gt;memcg_id)
+		__entry-&gt;pid,
+		__entry-&gt;memcg_id,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_direct_reclaim_end,
@@ -220,9 +228,10 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__field(unsigned long, cache_items)
 		__field(unsigned long long, delta)
 		__field(unsigned long, total_scan)
+		__field(u64, memcg_id)
 		__field(int, priority)
 		__field(int, nid)
-		__field(u64, memcg_id)
+		__field(int, pid)
 	),
 
 	TP_fast_assign(
@@ -236,19 +245,22 @@ TRACE_EVENT(mm_shrink_slab_start,
 		__entry-&gt;priority = priority;
 		__entry-&gt;nid = sc-&gt;nid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
+		__entry-&gt;pid = current-&gt;pid;
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu objects to shrink %ld gfp_flags %s cache items %ld delta %lld total_scan %ld priority %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;nr_objects_to_shrink,
 		show_gfp_flags(__entry-&gt;gfp_flags),
 		__entry-&gt;cache_items,
 		__entry-&gt;delta,
 		__entry-&gt;total_scan,
-		__entry-&gt;priority)
+		__entry-&gt;priority,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_shrink_slab_end,
@@ -266,6 +278,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__field(long, total_scan)
 		__field(int, nid)
 		__field(int, retval)
+		__field(int, pid)
 		__field(u64, memcg_id)
 	),
 
@@ -277,18 +290,21 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry-&gt;total_scan = total_scan;
 		__entry-&gt;nid = nid;
 		__entry-&gt;retval = shrinker_retval;
+		__entry-&gt;pid = current-&gt;pid;
 		__entry-&gt;memcg_id = mem_cgroup_id(memcg);
 	),
 
-	TP_printk(&quot;%pS %p: nid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d&quot;,
+	TP_printk(&quot;%pS %p: nid: %d pid: %d memcg_id: %llu unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d %s&quot;,
 		__entry-&gt;shrink,
 		__entry-&gt;shr,
 		__entry-&gt;nid,
+		__entry-&gt;pid,
 		__entry-&gt;memcg_id,
 		__entry-&gt;unused_scan,
 		__entry-&gt;new_scan,
 		__entry-&gt;total_scan,
-		__entry-&gt;retval)
+		__entry-&gt;retval,
+		__event_in_irq() ? &quot;(in-irq)&quot; : &quot;&quot;)
 );
 
 TRACE_EVENT(mm_vmscan_lru_isolate,
-- 
2.33.8</pre>
</details>
<div class="review-comment-signals">Signals: clarification, explanation</div>
</div>
</div>
</div>

    <footer>LKML Daily Activity Tracker</footer>
    <script>
    // When arriving via a date anchor (e.g. #2026-02-15 from a daily report),
    // scroll the anchor into view after a brief delay so layout is complete.
    (function () {
        var hash = window.location.hash;
        if (!hash) return;
        var target = document.getElementById(hash.slice(1));
        if (!target) return;
        setTimeout(function () {
            target.scrollIntoView({behavior: 'smooth', block: 'start'});
        }, 80);
    })();
    </script>
</body>
</html>