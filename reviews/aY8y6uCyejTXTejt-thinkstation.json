{
  "thread_id": "aY8y6uCyejTXTejt@thinkstation",
  "subject": "Re: [BUG] Fault during memory acceptance for TDX VMs with certain memory sizes",
  "url": "https://lore.kernel.org/all/aY8y6uCyejTXTejt@thinkstation/",
  "dates": {
    "2026-02-13": {
      "report_file": "2026-02-13_ollama_llama3.1-8b.html",
      "developer": "Kiryl Shutsemau",
      "reviews": [
        {
          "author": "Dave Hansen",
          "summary": "Reviewer Dave Hansen suspects a mismatch between 'unit_size' and bitmap size, or an unaligned access causing a crash during memory acceptance for TDX VMs with certain memory sizes.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested_changes"
          ],
          "has_inline_review": false,
          "tags_given": [],
          "analysis_source": "llm",
          "raw_body": "On 2/12/26 08:29, Moritz Sanft wrote:\n> Based on our current (trial-and-error-based) knowledge, the issue only\n> occurs on TDX VMs with memory sizes >64GB, where the memory size is not\n> aligned to a multiple of 1024. For instance, the QEMU argument `-m 67G`\n> works, while `-m 67000M` results in the crash cited below. The\n> configurations we've tested so far are as follows:\n\nI don't see any outrageous bugs in the code. I'm going to take a guess\nthough: the 'unit_size' and the bitmap size don't match or aren't\nconsistent.\n\nI'd guess that _something_ is unaligned and you're running off the end\nof the bitmap or the *mapping* for the bitmap. Any chance you can throw\na bunch of printk()'s in the kernel and see what all the fields in here are:\n\nstruct efi_unaccepted_memory {\n        u32 version;\n        u32 unit_size;\n        u64 phys_base;\n        u64 size;\n        unsigned long bitmap[];\n};\n\nAlong with the address of bitmap[] and all the calls to: bitmap_clear()?\n\nThat that should shed some light on it.\n\nAny other TDX folks that want to try and reproduce this and do the same\nwould also be much appreciated!\n",
          "reply_to": ""
        },
        {
          "author": "Moritz Sanft (author)",
          "summary": "The reviewer, Moritz Sanft (author), initially reported a bug causing a kernel panic during memory acceptance for TDX VMs with certain memory sizes. They provided logs and asked for further investigation. After applying patches and additional logging, the issue was resolved, and the VM booted successfully.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "patch seems to fix the problem"
          ],
          "has_inline_review": false,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "> Any chance you can throw\n> a bunch of printk()'s in the kernel and see what all the fields in here are:\n> \n> struct efi_unaccepted_memory {\n>         u32 version;\n>         u32 unit_size;\n>         u64 phys_base;\n>         u64 size;\n>         unsigned long bitmap[];\n> };\n> \n> Along with the address of bitmap[] and all the calls to: bitmap_clear()?\n\nThanks for the guidance. I've added this logging via the patch in [1], \nwhich produced the following output:\n\n```\n[    0.033292] accept_memory(start=0x0000000000099000 size=0x6000)\n[    0.037860]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.041469] Using GB pages for direct mapping\n[    0.043090] accept_memory(start=0x00000010db600000 size=0x200000)\n[    0.045311]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.058123]   bitmap_clear(bitmap=ff1100007d624030, start=32475, len=1)\n[    0.060921] accept_memory(start=0x00000010db7ff000 size=0x1000)\n[    0.063142]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.066865] accept_memory(start=0x00000010db7fe000 size=0x1000)\n[    0.069096]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.073705] accept_memory(start=0x00000010db7fd000 size=0x1000)\n[    0.075908]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n// unrelated logs omitted here\n[    0.134988] accept_memory(start=0x00000010db7fcf40 size=0x83)\n[    0.137152]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.140828] BUG: unable to handle page fault for address: \nff1100007d625008\n```\n\nFind a full log attached in [2].\n\nPlease let me know if we need to gather any further logs - we're happy \nto do so.\n\nBest Regards,\nMoritz Sanft\n\n[1]: https://gist.github.com/msanft/13709e1ec9976a1b4b2723b98163a04b\n[2]: https://gist.github.com/msanft/d102475bb28baa4b7958ed35e001e962\n\n\n---\n\n> Could you check it this patch makes a difference:\n> \n> diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c\n> index c2c067eff634..f2a00cd429f2 100644\n> --- a/drivers/firmware/efi/unaccepted_memory.c\n> +++ b/drivers/firmware/efi/unaccepted_memory.c\n> @@ -35,7 +35,7 @@ void accept_memory(phys_addr_t start, unsigned long size)\n>  \tstruct efi_unaccepted_memory *unaccepted;\n>  \tunsigned long range_start, range_end;\n>  \tstruct accept_range range, *entry;\n> -\tphys_addr_t end = start + size;\n> +\tphys_addr_t end = start + PAGE_ALIGN(size);\n>  \tunsigned long flags;\n>  \tu64 unit_size;\n\nThanks, I tried this on the `-m 67000M` VM and the crash still occurs. I \nextended the previously-added logging to also log the values for `start \n+ size` and `start + PAGE_ALIGN(size)`. Please find the full patch \nincluding the logging and your change in [1].\n\nThe produced logs are as follows:\n\n```\n[    0.046472] accept_memory(start=0x00000010db600000 size=0x200000)\n[    0.048747]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.052557]   (start + size)=0x00000010db800000 (start + \nPAGE_ALIGN(size))=0x00000010db800000\n[    0.065217]   bitmap_clear(bitmap=ff1100007d624030, start=32475, len=1)\n[    0.067928] accept_memory(start=0x00000010db7ff000 size=0x1000)\n[    0.070167]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.073917]   (start + size)=0x00000010db800000 (start + \nPAGE_ALIGN(size))=0x00000010db800000\n[    0.077150] accept_memory(start=0x00000010db7fe000 size=0x1000)\n[    0.079365]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.083080]   (start + size)=0x00000010db7ff000 (start + \nPAGE_ALIGN(size))=0x00000010db7ff000\n[    0.087123] accept_memory(start=0x00000010db7fd000 size=0x1000)\n[    0.089362]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.093239]   (start + size)=0x00000010db7fe000 (start + \nPAGE_ALIGN(size))=0x00000010db7fe000\n// unrelated\n[    0.150522] APIC: Switched APIC routing to: cluster x2apic\n[    0.152595] accept_memory(start=0x00000010db7fcf40 size=0x83)\n[    0.154745]   unaccepted: version=1 unit_size=2097152 \nphys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n[    0.158479]   (start + size)=0x00000010db7fcfc3 (start + \nPAGE_ALIGN(size))=0x00000010db7fdf40\n[    0.161713] BUG: unable to handle page fault for address: \nff1100007d625008\n```\n\n[1]: https://gist.github.com/msanft/d6d7e32a65708f5bd36233649e4facee\n\n\n\n\n---\n\n> What about the patch below. It seems we under-reserve memory for the\n> table if it is unaligned.\n> \n> I still think that we need align start/size/end to the PAGE_SIZE in\n> accept_memory()/range_contains_unaccepted_memory() before doing anything\n> else. Otherwise (end % unit_size) check is broken. But it seems to be\n> unrelated to the problem you see.\n> \n> diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c\n> index 111e87a618e5..56e9d73412fa 100644\n> --- a/drivers/firmware/efi/efi.c\n> +++ b/drivers/firmware/efi/efi.c\n> @@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,\n>  \n>  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)\n>  {\n> -\tphys_addr_t start, size;\n> +\tphys_addr_t start, end;\n>  \n>  \tstart = PAGE_ALIGN_DOWN(efi.unaccepted);\n> -\tsize = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\n> +\tend = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted->size);\n>  \n> -\tmemblock_add(start, size);\n> -\tmemblock_reserve(start, size);\n> +\tmemblock_add(start, end - start);\n> +\tmemblock_reserve(start, end - start);\n>  }\n>  \n>  int __init efi_config_parse_tables(const efi_config_table_t *config_tables,\n\nThanks, this patch seems to fix the problem causing the panic. The VM \nboots as expected with this.\n\nPlease let me know if any more information is required.\n\nBest Regards,\nMoritz Sanft\n\n\n---\n\n> What about the patch below. It seems we under-reserve memory for the\n> table if it is unaligned.\n> \n> I still think that we need align start/size/end to the PAGE_SIZE in\n> accept_memory()/range_contains_unaccepted_memory() before doing anything\n> else. Otherwise (end % unit_size) check is broken. But it seems to be\n> unrelated to the problem you see.\n> \n> diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c\n> index 111e87a618e5..56e9d73412fa 100644\n> --- a/drivers/firmware/efi/efi.c\n> +++ b/drivers/firmware/efi/efi.c\n> @@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,\n>  \n>  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)\n>  {\n> -\tphys_addr_t start, size;\n> +\tphys_addr_t start, end;\n>  \n>  \tstart = PAGE_ALIGN_DOWN(efi.unaccepted);\n> -\tsize = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\n> +\tend = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted->size);\n>  \n> -\tmemblock_add(start, size);\n> -\tmemblock_reserve(start, size);\n> +\tmemblock_add(start, end - start);\n> +\tmemblock_reserve(start, end - start);\n>  }\n>  \n>  int __init efi_config_parse_tables(const efi_config_table_t *config_tables,\n\nThanks, this patch seems to fix the problem causing the panic. The VM \nboots as expected with this.\n\nPlease let me know if any more information is required.\n\nBest Regards,\nMoritz Sanft\n",
          "reply_to": ""
        },
        {
          "author": "Kiryl Shutsemau",
          "summary": "Reviewer Kiryl Shutsemau raised concerns that the original patch may not fully address the issue, suggesting additional alignment checks in accept_memory() and range_contains_unaccepted_memory(). He also provided two patches to be considered.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "requested changes",
            "additional alignment checks"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Fri, Feb 13, 2026 at 09:34:46AM +0100, Moritz Sanft wrote:\n> > Any chance you can throw\n> > a bunch of printk()'s in the kernel and see what all the fields in here are:\n> > \n> > struct efi_unaccepted_memory {\n> >         u32 version;\n> >         u32 unit_size;\n> >         u64 phys_base;\n> >         u64 size;\n> >         unsigned long bitmap[];\n> > };\n> > \n> > Along with the address of bitmap[] and all the calls to: bitmap_clear()?\n> \n> Thanks for the guidance. I've added this logging via the patch in [1], which\n> produced the following output:\n> \n> ```\n> [    0.033292] accept_memory(start=0x0000000000099000 size=0x6000)\n> [    0.037860]   unaccepted: version=1 unit_size=2097152\n> phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n> [    0.041469] Using GB pages for direct mapping\n> [    0.043090] accept_memory(start=0x00000010db600000 size=0x200000)\n> [    0.045311]   unaccepted: version=1 unit_size=2097152\n> phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n> [    0.058123]   bitmap_clear(bitmap=ff1100007d624030, start=32475, len=1)\n> [    0.060921] accept_memory(start=0x00000010db7ff000 size=0x1000)\n> [    0.063142]   unaccepted: version=1 unit_size=2097152\n> phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n> [    0.066865] accept_memory(start=0x00000010db7fe000 size=0x1000)\n> [    0.069096]   unaccepted: version=1 unit_size=2097152\n> phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n> [    0.073705] accept_memory(start=0x00000010db7fd000 size=0x1000)\n> [    0.075908]   unaccepted: version=1 unit_size=2097152\n> phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n> // unrelated logs omitted here\n> [    0.134988] accept_memory(start=0x00000010db7fcf40 size=0x83)\n> [    0.137152]   unaccepted: version=1 unit_size=2097152\n> phys_base=0x100000000 size=0xfdc bitmap=ff1100007d624030\n> [    0.140828] BUG: unable to handle page fault for address:\n> ff1100007d625008\n> ```\n> \n> Find a full log attached in [2].\n> \n> Please let me know if we need to gather any further logs - we're happy to do\n> so.\n\nCould you check it this patch makes a difference:\n\ndiff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c\nindex c2c067eff634..f2a00cd429f2 100644\n--- a/drivers/firmware/efi/unaccepted_memory.c\n+++ b/drivers/firmware/efi/unaccepted_memory.c\n@@ -35,7 +35,7 @@ void accept_memory(phys_addr_t start, unsigned long size)\n \tstruct efi_unaccepted_memory *unaccepted;\n \tunsigned long range_start, range_end;\n \tstruct accept_range range, *entry;\n-\tphys_addr_t end = start + size;\n+\tphys_addr_t end = start + PAGE_ALIGN(size);\n \tunsigned long flags;\n \tu64 unit_size;\n \n-- \n  Kiryl Shutsemau / Kirill A. Shutemov\n\n\n---\n\nOn Fri, Feb 13, 2026 at 01:33:56PM +0100, Moritz Sanft wrote:\n> > Could you check it this patch makes a difference:\n> > \n> > diff --git a/drivers/firmware/efi/unaccepted_memory.c b/drivers/firmware/efi/unaccepted_memory.c\n> > index c2c067eff634..f2a00cd429f2 100644\n> > --- a/drivers/firmware/efi/unaccepted_memory.c\n> > +++ b/drivers/firmware/efi/unaccepted_memory.c\n> > @@ -35,7 +35,7 @@ void accept_memory(phys_addr_t start, unsigned long size)\n> >  \tstruct efi_unaccepted_memory *unaccepted;\n> >  \tunsigned long range_start, range_end;\n> >  \tstruct accept_range range, *entry;\n> > -\tphys_addr_t end = start + size;\n> > +\tphys_addr_t end = start + PAGE_ALIGN(size);\n> >  \tunsigned long flags;\n> >  \tu64 unit_size;\n> \n> Thanks, I tried this on the `-m 67000M` VM and the crash still occurs. I\n> extended the previously-added logging to also log the values for `start +\n> size` and `start + PAGE_ALIGN(size)`. Please find the full patch including\n> the logging and your change in [1].\n\nWhat about the patch below. It seems we under-reserve memory for the\ntable if it is unaligned.\n\nI still think that we need align start/size/end to the PAGE_SIZE in\naccept_memory()/range_contains_unaccepted_memory() before doing anything\nelse. Otherwise (end % unit_size) check is broken. But it seems to be\nunrelated to the problem you see.\n\ndiff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c\nindex 111e87a618e5..56e9d73412fa 100644\n--- a/drivers/firmware/efi/efi.c\n+++ b/drivers/firmware/efi/efi.c\n@@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,\n \n static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)\n {\n-\tphys_addr_t start, size;\n+\tphys_addr_t start, end;\n \n \tstart = PAGE_ALIGN_DOWN(efi.unaccepted);\n-\tsize = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\n+\tend = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted->size);\n \n-\tmemblock_add(start, size);\n-\tmemblock_reserve(start, size);\n+\tmemblock_add(start, end - start);\n+\tmemblock_reserve(start, end - start);\n }\n \n int __init efi_config_parse_tables(const efi_config_table_t *config_tables,\n-- \n  Kiryl Shutsemau / Kirill A. Shutemov\n",
          "reply_to": ""
        },
        {
          "author": "Verma, L",
          "summary": "The reviewer, Verma, L, agrees that the patch fixes a bug in TDX VMs and reproduces the issue, but suggests an additional change to account for the table's offset within its starting page.",
          "sentiment": "needs_work",
          "sentiment_signals": [
            "agreement on fix",
            "additional suggested change"
          ],
          "has_inline_review": true,
          "tags_given": [
            "Reviewed-by"
          ],
          "analysis_source": "llm",
          "raw_body": "On Fri, 2026-02-13 at 14:24 +0000, Kiryl Shutsemau wrote:\r\n> \r\n> I still think that we need align start/size/end to the PAGE_SIZE in\r\n> accept_memory()/range_contains_unaccepted_memory() before doing anything\r\n> else. Otherwise (end % unit_size) check is broken. But it seems to be\r\n> unrelated to the problem you see.\r\n> \r\n> diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c\r\n> index 111e87a618e5..56e9d73412fa 100644\r\n> --- a/drivers/firmware/efi/efi.c\r\n> +++ b/drivers/firmware/efi/efi.c\r\n> @@ -692,13 +692,13 @@ static __init int match_config_table(const efi_guid_t *guid,\r\n>  \r\n>  static __init void reserve_unaccepted(struct efi_unaccepted_memory *unaccepted)\r\n>  {\r\n> -\tphys_addr_t start, size;\r\n> +\tphys_addr_t start, end;\r\n>  \r\n>  \tstart = PAGE_ALIGN_DOWN(efi.unaccepted);\r\n> -\tsize = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\r\n> +\tend = PAGE_ALIGN(efi.unaccepted + sizeof(*unaccepted) + unaccepted->size);\r\n>  \r\n> -\tmemblock_add(start, size);\r\n> -\tmemblock_reserve(start, size);\r\n> +\tmemblock_add(start, end - start);\r\n> +\tmemblock_reserve(start, end - start);\r\n>  }\r\n>  \r\n>  int __init efi_config_parse_tables(const efi_config_table_t *config_tables,\r\n\r\nI was able to reproduce the original BUG on a TDX system, and after\r\nsome LLM-assisted debugging, this similar patch seems to fix it:\r\n\r\n---\r\n\r\ndiff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c\r\nindex 55452e61af31d..9f66f0f535420 100644\r\n--- a/drivers/firmware/efi/efi.c\r\n+++ b/drivers/firmware/efi/efi.c\r\n@@ -695,7 +695,8 @@ static __init void reserve_unaccepted(struct\r\nefi_unaccepted_memory *unaccepted)\r\n        phys_addr_t start, size;\r\n \r\n        start = PAGE_ALIGN_DOWN(efi.unaccepted);\r\n-       size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size);\r\n+       size = PAGE_ALIGN(sizeof(*unaccepted) + unaccepted->size +\r\n+                         offset_in_page(efi.unaccepted));\r\n \r\n        memblock_add(start, size);\r\n        memblock_reserve(start, size);\r\n\r\n\r\n---\r\n\r\nThe hypothesis is that the original size calculation does not account\r\nfor the table's offset within its starting page. The EFI pool allocator\r\nperforms sub-page allocation, so efi.unaccepted may not be page\r\naligned.\r\n",
          "reply_to": ""
        }
      ],
      "analysis_source": "llm"
    }
  }
}